# Palkeoramix decompiler. 

const factory = 0x43ec799eadd63848443e2347c49f5f52e8fe0f6f
const WETH = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2

#
#  Regular functions
#

def getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut): # not payable
  require calldata.size - 4 >=′ 96
  revert with 0, 'Deprecated: Use getAmountsIn'

def getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut): # not payable
  require calldata.size - 4 >=′ 96
  revert with 0, 'Deprecated: Use getAmountsOut'

def quote(uint256 amountA, uint256 reserveA, uint256 reserveB): # not payable
  require calldata.size - 4 >=′ 96
  if amountA <= 0:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'FraxswapRouterLibrary: INSUFFICIENT_AMOUNT'
  if reserveA <= 0:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'FraxswapRouterLibrary: INSUFFICIENT_LIQUIDITY'
  if reserveB <= 0:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'FraxswapRouterLibrary: INSUFFICIENT_LIQUIDITY'
  if amountA and reserveB > -1 / amountA:
      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
  if not reserveA:
      revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
  return (amountA * reserveB / reserveA)

def swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] path, address to, uint256 deadline): # not payable
  require calldata.size - 4 >=′ 160
  require path <= LOCK8605463013()
  require path + 35 <′ calldata.size
  require path.length <= LOCK8605463013()
  require path + (32 * path.length) + 36 <= calldata.size
  require to == to
  if deadline < block.timestamp:
      revert with 0, 'FraxswapV1Router: EXPIRED'
  if path.length < 2:
      revert with 0, 'FraxswapRouterLibrary: INVALID_PATH'
  if path.length > LOCK8605463013():
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  if 0 >= path.length:
      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def swapTokensForExactTokens(uint256 amountOut, uint256 amountInMax, address[] path, address to, uint256 deadline): # not payable
  require calldata.size - 4 >=′ 160
  require path <= LOCK8605463013()
  require path + 35 <′ calldata.size
  require path.length <= LOCK8605463013()
  require path + (32 * path.length) + 36 <= calldata.size
  require to == to
  if deadline < block.timestamp:
      revert with 0, 'FraxswapV1Router: EXPIRED'
  if path.length < 2:
      revert with 0, 'FraxswapRouterLibrary: INVALID_PATH'
  if path.length > LOCK8605463013():
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  if path.length < 1:
      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
  if path.length - 1 >= path.length:
      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
  if path.length < 1:
      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def swapExactETHForTokens(uint256 amountOutMin, address[] path, address to, uint256 deadline) payable: 
  require calldata.size - 4 >=′ 128
  require path <= LOCK8605463013()
  require path + 35 <′ calldata.size
  require path.length <= LOCK8605463013()
  require path + (32 * path.length) + 36 <= calldata.size
  require to == to
  if deadline < block.timestamp:
      revert with 0, 'FraxswapV1Router: EXPIRED'
  if 0 >= path.length:
      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
  require cd[(path + 36)] == address(cd[(path + 36)])
  if address(cd[(path + 36)]) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
      revert with 0, 'FraxswapV1Router: INVALID_PATH'
  if path.length < 2:
      revert with 0, 'FraxswapRouterLibrary: INVALID_PATH'
  if path.length > LOCK8605463013():
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  if 0 >= path.length:
      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def swapExactTokensForETH(uint256 amountIn, uint256 amountOutMin, address[] path, address to, uint256 deadline): # not payable
  require calldata.size - 4 >=′ 160
  require path <= LOCK8605463013()
  require path + 35 <′ calldata.size
  require path.length <= LOCK8605463013()
  require path + (32 * path.length) + 36 <= calldata.size
  require to == to
  if deadline < block.timestamp:
      revert with 0, 'FraxswapV1Router: EXPIRED'
  if path.length < 1:
      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
  if path.length - 1 >= path.length:
      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
  require cd[((32 * path.length - 1) + path + 36)] == address(cd[((32 * path.length - 1) + path + 36)])
  if address(cd[((32 * path.length - 1) + path + 36)]) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
      revert with 0, 'FraxswapV1Router: INVALID_PATH'
  if path.length < 2:
      revert with 0, 'FraxswapRouterLibrary: INVALID_PATH'
  if path.length > LOCK8605463013():
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  if 0 >= path.length:
      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def swapETHForExactTokens(uint256 amountOut, address[] path, address to, uint256 deadline) payable: 
  require calldata.size - 4 >=′ 128
  require path <= LOCK8605463013()
  require path + 35 <′ calldata.size
  require path.length <= LOCK8605463013()
  require path + (32 * path.length) + 36 <= calldata.size
  require to == to
  if deadline < block.timestamp:
      revert with 0, 'FraxswapV1Router: EXPIRED'
  if 0 >= path.length:
      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
  require cd[(path + 36)] == address(cd[(path + 36)])
  if address(cd[(path + 36)]) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
      revert with 0, 'FraxswapV1Router: INVALID_PATH'
  if path.length < 2:
      revert with 0, 'FraxswapRouterLibrary: INVALID_PATH'
  if path.length > LOCK8605463013():
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  if path.length < 1:
      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
  if path.length - 1 >= path.length:
      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
  if path.length < 1:
      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def swapTokensForExactETH(uint256 amountOut, uint256 amountInMax, address[] path, address to, uint256 deadline): # not payable
  require calldata.size - 4 >=′ 160
  require path <= LOCK8605463013()
  require path + 35 <′ calldata.size
  require path.length <= LOCK8605463013()
  require path + (32 * path.length) + 36 <= calldata.size
  require to == to
  if deadline < block.timestamp:
      revert with 0, 'FraxswapV1Router: EXPIRED'
  if path.length < 1:
      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
  if path.length - 1 >= path.length:
      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
  require cd[((32 * path.length - 1) + path + 36)] == address(cd[((32 * path.length - 1) + path + 36)])
  if address(cd[((32 * path.length - 1) + path + 36)]) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
      revert with 0, 'FraxswapV1Router: INVALID_PATH'
  if path.length < 2:
      revert with 0, 'FraxswapRouterLibrary: INVALID_PATH'
  if path.length > LOCK8605463013():
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  if path.length < 1:
      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
  if path.length - 1 >= path.length:
      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
  if path.length < 1:
      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] path, address to, uint256 deadline): # not payable
  require calldata.size - 4 >=′ 160
  require path <= LOCK8605463013()
  require path + 35 <′ calldata.size
  require path.length <= LOCK8605463013()
  require path + (32 * path.length) + 36 <= calldata.size
  require to == to
  if deadline < block.timestamp:
      revert with 0, 'FraxswapV1Router: EXPIRED'
  if 0 >= path.length:
      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
  require cd[(path + 36)] == address(cd[(path + 36)])
  if 0 >= path.length:
      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
  require cd[(path + 36)] == address(cd[(path + 36)])
  if 1 >= path.length:
      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
  require cd[(path + 68)] == address(cd[(path + 68)])
  if not address(cd[(path + 36)]) - address(cd[(path + 68)]):
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
  if address(cd[(path + 36)]) < address(cd[(path + 68)]):
      if not address(cd[(path + 36)]):
          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'FraxswapRouterLibrary: ZERO_ADDRESS'
  else:
      if not address(cd[(path + 68)]):
          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'FraxswapRouterLibrary: ZERO_ADDRESS'
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] path, address to, uint256 deadline): # not payable
  require calldata.size - 4 >=′ 160
  require path <= LOCK8605463013()
  require path + 35 <′ calldata.size
  require path.length <= LOCK8605463013()
  require path + (32 * path.length) + 36 <= calldata.size
  require to == to
  if deadline < block.timestamp:
      revert with 0, 'FraxswapV1Router: EXPIRED'
  if path.length < 1:
      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
  if path.length - 1 >= path.length:
      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
  require cd[((32 * path.length - 1) + path + 36)] == address(cd[((32 * path.length - 1) + path + 36)])
  if address(cd[((32 * path.length - 1) + path + 36)]) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
      revert with 0, 'FraxswapV1Router: INVALID_PATH'
  if 0 >= path.length:
      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
  require cd[(path + 36)] == address(cd[(path + 36)])
  if 0 >= path.length:
      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
  require cd[(path + 36)] == address(cd[(path + 36)])
  if 1 >= path.length:
      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
  require cd[(path + 68)] == address(cd[(path + 68)])
  if not address(cd[(path + 36)]) - address(cd[(path + 68)]):
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
  if address(cd[(path + 36)]) < address(cd[(path + 68)]):
      if not address(cd[(path + 36)]):
          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'FraxswapRouterLibrary: ZERO_ADDRESS'
  else:
      if not address(cd[(path + 68)]):
          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'FraxswapRouterLibrary: ZERO_ADDRESS'
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def removeLiquidity(address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline): # not payable
  require calldata.size - 4 >=′ 224
  require tokenA == tokenA
  require tokenB == tokenB
  require to == to
  if deadline < block.timestamp:
      revert with 0, 'FraxswapV1Router: EXPIRED'
  if not tokenA - tokenB:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
  if tokenA < tokenB:
      if not tokenA:
          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'FraxswapRouterLibrary: ZERO_ADDRESS'
      call address(sha3(0, 4894420617473177672, sha3(tokenA, tokenB), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).transferFrom(address sender, address recipient, uint256 amount) with:
           gas gas_remaining wei
          args caller, address(sha3(0, 4894420617473177672, sha3(tokenA, tokenB), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)), liquidity
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      require return_data.size >=′ 32
      require ext_call.return_data[0] == bool(ext_call.return_data[0])
      call address(sha3(0, 4894420617473177672, sha3(tokenA, tokenB), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).burn(address to) with:
           gas gas_remaining wei
          args to
  else:
      if not tokenB:
          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'FraxswapRouterLibrary: ZERO_ADDRESS'
      call address(sha3(0, 4894420617473177672, sha3(tokenB, tokenA), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).transferFrom(address sender, address recipient, uint256 amount) with:
           gas gas_remaining wei
          args caller, address(sha3(0, 4894420617473177672, sha3(tokenB, tokenA), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)), liquidity
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      require return_data.size >=′ 32
      require ext_call.return_data[0] == bool(ext_call.return_data[0])
      call address(sha3(0, 4894420617473177672, sha3(tokenB, tokenA), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).burn(address to) with:
           gas gas_remaining wei
          args to
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  require return_data.size >=′ 64
  if not tokenA - tokenB:
      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
  if tokenA < tokenB:
      if not tokenA:
          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
      if tokenA == tokenA:
          if ext_call.return_data[0] < amountAMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
          if ext_call.return_data[32] < amountBMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
          return ext_call.return_data[0], ext_call.return_data[32]
  else:
      if not tokenB:
          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
      if tokenA == tokenB:
          if ext_call.return_data[0] < amountAMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
          if ext_call.return_data[32] < amountBMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
          return ext_call.return_data[0], ext_call.return_data[32]
  if ext_call.return_data[32] < amountAMin:
      revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
  if ext_call.return_data[0] < amountBMin:
      revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
  return ext_call.return_data[32], ext_call.return_data[0]

def removeLiquidityWithPermit(address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s): # not payable
  require calldata.size - 4 >=′ 352
  require tokenA == tokenA
  require tokenB == tokenB
  require to == to
  require approveMax == approveMax
  require v == v
  if not tokenA - tokenB:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
  if tokenA < tokenB:
      if not tokenA:
          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'FraxswapRouterLibrary: ZERO_ADDRESS'
      require ext_code.size(address(sha3(0, 4894420617473177672, sha3(tokenA, tokenB), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
      if approveMax:
          call address(sha3(0, 4894420617473177672, sha3(tokenA, tokenB), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
               gas gas_remaining wei
              args caller, this.address, -1, deadline, v << 248, r, s
      else:
          call address(sha3(0, 4894420617473177672, sha3(tokenA, tokenB), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
               gas gas_remaining wei
              args caller, this.address, liquidity, deadline, v << 248, r, s
  else:
      if not tokenB:
          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'FraxswapRouterLibrary: ZERO_ADDRESS'
      require ext_code.size(address(sha3(0, 4894420617473177672, sha3(tokenB, tokenA), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
      if approveMax:
          call address(sha3(0, 4894420617473177672, sha3(tokenB, tokenA), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
               gas gas_remaining wei
              args caller, this.address, -1, deadline, v << 248, r, s
      else:
          call address(sha3(0, 4894420617473177672, sha3(tokenB, tokenA), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
               gas gas_remaining wei
              args caller, this.address, liquidity, deadline, v << 248, r, s
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  if deadline < block.timestamp:
      revert with 0, 'FraxswapV1Router: EXPIRED'
  if not tokenA - tokenB:
      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
  if tokenA < tokenB:
      if not tokenA:
          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
      call address(sha3(0, 4894420617473177672, sha3(tokenA, tokenB), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).transferFrom(address sender, address recipient, uint256 amount) with:
           gas gas_remaining wei
          args caller, address(sha3(0, 4894420617473177672, sha3(tokenA, tokenB), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)), liquidity
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      require return_data.size >=′ 32
      require ext_call.return_data[0] == bool(ext_call.return_data[0])
      call address(sha3(0, 4894420617473177672, sha3(tokenA, tokenB), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).burn(address to) with:
           gas gas_remaining wei
          args to
  else:
      if not tokenB:
          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
      call address(sha3(0, 4894420617473177672, sha3(tokenB, tokenA), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).transferFrom(address sender, address recipient, uint256 amount) with:
           gas gas_remaining wei
          args caller, address(sha3(0, 4894420617473177672, sha3(tokenB, tokenA), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)), liquidity
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      require return_data.size >=′ 32
      require ext_call.return_data[0] == bool(ext_call.return_data[0])
      call address(sha3(0, 4894420617473177672, sha3(tokenB, tokenA), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).burn(address to) with:
           gas gas_remaining wei
          args to
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  require return_data.size >=′ 64
  if not tokenA - tokenB:
      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
  if tokenA < tokenB:
      if not tokenA:
          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
      if tokenA == tokenA:
          if ext_call.return_data[0] < amountAMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
          if ext_call.return_data[32] < amountBMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
          return ext_call.return_data[0], ext_call.return_data[32]
  else:
      if not tokenB:
          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
      if tokenA == tokenB:
          if ext_call.return_data[0] < amountAMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
          if ext_call.return_data[32] < amountBMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
          return ext_call.return_data[0], ext_call.return_data[32]
  if ext_call.return_data[32] < amountAMin:
      revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
  if ext_call.return_data[0] < amountBMin:
      revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
  return ext_call.return_data[32], ext_call.return_data[0]

def removeLiquidityETHWithPermit(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s): # not payable
  require calldata.size - 4 >=′ 320
  require token == token
  require to == to
  require approveMax == approveMax
  require v == v
  if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
  if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
      require ext_code.size(address(sha3(0, 4894420617473177672, sha3(13847067169082572429, token), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
      if approveMax:
          call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, token), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
               gas gas_remaining wei
              args caller, this.address, -1, deadline, v << 248, r, s
      else:
          call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, token), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
               gas gas_remaining wei
              args caller, this.address, liquidity, deadline, v << 248, r, s
  else:
      if not token:
          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'FraxswapRouterLibrary: ZERO_ADDRESS'
      require ext_code.size(address(sha3(0, 4894420617473177672, sha3(token, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
      if approveMax:
          call address(sha3(0, 4894420617473177672, sha3(token, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
               gas gas_remaining wei
              args caller, this.address, -1, deadline, v << 248, r, s
      else:
          call address(sha3(0, 4894420617473177672, sha3(token, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
               gas gas_remaining wei
              args caller, this.address, liquidity, deadline, v << 248, r, s
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  if deadline < block.timestamp:
      revert with 0, 'FraxswapV1Router: EXPIRED'
  if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
  if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
      call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, token), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).transferFrom(address sender, address recipient, uint256 amount) with:
           gas gas_remaining wei
          args caller, address(sha3(0, 4894420617473177672, sha3(13847067169082572429, token), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)), liquidity
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      require return_data.size >=′ 32
      require ext_call.return_data[0] == bool(ext_call.return_data[0])
      call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, token), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).burn(address to) with:
           gas gas_remaining wei
          args this.address
  else:
      if not token:
          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
      call address(sha3(0, 4894420617473177672, sha3(token, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).transferFrom(address sender, address recipient, uint256 amount) with:
           gas gas_remaining wei
          args caller, address(sha3(0, 4894420617473177672, sha3(token, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)), liquidity
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      require return_data.size >=′ 32
      require ext_call.return_data[0] == bool(ext_call.return_data[0])
      call address(sha3(0, 4894420617473177672, sha3(token, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).burn(address to) with:
           gas gas_remaining wei
          args this.address
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  require return_data.size >=′ 64
  if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
  if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
      if token == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
          if ext_call.return_data[0] < amountTokenMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
          if ext_call.return_data[32] < amountETHMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
      else:
          if ext_call.return_data[32] < amountTokenMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
          if ext_call.return_data[0] < amountETHMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
  else:
      if not token:
          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
      if token == token:
          if ext_call.return_data[0] < amountTokenMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
          if ext_call.return_data[32] < amountETHMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
      else:
          if ext_call.return_data[32] < amountTokenMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
          if ext_call.return_data[0] < amountETHMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s): # not payable
  require calldata.size - 4 >=′ 320
  require token == token
  require to == to
  require approveMax == approveMax
  require v == v
  if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
  if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
      require ext_code.size(address(sha3(0, 4894420617473177672, sha3(13847067169082572429, token), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
      if approveMax:
          call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, token), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
               gas gas_remaining wei
              args caller, this.address, -1, deadline, v << 248, r, s
      else:
          call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, token), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
               gas gas_remaining wei
              args caller, this.address, liquidity, deadline, v << 248, r, s
  else:
      if not token:
          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'FraxswapRouterLibrary: ZERO_ADDRESS'
      require ext_code.size(address(sha3(0, 4894420617473177672, sha3(token, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
      if approveMax:
          call address(sha3(0, 4894420617473177672, sha3(token, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
               gas gas_remaining wei
              args caller, this.address, -1, deadline, v << 248, r, s
      else:
          call address(sha3(0, 4894420617473177672, sha3(token, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
               gas gas_remaining wei
              args caller, this.address, liquidity, deadline, v << 248, r, s
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  if deadline < block.timestamp:
      revert with 0, 'FraxswapV1Router: EXPIRED'
  if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
  if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
      call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, token), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).transferFrom(address sender, address recipient, uint256 amount) with:
           gas gas_remaining wei
          args caller, address(sha3(0, 4894420617473177672, sha3(13847067169082572429, token), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)), liquidity
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      require return_data.size >=′ 32
      require ext_call.return_data[0] == bool(ext_call.return_data[0])
      call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, token), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).burn(address to) with:
           gas gas_remaining wei
          args this.address
  else:
      if not token:
          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
      call address(sha3(0, 4894420617473177672, sha3(token, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).transferFrom(address sender, address recipient, uint256 amount) with:
           gas gas_remaining wei
          args caller, address(sha3(0, 4894420617473177672, sha3(token, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)), liquidity
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      require return_data.size >=′ 32
      require ext_call.return_data[0] == bool(ext_call.return_data[0])
      call address(sha3(0, 4894420617473177672, sha3(token, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).burn(address to) with:
           gas gas_remaining wei
          args this.address
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  require return_data.size >=′ 64
  if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
  if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
      if token == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
          if ext_call.return_data[0] < amountTokenMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
          if ext_call.return_data[32] < amountETHMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
      else:
          if ext_call.return_data[32] < amountTokenMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
          if ext_call.return_data[0] < amountETHMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
  else:
      if not token:
          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
      if token == token:
          if ext_call.return_data[0] < amountTokenMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
          if ext_call.return_data[32] < amountETHMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
      else:
          if ext_call.return_data[32] < amountTokenMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
          if ext_call.return_data[0] < amountETHMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
  static call token.balanceOf(address account) with:
          gas gas_remaining wei
         args this.address
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  require return_data.size >=′ 32
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def removeLiquidityETHSupportingFeeOnTransferTokens(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline): # not payable
  require calldata.size - 4 >=′ 192
  require token == token
  require to == to
  if deadline < block.timestamp:
      revert with 0, 'FraxswapV1Router: EXPIRED'
  if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
  if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
      call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, token), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).transferFrom(address sender, address recipient, uint256 amount) with:
           gas gas_remaining wei
          args caller, address(sha3(0, 4894420617473177672, sha3(13847067169082572429, token), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)), liquidity
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      require return_data.size >=′ 32
      require ext_call.return_data[0] == bool(ext_call.return_data[0])
      call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, token), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).burn(address to) with:
           gas gas_remaining wei
          args this.address
  else:
      if not token:
          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'FraxswapRouterLibrary: ZERO_ADDRESS'
      call address(sha3(0, 4894420617473177672, sha3(token, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).transferFrom(address sender, address recipient, uint256 amount) with:
           gas gas_remaining wei
          args caller, address(sha3(0, 4894420617473177672, sha3(token, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)), liquidity
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      require return_data.size >=′ 32
      require ext_call.return_data[0] == bool(ext_call.return_data[0])
      call address(sha3(0, 4894420617473177672, sha3(token, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).burn(address to) with:
           gas gas_remaining wei
          args this.address
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  require return_data.size >=′ 64
  if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
  if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
      if token == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
          if ext_call.return_data[0] < amountTokenMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
          if ext_call.return_data[32] < amountETHMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
          static call token.balanceOf(address account) with:
                  gas gas_remaining wei
                 args this.address
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          require return_data.size >=′ 32
          mem[(4 * ceil32(return_data.size)) + 385 len 96] = transfer(address recipient, uint256 amount), address(to) << 64, 0, ext_call.return_data[0], mem[(4 * ceil32(return_data.size)) + 385 len 28]
          call token.mem[(4 * ceil32(return_data.size)) + 385 len 4] with:
               gas gas_remaining wei
              args mem[(4 * ceil32(return_data.size)) + 389 len 64]
          if not return_data.size:
              if not ext_call.success:
                  revert with 0, 'TransferHelper::safeTransfer: transfer failed'
          else:
              mem[(4 * ceil32(return_data.size)) + 417 len return_data.size] = ext_call.return_data[0 len return_data.size]
              if not ext_call.success:
                  revert with 0, 'TransferHelper::safeTransfer: transfer failed'
              if return_data.size:
                  require return_data.size >=′ 32
              else:
                  require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.withdraw(uint256 amount) with:
                       gas gas_remaining wei
                      args ext_call.return_data[32]
      else:
          if ext_call.return_data[32] < amountTokenMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
          if ext_call.return_data[0] < amountETHMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
          static call token.balanceOf(address account) with:
                  gas gas_remaining wei
                 args this.address
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          require return_data.size >=′ 32
          mem[(4 * ceil32(return_data.size)) + 385 len 96] = transfer(address recipient, uint256 amount), address(to) << 64, 0, ext_call.return_data[0], mem[(4 * ceil32(return_data.size)) + 385 len 28]
          call token.mem[(4 * ceil32(return_data.size)) + 385 len 4] with:
               gas gas_remaining wei
              args mem[(4 * ceil32(return_data.size)) + 389 len 64]
          if not return_data.size:
              if not ext_call.success:
                  revert with 0, 'TransferHelper::safeTransfer: transfer failed'
          else:
              mem[(4 * ceil32(return_data.size)) + 417 len return_data.size] = ext_call.return_data[0 len return_data.size]
              if not ext_call.success:
                  revert with 0, 'TransferHelper::safeTransfer: transfer failed'
              if return_data.size:
                  require return_data.size >=′ 32
              else:
                  require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.withdraw(uint256 amount) with:
                       gas gas_remaining wei
                      args ext_call.return_data[0]
  else:
      if not token:
          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
      if token == token:
          if ext_call.return_data[0] < amountTokenMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
          if ext_call.return_data[32] < amountETHMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
          static call token.balanceOf(address account) with:
                  gas gas_remaining wei
                 args this.address
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          require return_data.size >=′ 32
          mem[(4 * ceil32(return_data.size)) + 385 len 96] = transfer(address recipient, uint256 amount), address(to) << 64, 0, ext_call.return_data[0], mem[(4 * ceil32(return_data.size)) + 385 len 28]
          call token.mem[(4 * ceil32(return_data.size)) + 385 len 4] with:
               gas gas_remaining wei
              args mem[(4 * ceil32(return_data.size)) + 389 len 64]
          if not return_data.size:
              if not ext_call.success:
                  revert with 0, 'TransferHelper::safeTransfer: transfer failed'
          else:
              mem[(4 * ceil32(return_data.size)) + 417 len return_data.size] = ext_call.return_data[0 len return_data.size]
              if not ext_call.success:
                  revert with 0, 'TransferHelper::safeTransfer: transfer failed'
              if return_data.size:
                  require return_data.size >=′ 32
              else:
                  require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.withdraw(uint256 amount) with:
                       gas gas_remaining wei
                      args ext_call.return_data[32]
      else:
          if ext_call.return_data[32] < amountTokenMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
          if ext_call.return_data[0] < amountETHMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
          static call token.balanceOf(address account) with:
                  gas gas_remaining wei
                 args this.address
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          require return_data.size >=′ 32
          mem[(4 * ceil32(return_data.size)) + 385 len 96] = transfer(address recipient, uint256 amount), address(to) << 64, 0, ext_call.return_data[0], mem[(4 * ceil32(return_data.size)) + 385 len 28]
          call token.mem[(4 * ceil32(return_data.size)) + 385 len 4] with:
               gas gas_remaining wei
              args mem[(4 * ceil32(return_data.size)) + 389 len 64]
          if not return_data.size:
              if not ext_call.success:
                  revert with 0, 'TransferHelper::safeTransfer: transfer failed'
          else:
              mem[(4 * ceil32(return_data.size)) + 417 len return_data.size] = ext_call.return_data[0 len return_data.size]
              if not ext_call.success:
                  revert with 0, 'TransferHelper::safeTransfer: transfer failed'
              if return_data.size:
                  require return_data.size >=′ 32
              else:
                  require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.withdraw(uint256 amount) with:
                       gas gas_remaining wei
                      args ext_call.return_data[0]
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def removeLiquidityETH(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline): # not payable
  require calldata.size - 4 >=′ 192
  require token == token
  require to == to
  if deadline < block.timestamp:
      revert with 0, 'FraxswapV1Router: EXPIRED'
  if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
  if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
      call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, token), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).transferFrom(address sender, address recipient, uint256 amount) with:
           gas gas_remaining wei
          args caller, address(sha3(0, 4894420617473177672, sha3(13847067169082572429, token), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)), liquidity
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      require return_data.size >=′ 32
      require ext_call.return_data[0] == bool(ext_call.return_data[0])
      call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, token), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).burn(address to) with:
           gas gas_remaining wei
          args this.address
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      require return_data.size >=′ 64
      if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
          revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
      if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
          if token == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
              if ext_call.return_data[0] < amountTokenMin:
                  revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
              if ext_call.return_data[32] < amountETHMin:
                  revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
              mem[(2 * ceil32(return_data.size)) + 385 len 96] = transfer(address recipient, uint256 amount), address(to) << 64, 0, ext_call.return_data[0], mem[(2 * ceil32(return_data.size)) + 385 len 28]
              call token.mem[(2 * ceil32(return_data.size)) + 385 len 4] with:
                   gas gas_remaining wei
                  args mem[(2 * ceil32(return_data.size)) + 389 len 64]
              if not return_data.size:
                  if not ext_call.success:
                      revert with 0, 'TransferHelper::safeTransfer: transfer failed'
                  require 13847067169082572429, Mask(96, 64, token) >> 64 == bool(13847067169082572429, Mask(96, 64, token) >> 64)
              else:
                  mem[(2 * ceil32(return_data.size)) + 417 len return_data.size] = ext_call.return_data[0 len return_data.size]
                  if not ext_call.success:
                      revert with 0, 'TransferHelper::safeTransfer: transfer failed'
                  if return_data.size:
                      require return_data.size >=′ 32
                      require mem[(2 * ceil32(return_data.size)) + 417] == bool(mem[(2 * ceil32(return_data.size)) + 417])
                  else:
                      require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.withdraw(uint256 amount) with:
                           gas gas_remaining wei
                          args ext_call.return_data[32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
          else:
              if ext_call.return_data[32] < amountTokenMin:
                  revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
              if ext_call.return_data[0] < amountETHMin:
                  revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
              mem[(2 * ceil32(return_data.size)) + 385 len 96] = transfer(address recipient, uint256 amount), address(to) << 64, 0, ext_call.return_data[32], mem[(2 * ceil32(return_data.size)) + 385 len 28]
              call token.mem[(2 * ceil32(return_data.size)) + 385 len 4] with:
                   gas gas_remaining wei
                  args mem[(2 * ceil32(return_data.size)) + 389 len 64]
              if not return_data.size:
                  if not ext_call.success:
                      revert with 0, 'TransferHelper::safeTransfer: transfer failed'
                  require 13847067169082572429, Mask(96, 64, token) >> 64 == bool(13847067169082572429, Mask(96, 64, token) >> 64)
              else:
                  mem[(2 * ceil32(return_data.size)) + 417 len return_data.size] = ext_call.return_data[0 len return_data.size]
                  if not ext_call.success:
                      revert with 0, 'TransferHelper::safeTransfer: transfer failed'
                  if return_data.size:
                      require return_data.size >=′ 32
                      require mem[(2 * ceil32(return_data.size)) + 417] == bool(mem[(2 * ceil32(return_data.size)) + 417])
                  else:
                      require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.withdraw(uint256 amount) with:
                           gas gas_remaining wei
                          args ext_call.return_data[0]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
      else:
          if not token:
              revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
          if token == token:
              if ext_call.return_data[0] < amountTokenMin:
                  revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
              if ext_call.return_data[32] < amountETHMin:
                  revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
              mem[(2 * ceil32(return_data.size)) + 385 len 96] = transfer(address recipient, uint256 amount), address(to) << 64, 0, ext_call.return_data[0], mem[(2 * ceil32(return_data.size)) + 385 len 28]
              call token.mem[(2 * ceil32(return_data.size)) + 385 len 4] with:
                   gas gas_remaining wei
                  args mem[(2 * ceil32(return_data.size)) + 389 len 64]
              if not return_data.size:
                  if not ext_call.success:
                      revert with 0, 'TransferHelper::safeTransfer: transfer failed'
                  require 13847067169082572429, Mask(96, 64, token) >> 64 == bool(13847067169082572429, Mask(96, 64, token) >> 64)
              else:
                  mem[(2 * ceil32(return_data.size)) + 417 len return_data.size] = ext_call.return_data[0 len return_data.size]
                  if not ext_call.success:
                      revert with 0, 'TransferHelper::safeTransfer: transfer failed'
                  if return_data.size:
                      require return_data.size >=′ 32
                      require mem[(2 * ceil32(return_data.size)) + 417] == bool(mem[(2 * ceil32(return_data.size)) + 417])
                  else:
                      require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.withdraw(uint256 amount) with:
                           gas gas_remaining wei
                          args ext_call.return_data[32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
          else:
              if ext_call.return_data[32] < amountTokenMin:
                  revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
              if ext_call.return_data[0] < amountETHMin:
                  revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
              mem[(2 * ceil32(return_data.size)) + 385 len 96] = transfer(address recipient, uint256 amount), address(to) << 64, 0, ext_call.return_data[32], mem[(2 * ceil32(return_data.size)) + 385 len 28]
              call token.mem[(2 * ceil32(return_data.size)) + 385 len 4] with:
                   gas gas_remaining wei
                  args mem[(2 * ceil32(return_data.size)) + 389 len 64]
              if not return_data.size:
                  if not ext_call.success:
                      revert with 0, 'TransferHelper::safeTransfer: transfer failed'
                  require 13847067169082572429, Mask(96, 64, token) >> 64 == bool(13847067169082572429, Mask(96, 64, token) >> 64)
              else:
                  mem[(2 * ceil32(return_data.size)) + 417 len return_data.size] = ext_call.return_data[0 len return_data.size]
                  if not ext_call.success:
                      revert with 0, 'TransferHelper::safeTransfer: transfer failed'
                  if return_data.size:
                      require return_data.size >=′ 32
                      require mem[(2 * ceil32(return_data.size)) + 417] == bool(mem[(2 * ceil32(return_data.size)) + 417])
                  else:
                      require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.withdraw(uint256 amount) with:
                           gas gas_remaining wei
                          args ext_call.return_data[0]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
  else:
      if not token:
          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'FraxswapRouterLibrary: ZERO_ADDRESS'
      call address(sha3(0, 4894420617473177672, sha3(token, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).transferFrom(address sender, address recipient, uint256 amount) with:
           gas gas_remaining wei
          args caller, address(sha3(0, 4894420617473177672, sha3(token, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)), liquidity
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      require return_data.size >=′ 32
      require ext_call.return_data[0] == bool(ext_call.return_data[0])
      call address(sha3(0, 4894420617473177672, sha3(token, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).burn(address to) with:
           gas gas_remaining wei
          args this.address
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      require return_data.size >=′ 64
      if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
          revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
      if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
          if token == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
              if ext_call.return_data[0] < amountTokenMin:
                  revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
              if ext_call.return_data[32] < amountETHMin:
                  revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
              mem[(2 * ceil32(return_data.size)) + 385 len 96] = transfer(address recipient, uint256 amount), address(to) << 64, 0, ext_call.return_data[0], mem[(2 * ceil32(return_data.size)) + 385 len 28]
              call token.mem[(2 * ceil32(return_data.size)) + 385 len 4] with:
                   gas gas_remaining wei
                  args mem[(2 * ceil32(return_data.size)) + 389 len 64]
              if not return_data.size:
                  if not ext_call.success:
                      revert with 0, 'TransferHelper::safeTransfer: transfer failed'
                  require token, 0 == bool(token, 0)
              else:
                  mem[(2 * ceil32(return_data.size)) + 417 len return_data.size] = ext_call.return_data[0 len return_data.size]
                  if not ext_call.success:
                      revert with 0, 'TransferHelper::safeTransfer: transfer failed'
                  if return_data.size:
                      require return_data.size >=′ 32
                      require mem[(2 * ceil32(return_data.size)) + 417] == bool(mem[(2 * ceil32(return_data.size)) + 417])
                  else:
                      require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.withdraw(uint256 amount) with:
                           gas gas_remaining wei
                          args ext_call.return_data[32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
          else:
              if ext_call.return_data[32] < amountTokenMin:
                  revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
              if ext_call.return_data[0] < amountETHMin:
                  revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
              mem[(2 * ceil32(return_data.size)) + 385 len 96] = transfer(address recipient, uint256 amount), address(to) << 64, 0, ext_call.return_data[32], mem[(2 * ceil32(return_data.size)) + 385 len 28]
              call token.mem[(2 * ceil32(return_data.size)) + 385 len 4] with:
                   gas gas_remaining wei
                  args mem[(2 * ceil32(return_data.size)) + 389 len 64]
              if not return_data.size:
                  if not ext_call.success:
                      revert with 0, 'TransferHelper::safeTransfer: transfer failed'
                  require token, 0 == bool(token, 0)
              else:
                  mem[(2 * ceil32(return_data.size)) + 417 len return_data.size] = ext_call.return_data[0 len return_data.size]
                  if not ext_call.success:
                      revert with 0, 'TransferHelper::safeTransfer: transfer failed'
                  if return_data.size:
                      require return_data.size >=′ 32
                      require mem[(2 * ceil32(return_data.size)) + 417] == bool(mem[(2 * ceil32(return_data.size)) + 417])
                  else:
                      require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.withdraw(uint256 amount) with:
                           gas gas_remaining wei
                          args ext_call.return_data[0]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
      else:
          if not token:
              revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
          if token == token:
              if ext_call.return_data[0] < amountTokenMin:
                  revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
              if ext_call.return_data[32] < amountETHMin:
                  revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
              mem[(2 * ceil32(return_data.size)) + 385 len 96] = transfer(address recipient, uint256 amount), address(to) << 64, 0, ext_call.return_data[0], mem[(2 * ceil32(return_data.size)) + 385 len 28]
              call token.mem[(2 * ceil32(return_data.size)) + 385 len 4] with:
                   gas gas_remaining wei
                  args mem[(2 * ceil32(return_data.size)) + 389 len 64]
              if not return_data.size:
                  if not ext_call.success:
                      revert with 0, 'TransferHelper::safeTransfer: transfer failed'
                  require token, 0 == bool(token, 0)
              else:
                  mem[(2 * ceil32(return_data.size)) + 417 len return_data.size] = ext_call.return_data[0 len return_data.size]
                  if not ext_call.success:
                      revert with 0, 'TransferHelper::safeTransfer: transfer failed'
                  if return_data.size:
                      require return_data.size >=′ 32
                      require mem[(2 * ceil32(return_data.size)) + 417] == bool(mem[(2 * ceil32(return_data.size)) + 417])
                  else:
                      require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.withdraw(uint256 amount) with:
                           gas gas_remaining wei
                          args ext_call.return_data[32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
          else:
              if ext_call.return_data[32] < amountTokenMin:
                  revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
              if ext_call.return_data[0] < amountETHMin:
                  revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
              mem[(2 * ceil32(return_data.size)) + 385 len 96] = transfer(address recipient, uint256 amount), address(to) << 64, 0, ext_call.return_data[32], mem[(2 * ceil32(return_data.size)) + 385 len 28]
              call token.mem[(2 * ceil32(return_data.size)) + 385 len 4] with:
                   gas gas_remaining wei
                  args mem[(2 * ceil32(return_data.size)) + 389 len 64]
              if not return_data.size:
                  if not ext_call.success:
                      revert with 0, 'TransferHelper::safeTransfer: transfer failed'
                  require token, 0 == bool(token, 0)
              else:
                  mem[(2 * ceil32(return_data.size)) + 417 len return_data.size] = ext_call.return_data[0 len return_data.size]
                  if not ext_call.success:
                      revert with 0, 'TransferHelper::safeTransfer: transfer failed'
                  if return_data.size:
                      require return_data.size >=′ 32
                      require mem[(2 * ceil32(return_data.size)) + 417] == bool(mem[(2 * ceil32(return_data.size)) + 417])
                  else:
                      require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.withdraw(uint256 amount) with:
                           gas gas_remaining wei
                          args ext_call.return_data[0]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def getAmountsIn(uint256 amountOut, address[] path): # not payable
  require calldata.size - 4 >=′ 64
  require path <= LOCK8605463013()
  require path + 35 <′ calldata.size
  if path.length > LOCK8605463013():
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  if ceil32(32 * path.length) + 97 > LOCK8605463013() or ceil32(32 * path.length) + 97 < 96:
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  mem[96] = path.length
  require (32 * path.length) + path + 36 <= calldata.size
  s = 128
  idx = path + 36
  while idx < (32 * path.length) + path + 36:
      require cd[idx] == address(cd[idx])
      mem[s] = cd[idx]
      s = s + 32
      idx = idx + 32
      continue 
  if path.length < 2:
      revert with 0, 'FraxswapRouterLibrary: INVALID_PATH'
  if path.length > LOCK8605463013():
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  mem[ceil32(32 * path.length) + 97] = path.length
  mem[64] = ceil32(32 * path.length) + (32 * path.length) + 129
  if not path.length:
      if path.length < 1:
          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
      if path.length - 1 >= path.length:
          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
      mem[(32 * path.length - 1) + ceil32(32 * path.length) + 129] = amountOut
      if path.length < 1:
          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
      idx = mem[96] - 1
      while idx:
          if idx < 1:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if idx - 1 >= mem[96]:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          if idx >= mem[96]:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          _275 = mem[(32 * idx) + 128]
          if not mem[(32 * idx - 1) + 140 len 20] - mem[(32 * idx) + 140 len 20]:
              revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
          if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
              if not mem[(32 * idx - 1) + 140 len 20]:
                  revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              _288 = mem[64]
              mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
              mem[mem[64] + 52] = address(_275)
              _289 = mem[64]
              mem[mem[64]] = 40
              mem[64] = mem[64] + 72
              _291 = sha3(mem[_289 + 32 len mem[_289]])
              mem[_288 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
              mem[_288 + 105] = 0x43ec799eadd63848443e2347c49f5f52e8fe0f6f000000000000000000000000
              mem[_288 + 125] = _291
              mem[_288 + 157] = 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3
              mem[_288 + 72] = 85
              static call address(sha3(0, 4894420617473177672, _291, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).twammUpToDate() with:
                      gas gas_remaining wei
              mem[_288 + 189] = ext_call.return_data[0]
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 32
              require ext_call.return_data[0] == bool(ext_call.return_data[0])
              if not ext_call.return_data[0]:
                  revert with 0, 'twamm out of date'
              if idx >= mem[ceil32(32 * path.length) + 97]:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              _348 = mem[(32 * idx) + ceil32(32 * path.length) + 129]
              if idx < 1:
                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
              if idx - 1 >= mem[96]:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              mem[_288 + ceil32(return_data.size) + 193] = mem[(32 * idx) + ceil32(32 * path.length) + 129]
              mem[_288 + ceil32(return_data.size) + 225] = mem[(32 * idx - 1) + 140 len 20]
              static call address(sha3(0, 4894420617473177672, _291, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getAmountIn(uint256 amountOut, address tokenOut) with:
                      gas gas_remaining wei
                     args _348, mem[(32 * idx - 1) + 140 len 20]
              mem[_288 + ceil32(return_data.size) + 189] = ext_call.return_data[0]
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              mem[64] = _288 + (2 * ceil32(return_data.size)) + 189
          else:
              if not mem[(32 * idx) + 140 len 20]:
                  revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              _294 = mem[64]
              mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
              mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
              _295 = mem[64]
              mem[mem[64]] = 40
              mem[64] = mem[64] + 72
              _297 = sha3(mem[_295 + 32 len mem[_295]])
              mem[_294 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
              mem[_294 + 105] = 0x43ec799eadd63848443e2347c49f5f52e8fe0f6f000000000000000000000000
              mem[_294 + 125] = _297
              mem[_294 + 157] = 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3
              mem[_294 + 72] = 85
              static call address(sha3(0, 4894420617473177672, _297, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).twammUpToDate() with:
                      gas gas_remaining wei
              mem[_294 + 189] = ext_call.return_data[0]
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 32
              require ext_call.return_data[0] == bool(ext_call.return_data[0])
              if not ext_call.return_data[0]:
                  revert with 0, 'twamm out of date'
              if idx >= mem[ceil32(32 * path.length) + 97]:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              _350 = mem[(32 * idx) + ceil32(32 * path.length) + 129]
              if idx < 1:
                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
              if idx - 1 >= mem[96]:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              mem[_294 + ceil32(return_data.size) + 193] = mem[(32 * idx) + ceil32(32 * path.length) + 129]
              mem[_294 + ceil32(return_data.size) + 225] = mem[(32 * idx - 1) + 140 len 20]
              static call address(sha3(0, 4894420617473177672, _297, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getAmountIn(uint256 amountOut, address tokenOut) with:
                      gas gas_remaining wei
                     args _350, mem[(32 * idx - 1) + 140 len 20]
              mem[_294 + ceil32(return_data.size) + 189] = ext_call.return_data[0]
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              mem[64] = _294 + (2 * ceil32(return_data.size)) + 189
          require return_data.size >=′ 32
          if idx < 1:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if idx - 1 >= mem[ceil32(32 * path.length) + 97]:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          mem[(32 * idx - 1) + ceil32(32 * path.length) + 129] = ext_call.return_data[0]
          if not idx:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          idx = idx - 1
          continue 
      mem[mem[64]] = 32
      _266 = mem[ceil32(32 * path.length) + 97]
      mem[mem[64] + 32] = mem[ceil32(32 * path.length) + 97]
      mem[mem[64] + 64 len 32 * _266] = mem[ceil32(32 * path.length) + 129 len 32 * _266]
      return 32, mem[mem[64] + 32 len (32 * _266) + 32]
  mem[ceil32(32 * path.length) + 129 len 32 * path.length] = call.data[calldata.size len 32 * path.length]
  if path.length < 1:
      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
  if path.length - 1 >= path.length:
      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
  mem[(32 * path.length - 1) + ceil32(32 * path.length) + 129] = amountOut
  if path.length < 1:
      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
  idx = mem[96] - 1
  while idx:
      if idx < 1:
          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
      if idx - 1 >= mem[96]:
          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
      if idx >= mem[96]:
          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
      _277 = mem[(32 * idx) + 128]
      if not mem[(32 * idx - 1) + 140 len 20] - mem[(32 * idx) + 140 len 20]:
          revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
      if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
          if not mem[(32 * idx - 1) + 140 len 20]:
              revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
          _300 = mem[64]
          mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
          mem[mem[64] + 52] = address(_277)
          _301 = mem[64]
          mem[mem[64]] = 40
          mem[64] = mem[64] + 72
          _303 = sha3(mem[_301 + 32 len mem[_301]])
          mem[_300 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
          mem[_300 + 105] = 0x43ec799eadd63848443e2347c49f5f52e8fe0f6f000000000000000000000000
          mem[_300 + 125] = _303
          mem[_300 + 157] = 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3
          mem[_300 + 72] = 85
          static call address(sha3(0, 4894420617473177672, _303, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).twammUpToDate() with:
                  gas gas_remaining wei
          mem[_300 + 189] = ext_call.return_data[0]
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          require return_data.size >=′ 32
          require ext_call.return_data[0] == bool(ext_call.return_data[0])
          if not ext_call.return_data[0]:
              revert with 0, 'twamm out of date'
          if idx >= mem[ceil32(32 * path.length) + 97]:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          _352 = mem[(32 * idx) + ceil32(32 * path.length) + 129]
          if idx < 1:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if idx - 1 >= mem[96]:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          mem[_300 + ceil32(return_data.size) + 193] = mem[(32 * idx) + ceil32(32 * path.length) + 129]
          mem[_300 + ceil32(return_data.size) + 225] = mem[(32 * idx - 1) + 140 len 20]
          static call address(sha3(0, 4894420617473177672, _303, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getAmountIn(uint256 amountOut, address tokenOut) with:
                  gas gas_remaining wei
                 args _352, mem[(32 * idx - 1) + 140 len 20]
          mem[_300 + ceil32(return_data.size) + 189] = ext_call.return_data[0]
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          mem[64] = _300 + (2 * ceil32(return_data.size)) + 189
      else:
          if not mem[(32 * idx) + 140 len 20]:
              revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
          _306 = mem[64]
          mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
          mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
          _307 = mem[64]
          mem[mem[64]] = 40
          mem[64] = mem[64] + 72
          _309 = sha3(mem[_307 + 32 len mem[_307]])
          mem[_306 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
          mem[_306 + 105] = 0x43ec799eadd63848443e2347c49f5f52e8fe0f6f000000000000000000000000
          mem[_306 + 125] = _309
          mem[_306 + 157] = 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3
          mem[_306 + 72] = 85
          static call address(sha3(0, 4894420617473177672, _309, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).twammUpToDate() with:
                  gas gas_remaining wei
          mem[_306 + 189] = ext_call.return_data[0]
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          require return_data.size >=′ 32
          require ext_call.return_data[0] == bool(ext_call.return_data[0])
          if not ext_call.return_data[0]:
              revert with 0, 'twamm out of date'
          if idx >= mem[ceil32(32 * path.length) + 97]:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          _354 = mem[(32 * idx) + ceil32(32 * path.length) + 129]
          if idx < 1:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if idx - 1 >= mem[96]:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          mem[_306 + ceil32(return_data.size) + 193] = mem[(32 * idx) + ceil32(32 * path.length) + 129]
          mem[_306 + ceil32(return_data.size) + 225] = mem[(32 * idx - 1) + 140 len 20]
          static call address(sha3(0, 4894420617473177672, _309, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getAmountIn(uint256 amountOut, address tokenOut) with:
                  gas gas_remaining wei
                 args _354, mem[(32 * idx - 1) + 140 len 20]
          mem[_306 + ceil32(return_data.size) + 189] = ext_call.return_data[0]
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          mem[64] = _306 + (2 * ceil32(return_data.size)) + 189
      require return_data.size >=′ 32
      if idx < 1:
          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
      if idx - 1 >= mem[ceil32(32 * path.length) + 97]:
          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
      mem[(32 * idx - 1) + ceil32(32 * path.length) + 129] = ext_call.return_data[0]
      if not idx:
          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
      idx = idx - 1
      continue 
  mem[mem[64]] = 32
  _268 = mem[ceil32(32 * path.length) + 97]
  mem[mem[64] + 32] = mem[ceil32(32 * path.length) + 97]
  mem[mem[64] + 64 len 32 * _268] = mem[ceil32(32 * path.length) + 129 len 32 * _268]
  return 32, mem[mem[64] + 32 len (32 * _268) + 32]

def getAmountsInWithTwamm(uint256 amountOut, address[] path): # not payable
  require calldata.size - 4 >=′ 64
  require path <= LOCK8605463013()
  require path + 35 <′ calldata.size
  if path.length > LOCK8605463013():
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  if ceil32(32 * path.length) + 97 > LOCK8605463013() or ceil32(32 * path.length) + 97 < 96:
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  mem[96] = path.length
  require (32 * path.length) + path + 36 <= calldata.size
  s = 128
  idx = path + 36
  while idx < (32 * path.length) + path + 36:
      require cd[idx] == address(cd[idx])
      mem[s] = cd[idx]
      s = s + 32
      idx = idx + 32
      continue 
  if path.length < 2:
      revert with 0, 'FraxswapRouterLibrary: INVALID_PATH'
  if path.length > LOCK8605463013():
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  mem[ceil32(32 * path.length) + 97] = path.length
  mem[64] = ceil32(32 * path.length) + (32 * path.length) + 129
  if not path.length:
      if path.length < 1:
          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
      if path.length - 1 >= path.length:
          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
      mem[(32 * path.length - 1) + ceil32(32 * path.length) + 129] = amountOut
      if path.length < 1:
          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
      idx = mem[96] - 1
      while idx:
          if idx < 1:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if idx - 1 >= mem[96]:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          if idx >= mem[96]:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          _243 = mem[(32 * idx) + 128]
          if not mem[(32 * idx - 1) + 140 len 20] - mem[(32 * idx) + 140 len 20]:
              revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
          if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
              if not mem[(32 * idx - 1) + 140 len 20]:
                  revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              _256 = mem[64]
              mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
              mem[mem[64] + 52] = address(_243)
              _257 = mem[64]
              mem[mem[64]] = 40
              mem[64] = mem[64] + 72
              _259 = sha3(mem[_257 + 32 len mem[_257]])
              mem[_256 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
              mem[_256 + 105] = 0x43ec799eadd63848443e2347c49f5f52e8fe0f6f000000000000000000000000
              mem[_256 + 125] = _259
              mem[_256 + 157] = 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3
              mem[_256 + 72] = 85
              mem[_256 + 189] = 0x2e0ae37500000000000000000000000000000000000000000000000000000000
              mem[_256 + 193] = block.timestamp
              require ext_code.size(address(sha3(0, 4894420617473177672, _259, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
              call address(sha3(0, 4894420617473177672, _259, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                   gas gas_remaining wei
                  args block.timestamp
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              if idx >= mem[ceil32(32 * path.length) + 97]:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              _304 = mem[(32 * idx) + ceil32(32 * path.length) + 129]
              if idx < 1:
                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
              if idx - 1 >= mem[96]:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              mem[_256 + 193] = mem[(32 * idx) + ceil32(32 * path.length) + 129]
              mem[_256 + 225] = mem[(32 * idx - 1) + 140 len 20]
              static call address(sha3(0, 4894420617473177672, _259, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getAmountIn(uint256 amountOut, address tokenOut) with:
                      gas gas_remaining wei
                     args _304, mem[(32 * idx - 1) + 140 len 20]
              mem[_256 + 189] = ext_call.return_data[0]
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              mem[64] = _256 + ceil32(return_data.size) + 189
          else:
              if not mem[(32 * idx) + 140 len 20]:
                  revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              _262 = mem[64]
              mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
              mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
              _263 = mem[64]
              mem[mem[64]] = 40
              mem[64] = mem[64] + 72
              _265 = sha3(mem[_263 + 32 len mem[_263]])
              mem[_262 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
              mem[_262 + 105] = 0x43ec799eadd63848443e2347c49f5f52e8fe0f6f000000000000000000000000
              mem[_262 + 125] = _265
              mem[_262 + 157] = 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3
              mem[_262 + 72] = 85
              mem[_262 + 189] = 0x2e0ae37500000000000000000000000000000000000000000000000000000000
              mem[_262 + 193] = block.timestamp
              require ext_code.size(address(sha3(0, 4894420617473177672, _265, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
              call address(sha3(0, 4894420617473177672, _265, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                   gas gas_remaining wei
                  args block.timestamp
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              if idx >= mem[ceil32(32 * path.length) + 97]:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              _305 = mem[(32 * idx) + ceil32(32 * path.length) + 129]
              if idx < 1:
                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
              if idx - 1 >= mem[96]:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              mem[_262 + 193] = mem[(32 * idx) + ceil32(32 * path.length) + 129]
              mem[_262 + 225] = mem[(32 * idx - 1) + 140 len 20]
              static call address(sha3(0, 4894420617473177672, _265, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getAmountIn(uint256 amountOut, address tokenOut) with:
                      gas gas_remaining wei
                     args _305, mem[(32 * idx - 1) + 140 len 20]
              mem[_262 + 189] = ext_call.return_data[0]
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              mem[64] = _262 + ceil32(return_data.size) + 189
          require return_data.size >=′ 32
          if idx < 1:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if idx - 1 >= mem[ceil32(32 * path.length) + 97]:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          mem[(32 * idx - 1) + ceil32(32 * path.length) + 129] = ext_call.return_data[0]
          if not idx:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          idx = idx - 1
          continue 
      mem[mem[64]] = 32
      _234 = mem[ceil32(32 * path.length) + 97]
      mem[mem[64] + 32] = mem[ceil32(32 * path.length) + 97]
      mem[mem[64] + 64 len 32 * _234] = mem[ceil32(32 * path.length) + 129 len 32 * _234]
      return 32, mem[mem[64] + 32 len (32 * _234) + 32]
  mem[ceil32(32 * path.length) + 129 len 32 * path.length] = call.data[calldata.size len 32 * path.length]
  if path.length < 1:
      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
  if path.length - 1 >= path.length:
      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
  mem[(32 * path.length - 1) + ceil32(32 * path.length) + 129] = amountOut
  if path.length < 1:
      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
  idx = mem[96] - 1
  while idx:
      if idx < 1:
          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
      if idx - 1 >= mem[96]:
          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
      if idx >= mem[96]:
          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
      _245 = mem[(32 * idx) + 128]
      if not mem[(32 * idx - 1) + 140 len 20] - mem[(32 * idx) + 140 len 20]:
          revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
      if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
          if not mem[(32 * idx - 1) + 140 len 20]:
              revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
          _268 = mem[64]
          mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
          mem[mem[64] + 52] = address(_245)
          _269 = mem[64]
          mem[mem[64]] = 40
          mem[64] = mem[64] + 72
          _271 = sha3(mem[_269 + 32 len mem[_269]])
          mem[_268 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
          mem[_268 + 105] = 0x43ec799eadd63848443e2347c49f5f52e8fe0f6f000000000000000000000000
          mem[_268 + 125] = _271
          mem[_268 + 157] = 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3
          mem[_268 + 72] = 85
          mem[_268 + 189] = 0x2e0ae37500000000000000000000000000000000000000000000000000000000
          mem[_268 + 193] = block.timestamp
          require ext_code.size(address(sha3(0, 4894420617473177672, _271, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
          call address(sha3(0, 4894420617473177672, _271, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
               gas gas_remaining wei
              args block.timestamp
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          if idx >= mem[ceil32(32 * path.length) + 97]:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          _306 = mem[(32 * idx) + ceil32(32 * path.length) + 129]
          if idx < 1:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if idx - 1 >= mem[96]:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          mem[_268 + 193] = mem[(32 * idx) + ceil32(32 * path.length) + 129]
          mem[_268 + 225] = mem[(32 * idx - 1) + 140 len 20]
          static call address(sha3(0, 4894420617473177672, _271, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getAmountIn(uint256 amountOut, address tokenOut) with:
                  gas gas_remaining wei
                 args _306, mem[(32 * idx - 1) + 140 len 20]
          mem[_268 + 189] = ext_call.return_data[0]
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          mem[64] = _268 + ceil32(return_data.size) + 189
      else:
          if not mem[(32 * idx) + 140 len 20]:
              revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
          _274 = mem[64]
          mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
          mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
          _275 = mem[64]
          mem[mem[64]] = 40
          mem[64] = mem[64] + 72
          _277 = sha3(mem[_275 + 32 len mem[_275]])
          mem[_274 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
          mem[_274 + 105] = 0x43ec799eadd63848443e2347c49f5f52e8fe0f6f000000000000000000000000
          mem[_274 + 125] = _277
          mem[_274 + 157] = 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3
          mem[_274 + 72] = 85
          mem[_274 + 189] = 0x2e0ae37500000000000000000000000000000000000000000000000000000000
          mem[_274 + 193] = block.timestamp
          require ext_code.size(address(sha3(0, 4894420617473177672, _277, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
          call address(sha3(0, 4894420617473177672, _277, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
               gas gas_remaining wei
              args block.timestamp
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          if idx >= mem[ceil32(32 * path.length) + 97]:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          _307 = mem[(32 * idx) + ceil32(32 * path.length) + 129]
          if idx < 1:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if idx - 1 >= mem[96]:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          mem[_274 + 193] = mem[(32 * idx) + ceil32(32 * path.length) + 129]
          mem[_274 + 225] = mem[(32 * idx - 1) + 140 len 20]
          static call address(sha3(0, 4894420617473177672, _277, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getAmountIn(uint256 amountOut, address tokenOut) with:
                  gas gas_remaining wei
                 args _307, mem[(32 * idx - 1) + 140 len 20]
          mem[_274 + 189] = ext_call.return_data[0]
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          mem[64] = _274 + ceil32(return_data.size) + 189
      require return_data.size >=′ 32
      if idx < 1:
          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
      if idx - 1 >= mem[ceil32(32 * path.length) + 97]:
          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
      mem[(32 * idx - 1) + ceil32(32 * path.length) + 129] = ext_call.return_data[0]
      if not idx:
          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
      idx = idx - 1
      continue 
  mem[mem[64]] = 32
  _236 = mem[ceil32(32 * path.length) + 97]
  mem[mem[64] + 32] = mem[ceil32(32 * path.length) + 97]
  mem[mem[64] + 64 len 32 * _236] = mem[ceil32(32 * path.length) + 129 len 32 * _236]
  return 32, mem[mem[64] + 32 len (32 * _236) + 32]

def getAmountsOutWithTwamm(uint256 amountIn, address[] path): # not payable
  require calldata.size - 4 >=′ 64
  require path <= LOCK8605463013()
  require path + 35 <′ calldata.size
  if path.length > LOCK8605463013():
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  if ceil32(32 * path.length) + 97 > LOCK8605463013() or ceil32(32 * path.length) + 97 < 96:
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  mem[96] = path.length
  require (32 * path.length) + path + 36 <= calldata.size
  s = 128
  idx = path + 36
  while idx < (32 * path.length) + path + 36:
      require cd[idx] == address(cd[idx])
      mem[s] = cd[idx]
      s = s + 32
      idx = idx + 32
      continue 
  if path.length < 2:
      revert with 0, 'FraxswapRouterLibrary: INVALID_PATH'
  if path.length > LOCK8605463013():
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  mem[ceil32(32 * path.length) + 97] = path.length
  mem[64] = ceil32(32 * path.length) + (32 * path.length) + 129
  if not path.length:
      if 0 < path.length:
          mem[ceil32(32 * path.length) + 129] = amountIn
          if var57001 < 1:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if var61002 >= var61001:
              return Array(len=path.length, data=mem[ceil32(32 * path.length) + 129 len 32 * path.length])
          if var63001 < path.length:
              if 1 > !var67002:
                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
              idx = var69003 + 1
              s = var69006
              t = var69010
              while idx < path.length:
                  _1166 = mem[(32 * idx) + 128]
                  if not address(s) - mem[(32 * idx) + 140 len 20]:
                      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
                  if address(s) < mem[(32 * idx) + 140 len 20]:
                      if not address(s):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _1176 = mem[64]
                      mem[mem[64] + 32] = address(s)
                      mem[mem[64] + 52] = address(_1166)
                      _1177 = mem[64]
                      mem[mem[64]] = 40
                      mem[64] = mem[64] + 72
                      _1179 = sha3(mem[_1177 + 32 len mem[_1177]])
                      mem[_1176 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                      mem[_1176 + 105] = 0x43ec799eadd63848443e2347c49f5f52e8fe0f6f000000000000000000000000
                      mem[_1176 + 125] = _1179
                      mem[_1176 + 157] = 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3
                      mem[_1176 + 72] = 85
                      mem[_1176 + 189] = 0x2e0ae37500000000000000000000000000000000000000000000000000000000
                      mem[_1176 + 193] = block.timestamp
                      require ext_code.size(address(sha3(0, 4894420617473177672, _1179, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
                      call address(sha3(0, 4894420617473177672, _1179, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      if t >= mem[ceil32(32 * path.length) + 97]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      _1224 = mem[(32 * t) + ceil32(32 * path.length) + 129]
                      if t >= mem[96]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      _1232 = mem[(32 * t) + 128]
                      mem[_1176 + 193] = mem[(32 * t) + ceil32(32 * path.length) + 129]
                      mem[_1176 + 225] = address(_1232)
                      static call address(sha3(0, 4894420617473177672, _1179, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getAmountOut(uint256 amountIn, address tokenIn) with:
                              gas gas_remaining wei
                             args _1224, address(_1232)
                      mem[_1176 + 189] = ext_call.return_data[0]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      mem[64] = _1176 + ceil32(return_data.size) + 189
                      require return_data.size >=′ 32
                      if 1 > !t:
                          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                      if t + 1 >= mem[ceil32(32 * path.length) + 97]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      mem[(32 * t + 1) + ceil32(32 * path.length) + 129] = ext_call.return_data[0]
                      if not t - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
                          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                      if mem[96] < 1:
                          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                      if t + 1 < mem[96] - 1:
                          if t + 1 >= mem[96]:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          if 1 > !(t + 1):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          idx = t + 2
                          s = mem[(32 * t + 1) + 128]
                          t = t + 1
                          continue 
                      mem[_1176 + ceil32(return_data.size) + 189] = 32
                      _1272 = mem[ceil32(32 * path.length) + 97]
                      mem[_1176 + ceil32(return_data.size) + 221] = mem[ceil32(32 * path.length) + 97]
                      idx = 0
                      s = _1176 + ceil32(return_data.size) + 253
                      t = ceil32(32 * path.length) + 129
                      while idx < _1272:
                          mem[s] = mem[t]
                          idx = idx + 1
                          s = s + 32
                          t = t + 32
                          continue 
                      return 32, mem[_1176 + ceil32(return_data.size) + 221 len (32 * _1272) + 32]
                  if not mem[(32 * idx) + 140 len 20]:
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                  _1182 = mem[64]
                  mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                  mem[mem[64] + 52] = address(s)
                  _1183 = mem[64]
                  mem[mem[64]] = 40
                  mem[64] = mem[64] + 72
                  _1185 = sha3(mem[_1183 + 32 len mem[_1183]])
                  mem[_1182 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                  mem[_1182 + 105] = 0x43ec799eadd63848443e2347c49f5f52e8fe0f6f000000000000000000000000
                  mem[_1182 + 125] = _1185
                  mem[_1182 + 157] = 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3
                  mem[_1182 + 72] = 85
                  mem[_1182 + 189] = 0x2e0ae37500000000000000000000000000000000000000000000000000000000
                  mem[_1182 + 193] = block.timestamp
                  require ext_code.size(address(sha3(0, 4894420617473177672, _1185, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
                  call address(sha3(0, 4894420617473177672, _1185, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                       gas gas_remaining wei
                      args block.timestamp
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if t >= mem[ceil32(32 * path.length) + 97]:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  _1226 = mem[(32 * t) + ceil32(32 * path.length) + 129]
                  if t >= mem[96]:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  _1234 = mem[(32 * t) + 128]
                  mem[_1182 + 193] = mem[(32 * t) + ceil32(32 * path.length) + 129]
                  mem[_1182 + 225] = address(_1234)
                  static call address(sha3(0, 4894420617473177672, _1185, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getAmountOut(uint256 amountIn, address tokenIn) with:
                          gas gas_remaining wei
                         args _1226, address(_1234)
                  mem[_1182 + 189] = ext_call.return_data[0]
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  mem[64] = _1182 + ceil32(return_data.size) + 189
                  require return_data.size >=′ 32
                  if 1 > !t:
                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                  if t + 1 >= mem[ceil32(32 * path.length) + 97]:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  mem[(32 * t + 1) + ceil32(32 * path.length) + 129] = ext_call.return_data[0]
                  if not t - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                  if mem[96] < 1:
                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                  if t + 1 < mem[96] - 1:
                      if t + 1 >= mem[96]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      if 1 > !(t + 1):
                          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                      idx = t + 2
                      s = mem[(32 * t + 1) + 128]
                      t = t + 1
                      continue 
                  mem[_1182 + ceil32(return_data.size) + 189] = 32
                  _1273 = mem[ceil32(32 * path.length) + 97]
                  mem[_1182 + ceil32(return_data.size) + 221] = mem[ceil32(32 * path.length) + 97]
                  idx = 0
                  s = _1182 + ceil32(return_data.size) + 253
                  t = ceil32(32 * path.length) + 129
                  while idx < _1273:
                      mem[s] = mem[t]
                      idx = idx + 1
                      s = s + 32
                      t = t + 32
                      continue 
                  return 32, mem[_1182 + ceil32(return_data.size) + 221 len (32 * _1273) + 32]
  else:
      mem[ceil32(32 * path.length) + 129 len 32 * path.length] = call.data[calldata.size len 32 * path.length]
      if 0 < path.length:
          mem[ceil32(32 * path.length) + 129] = amountIn
          if var58001 < 1:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if var62002 >= var62001:
              return Array(len=path.length, data=mem[ceil32(32 * path.length) + 129 len 32 * path.length])
          if var64001 < path.length:
              if 1 > !var68002:
                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
              idx = var70003 + 1
              s = var70006
              t = var70010
              while idx < path.length:
                  _1167 = mem[(32 * idx) + 128]
                  if not address(s) - mem[(32 * idx) + 140 len 20]:
                      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
                  if address(s) < mem[(32 * idx) + 140 len 20]:
                      if not address(s):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _1188 = mem[64]
                      mem[mem[64] + 32] = address(s)
                      mem[mem[64] + 52] = address(_1167)
                      _1189 = mem[64]
                      mem[mem[64]] = 40
                      mem[64] = mem[64] + 72
                      _1191 = sha3(mem[_1189 + 32 len mem[_1189]])
                      mem[_1188 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                      mem[_1188 + 105] = 0x43ec799eadd63848443e2347c49f5f52e8fe0f6f000000000000000000000000
                      mem[_1188 + 125] = _1191
                      mem[_1188 + 157] = 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3
                      mem[_1188 + 72] = 85
                      mem[_1188 + 189] = 0x2e0ae37500000000000000000000000000000000000000000000000000000000
                      mem[_1188 + 193] = block.timestamp
                      require ext_code.size(address(sha3(0, 4894420617473177672, _1191, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
                      call address(sha3(0, 4894420617473177672, _1191, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      if t >= mem[ceil32(32 * path.length) + 97]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      _1228 = mem[(32 * t) + ceil32(32 * path.length) + 129]
                      if t >= mem[96]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      _1236 = mem[(32 * t) + 128]
                      mem[_1188 + 193] = mem[(32 * t) + ceil32(32 * path.length) + 129]
                      mem[_1188 + 225] = address(_1236)
                      static call address(sha3(0, 4894420617473177672, _1191, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getAmountOut(uint256 amountIn, address tokenIn) with:
                              gas gas_remaining wei
                             args _1228, address(_1236)
                      mem[_1188 + 189] = ext_call.return_data[0]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      mem[64] = _1188 + ceil32(return_data.size) + 189
                      require return_data.size >=′ 32
                      if 1 > !t:
                          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                      if t + 1 >= mem[ceil32(32 * path.length) + 97]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      mem[(32 * t + 1) + ceil32(32 * path.length) + 129] = ext_call.return_data[0]
                      if not t - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
                          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                      if mem[96] < 1:
                          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                      if t + 1 < mem[96] - 1:
                          if t + 1 >= mem[96]:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          if 1 > !(t + 1):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          idx = t + 2
                          s = mem[(32 * t + 1) + 128]
                          t = t + 1
                          continue 
                      mem[_1188 + ceil32(return_data.size) + 189] = 32
                      _1274 = mem[ceil32(32 * path.length) + 97]
                      mem[_1188 + ceil32(return_data.size) + 221] = mem[ceil32(32 * path.length) + 97]
                      idx = 0
                      s = _1188 + ceil32(return_data.size) + 253
                      t = ceil32(32 * path.length) + 129
                      while idx < _1274:
                          mem[s] = mem[t]
                          idx = idx + 1
                          s = s + 32
                          t = t + 32
                          continue 
                      return 32, mem[_1188 + ceil32(return_data.size) + 221 len (32 * _1274) + 32]
                  if not mem[(32 * idx) + 140 len 20]:
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                  _1194 = mem[64]
                  mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                  mem[mem[64] + 52] = address(s)
                  _1195 = mem[64]
                  mem[mem[64]] = 40
                  mem[64] = mem[64] + 72
                  _1197 = sha3(mem[_1195 + 32 len mem[_1195]])
                  mem[_1194 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                  mem[_1194 + 105] = 0x43ec799eadd63848443e2347c49f5f52e8fe0f6f000000000000000000000000
                  mem[_1194 + 125] = _1197
                  mem[_1194 + 157] = 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3
                  mem[_1194 + 72] = 85
                  mem[_1194 + 189] = 0x2e0ae37500000000000000000000000000000000000000000000000000000000
                  mem[_1194 + 193] = block.timestamp
                  require ext_code.size(address(sha3(0, 4894420617473177672, _1197, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
                  call address(sha3(0, 4894420617473177672, _1197, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                       gas gas_remaining wei
                      args block.timestamp
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if t >= mem[ceil32(32 * path.length) + 97]:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  _1230 = mem[(32 * t) + ceil32(32 * path.length) + 129]
                  if t >= mem[96]:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  _1238 = mem[(32 * t) + 128]
                  mem[_1194 + 193] = mem[(32 * t) + ceil32(32 * path.length) + 129]
                  mem[_1194 + 225] = address(_1238)
                  static call address(sha3(0, 4894420617473177672, _1197, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getAmountOut(uint256 amountIn, address tokenIn) with:
                          gas gas_remaining wei
                         args _1230, address(_1238)
                  mem[_1194 + 189] = ext_call.return_data[0]
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  mem[64] = _1194 + ceil32(return_data.size) + 189
                  require return_data.size >=′ 32
                  if 1 > !t:
                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                  if t + 1 >= mem[ceil32(32 * path.length) + 97]:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  mem[(32 * t + 1) + ceil32(32 * path.length) + 129] = ext_call.return_data[0]
                  if not t - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                  if mem[96] < 1:
                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                  if t + 1 < mem[96] - 1:
                      if t + 1 >= mem[96]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      if 1 > !(t + 1):
                          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                      idx = t + 2
                      s = mem[(32 * t + 1) + 128]
                      t = t + 1
                      continue 
                  mem[_1194 + ceil32(return_data.size) + 189] = 32
                  _1275 = mem[ceil32(32 * path.length) + 97]
                  mem[_1194 + ceil32(return_data.size) + 221] = mem[ceil32(32 * path.length) + 97]
                  idx = 0
                  s = _1194 + ceil32(return_data.size) + 253
                  t = ceil32(32 * path.length) + 129
                  while idx < _1275:
                      mem[s] = mem[t]
                      idx = idx + 1
                      s = s + 32
                      t = t + 32
                      continue 
                  return 32, mem[_1194 + ceil32(return_data.size) + 221 len (32 * _1275) + 32]
  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).

def getAmountsOut(uint256 amountIn, address[] path): # not payable
  require calldata.size - 4 >=′ 64
  require path <= LOCK8605463013()
  require path + 35 <′ calldata.size
  if path.length > LOCK8605463013():
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  if ceil32(32 * path.length) + 97 > LOCK8605463013() or ceil32(32 * path.length) + 97 < 96:
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  mem[96] = path.length
  require (32 * path.length) + path + 36 <= calldata.size
  s = 128
  idx = path + 36
  while idx < (32 * path.length) + path + 36:
      require cd[idx] == address(cd[idx])
      mem[s] = cd[idx]
      s = s + 32
      idx = idx + 32
      continue 
  if path.length < 2:
      revert with 0, 'FraxswapRouterLibrary: INVALID_PATH'
  if path.length > LOCK8605463013():
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  mem[ceil32(32 * path.length) + 97] = path.length
  mem[64] = ceil32(32 * path.length) + (32 * path.length) + 129
  if not path.length:
      if 0 < path.length:
          mem[ceil32(32 * path.length) + 129] = amountIn
          if var63001 < 1:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if var67002 >= var67001:
              return Array(len=path.length, data=mem[ceil32(32 * path.length) + 129 len 32 * path.length])
          if var69001 < path.length:
              if 1 > !var73002:
                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
              idx = var75003 + 1
              s = var75006
              t = var75010
              while idx < path.length:
                  _1326 = mem[(32 * idx) + 128]
                  if not address(s) - mem[(32 * idx) + 140 len 20]:
                      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
                  if address(s) < mem[(32 * idx) + 140 len 20]:
                      if not address(s):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _1336 = mem[64]
                      mem[mem[64] + 32] = address(s)
                      mem[mem[64] + 52] = address(_1326)
                      _1337 = mem[64]
                      mem[mem[64]] = 40
                      mem[64] = mem[64] + 72
                      _1339 = sha3(mem[_1337 + 32 len mem[_1337]])
                      mem[_1336 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                      mem[_1336 + 105] = 0x43ec799eadd63848443e2347c49f5f52e8fe0f6f000000000000000000000000
                      mem[_1336 + 125] = _1339
                      mem[_1336 + 157] = 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3
                      mem[_1336 + 72] = 85
                      static call address(sha3(0, 4894420617473177672, _1339, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).twammUpToDate() with:
                              gas gas_remaining wei
                      mem[_1336 + 189] = ext_call.return_data[0]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      require ext_call.return_data[0] == bool(ext_call.return_data[0])
                      if not ext_call.return_data[0]:
                          revert with 0, 'twamm out of date'
                      if t >= mem[ceil32(32 * path.length) + 97]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      _1396 = mem[(32 * t) + ceil32(32 * path.length) + 129]
                      if t >= mem[96]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      _1408 = mem[(32 * t) + 128]
                      mem[_1336 + ceil32(return_data.size) + 193] = mem[(32 * t) + ceil32(32 * path.length) + 129]
                      mem[_1336 + ceil32(return_data.size) + 225] = address(_1408)
                      static call address(sha3(0, 4894420617473177672, _1339, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getAmountOut(uint256 amountIn, address tokenIn) with:
                              gas gas_remaining wei
                             args _1396, address(_1408)
                      mem[_1336 + ceil32(return_data.size) + 189] = ext_call.return_data[0]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      mem[64] = _1336 + (2 * ceil32(return_data.size)) + 189
                      require return_data.size >=′ 32
                      if 1 > !t:
                          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                      if t + 1 >= mem[ceil32(32 * path.length) + 97]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      mem[(32 * t + 1) + ceil32(32 * path.length) + 129] = ext_call.return_data[0]
                      if not t - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
                          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                      if mem[96] < 1:
                          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                      if t + 1 < mem[96] - 1:
                          if t + 1 >= mem[96]:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          if 1 > !(t + 1):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          idx = t + 2
                          s = mem[(32 * t + 1) + 128]
                          t = t + 1
                          continue 
                      mem[_1336 + (2 * ceil32(return_data.size)) + 189] = 32
                      _1448 = mem[ceil32(32 * path.length) + 97]
                      mem[_1336 + (2 * ceil32(return_data.size)) + 221] = mem[ceil32(32 * path.length) + 97]
                      idx = 0
                      s = _1336 + (2 * ceil32(return_data.size)) + 253
                      t = ceil32(32 * path.length) + 129
                      while idx < _1448:
                          mem[s] = mem[t]
                          idx = idx + 1
                          s = s + 32
                          t = t + 32
                          continue 
                      return 32, mem[_1336 + (2 * ceil32(return_data.size)) + 221 len (32 * _1448) + 32]
                  if not mem[(32 * idx) + 140 len 20]:
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                  _1342 = mem[64]
                  mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                  mem[mem[64] + 52] = address(s)
                  _1343 = mem[64]
                  mem[mem[64]] = 40
                  mem[64] = mem[64] + 72
                  _1345 = sha3(mem[_1343 + 32 len mem[_1343]])
                  mem[_1342 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                  mem[_1342 + 105] = 0x43ec799eadd63848443e2347c49f5f52e8fe0f6f000000000000000000000000
                  mem[_1342 + 125] = _1345
                  mem[_1342 + 157] = 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3
                  mem[_1342 + 72] = 85
                  static call address(sha3(0, 4894420617473177672, _1345, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).twammUpToDate() with:
                          gas gas_remaining wei
                  mem[_1342 + 189] = ext_call.return_data[0]
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >=′ 32
                  require ext_call.return_data[0] == bool(ext_call.return_data[0])
                  if not ext_call.return_data[0]:
                      revert with 0, 'twamm out of date'
                  if t >= mem[ceil32(32 * path.length) + 97]:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  _1399 = mem[(32 * t) + ceil32(32 * path.length) + 129]
                  if t >= mem[96]:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  _1410 = mem[(32 * t) + 128]
                  mem[_1342 + ceil32(return_data.size) + 193] = mem[(32 * t) + ceil32(32 * path.length) + 129]
                  mem[_1342 + ceil32(return_data.size) + 225] = address(_1410)
                  static call address(sha3(0, 4894420617473177672, _1345, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getAmountOut(uint256 amountIn, address tokenIn) with:
                          gas gas_remaining wei
                         args _1399, address(_1410)
                  mem[_1342 + ceil32(return_data.size) + 189] = ext_call.return_data[0]
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  mem[64] = _1342 + (2 * ceil32(return_data.size)) + 189
                  require return_data.size >=′ 32
                  if 1 > !t:
                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                  if t + 1 >= mem[ceil32(32 * path.length) + 97]:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  mem[(32 * t + 1) + ceil32(32 * path.length) + 129] = ext_call.return_data[0]
                  if not t - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                  if mem[96] < 1:
                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                  if t + 1 < mem[96] - 1:
                      if t + 1 >= mem[96]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      if 1 > !(t + 1):
                          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                      idx = t + 2
                      s = mem[(32 * t + 1) + 128]
                      t = t + 1
                      continue 
                  mem[_1342 + (2 * ceil32(return_data.size)) + 189] = 32
                  _1449 = mem[ceil32(32 * path.length) + 97]
                  mem[_1342 + (2 * ceil32(return_data.size)) + 221] = mem[ceil32(32 * path.length) + 97]
                  idx = 0
                  s = _1342 + (2 * ceil32(return_data.size)) + 253
                  t = ceil32(32 * path.length) + 129
                  while idx < _1449:
                      mem[s] = mem[t]
                      idx = idx + 1
                      s = s + 32
                      t = t + 32
                      continue 
                  return 32, mem[_1342 + (2 * ceil32(return_data.size)) + 221 len (32 * _1449) + 32]
  else:
      mem[ceil32(32 * path.length) + 129 len 32 * path.length] = call.data[calldata.size len 32 * path.length]
      if 0 < path.length:
          mem[ceil32(32 * path.length) + 129] = amountIn
          if var64001 < 1:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if var68002 >= var68001:
              return Array(len=path.length, data=mem[ceil32(32 * path.length) + 129 len 32 * path.length])
          if var70001 < path.length:
              if 1 > !var74002:
                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
              idx = var76003 + 1
              s = var76006
              t = var76010
              while idx < path.length:
                  _1327 = mem[(32 * idx) + 128]
                  if not address(s) - mem[(32 * idx) + 140 len 20]:
                      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
                  if address(s) < mem[(32 * idx) + 140 len 20]:
                      if not address(s):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _1348 = mem[64]
                      mem[mem[64] + 32] = address(s)
                      mem[mem[64] + 52] = address(_1327)
                      _1349 = mem[64]
                      mem[mem[64]] = 40
                      mem[64] = mem[64] + 72
                      _1351 = sha3(mem[_1349 + 32 len mem[_1349]])
                      mem[_1348 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                      mem[_1348 + 105] = 0x43ec799eadd63848443e2347c49f5f52e8fe0f6f000000000000000000000000
                      mem[_1348 + 125] = _1351
                      mem[_1348 + 157] = 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3
                      mem[_1348 + 72] = 85
                      static call address(sha3(0, 4894420617473177672, _1351, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).twammUpToDate() with:
                              gas gas_remaining wei
                      mem[_1348 + 189] = ext_call.return_data[0]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      require ext_call.return_data[0] == bool(ext_call.return_data[0])
                      if not ext_call.return_data[0]:
                          revert with 0, 'twamm out of date'
                      if t >= mem[ceil32(32 * path.length) + 97]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      _1402 = mem[(32 * t) + ceil32(32 * path.length) + 129]
                      if t >= mem[96]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      _1412 = mem[(32 * t) + 128]
                      mem[_1348 + ceil32(return_data.size) + 193] = mem[(32 * t) + ceil32(32 * path.length) + 129]
                      mem[_1348 + ceil32(return_data.size) + 225] = address(_1412)
                      static call address(sha3(0, 4894420617473177672, _1351, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getAmountOut(uint256 amountIn, address tokenIn) with:
                              gas gas_remaining wei
                             args _1402, address(_1412)
                      mem[_1348 + ceil32(return_data.size) + 189] = ext_call.return_data[0]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      mem[64] = _1348 + (2 * ceil32(return_data.size)) + 189
                      require return_data.size >=′ 32
                      if 1 > !t:
                          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                      if t + 1 >= mem[ceil32(32 * path.length) + 97]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      mem[(32 * t + 1) + ceil32(32 * path.length) + 129] = ext_call.return_data[0]
                      if not t - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
                          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                      if mem[96] < 1:
                          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                      if t + 1 < mem[96] - 1:
                          if t + 1 >= mem[96]:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          if 1 > !(t + 1):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          idx = t + 2
                          s = mem[(32 * t + 1) + 128]
                          t = t + 1
                          continue 
                      mem[_1348 + (2 * ceil32(return_data.size)) + 189] = 32
                      _1450 = mem[ceil32(32 * path.length) + 97]
                      mem[_1348 + (2 * ceil32(return_data.size)) + 221] = mem[ceil32(32 * path.length) + 97]
                      idx = 0
                      s = _1348 + (2 * ceil32(return_data.size)) + 253
                      t = ceil32(32 * path.length) + 129
                      while idx < _1450:
                          mem[s] = mem[t]
                          idx = idx + 1
                          s = s + 32
                          t = t + 32
                          continue 
                      return 32, mem[_1348 + (2 * ceil32(return_data.size)) + 221 len (32 * _1450) + 32]
                  if not mem[(32 * idx) + 140 len 20]:
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                  _1354 = mem[64]
                  mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                  mem[mem[64] + 52] = address(s)
                  _1355 = mem[64]
                  mem[mem[64]] = 40
                  mem[64] = mem[64] + 72
                  _1357 = sha3(mem[_1355 + 32 len mem[_1355]])
                  mem[_1354 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                  mem[_1354 + 105] = 0x43ec799eadd63848443e2347c49f5f52e8fe0f6f000000000000000000000000
                  mem[_1354 + 125] = _1357
                  mem[_1354 + 157] = 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3
                  mem[_1354 + 72] = 85
                  static call address(sha3(0, 4894420617473177672, _1357, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).twammUpToDate() with:
                          gas gas_remaining wei
                  mem[_1354 + 189] = ext_call.return_data[0]
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >=′ 32
                  require ext_call.return_data[0] == bool(ext_call.return_data[0])
                  if not ext_call.return_data[0]:
                      revert with 0, 'twamm out of date'
                  if t >= mem[ceil32(32 * path.length) + 97]:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  _1405 = mem[(32 * t) + ceil32(32 * path.length) + 129]
                  if t >= mem[96]:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  _1414 = mem[(32 * t) + 128]
                  mem[_1354 + ceil32(return_data.size) + 193] = mem[(32 * t) + ceil32(32 * path.length) + 129]
                  mem[_1354 + ceil32(return_data.size) + 225] = address(_1414)
                  static call address(sha3(0, 4894420617473177672, _1357, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getAmountOut(uint256 amountIn, address tokenIn) with:
                          gas gas_remaining wei
                         args _1405, address(_1414)
                  mem[_1354 + ceil32(return_data.size) + 189] = ext_call.return_data[0]
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  mem[64] = _1354 + (2 * ceil32(return_data.size)) + 189
                  require return_data.size >=′ 32
                  if 1 > !t:
                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                  if t + 1 >= mem[ceil32(32 * path.length) + 97]:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  mem[(32 * t + 1) + ceil32(32 * path.length) + 129] = ext_call.return_data[0]
                  if not t - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                  if mem[96] < 1:
                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                  if t + 1 < mem[96] - 1:
                      if t + 1 >= mem[96]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      if 1 > !(t + 1):
                          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                      idx = t + 2
                      s = mem[(32 * t + 1) + 128]
                      t = t + 1
                      continue 
                  mem[_1354 + (2 * ceil32(return_data.size)) + 189] = 32
                  _1451 = mem[ceil32(32 * path.length) + 97]
                  mem[_1354 + (2 * ceil32(return_data.size)) + 221] = mem[ceil32(32 * path.length) + 97]
                  idx = 0
                  s = _1354 + (2 * ceil32(return_data.size)) + 253
                  t = ceil32(32 * path.length) + 129
                  while idx < _1451:
                      mem[s] = mem[t]
                      idx = idx + 1
                      s = s + 32
                      t = t + 32
                      continue 
                  return 32, mem[_1354 + (2 * ceil32(return_data.size)) + 221 len (32 * _1451) + 32]
  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).

def addLiquidityETH(address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline) payable: 
  require calldata.size - 4 >=′ 192
  require token == token
  require to == to
  if deadline < block.timestamp:
      revert with 0, 'FraxswapV1Router: EXPIRED'
  static call 0x43ec799eadd63848443e2347c49f5f52e8fe0f6f.getPair(address , address ) with:
          gas gas_remaining wei
         args address(token), 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  require return_data.size >=′ 32
  require ext_call.return_data[0] == ext_call.return_data[12 len 20]
  if ext_call.return_data[12 len 20]:
      if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
          revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
      if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
          if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
              revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
          if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
              require ext_code.size(address(sha3(0, 4894420617473177672, sha3(13847067169082572429, token), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
              call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, token), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                   gas gas_remaining wei
                  args block.timestamp
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              static call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, token), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getTwammReserves() with:
                      gas gas_remaining wei
          else:
              if not token:
                  revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              require ext_code.size(address(sha3(0, 4894420617473177672, sha3(token, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
              call address(sha3(0, 4894420617473177672, sha3(token, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                   gas gas_remaining wei
                  args block.timestamp
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              static call address(sha3(0, 4894420617473177672, sha3(token, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getTwammReserves() with:
                      gas gas_remaining wei
          mem[ceil32(return_data.size) + 285 len 192] = ext_call.return_data[0 len 192]
          require return_data.size >=′ 192
          require ext_call.return_data[0] == ext_call.return_data[18 len 14]
          require ext_call.return_data[32] == ext_call.return_data[50 len 14]
          require ext_call.return_data[64] == ext_call.return_data[92 len 4]
          require ext_call.return_data[96] == ext_call.return_data[114 len 14]
          require ext_call.return_data[128] == ext_call.return_data[146 len 14]
          if token == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
              if not ext_call.return_data[18 len 14]:
                  if not ext_call.return_data[50 len 14]:
                      if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                          mem[(2 * ceil32(return_data.size)) + 321] = 42
                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: IDENTICAL'
                          mem[(2 * ceil32(return_data.size)) + 385] = '_ADDRESSES'
                      else:
                          if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                          if token:
                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                          mem[(2 * ceil32(return_data.size)) + 321] = 35
                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: ZERO_ADDR'
                          mem[(2 * ceil32(return_data.size)) + 385] = 'ESS'
                  else:
                      if amountTokenDesired <= 0:
                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                          mem[(2 * ceil32(return_data.size)) + 321] = 42
                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                      else:
                          if ext_call.return_data[18 len 14] <= 0:
                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                              mem[(2 * ceil32(return_data.size)) + 321] = 45
                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                              mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                          else:
                              if ext_call.return_data[50 len 14] <= 0:
                                  mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(2 * ceil32(return_data.size)) + 289] = 32
                                  mem[(2 * ceil32(return_data.size)) + 321] = 45
                                  mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                  mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                              else:
                                  if amountTokenDesired and ext_call.return_data[50 len 14] > -1 / amountTokenDesired:
                                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                                  if not ext_call.return_data[18 len 14]:
                                      revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                                  if amountTokenDesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] > call.value:
                                      if call.value <= 0:
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 42
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                                      else:
                                          if ext_call.return_data[50 len 14] > 0:
                                              if ext_call.return_data[18 len 14] > 0:
                                                  if call.value and ext_call.return_data[18 len 14] > -1 / call.value:
                                                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                                                  if not ext_call.return_data[50 len 14]:
                                                      revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                                                  if call.value * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] > amountTokenDesired:
                                                      revert with Panic(1)  # If you call assert with an argument that evaluates to false.
                                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 45
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                                  else:
                                      if amountTokenDesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] < amountETHMin:
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 39
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_B'
                                          mem[(2 * ceil32(return_data.size)) + 385] = '_AMOUNT'
                                      else:
                                          if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                                              mem[(2 * ceil32(return_data.size)) + 321] = 42
                                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: IDENTICAL'
                                              mem[(2 * ceil32(return_data.size)) + 385] = '_ADDRESSES'
                                          else:
                                              if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                              if token:
                                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                                              mem[(2 * ceil32(return_data.size)) + 321] = 35
                                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: ZERO_ADDR'
                                              mem[(2 * ceil32(return_data.size)) + 385] = 'ESS'
              else:
                  if amountTokenDesired <= 0:
                      mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(2 * ceil32(return_data.size)) + 289] = 32
                      mem[(2 * ceil32(return_data.size)) + 321] = 42
                      mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                      mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                  else:
                      if ext_call.return_data[18 len 14] <= 0:
                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                          mem[(2 * ceil32(return_data.size)) + 321] = 45
                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                      else:
                          if ext_call.return_data[50 len 14] <= 0:
                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                              mem[(2 * ceil32(return_data.size)) + 321] = 45
                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                              mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                          else:
                              if amountTokenDesired and ext_call.return_data[50 len 14] > -1 / amountTokenDesired:
                                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                              if not ext_call.return_data[18 len 14]:
                                  revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                              if amountTokenDesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] <= call.value:
                                  if amountTokenDesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] < amountETHMin:
                                      mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                      mem[(2 * ceil32(return_data.size)) + 289] = 32
                                      mem[(2 * ceil32(return_data.size)) + 321] = 39
                                      mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_B'
                                      mem[(2 * ceil32(return_data.size)) + 385] = '_AMOUNT'
                                  else:
                                      if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 42
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: IDENTICAL'
                                          mem[(2 * ceil32(return_data.size)) + 385] = '_ADDRESSES'
                                      else:
                                          if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                          if token:
                                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 35
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: ZERO_ADDR'
                                          mem[(2 * ceil32(return_data.size)) + 385] = 'ESS'
                              else:
                                  if call.value <= 0:
                                      mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                      mem[(2 * ceil32(return_data.size)) + 289] = 32
                                      mem[(2 * ceil32(return_data.size)) + 321] = 42
                                      mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                      mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                                  else:
                                      if ext_call.return_data[50 len 14] <= 0:
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 45
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                                      else:
                                          if ext_call.return_data[18 len 14] <= 0:
                                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                                              mem[(2 * ceil32(return_data.size)) + 321] = 45
                                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                              mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                                          else:
                                              if call.value and ext_call.return_data[18 len 14] > -1 / call.value:
                                                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                                              if not ext_call.return_data[50 len 14]:
                                                  revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                                              if call.value * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] > amountTokenDesired:
                                                  revert with Panic(1)  # If you call assert with an argument that evaluates to false.
                                              if call.value * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] >= amountTokenMin:
                                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                                              mem[(2 * ceil32(return_data.size)) + 321] = 39
                                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_A'
                                              mem[(2 * ceil32(return_data.size)) + 385] = '_AMOUNT'
          else:
              if not ext_call.return_data[50 len 14]:
                  if not ext_call.return_data[18 len 14]:
                      if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                          mem[(2 * ceil32(return_data.size)) + 321] = 42
                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: IDENTICAL'
                          mem[(2 * ceil32(return_data.size)) + 385] = '_ADDRESSES'
                      else:
                          if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                          if token:
                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                          mem[(2 * ceil32(return_data.size)) + 321] = 35
                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: ZERO_ADDR'
                          mem[(2 * ceil32(return_data.size)) + 385] = 'ESS'
                  else:
                      if amountTokenDesired <= 0:
                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                          mem[(2 * ceil32(return_data.size)) + 321] = 42
                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                      else:
                          if ext_call.return_data[50 len 14] <= 0:
                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                              mem[(2 * ceil32(return_data.size)) + 321] = 45
                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                              mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                          else:
                              if ext_call.return_data[18 len 14] <= 0:
                                  mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(2 * ceil32(return_data.size)) + 289] = 32
                                  mem[(2 * ceil32(return_data.size)) + 321] = 45
                                  mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                  mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                              else:
                                  if amountTokenDesired and ext_call.return_data[18 len 14] > -1 / amountTokenDesired:
                                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                                  if not ext_call.return_data[50 len 14]:
                                      revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                                  if amountTokenDesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] > call.value:
                                      if call.value <= 0:
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 42
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                                      else:
                                          if ext_call.return_data[18 len 14] > 0:
                                              if ext_call.return_data[50 len 14] > 0:
                                                  if call.value and ext_call.return_data[50 len 14] > -1 / call.value:
                                                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                                                  if not ext_call.return_data[18 len 14]:
                                                      revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                                                  if call.value * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] > amountTokenDesired:
                                                      revert with Panic(1)  # If you call assert with an argument that evaluates to false.
                                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 45
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                                  else:
                                      if amountTokenDesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] < amountETHMin:
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 39
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_B'
                                          mem[(2 * ceil32(return_data.size)) + 385] = '_AMOUNT'
                                      else:
                                          if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                                              mem[(2 * ceil32(return_data.size)) + 321] = 42
                                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: IDENTICAL'
                                              mem[(2 * ceil32(return_data.size)) + 385] = '_ADDRESSES'
                                          else:
                                              if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                              if token:
                                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                                              mem[(2 * ceil32(return_data.size)) + 321] = 35
                                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: ZERO_ADDR'
                                              mem[(2 * ceil32(return_data.size)) + 385] = 'ESS'
              else:
                  if amountTokenDesired <= 0:
                      mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(2 * ceil32(return_data.size)) + 289] = 32
                      mem[(2 * ceil32(return_data.size)) + 321] = 42
                      mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                      mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                  else:
                      if ext_call.return_data[50 len 14] <= 0:
                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                          mem[(2 * ceil32(return_data.size)) + 321] = 45
                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                      else:
                          if ext_call.return_data[18 len 14] <= 0:
                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                              mem[(2 * ceil32(return_data.size)) + 321] = 45
                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                              mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                          else:
                              if amountTokenDesired and ext_call.return_data[18 len 14] > -1 / amountTokenDesired:
                                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                              if not ext_call.return_data[50 len 14]:
                                  revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                              if amountTokenDesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] <= call.value:
                                  if amountTokenDesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] < amountETHMin:
                                      mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                      mem[(2 * ceil32(return_data.size)) + 289] = 32
                                      mem[(2 * ceil32(return_data.size)) + 321] = 39
                                      mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_B'
                                      mem[(2 * ceil32(return_data.size)) + 385] = '_AMOUNT'
                                  else:
                                      if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 42
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: IDENTICAL'
                                          mem[(2 * ceil32(return_data.size)) + 385] = '_ADDRESSES'
                                      else:
                                          if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                          if token:
                                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 35
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: ZERO_ADDR'
                                          mem[(2 * ceil32(return_data.size)) + 385] = 'ESS'
                              else:
                                  if call.value <= 0:
                                      mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                      mem[(2 * ceil32(return_data.size)) + 289] = 32
                                      mem[(2 * ceil32(return_data.size)) + 321] = 42
                                      mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                      mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                                  else:
                                      if ext_call.return_data[18 len 14] <= 0:
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 45
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                                      else:
                                          if ext_call.return_data[50 len 14] <= 0:
                                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                                              mem[(2 * ceil32(return_data.size)) + 321] = 45
                                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                              mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                                          else:
                                              if call.value and ext_call.return_data[50 len 14] > -1 / call.value:
                                                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                                              if not ext_call.return_data[18 len 14]:
                                                  revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                                              if call.value * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] > amountTokenDesired:
                                                  revert with Panic(1)  # If you call assert with an argument that evaluates to false.
                                              if call.value * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] >= amountTokenMin:
                                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                                              mem[(2 * ceil32(return_data.size)) + 321] = 39
                                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_A'
                                              mem[(2 * ceil32(return_data.size)) + 385] = '_AMOUNT'
      else:
          if not token:
              revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
          if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
              revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
          if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
              require ext_code.size(address(sha3(0, 4894420617473177672, sha3(13847067169082572429, token), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
              call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, token), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                   gas gas_remaining wei
                  args block.timestamp
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              static call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, token), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getTwammReserves() with:
                      gas gas_remaining wei
          else:
              if not token:
                  revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              require ext_code.size(address(sha3(0, 4894420617473177672, sha3(token, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
              call address(sha3(0, 4894420617473177672, sha3(token, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                   gas gas_remaining wei
                  args block.timestamp
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              static call address(sha3(0, 4894420617473177672, sha3(token, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getTwammReserves() with:
                      gas gas_remaining wei
          mem[ceil32(return_data.size) + 285 len 192] = ext_call.return_data[0 len 192]
          require return_data.size >=′ 192
          require ext_call.return_data[0] == ext_call.return_data[18 len 14]
          require ext_call.return_data[32] == ext_call.return_data[50 len 14]
          require ext_call.return_data[64] == ext_call.return_data[92 len 4]
          require ext_call.return_data[96] == ext_call.return_data[114 len 14]
          require ext_call.return_data[128] == ext_call.return_data[146 len 14]
          if token == token:
              if not ext_call.return_data[18 len 14]:
                  if not ext_call.return_data[50 len 14]:
                      if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                          mem[(2 * ceil32(return_data.size)) + 321] = 42
                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: IDENTICAL'
                          mem[(2 * ceil32(return_data.size)) + 385] = '_ADDRESSES'
                      else:
                          if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                          if token:
                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                          mem[(2 * ceil32(return_data.size)) + 321] = 35
                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: ZERO_ADDR'
                          mem[(2 * ceil32(return_data.size)) + 385] = 'ESS'
                  else:
                      if amountTokenDesired <= 0:
                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                          mem[(2 * ceil32(return_data.size)) + 321] = 42
                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                      else:
                          if ext_call.return_data[18 len 14] <= 0:
                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                              mem[(2 * ceil32(return_data.size)) + 321] = 45
                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                              mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                          else:
                              if ext_call.return_data[50 len 14] <= 0:
                                  mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(2 * ceil32(return_data.size)) + 289] = 32
                                  mem[(2 * ceil32(return_data.size)) + 321] = 45
                                  mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                  mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                              else:
                                  if amountTokenDesired and ext_call.return_data[50 len 14] > -1 / amountTokenDesired:
                                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                                  if not ext_call.return_data[18 len 14]:
                                      revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                                  if amountTokenDesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] > call.value:
                                      if call.value <= 0:
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 42
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                                      else:
                                          if ext_call.return_data[50 len 14] > 0:
                                              if ext_call.return_data[18 len 14] > 0:
                                                  if call.value and ext_call.return_data[18 len 14] > -1 / call.value:
                                                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                                                  if not ext_call.return_data[50 len 14]:
                                                      revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                                                  if call.value * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] > amountTokenDesired:
                                                      revert with Panic(1)  # If you call assert with an argument that evaluates to false.
                                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 45
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                                  else:
                                      if amountTokenDesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] < amountETHMin:
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 39
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_B'
                                          mem[(2 * ceil32(return_data.size)) + 385] = '_AMOUNT'
                                      else:
                                          if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                                              mem[(2 * ceil32(return_data.size)) + 321] = 42
                                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: IDENTICAL'
                                              mem[(2 * ceil32(return_data.size)) + 385] = '_ADDRESSES'
                                          else:
                                              if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                              if token:
                                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                                              mem[(2 * ceil32(return_data.size)) + 321] = 35
                                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: ZERO_ADDR'
                                              mem[(2 * ceil32(return_data.size)) + 385] = 'ESS'
              else:
                  if amountTokenDesired <= 0:
                      mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(2 * ceil32(return_data.size)) + 289] = 32
                      mem[(2 * ceil32(return_data.size)) + 321] = 42
                      mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                      mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                  else:
                      if ext_call.return_data[18 len 14] <= 0:
                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                          mem[(2 * ceil32(return_data.size)) + 321] = 45
                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                      else:
                          if ext_call.return_data[50 len 14] <= 0:
                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                              mem[(2 * ceil32(return_data.size)) + 321] = 45
                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                              mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                          else:
                              if amountTokenDesired and ext_call.return_data[50 len 14] > -1 / amountTokenDesired:
                                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                              if not ext_call.return_data[18 len 14]:
                                  revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                              if amountTokenDesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] <= call.value:
                                  if amountTokenDesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] < amountETHMin:
                                      mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                      mem[(2 * ceil32(return_data.size)) + 289] = 32
                                      mem[(2 * ceil32(return_data.size)) + 321] = 39
                                      mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_B'
                                      mem[(2 * ceil32(return_data.size)) + 385] = '_AMOUNT'
                                  else:
                                      if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 42
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: IDENTICAL'
                                          mem[(2 * ceil32(return_data.size)) + 385] = '_ADDRESSES'
                                      else:
                                          if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                          if token:
                                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 35
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: ZERO_ADDR'
                                          mem[(2 * ceil32(return_data.size)) + 385] = 'ESS'
                              else:
                                  if call.value <= 0:
                                      mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                      mem[(2 * ceil32(return_data.size)) + 289] = 32
                                      mem[(2 * ceil32(return_data.size)) + 321] = 42
                                      mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                      mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                                  else:
                                      if ext_call.return_data[50 len 14] <= 0:
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 45
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                                      else:
                                          if ext_call.return_data[18 len 14] <= 0:
                                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                                              mem[(2 * ceil32(return_data.size)) + 321] = 45
                                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                              mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                                          else:
                                              if call.value and ext_call.return_data[18 len 14] > -1 / call.value:
                                                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                                              if not ext_call.return_data[50 len 14]:
                                                  revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                                              if call.value * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] > amountTokenDesired:
                                                  revert with Panic(1)  # If you call assert with an argument that evaluates to false.
                                              if call.value * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] >= amountTokenMin:
                                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                                              mem[(2 * ceil32(return_data.size)) + 321] = 39
                                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_A'
                                              mem[(2 * ceil32(return_data.size)) + 385] = '_AMOUNT'
          else:
              if not ext_call.return_data[50 len 14]:
                  if not ext_call.return_data[18 len 14]:
                      if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                          mem[(2 * ceil32(return_data.size)) + 321] = 42
                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: IDENTICAL'
                          mem[(2 * ceil32(return_data.size)) + 385] = '_ADDRESSES'
                      else:
                          if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                          if token:
                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                          mem[(2 * ceil32(return_data.size)) + 321] = 35
                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: ZERO_ADDR'
                          mem[(2 * ceil32(return_data.size)) + 385] = 'ESS'
                  else:
                      if amountTokenDesired <= 0:
                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                          mem[(2 * ceil32(return_data.size)) + 321] = 42
                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                      else:
                          if ext_call.return_data[50 len 14] <= 0:
                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                              mem[(2 * ceil32(return_data.size)) + 321] = 45
                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                              mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                          else:
                              if ext_call.return_data[18 len 14] <= 0:
                                  mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(2 * ceil32(return_data.size)) + 289] = 32
                                  mem[(2 * ceil32(return_data.size)) + 321] = 45
                                  mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                  mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                              else:
                                  if amountTokenDesired and ext_call.return_data[18 len 14] > -1 / amountTokenDesired:
                                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                                  if not ext_call.return_data[50 len 14]:
                                      revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                                  if amountTokenDesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] > call.value:
                                      if call.value <= 0:
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 42
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                                      else:
                                          if ext_call.return_data[18 len 14] > 0:
                                              if ext_call.return_data[50 len 14] > 0:
                                                  if call.value and ext_call.return_data[50 len 14] > -1 / call.value:
                                                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                                                  if not ext_call.return_data[18 len 14]:
                                                      revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                                                  if call.value * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] > amountTokenDesired:
                                                      revert with Panic(1)  # If you call assert with an argument that evaluates to false.
                                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 45
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                                  else:
                                      if amountTokenDesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] < amountETHMin:
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 39
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_B'
                                          mem[(2 * ceil32(return_data.size)) + 385] = '_AMOUNT'
                                      else:
                                          if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                                              mem[(2 * ceil32(return_data.size)) + 321] = 42
                                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: IDENTICAL'
                                              mem[(2 * ceil32(return_data.size)) + 385] = '_ADDRESSES'
                                          else:
                                              if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                              if token:
                                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                                              mem[(2 * ceil32(return_data.size)) + 321] = 35
                                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: ZERO_ADDR'
                                              mem[(2 * ceil32(return_data.size)) + 385] = 'ESS'
              else:
                  if amountTokenDesired <= 0:
                      mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(2 * ceil32(return_data.size)) + 289] = 32
                      mem[(2 * ceil32(return_data.size)) + 321] = 42
                      mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                      mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                  else:
                      if ext_call.return_data[50 len 14] <= 0:
                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                          mem[(2 * ceil32(return_data.size)) + 321] = 45
                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                      else:
                          if ext_call.return_data[18 len 14] <= 0:
                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                              mem[(2 * ceil32(return_data.size)) + 321] = 45
                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                              mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                          else:
                              if amountTokenDesired and ext_call.return_data[18 len 14] > -1 / amountTokenDesired:
                                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                              if not ext_call.return_data[50 len 14]:
                                  revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                              if amountTokenDesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] <= call.value:
                                  if amountTokenDesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] < amountETHMin:
                                      mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                      mem[(2 * ceil32(return_data.size)) + 289] = 32
                                      mem[(2 * ceil32(return_data.size)) + 321] = 39
                                      mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_B'
                                      mem[(2 * ceil32(return_data.size)) + 385] = '_AMOUNT'
                                  else:
                                      if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 42
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: IDENTICAL'
                                          mem[(2 * ceil32(return_data.size)) + 385] = '_ADDRESSES'
                                      else:
                                          if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                          if token:
                                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 35
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: ZERO_ADDR'
                                          mem[(2 * ceil32(return_data.size)) + 385] = 'ESS'
                              else:
                                  if call.value <= 0:
                                      mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                      mem[(2 * ceil32(return_data.size)) + 289] = 32
                                      mem[(2 * ceil32(return_data.size)) + 321] = 42
                                      mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                      mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                                  else:
                                      if ext_call.return_data[18 len 14] <= 0:
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 45
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                                      else:
                                          if ext_call.return_data[50 len 14] <= 0:
                                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                                              mem[(2 * ceil32(return_data.size)) + 321] = 45
                                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                              mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                                          else:
                                              if call.value and ext_call.return_data[50 len 14] > -1 / call.value:
                                                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                                              if not ext_call.return_data[18 len 14]:
                                                  revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                                              if call.value * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] > amountTokenDesired:
                                                  revert with Panic(1)  # If you call assert with an argument that evaluates to false.
                                              if call.value * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] >= amountTokenMin:
                                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                                              mem[(2 * ceil32(return_data.size)) + 321] = 39
                                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_A'
                                              mem[(2 * ceil32(return_data.size)) + 385] = '_AMOUNT'
      revert with memory
        from (2 * ceil32(return_data.size)) + 285
         len ceil32(return_data.size) + 132
  call 0x43ec799eadd63848443e2347c49f5f52e8fe0f6f.createPair(address tokenA, address tokenB) with:
       gas gas_remaining wei
      args address(token), 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  require return_data.size >=′ 32
  require ext_call.return_data[0] == ext_call.return_data[12 len 20]
  if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
  if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
      if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
          revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
      if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
          require ext_code.size(address(sha3(0, 4894420617473177672, sha3(13847067169082572429, token), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
          call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, token), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
               gas gas_remaining wei
              args block.timestamp
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          static call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, token), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getTwammReserves() with:
                  gas gas_remaining wei
      else:
          if not token:
              revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
          require ext_code.size(address(sha3(0, 4894420617473177672, sha3(token, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
          call address(sha3(0, 4894420617473177672, sha3(token, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
               gas gas_remaining wei
              args block.timestamp
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          static call address(sha3(0, 4894420617473177672, sha3(token, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getTwammReserves() with:
                  gas gas_remaining wei
      mem[(2 * ceil32(return_data.size)) + 285 len 192] = ext_call.return_data[0 len 192]
      require return_data.size >=′ 192
      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
      if token == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
          if ext_call.return_data[18 len 14]:
              if amountTokenDesired <= 0:
                  mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                  mem[(4 * ceil32(return_data.size)) + 289] = 32
                  mem[(4 * ceil32(return_data.size)) + 321] = 42
                  mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                  mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
              else:
                  if ext_call.return_data[18 len 14] <= 0:
                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                      mem[(4 * ceil32(return_data.size)) + 321] = 45
                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                      mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                  else:
                      if ext_call.return_data[50 len 14] <= 0:
                          mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(4 * ceil32(return_data.size)) + 289] = 32
                          mem[(4 * ceil32(return_data.size)) + 321] = 45
                          mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                          mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                      else:
                          if amountTokenDesired and ext_call.return_data[50 len 14] > -1 / amountTokenDesired:
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if not ext_call.return_data[18 len 14]:
                              revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                          if amountTokenDesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] <= call.value:
                              if amountTokenDesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] >= amountETHMin:
                                  if token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                              mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(4 * ceil32(return_data.size)) + 289] = 32
                              mem[(4 * ceil32(return_data.size)) + 321] = 39
                              mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_B'
                              mem[(4 * ceil32(return_data.size)) + 385] = '_AMOUNT'
                          else:
                              if call.value <= 0:
                                  mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(4 * ceil32(return_data.size)) + 289] = 32
                                  mem[(4 * ceil32(return_data.size)) + 321] = 42
                                  mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                  mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                              else:
                                  if ext_call.return_data[50 len 14] > 0:
                                      if ext_call.return_data[18 len 14] > 0:
                                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                  mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(4 * ceil32(return_data.size)) + 289] = 32
                                  mem[(4 * ceil32(return_data.size)) + 321] = 45
                                  mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                  mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
          else:
              if not ext_call.return_data[50 len 14]:
                  if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                      mem[(4 * ceil32(return_data.size)) + 321] = 42
                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: IDENTICAL'
                      mem[(4 * ceil32(return_data.size)) + 385] = '_ADDRESSES'
                  else:
                      if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                      if token:
                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                      mem[(4 * ceil32(return_data.size)) + 321] = 35
                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: ZERO_ADDR'
                      mem[(4 * ceil32(return_data.size)) + 385] = 'ESS'
              else:
                  if amountTokenDesired <= 0:
                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                      mem[(4 * ceil32(return_data.size)) + 321] = 42
                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                      mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                  else:
                      if ext_call.return_data[18 len 14] <= 0:
                          mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(4 * ceil32(return_data.size)) + 289] = 32
                          mem[(4 * ceil32(return_data.size)) + 321] = 45
                          mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                          mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                      else:
                          if ext_call.return_data[50 len 14] <= 0:
                              mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(4 * ceil32(return_data.size)) + 289] = 32
                              mem[(4 * ceil32(return_data.size)) + 321] = 45
                              mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                              mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                          else:
                              if amountTokenDesired and ext_call.return_data[50 len 14] > -1 / amountTokenDesired:
                                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                              if not ext_call.return_data[18 len 14]:
                                  revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                              if amountTokenDesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] <= call.value:
                                  if amountTokenDesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] >= amountETHMin:
                                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                  mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(4 * ceil32(return_data.size)) + 289] = 32
                                  mem[(4 * ceil32(return_data.size)) + 321] = 39
                                  mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_B'
                                  mem[(4 * ceil32(return_data.size)) + 385] = '_AMOUNT'
                              else:
                                  if call.value <= 0:
                                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                                      mem[(4 * ceil32(return_data.size)) + 321] = 42
                                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                      mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                                  else:
                                      if ext_call.return_data[50 len 14] > 0:
                                          if ext_call.return_data[18 len 14] > 0:
                                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                                      mem[(4 * ceil32(return_data.size)) + 321] = 45
                                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                      mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
      else:
          if ext_call.return_data[50 len 14]:
              if amountTokenDesired <= 0:
                  mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                  mem[(4 * ceil32(return_data.size)) + 289] = 32
                  mem[(4 * ceil32(return_data.size)) + 321] = 42
                  mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                  mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
              else:
                  if ext_call.return_data[50 len 14] <= 0:
                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                      mem[(4 * ceil32(return_data.size)) + 321] = 45
                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                      mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                  else:
                      if ext_call.return_data[18 len 14] <= 0:
                          mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(4 * ceil32(return_data.size)) + 289] = 32
                          mem[(4 * ceil32(return_data.size)) + 321] = 45
                          mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                          mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                      else:
                          if amountTokenDesired and ext_call.return_data[18 len 14] > -1 / amountTokenDesired:
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if not ext_call.return_data[50 len 14]:
                              revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                          if amountTokenDesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] <= call.value:
                              if amountTokenDesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] >= amountETHMin:
                                  if token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                              mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(4 * ceil32(return_data.size)) + 289] = 32
                              mem[(4 * ceil32(return_data.size)) + 321] = 39
                              mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_B'
                              mem[(4 * ceil32(return_data.size)) + 385] = '_AMOUNT'
                          else:
                              if call.value <= 0:
                                  mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(4 * ceil32(return_data.size)) + 289] = 32
                                  mem[(4 * ceil32(return_data.size)) + 321] = 42
                                  mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                  mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                              else:
                                  if ext_call.return_data[18 len 14] > 0:
                                      if ext_call.return_data[50 len 14] > 0:
                                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                  mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(4 * ceil32(return_data.size)) + 289] = 32
                                  mem[(4 * ceil32(return_data.size)) + 321] = 45
                                  mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                  mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
          else:
              if not ext_call.return_data[18 len 14]:
                  if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                      mem[(4 * ceil32(return_data.size)) + 321] = 42
                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: IDENTICAL'
                      mem[(4 * ceil32(return_data.size)) + 385] = '_ADDRESSES'
                  else:
                      if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                      if token:
                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                      mem[(4 * ceil32(return_data.size)) + 321] = 35
                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: ZERO_ADDR'
                      mem[(4 * ceil32(return_data.size)) + 385] = 'ESS'
              else:
                  if amountTokenDesired <= 0:
                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                      mem[(4 * ceil32(return_data.size)) + 321] = 42
                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                      mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                  else:
                      if ext_call.return_data[50 len 14] <= 0:
                          mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(4 * ceil32(return_data.size)) + 289] = 32
                          mem[(4 * ceil32(return_data.size)) + 321] = 45
                          mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                          mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                      else:
                          if ext_call.return_data[18 len 14] <= 0:
                              mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(4 * ceil32(return_data.size)) + 289] = 32
                              mem[(4 * ceil32(return_data.size)) + 321] = 45
                              mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                              mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                          else:
                              if amountTokenDesired and ext_call.return_data[18 len 14] > -1 / amountTokenDesired:
                                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                              if not ext_call.return_data[50 len 14]:
                                  revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                              if amountTokenDesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] <= call.value:
                                  if amountTokenDesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] >= amountETHMin:
                                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                  mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(4 * ceil32(return_data.size)) + 289] = 32
                                  mem[(4 * ceil32(return_data.size)) + 321] = 39
                                  mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_B'
                                  mem[(4 * ceil32(return_data.size)) + 385] = '_AMOUNT'
                              else:
                                  if call.value <= 0:
                                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                                      mem[(4 * ceil32(return_data.size)) + 321] = 42
                                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                      mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                                  else:
                                      if ext_call.return_data[18 len 14] > 0:
                                          if ext_call.return_data[50 len 14] > 0:
                                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                                      mem[(4 * ceil32(return_data.size)) + 321] = 45
                                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                      mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
  else:
      if not token:
          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
      if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
          revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
      if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
          require ext_code.size(address(sha3(0, 4894420617473177672, sha3(13847067169082572429, token), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
          call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, token), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
               gas gas_remaining wei
              args block.timestamp
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          static call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, token), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getTwammReserves() with:
                  gas gas_remaining wei
      else:
          if not token:
              revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
          require ext_code.size(address(sha3(0, 4894420617473177672, sha3(token, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
          call address(sha3(0, 4894420617473177672, sha3(token, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
               gas gas_remaining wei
              args block.timestamp
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          static call address(sha3(0, 4894420617473177672, sha3(token, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getTwammReserves() with:
                  gas gas_remaining wei
      mem[(2 * ceil32(return_data.size)) + 285 len 192] = ext_call.return_data[0 len 192]
      require return_data.size >=′ 192
      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
      if token == token:
          if ext_call.return_data[18 len 14]:
              if amountTokenDesired <= 0:
                  mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                  mem[(4 * ceil32(return_data.size)) + 289] = 32
                  mem[(4 * ceil32(return_data.size)) + 321] = 42
                  mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                  mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
              else:
                  if ext_call.return_data[18 len 14] <= 0:
                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                      mem[(4 * ceil32(return_data.size)) + 321] = 45
                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                      mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                  else:
                      if ext_call.return_data[50 len 14] <= 0:
                          mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(4 * ceil32(return_data.size)) + 289] = 32
                          mem[(4 * ceil32(return_data.size)) + 321] = 45
                          mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                          mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                      else:
                          if amountTokenDesired and ext_call.return_data[50 len 14] > -1 / amountTokenDesired:
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if not ext_call.return_data[18 len 14]:
                              revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                          if amountTokenDesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] <= call.value:
                              if amountTokenDesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] >= amountETHMin:
                                  if token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                              mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(4 * ceil32(return_data.size)) + 289] = 32
                              mem[(4 * ceil32(return_data.size)) + 321] = 39
                              mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_B'
                              mem[(4 * ceil32(return_data.size)) + 385] = '_AMOUNT'
                          else:
                              if call.value <= 0:
                                  mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(4 * ceil32(return_data.size)) + 289] = 32
                                  mem[(4 * ceil32(return_data.size)) + 321] = 42
                                  mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                  mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                              else:
                                  if ext_call.return_data[50 len 14] > 0:
                                      if ext_call.return_data[18 len 14] > 0:
                                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                  mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(4 * ceil32(return_data.size)) + 289] = 32
                                  mem[(4 * ceil32(return_data.size)) + 321] = 45
                                  mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                  mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
          else:
              if not ext_call.return_data[50 len 14]:
                  if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                      mem[(4 * ceil32(return_data.size)) + 321] = 42
                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: IDENTICAL'
                      mem[(4 * ceil32(return_data.size)) + 385] = '_ADDRESSES'
                  else:
                      if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                      if token:
                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                      mem[(4 * ceil32(return_data.size)) + 321] = 35
                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: ZERO_ADDR'
                      mem[(4 * ceil32(return_data.size)) + 385] = 'ESS'
              else:
                  if amountTokenDesired <= 0:
                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                      mem[(4 * ceil32(return_data.size)) + 321] = 42
                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                      mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                  else:
                      if ext_call.return_data[18 len 14] <= 0:
                          mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(4 * ceil32(return_data.size)) + 289] = 32
                          mem[(4 * ceil32(return_data.size)) + 321] = 45
                          mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                          mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                      else:
                          if ext_call.return_data[50 len 14] <= 0:
                              mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(4 * ceil32(return_data.size)) + 289] = 32
                              mem[(4 * ceil32(return_data.size)) + 321] = 45
                              mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                              mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                          else:
                              if amountTokenDesired and ext_call.return_data[50 len 14] > -1 / amountTokenDesired:
                                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                              if not ext_call.return_data[18 len 14]:
                                  revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                              if amountTokenDesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] <= call.value:
                                  if amountTokenDesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] >= amountETHMin:
                                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                  mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(4 * ceil32(return_data.size)) + 289] = 32
                                  mem[(4 * ceil32(return_data.size)) + 321] = 39
                                  mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_B'
                                  mem[(4 * ceil32(return_data.size)) + 385] = '_AMOUNT'
                              else:
                                  if call.value <= 0:
                                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                                      mem[(4 * ceil32(return_data.size)) + 321] = 42
                                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                      mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                                  else:
                                      if ext_call.return_data[50 len 14] > 0:
                                          if ext_call.return_data[18 len 14] > 0:
                                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                                      mem[(4 * ceil32(return_data.size)) + 321] = 45
                                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                      mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
      else:
          if ext_call.return_data[50 len 14]:
              if amountTokenDesired <= 0:
                  mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                  mem[(4 * ceil32(return_data.size)) + 289] = 32
                  mem[(4 * ceil32(return_data.size)) + 321] = 42
                  mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                  mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
              else:
                  if ext_call.return_data[50 len 14] <= 0:
                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                      mem[(4 * ceil32(return_data.size)) + 321] = 45
                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                      mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                  else:
                      if ext_call.return_data[18 len 14] <= 0:
                          mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(4 * ceil32(return_data.size)) + 289] = 32
                          mem[(4 * ceil32(return_data.size)) + 321] = 45
                          mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                          mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                      else:
                          if amountTokenDesired and ext_call.return_data[18 len 14] > -1 / amountTokenDesired:
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if not ext_call.return_data[50 len 14]:
                              revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                          if amountTokenDesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] <= call.value:
                              if amountTokenDesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] >= amountETHMin:
                                  if token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                              mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(4 * ceil32(return_data.size)) + 289] = 32
                              mem[(4 * ceil32(return_data.size)) + 321] = 39
                              mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_B'
                              mem[(4 * ceil32(return_data.size)) + 385] = '_AMOUNT'
                          else:
                              if call.value <= 0:
                                  mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(4 * ceil32(return_data.size)) + 289] = 32
                                  mem[(4 * ceil32(return_data.size)) + 321] = 42
                                  mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                  mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                              else:
                                  if ext_call.return_data[18 len 14] > 0:
                                      if ext_call.return_data[50 len 14] > 0:
                                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                  mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(4 * ceil32(return_data.size)) + 289] = 32
                                  mem[(4 * ceil32(return_data.size)) + 321] = 45
                                  mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                  mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
          else:
              if not ext_call.return_data[18 len 14]:
                  if not token - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                      mem[(4 * ceil32(return_data.size)) + 321] = 42
                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: IDENTICAL'
                      mem[(4 * ceil32(return_data.size)) + 385] = '_ADDRESSES'
                  else:
                      if token >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                      if token:
                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                      mem[(4 * ceil32(return_data.size)) + 321] = 35
                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: ZERO_ADDR'
                      mem[(4 * ceil32(return_data.size)) + 385] = 'ESS'
              else:
                  if amountTokenDesired <= 0:
                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                      mem[(4 * ceil32(return_data.size)) + 321] = 42
                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                      mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                  else:
                      if ext_call.return_data[50 len 14] <= 0:
                          mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(4 * ceil32(return_data.size)) + 289] = 32
                          mem[(4 * ceil32(return_data.size)) + 321] = 45
                          mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                          mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                      else:
                          if ext_call.return_data[18 len 14] <= 0:
                              mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(4 * ceil32(return_data.size)) + 289] = 32
                              mem[(4 * ceil32(return_data.size)) + 321] = 45
                              mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                              mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                          else:
                              if amountTokenDesired and ext_call.return_data[18 len 14] > -1 / amountTokenDesired:
                                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                              if not ext_call.return_data[50 len 14]:
                                  revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                              if amountTokenDesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] <= call.value:
                                  if amountTokenDesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] >= amountETHMin:
                                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                  mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(4 * ceil32(return_data.size)) + 289] = 32
                                  mem[(4 * ceil32(return_data.size)) + 321] = 39
                                  mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_B'
                                  mem[(4 * ceil32(return_data.size)) + 385] = '_AMOUNT'
                              else:
                                  if call.value <= 0:
                                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                                      mem[(4 * ceil32(return_data.size)) + 321] = 42
                                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                      mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                                  else:
                                      if ext_call.return_data[18 len 14] > 0:
                                          if ext_call.return_data[50 len 14] > 0:
                                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                                      mem[(4 * ceil32(return_data.size)) + 321] = 45
                                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                      mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
  revert with memory
    from (4 * ceil32(return_data.size)) + 285
     len (5 * ceil32(return_data.size)) + 132

def addLiquidity(address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline): # not payable
  require calldata.size - 4 >=′ 256
  require tokenA == tokenA
  require tokenB == tokenB
  require to == to
  if deadline < block.timestamp:
      revert with 0, 'FraxswapV1Router: EXPIRED'
  static call 0x43ec799eadd63848443e2347c49f5f52e8fe0f6f.getPair(address , address ) with:
          gas gas_remaining wei
         args address(tokenA), tokenB
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  require return_data.size >=′ 32
  require ext_call.return_data[0] == ext_call.return_data[12 len 20]
  if ext_call.return_data[12 len 20]:
      if not tokenA - tokenB:
          revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
      if tokenA < tokenB:
          if not tokenA:
              revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
          if not tokenA - tokenB:
              revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
          if tokenA < tokenB:
              if not tokenA:
                  revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              require ext_code.size(address(sha3(0, 4894420617473177672, sha3(tokenA, tokenB), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
              call address(sha3(0, 4894420617473177672, sha3(tokenA, tokenB), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                   gas gas_remaining wei
                  args block.timestamp
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              static call address(sha3(0, 4894420617473177672, sha3(tokenA, tokenB), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getTwammReserves() with:
                      gas gas_remaining wei
          else:
              if not tokenB:
                  revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              require ext_code.size(address(sha3(0, 4894420617473177672, sha3(tokenB, tokenA), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
              call address(sha3(0, 4894420617473177672, sha3(tokenB, tokenA), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                   gas gas_remaining wei
                  args block.timestamp
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              static call address(sha3(0, 4894420617473177672, sha3(tokenB, tokenA), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getTwammReserves() with:
                      gas gas_remaining wei
          mem[ceil32(return_data.size) + 285 len 192] = ext_call.return_data[0 len 192]
          require return_data.size >=′ 192
          require ext_call.return_data[0] == ext_call.return_data[18 len 14]
          require ext_call.return_data[32] == ext_call.return_data[50 len 14]
          require ext_call.return_data[64] == ext_call.return_data[92 len 4]
          require ext_call.return_data[96] == ext_call.return_data[114 len 14]
          require ext_call.return_data[128] == ext_call.return_data[146 len 14]
          if tokenA == tokenA:
              if not ext_call.return_data[18 len 14]:
                  if not ext_call.return_data[50 len 14]:
                      if not tokenA - tokenB:
                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                          mem[(2 * ceil32(return_data.size)) + 321] = 42
                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: IDENTICAL'
                          mem[(2 * ceil32(return_data.size)) + 385] = '_ADDRESSES'
                      else:
                          if tokenA < tokenB:
                              if tokenA:
                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                          else:
                              if tokenB:
                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                          mem[(2 * ceil32(return_data.size)) + 321] = 35
                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: ZERO_ADDR'
                          mem[(2 * ceil32(return_data.size)) + 385] = 'ESS'
                  else:
                      if amountADesired <= 0:
                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                          mem[(2 * ceil32(return_data.size)) + 321] = 42
                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                      else:
                          if ext_call.return_data[18 len 14] <= 0:
                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                              mem[(2 * ceil32(return_data.size)) + 321] = 45
                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                              mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                          else:
                              if ext_call.return_data[50 len 14] <= 0:
                                  mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(2 * ceil32(return_data.size)) + 289] = 32
                                  mem[(2 * ceil32(return_data.size)) + 321] = 45
                                  mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                  mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                              else:
                                  if amountADesired and ext_call.return_data[50 len 14] > -1 / amountADesired:
                                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                                  if not ext_call.return_data[18 len 14]:
                                      revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                                  if amountADesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] > amountBDesired:
                                      if amountBDesired <= 0:
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 42
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                                      else:
                                          if ext_call.return_data[50 len 14] > 0:
                                              if ext_call.return_data[18 len 14] > 0:
                                                  if amountBDesired and ext_call.return_data[18 len 14] > -1 / amountBDesired:
                                                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                                                  if not ext_call.return_data[50 len 14]:
                                                      revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                                                  if amountBDesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] > amountADesired:
                                                      revert with Panic(1)  # If you call assert with an argument that evaluates to false.
                                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 45
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                                  else:
                                      if amountADesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] < amountBMin:
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 39
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_B'
                                          mem[(2 * ceil32(return_data.size)) + 385] = '_AMOUNT'
                                      else:
                                          if not tokenA - tokenB:
                                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                                              mem[(2 * ceil32(return_data.size)) + 321] = 42
                                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: IDENTICAL'
                                              mem[(2 * ceil32(return_data.size)) + 385] = '_ADDRESSES'
                                          else:
                                              if tokenA < tokenB:
                                                  if tokenA:
                                                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                              else:
                                                  if tokenB:
                                                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                                              mem[(2 * ceil32(return_data.size)) + 321] = 35
                                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: ZERO_ADDR'
                                              mem[(2 * ceil32(return_data.size)) + 385] = 'ESS'
              else:
                  if amountADesired <= 0:
                      mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(2 * ceil32(return_data.size)) + 289] = 32
                      mem[(2 * ceil32(return_data.size)) + 321] = 42
                      mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                      mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                  else:
                      if ext_call.return_data[18 len 14] <= 0:
                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                          mem[(2 * ceil32(return_data.size)) + 321] = 45
                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                      else:
                          if ext_call.return_data[50 len 14] <= 0:
                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                              mem[(2 * ceil32(return_data.size)) + 321] = 45
                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                              mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                          else:
                              if amountADesired and ext_call.return_data[50 len 14] > -1 / amountADesired:
                                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                              if not ext_call.return_data[18 len 14]:
                                  revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                              if amountADesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] <= amountBDesired:
                                  if amountADesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] < amountBMin:
                                      mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                      mem[(2 * ceil32(return_data.size)) + 289] = 32
                                      mem[(2 * ceil32(return_data.size)) + 321] = 39
                                      mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_B'
                                      mem[(2 * ceil32(return_data.size)) + 385] = '_AMOUNT'
                                  else:
                                      if not tokenA - tokenB:
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 42
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: IDENTICAL'
                                          mem[(2 * ceil32(return_data.size)) + 385] = '_ADDRESSES'
                                      else:
                                          if tokenA < tokenB:
                                              if tokenA:
                                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                          else:
                                              if tokenB:
                                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 35
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: ZERO_ADDR'
                                          mem[(2 * ceil32(return_data.size)) + 385] = 'ESS'
                              else:
                                  if amountBDesired <= 0:
                                      mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                      mem[(2 * ceil32(return_data.size)) + 289] = 32
                                      mem[(2 * ceil32(return_data.size)) + 321] = 42
                                      mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                      mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                                  else:
                                      if ext_call.return_data[50 len 14] <= 0:
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 45
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                                      else:
                                          if ext_call.return_data[18 len 14] <= 0:
                                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                                              mem[(2 * ceil32(return_data.size)) + 321] = 45
                                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                              mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                                          else:
                                              if amountBDesired and ext_call.return_data[18 len 14] > -1 / amountBDesired:
                                                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                                              if not ext_call.return_data[50 len 14]:
                                                  revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                                              if amountBDesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] > amountADesired:
                                                  revert with Panic(1)  # If you call assert with an argument that evaluates to false.
                                              if amountBDesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] >= amountAMin:
                                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                                              mem[(2 * ceil32(return_data.size)) + 321] = 39
                                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_A'
                                              mem[(2 * ceil32(return_data.size)) + 385] = '_AMOUNT'
          else:
              if not ext_call.return_data[50 len 14]:
                  if not ext_call.return_data[18 len 14]:
                      if not tokenA - tokenB:
                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                          mem[(2 * ceil32(return_data.size)) + 321] = 42
                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: IDENTICAL'
                          mem[(2 * ceil32(return_data.size)) + 385] = '_ADDRESSES'
                      else:
                          if tokenA < tokenB:
                              if tokenA:
                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                          else:
                              if tokenB:
                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                          mem[(2 * ceil32(return_data.size)) + 321] = 35
                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: ZERO_ADDR'
                          mem[(2 * ceil32(return_data.size)) + 385] = 'ESS'
                  else:
                      if amountADesired <= 0:
                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                          mem[(2 * ceil32(return_data.size)) + 321] = 42
                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                      else:
                          if ext_call.return_data[50 len 14] <= 0:
                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                              mem[(2 * ceil32(return_data.size)) + 321] = 45
                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                              mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                          else:
                              if ext_call.return_data[18 len 14] <= 0:
                                  mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(2 * ceil32(return_data.size)) + 289] = 32
                                  mem[(2 * ceil32(return_data.size)) + 321] = 45
                                  mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                  mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                              else:
                                  if amountADesired and ext_call.return_data[18 len 14] > -1 / amountADesired:
                                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                                  if not ext_call.return_data[50 len 14]:
                                      revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                                  if amountADesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] > amountBDesired:
                                      if amountBDesired <= 0:
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 42
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                                      else:
                                          if ext_call.return_data[18 len 14] > 0:
                                              if ext_call.return_data[50 len 14] > 0:
                                                  if amountBDesired and ext_call.return_data[50 len 14] > -1 / amountBDesired:
                                                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                                                  if not ext_call.return_data[18 len 14]:
                                                      revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                                                  if amountBDesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] > amountADesired:
                                                      revert with Panic(1)  # If you call assert with an argument that evaluates to false.
                                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 45
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                                  else:
                                      if amountADesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] < amountBMin:
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 39
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_B'
                                          mem[(2 * ceil32(return_data.size)) + 385] = '_AMOUNT'
                                      else:
                                          if not tokenA - tokenB:
                                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                                              mem[(2 * ceil32(return_data.size)) + 321] = 42
                                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: IDENTICAL'
                                              mem[(2 * ceil32(return_data.size)) + 385] = '_ADDRESSES'
                                          else:
                                              if tokenA < tokenB:
                                                  if tokenA:
                                                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                              else:
                                                  if tokenB:
                                                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                                              mem[(2 * ceil32(return_data.size)) + 321] = 35
                                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: ZERO_ADDR'
                                              mem[(2 * ceil32(return_data.size)) + 385] = 'ESS'
              else:
                  if amountADesired <= 0:
                      mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(2 * ceil32(return_data.size)) + 289] = 32
                      mem[(2 * ceil32(return_data.size)) + 321] = 42
                      mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                      mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                  else:
                      if ext_call.return_data[50 len 14] <= 0:
                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                          mem[(2 * ceil32(return_data.size)) + 321] = 45
                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                      else:
                          if ext_call.return_data[18 len 14] <= 0:
                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                              mem[(2 * ceil32(return_data.size)) + 321] = 45
                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                              mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                          else:
                              if amountADesired and ext_call.return_data[18 len 14] > -1 / amountADesired:
                                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                              if not ext_call.return_data[50 len 14]:
                                  revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                              if amountADesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] <= amountBDesired:
                                  if amountADesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] < amountBMin:
                                      mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                      mem[(2 * ceil32(return_data.size)) + 289] = 32
                                      mem[(2 * ceil32(return_data.size)) + 321] = 39
                                      mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_B'
                                      mem[(2 * ceil32(return_data.size)) + 385] = '_AMOUNT'
                                  else:
                                      if not tokenA - tokenB:
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 42
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: IDENTICAL'
                                          mem[(2 * ceil32(return_data.size)) + 385] = '_ADDRESSES'
                                      else:
                                          if tokenA < tokenB:
                                              if tokenA:
                                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                          else:
                                              if tokenB:
                                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 35
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: ZERO_ADDR'
                                          mem[(2 * ceil32(return_data.size)) + 385] = 'ESS'
                              else:
                                  if amountBDesired <= 0:
                                      mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                      mem[(2 * ceil32(return_data.size)) + 289] = 32
                                      mem[(2 * ceil32(return_data.size)) + 321] = 42
                                      mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                      mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                                  else:
                                      if ext_call.return_data[18 len 14] <= 0:
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 45
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                                      else:
                                          if ext_call.return_data[50 len 14] <= 0:
                                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                                              mem[(2 * ceil32(return_data.size)) + 321] = 45
                                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                              mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                                          else:
                                              if amountBDesired and ext_call.return_data[50 len 14] > -1 / amountBDesired:
                                                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                                              if not ext_call.return_data[18 len 14]:
                                                  revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                                              if amountBDesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] > amountADesired:
                                                  revert with Panic(1)  # If you call assert with an argument that evaluates to false.
                                              if amountBDesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] >= amountAMin:
                                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                                              mem[(2 * ceil32(return_data.size)) + 321] = 39
                                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_A'
                                              mem[(2 * ceil32(return_data.size)) + 385] = '_AMOUNT'
      else:
          if not tokenB:
              revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
          if not tokenA - tokenB:
              revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
          if tokenA < tokenB:
              if not tokenA:
                  revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              require ext_code.size(address(sha3(0, 4894420617473177672, sha3(tokenA, tokenB), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
              call address(sha3(0, 4894420617473177672, sha3(tokenA, tokenB), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                   gas gas_remaining wei
                  args block.timestamp
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              static call address(sha3(0, 4894420617473177672, sha3(tokenA, tokenB), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getTwammReserves() with:
                      gas gas_remaining wei
          else:
              if not tokenB:
                  revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              require ext_code.size(address(sha3(0, 4894420617473177672, sha3(tokenB, tokenA), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
              call address(sha3(0, 4894420617473177672, sha3(tokenB, tokenA), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                   gas gas_remaining wei
                  args block.timestamp
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              static call address(sha3(0, 4894420617473177672, sha3(tokenB, tokenA), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getTwammReserves() with:
                      gas gas_remaining wei
          mem[ceil32(return_data.size) + 285 len 192] = ext_call.return_data[0 len 192]
          require return_data.size >=′ 192
          require ext_call.return_data[0] == ext_call.return_data[18 len 14]
          require ext_call.return_data[32] == ext_call.return_data[50 len 14]
          require ext_call.return_data[64] == ext_call.return_data[92 len 4]
          require ext_call.return_data[96] == ext_call.return_data[114 len 14]
          require ext_call.return_data[128] == ext_call.return_data[146 len 14]
          if tokenA == tokenB:
              if not ext_call.return_data[18 len 14]:
                  if not ext_call.return_data[50 len 14]:
                      if not tokenA - tokenB:
                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                          mem[(2 * ceil32(return_data.size)) + 321] = 42
                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: IDENTICAL'
                          mem[(2 * ceil32(return_data.size)) + 385] = '_ADDRESSES'
                      else:
                          if tokenA < tokenB:
                              if tokenA:
                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                          else:
                              if tokenB:
                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                          mem[(2 * ceil32(return_data.size)) + 321] = 35
                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: ZERO_ADDR'
                          mem[(2 * ceil32(return_data.size)) + 385] = 'ESS'
                  else:
                      if amountADesired <= 0:
                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                          mem[(2 * ceil32(return_data.size)) + 321] = 42
                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                      else:
                          if ext_call.return_data[18 len 14] <= 0:
                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                              mem[(2 * ceil32(return_data.size)) + 321] = 45
                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                              mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                          else:
                              if ext_call.return_data[50 len 14] <= 0:
                                  mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(2 * ceil32(return_data.size)) + 289] = 32
                                  mem[(2 * ceil32(return_data.size)) + 321] = 45
                                  mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                  mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                              else:
                                  if amountADesired and ext_call.return_data[50 len 14] > -1 / amountADesired:
                                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                                  if not ext_call.return_data[18 len 14]:
                                      revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                                  if amountADesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] > amountBDesired:
                                      if amountBDesired <= 0:
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 42
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                                      else:
                                          if ext_call.return_data[50 len 14] > 0:
                                              if ext_call.return_data[18 len 14] > 0:
                                                  if amountBDesired and ext_call.return_data[18 len 14] > -1 / amountBDesired:
                                                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                                                  if not ext_call.return_data[50 len 14]:
                                                      revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                                                  if amountBDesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] > amountADesired:
                                                      revert with Panic(1)  # If you call assert with an argument that evaluates to false.
                                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 45
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                                  else:
                                      if amountADesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] < amountBMin:
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 39
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_B'
                                          mem[(2 * ceil32(return_data.size)) + 385] = '_AMOUNT'
                                      else:
                                          if not tokenA - tokenB:
                                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                                              mem[(2 * ceil32(return_data.size)) + 321] = 42
                                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: IDENTICAL'
                                              mem[(2 * ceil32(return_data.size)) + 385] = '_ADDRESSES'
                                          else:
                                              if tokenA < tokenB:
                                                  if tokenA:
                                                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                              else:
                                                  if tokenB:
                                                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                                              mem[(2 * ceil32(return_data.size)) + 321] = 35
                                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: ZERO_ADDR'
                                              mem[(2 * ceil32(return_data.size)) + 385] = 'ESS'
              else:
                  if amountADesired <= 0:
                      mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(2 * ceil32(return_data.size)) + 289] = 32
                      mem[(2 * ceil32(return_data.size)) + 321] = 42
                      mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                      mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                  else:
                      if ext_call.return_data[18 len 14] <= 0:
                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                          mem[(2 * ceil32(return_data.size)) + 321] = 45
                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                      else:
                          if ext_call.return_data[50 len 14] <= 0:
                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                              mem[(2 * ceil32(return_data.size)) + 321] = 45
                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                              mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                          else:
                              if amountADesired and ext_call.return_data[50 len 14] > -1 / amountADesired:
                                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                              if not ext_call.return_data[18 len 14]:
                                  revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                              if amountADesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] <= amountBDesired:
                                  if amountADesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] < amountBMin:
                                      mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                      mem[(2 * ceil32(return_data.size)) + 289] = 32
                                      mem[(2 * ceil32(return_data.size)) + 321] = 39
                                      mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_B'
                                      mem[(2 * ceil32(return_data.size)) + 385] = '_AMOUNT'
                                  else:
                                      if not tokenA - tokenB:
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 42
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: IDENTICAL'
                                          mem[(2 * ceil32(return_data.size)) + 385] = '_ADDRESSES'
                                      else:
                                          if tokenA < tokenB:
                                              if tokenA:
                                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                          else:
                                              if tokenB:
                                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 35
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: ZERO_ADDR'
                                          mem[(2 * ceil32(return_data.size)) + 385] = 'ESS'
                              else:
                                  if amountBDesired <= 0:
                                      mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                      mem[(2 * ceil32(return_data.size)) + 289] = 32
                                      mem[(2 * ceil32(return_data.size)) + 321] = 42
                                      mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                      mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                                  else:
                                      if ext_call.return_data[50 len 14] <= 0:
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 45
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                                      else:
                                          if ext_call.return_data[18 len 14] <= 0:
                                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                                              mem[(2 * ceil32(return_data.size)) + 321] = 45
                                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                              mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                                          else:
                                              if amountBDesired and ext_call.return_data[18 len 14] > -1 / amountBDesired:
                                                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                                              if not ext_call.return_data[50 len 14]:
                                                  revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                                              if amountBDesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] > amountADesired:
                                                  revert with Panic(1)  # If you call assert with an argument that evaluates to false.
                                              if amountBDesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] >= amountAMin:
                                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                                              mem[(2 * ceil32(return_data.size)) + 321] = 39
                                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_A'
                                              mem[(2 * ceil32(return_data.size)) + 385] = '_AMOUNT'
          else:
              if not ext_call.return_data[50 len 14]:
                  if not ext_call.return_data[18 len 14]:
                      if not tokenA - tokenB:
                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                          mem[(2 * ceil32(return_data.size)) + 321] = 42
                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: IDENTICAL'
                          mem[(2 * ceil32(return_data.size)) + 385] = '_ADDRESSES'
                      else:
                          if tokenA < tokenB:
                              if tokenA:
                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                          else:
                              if tokenB:
                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                          mem[(2 * ceil32(return_data.size)) + 321] = 35
                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: ZERO_ADDR'
                          mem[(2 * ceil32(return_data.size)) + 385] = 'ESS'
                  else:
                      if amountADesired <= 0:
                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                          mem[(2 * ceil32(return_data.size)) + 321] = 42
                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                      else:
                          if ext_call.return_data[50 len 14] <= 0:
                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                              mem[(2 * ceil32(return_data.size)) + 321] = 45
                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                              mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                          else:
                              if ext_call.return_data[18 len 14] <= 0:
                                  mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(2 * ceil32(return_data.size)) + 289] = 32
                                  mem[(2 * ceil32(return_data.size)) + 321] = 45
                                  mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                  mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                              else:
                                  if amountADesired and ext_call.return_data[18 len 14] > -1 / amountADesired:
                                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                                  if not ext_call.return_data[50 len 14]:
                                      revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                                  if amountADesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] > amountBDesired:
                                      if amountBDesired <= 0:
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 42
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                                      else:
                                          if ext_call.return_data[18 len 14] > 0:
                                              if ext_call.return_data[50 len 14] > 0:
                                                  if amountBDesired and ext_call.return_data[50 len 14] > -1 / amountBDesired:
                                                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                                                  if not ext_call.return_data[18 len 14]:
                                                      revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                                                  if amountBDesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] > amountADesired:
                                                      revert with Panic(1)  # If you call assert with an argument that evaluates to false.
                                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 45
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                                  else:
                                      if amountADesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] < amountBMin:
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 39
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_B'
                                          mem[(2 * ceil32(return_data.size)) + 385] = '_AMOUNT'
                                      else:
                                          if not tokenA - tokenB:
                                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                                              mem[(2 * ceil32(return_data.size)) + 321] = 42
                                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: IDENTICAL'
                                              mem[(2 * ceil32(return_data.size)) + 385] = '_ADDRESSES'
                                          else:
                                              if tokenA < tokenB:
                                                  if tokenA:
                                                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                              else:
                                                  if tokenB:
                                                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                                              mem[(2 * ceil32(return_data.size)) + 321] = 35
                                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: ZERO_ADDR'
                                              mem[(2 * ceil32(return_data.size)) + 385] = 'ESS'
              else:
                  if amountADesired <= 0:
                      mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(2 * ceil32(return_data.size)) + 289] = 32
                      mem[(2 * ceil32(return_data.size)) + 321] = 42
                      mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                      mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                  else:
                      if ext_call.return_data[50 len 14] <= 0:
                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                          mem[(2 * ceil32(return_data.size)) + 321] = 45
                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                      else:
                          if ext_call.return_data[18 len 14] <= 0:
                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                              mem[(2 * ceil32(return_data.size)) + 321] = 45
                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                              mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                          else:
                              if amountADesired and ext_call.return_data[18 len 14] > -1 / amountADesired:
                                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                              if not ext_call.return_data[50 len 14]:
                                  revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                              if amountADesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] <= amountBDesired:
                                  if amountADesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] < amountBMin:
                                      mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                      mem[(2 * ceil32(return_data.size)) + 289] = 32
                                      mem[(2 * ceil32(return_data.size)) + 321] = 39
                                      mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_B'
                                      mem[(2 * ceil32(return_data.size)) + 385] = '_AMOUNT'
                                  else:
                                      if not tokenA - tokenB:
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 42
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: IDENTICAL'
                                          mem[(2 * ceil32(return_data.size)) + 385] = '_ADDRESSES'
                                      else:
                                          if tokenA < tokenB:
                                              if tokenA:
                                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                          else:
                                              if tokenB:
                                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 35
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: ZERO_ADDR'
                                          mem[(2 * ceil32(return_data.size)) + 385] = 'ESS'
                              else:
                                  if amountBDesired <= 0:
                                      mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                      mem[(2 * ceil32(return_data.size)) + 289] = 32
                                      mem[(2 * ceil32(return_data.size)) + 321] = 42
                                      mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                      mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                                  else:
                                      if ext_call.return_data[18 len 14] <= 0:
                                          mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                          mem[(2 * ceil32(return_data.size)) + 289] = 32
                                          mem[(2 * ceil32(return_data.size)) + 321] = 45
                                          mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                          mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                                      else:
                                          if ext_call.return_data[50 len 14] <= 0:
                                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                                              mem[(2 * ceil32(return_data.size)) + 321] = 45
                                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                              mem[(2 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                                          else:
                                              if amountBDesired and ext_call.return_data[50 len 14] > -1 / amountBDesired:
                                                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                                              if not ext_call.return_data[18 len 14]:
                                                  revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                                              if amountBDesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] > amountADesired:
                                                  revert with Panic(1)  # If you call assert with an argument that evaluates to false.
                                              if amountBDesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] >= amountAMin:
                                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                              mem[(2 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                              mem[(2 * ceil32(return_data.size)) + 289] = 32
                                              mem[(2 * ceil32(return_data.size)) + 321] = 39
                                              mem[(2 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_A'
                                              mem[(2 * ceil32(return_data.size)) + 385] = '_AMOUNT'
      revert with memory
        from (2 * ceil32(return_data.size)) + 285
         len ceil32(return_data.size) + 132
  call 0x43ec799eadd63848443e2347c49f5f52e8fe0f6f.createPair(address tokenA, address tokenB) with:
       gas gas_remaining wei
      args address(tokenA), tokenB
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  require return_data.size >=′ 32
  require ext_call.return_data[0] == ext_call.return_data[12 len 20]
  if not tokenA - tokenB:
      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
  if tokenA < tokenB:
      if not tokenA:
          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
      if not tokenA - tokenB:
          revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
      if tokenA < tokenB:
          if not tokenA:
              revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
          require ext_code.size(address(sha3(0, 4894420617473177672, sha3(tokenA, tokenB), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
          call address(sha3(0, 4894420617473177672, sha3(tokenA, tokenB), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
               gas gas_remaining wei
              args block.timestamp
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          static call address(sha3(0, 4894420617473177672, sha3(tokenA, tokenB), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getTwammReserves() with:
                  gas gas_remaining wei
      else:
          if not tokenB:
              revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
          require ext_code.size(address(sha3(0, 4894420617473177672, sha3(tokenB, tokenA), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
          call address(sha3(0, 4894420617473177672, sha3(tokenB, tokenA), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
               gas gas_remaining wei
              args block.timestamp
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          static call address(sha3(0, 4894420617473177672, sha3(tokenB, tokenA), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getTwammReserves() with:
                  gas gas_remaining wei
      mem[(2 * ceil32(return_data.size)) + 285 len 192] = ext_call.return_data[0 len 192]
      require return_data.size >=′ 192
      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
      if tokenA == tokenA:
          if ext_call.return_data[18 len 14]:
              if amountADesired <= 0:
                  mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                  mem[(4 * ceil32(return_data.size)) + 289] = 32
                  mem[(4 * ceil32(return_data.size)) + 321] = 42
                  mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                  mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
              else:
                  if ext_call.return_data[18 len 14] <= 0:
                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                      mem[(4 * ceil32(return_data.size)) + 321] = 45
                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                      mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                  else:
                      if ext_call.return_data[50 len 14] <= 0:
                          mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(4 * ceil32(return_data.size)) + 289] = 32
                          mem[(4 * ceil32(return_data.size)) + 321] = 45
                          mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                          mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                      else:
                          if amountADesired and ext_call.return_data[50 len 14] > -1 / amountADesired:
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if not ext_call.return_data[18 len 14]:
                              revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                          if amountADesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] <= amountBDesired:
                              if amountADesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] >= amountBMin:
                                  if tokenA - tokenB:
                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                              mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(4 * ceil32(return_data.size)) + 289] = 32
                              mem[(4 * ceil32(return_data.size)) + 321] = 39
                              mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_B'
                              mem[(4 * ceil32(return_data.size)) + 385] = '_AMOUNT'
                          else:
                              if amountBDesired <= 0:
                                  mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(4 * ceil32(return_data.size)) + 289] = 32
                                  mem[(4 * ceil32(return_data.size)) + 321] = 42
                                  mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                  mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                              else:
                                  if ext_call.return_data[50 len 14] > 0:
                                      if ext_call.return_data[18 len 14] > 0:
                                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                  mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(4 * ceil32(return_data.size)) + 289] = 32
                                  mem[(4 * ceil32(return_data.size)) + 321] = 45
                                  mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                  mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
          else:
              if not ext_call.return_data[50 len 14]:
                  if not tokenA - tokenB:
                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                      mem[(4 * ceil32(return_data.size)) + 321] = 42
                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: IDENTICAL'
                      mem[(4 * ceil32(return_data.size)) + 385] = '_ADDRESSES'
                  else:
                      if tokenA < tokenB:
                          if tokenA:
                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                      else:
                          if tokenB:
                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                      mem[(4 * ceil32(return_data.size)) + 321] = 35
                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: ZERO_ADDR'
                      mem[(4 * ceil32(return_data.size)) + 385] = 'ESS'
              else:
                  if amountADesired <= 0:
                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                      mem[(4 * ceil32(return_data.size)) + 321] = 42
                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                      mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                  else:
                      if ext_call.return_data[18 len 14] <= 0:
                          mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(4 * ceil32(return_data.size)) + 289] = 32
                          mem[(4 * ceil32(return_data.size)) + 321] = 45
                          mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                          mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                      else:
                          if ext_call.return_data[50 len 14] <= 0:
                              mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(4 * ceil32(return_data.size)) + 289] = 32
                              mem[(4 * ceil32(return_data.size)) + 321] = 45
                              mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                              mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                          else:
                              if amountADesired and ext_call.return_data[50 len 14] > -1 / amountADesired:
                                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                              if not ext_call.return_data[18 len 14]:
                                  revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                              if amountADesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] <= amountBDesired:
                                  if amountADesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] >= amountBMin:
                                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                  mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(4 * ceil32(return_data.size)) + 289] = 32
                                  mem[(4 * ceil32(return_data.size)) + 321] = 39
                                  mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_B'
                                  mem[(4 * ceil32(return_data.size)) + 385] = '_AMOUNT'
                              else:
                                  if amountBDesired <= 0:
                                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                                      mem[(4 * ceil32(return_data.size)) + 321] = 42
                                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                      mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                                  else:
                                      if ext_call.return_data[50 len 14] > 0:
                                          if ext_call.return_data[18 len 14] > 0:
                                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                                      mem[(4 * ceil32(return_data.size)) + 321] = 45
                                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                      mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
      else:
          if ext_call.return_data[50 len 14]:
              if amountADesired <= 0:
                  mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                  mem[(4 * ceil32(return_data.size)) + 289] = 32
                  mem[(4 * ceil32(return_data.size)) + 321] = 42
                  mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                  mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
              else:
                  if ext_call.return_data[50 len 14] <= 0:
                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                      mem[(4 * ceil32(return_data.size)) + 321] = 45
                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                      mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                  else:
                      if ext_call.return_data[18 len 14] <= 0:
                          mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(4 * ceil32(return_data.size)) + 289] = 32
                          mem[(4 * ceil32(return_data.size)) + 321] = 45
                          mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                          mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                      else:
                          if amountADesired and ext_call.return_data[18 len 14] > -1 / amountADesired:
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if not ext_call.return_data[50 len 14]:
                              revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                          if amountADesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] <= amountBDesired:
                              if amountADesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] >= amountBMin:
                                  if tokenA - tokenB:
                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                              mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(4 * ceil32(return_data.size)) + 289] = 32
                              mem[(4 * ceil32(return_data.size)) + 321] = 39
                              mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_B'
                              mem[(4 * ceil32(return_data.size)) + 385] = '_AMOUNT'
                          else:
                              if amountBDesired <= 0:
                                  mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(4 * ceil32(return_data.size)) + 289] = 32
                                  mem[(4 * ceil32(return_data.size)) + 321] = 42
                                  mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                  mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                              else:
                                  if ext_call.return_data[18 len 14] > 0:
                                      if ext_call.return_data[50 len 14] > 0:
                                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                  mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(4 * ceil32(return_data.size)) + 289] = 32
                                  mem[(4 * ceil32(return_data.size)) + 321] = 45
                                  mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                  mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
          else:
              if not ext_call.return_data[18 len 14]:
                  if not tokenA - tokenB:
                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                      mem[(4 * ceil32(return_data.size)) + 321] = 42
                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: IDENTICAL'
                      mem[(4 * ceil32(return_data.size)) + 385] = '_ADDRESSES'
                  else:
                      if tokenA < tokenB:
                          if tokenA:
                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                      else:
                          if tokenB:
                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                      mem[(4 * ceil32(return_data.size)) + 321] = 35
                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: ZERO_ADDR'
                      mem[(4 * ceil32(return_data.size)) + 385] = 'ESS'
              else:
                  if amountADesired <= 0:
                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                      mem[(4 * ceil32(return_data.size)) + 321] = 42
                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                      mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                  else:
                      if ext_call.return_data[50 len 14] <= 0:
                          mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(4 * ceil32(return_data.size)) + 289] = 32
                          mem[(4 * ceil32(return_data.size)) + 321] = 45
                          mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                          mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                      else:
                          if ext_call.return_data[18 len 14] <= 0:
                              mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(4 * ceil32(return_data.size)) + 289] = 32
                              mem[(4 * ceil32(return_data.size)) + 321] = 45
                              mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                              mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                          else:
                              if amountADesired and ext_call.return_data[18 len 14] > -1 / amountADesired:
                                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                              if not ext_call.return_data[50 len 14]:
                                  revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                              if amountADesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] <= amountBDesired:
                                  if amountADesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] >= amountBMin:
                                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                  mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(4 * ceil32(return_data.size)) + 289] = 32
                                  mem[(4 * ceil32(return_data.size)) + 321] = 39
                                  mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_B'
                                  mem[(4 * ceil32(return_data.size)) + 385] = '_AMOUNT'
                              else:
                                  if amountBDesired <= 0:
                                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                                      mem[(4 * ceil32(return_data.size)) + 321] = 42
                                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                      mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                                  else:
                                      if ext_call.return_data[18 len 14] > 0:
                                          if ext_call.return_data[50 len 14] > 0:
                                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                                      mem[(4 * ceil32(return_data.size)) + 321] = 45
                                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                      mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
  else:
      if not tokenB:
          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
      if not tokenA - tokenB:
          revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
      if tokenA < tokenB:
          if not tokenA:
              revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
          require ext_code.size(address(sha3(0, 4894420617473177672, sha3(tokenA, tokenB), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
          call address(sha3(0, 4894420617473177672, sha3(tokenA, tokenB), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
               gas gas_remaining wei
              args block.timestamp
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          static call address(sha3(0, 4894420617473177672, sha3(tokenA, tokenB), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getTwammReserves() with:
                  gas gas_remaining wei
      else:
          if not tokenB:
              revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
          require ext_code.size(address(sha3(0, 4894420617473177672, sha3(tokenB, tokenA), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
          call address(sha3(0, 4894420617473177672, sha3(tokenB, tokenA), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
               gas gas_remaining wei
              args block.timestamp
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          static call address(sha3(0, 4894420617473177672, sha3(tokenB, tokenA), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getTwammReserves() with:
                  gas gas_remaining wei
      mem[(2 * ceil32(return_data.size)) + 285 len 192] = ext_call.return_data[0 len 192]
      require return_data.size >=′ 192
      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
      if tokenA == tokenB:
          if ext_call.return_data[18 len 14]:
              if amountADesired <= 0:
                  mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                  mem[(4 * ceil32(return_data.size)) + 289] = 32
                  mem[(4 * ceil32(return_data.size)) + 321] = 42
                  mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                  mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
              else:
                  if ext_call.return_data[18 len 14] <= 0:
                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                      mem[(4 * ceil32(return_data.size)) + 321] = 45
                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                      mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                  else:
                      if ext_call.return_data[50 len 14] <= 0:
                          mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(4 * ceil32(return_data.size)) + 289] = 32
                          mem[(4 * ceil32(return_data.size)) + 321] = 45
                          mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                          mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                      else:
                          if amountADesired and ext_call.return_data[50 len 14] > -1 / amountADesired:
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if not ext_call.return_data[18 len 14]:
                              revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                          if amountADesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] <= amountBDesired:
                              if amountADesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] >= amountBMin:
                                  if tokenA - tokenB:
                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                              mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(4 * ceil32(return_data.size)) + 289] = 32
                              mem[(4 * ceil32(return_data.size)) + 321] = 39
                              mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_B'
                              mem[(4 * ceil32(return_data.size)) + 385] = '_AMOUNT'
                          else:
                              if amountBDesired <= 0:
                                  mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(4 * ceil32(return_data.size)) + 289] = 32
                                  mem[(4 * ceil32(return_data.size)) + 321] = 42
                                  mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                  mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                              else:
                                  if ext_call.return_data[50 len 14] > 0:
                                      if ext_call.return_data[18 len 14] > 0:
                                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                  mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(4 * ceil32(return_data.size)) + 289] = 32
                                  mem[(4 * ceil32(return_data.size)) + 321] = 45
                                  mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                  mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
          else:
              if not ext_call.return_data[50 len 14]:
                  if not tokenA - tokenB:
                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                      mem[(4 * ceil32(return_data.size)) + 321] = 42
                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: IDENTICAL'
                      mem[(4 * ceil32(return_data.size)) + 385] = '_ADDRESSES'
                  else:
                      if tokenA < tokenB:
                          if tokenA:
                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                      else:
                          if tokenB:
                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                      mem[(4 * ceil32(return_data.size)) + 321] = 35
                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: ZERO_ADDR'
                      mem[(4 * ceil32(return_data.size)) + 385] = 'ESS'
              else:
                  if amountADesired <= 0:
                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                      mem[(4 * ceil32(return_data.size)) + 321] = 42
                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                      mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                  else:
                      if ext_call.return_data[18 len 14] <= 0:
                          mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(4 * ceil32(return_data.size)) + 289] = 32
                          mem[(4 * ceil32(return_data.size)) + 321] = 45
                          mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                          mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                      else:
                          if ext_call.return_data[50 len 14] <= 0:
                              mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(4 * ceil32(return_data.size)) + 289] = 32
                              mem[(4 * ceil32(return_data.size)) + 321] = 45
                              mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                              mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                          else:
                              if amountADesired and ext_call.return_data[50 len 14] > -1 / amountADesired:
                                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                              if not ext_call.return_data[18 len 14]:
                                  revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                              if amountADesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] <= amountBDesired:
                                  if amountADesired * ext_call.return_data[50 len 14] / ext_call.return_data[18 len 14] >= amountBMin:
                                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                  mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(4 * ceil32(return_data.size)) + 289] = 32
                                  mem[(4 * ceil32(return_data.size)) + 321] = 39
                                  mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_B'
                                  mem[(4 * ceil32(return_data.size)) + 385] = '_AMOUNT'
                              else:
                                  if amountBDesired <= 0:
                                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                                      mem[(4 * ceil32(return_data.size)) + 321] = 42
                                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                      mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                                  else:
                                      if ext_call.return_data[50 len 14] > 0:
                                          if ext_call.return_data[18 len 14] > 0:
                                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                                      mem[(4 * ceil32(return_data.size)) + 321] = 45
                                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                      mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
      else:
          if ext_call.return_data[50 len 14]:
              if amountADesired <= 0:
                  mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                  mem[(4 * ceil32(return_data.size)) + 289] = 32
                  mem[(4 * ceil32(return_data.size)) + 321] = 42
                  mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                  mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
              else:
                  if ext_call.return_data[50 len 14] <= 0:
                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                      mem[(4 * ceil32(return_data.size)) + 321] = 45
                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                      mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                  else:
                      if ext_call.return_data[18 len 14] <= 0:
                          mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(4 * ceil32(return_data.size)) + 289] = 32
                          mem[(4 * ceil32(return_data.size)) + 321] = 45
                          mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                          mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                      else:
                          if amountADesired and ext_call.return_data[18 len 14] > -1 / amountADesired:
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if not ext_call.return_data[50 len 14]:
                              revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                          if amountADesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] <= amountBDesired:
                              if amountADesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] >= amountBMin:
                                  if tokenA - tokenB:
                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                              mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(4 * ceil32(return_data.size)) + 289] = 32
                              mem[(4 * ceil32(return_data.size)) + 321] = 39
                              mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_B'
                              mem[(4 * ceil32(return_data.size)) + 385] = '_AMOUNT'
                          else:
                              if amountBDesired <= 0:
                                  mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(4 * ceil32(return_data.size)) + 289] = 32
                                  mem[(4 * ceil32(return_data.size)) + 321] = 42
                                  mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                  mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                              else:
                                  if ext_call.return_data[18 len 14] > 0:
                                      if ext_call.return_data[50 len 14] > 0:
                                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                  mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(4 * ceil32(return_data.size)) + 289] = 32
                                  mem[(4 * ceil32(return_data.size)) + 321] = 45
                                  mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                  mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
          else:
              if not ext_call.return_data[18 len 14]:
                  if not tokenA - tokenB:
                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                      mem[(4 * ceil32(return_data.size)) + 321] = 42
                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: IDENTICAL'
                      mem[(4 * ceil32(return_data.size)) + 385] = '_ADDRESSES'
                  else:
                      if tokenA < tokenB:
                          if tokenA:
                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                      else:
                          if tokenB:
                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                      mem[(4 * ceil32(return_data.size)) + 321] = 35
                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: ZERO_ADDR'
                      mem[(4 * ceil32(return_data.size)) + 385] = 'ESS'
              else:
                  if amountADesired <= 0:
                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                      mem[(4 * ceil32(return_data.size)) + 321] = 42
                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                      mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                  else:
                      if ext_call.return_data[50 len 14] <= 0:
                          mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(4 * ceil32(return_data.size)) + 289] = 32
                          mem[(4 * ceil32(return_data.size)) + 321] = 45
                          mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                          mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                      else:
                          if ext_call.return_data[18 len 14] <= 0:
                              mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(4 * ceil32(return_data.size)) + 289] = 32
                              mem[(4 * ceil32(return_data.size)) + 321] = 45
                              mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                              mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
                          else:
                              if amountADesired and ext_call.return_data[18 len 14] > -1 / amountADesired:
                                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                              if not ext_call.return_data[50 len 14]:
                                  revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                              if amountADesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] <= amountBDesired:
                                  if amountADesired * ext_call.return_data[18 len 14] / ext_call.return_data[50 len 14] >= amountBMin:
                                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                  mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(4 * ceil32(return_data.size)) + 289] = 32
                                  mem[(4 * ceil32(return_data.size)) + 321] = 39
                                  mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapV1Router: INSUFFICIENT_B'
                                  mem[(4 * ceil32(return_data.size)) + 385] = '_AMOUNT'
                              else:
                                  if amountBDesired <= 0:
                                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                                      mem[(4 * ceil32(return_data.size)) + 321] = 42
                                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                      mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_AMOUNT'
                                  else:
                                      if ext_call.return_data[18 len 14] > 0:
                                          if ext_call.return_data[50 len 14] > 0:
                                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                      mem[(4 * ceil32(return_data.size)) + 285] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                      mem[(4 * ceil32(return_data.size)) + 289] = 32
                                      mem[(4 * ceil32(return_data.size)) + 321] = 45
                                      mem[(4 * ceil32(return_data.size)) + 353] = 'FraxswapRouterLibrary: INSUFFICI'
                                      mem[(4 * ceil32(return_data.size)) + 385] = 'ENT_LIQUIDITY'
  revert with memory
    from (4 * ceil32(return_data.size)) + 285
     len (5 * ceil32(return_data.size)) + 132

def swapExactETHForTokensSupportingFeeOnTransferTokens(uint256 amountOutMin, address[] path, address to, uint256 deadline) payable: 
  require calldata.size - 4 >=′ 128
  require path <= LOCK8605463013()
  require path + 35 <′ calldata.size
  require path.length <= LOCK8605463013()
  require path + (32 * path.length) + 36 <= calldata.size
  require to == to
  if deadline < block.timestamp:
      revert with 0, 'FraxswapV1Router: EXPIRED'
  if 0 >= path.length:
      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
  require cd[(path + 36)] == address(cd[(path + 36)])
  if address(cd[(path + 36)]) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
      revert with 0, 'FraxswapV1Router: INVALID_PATH'
  require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
     value call.value wei
       gas gas_remaining wei
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  if 0 >= path.length:
      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
  require cd[(path + 36)] == address(cd[(path + 36)])
  if 1 >= path.length:
      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
  require cd[(path + 68)] == address(cd[(path + 68)])
  if not address(cd[(path + 36)]) - address(cd[(path + 68)]):
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
  if address(cd[(path + 36)]) < address(cd[(path + 68)]):
      if not address(cd[(path + 36)]):
          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'FraxswapRouterLibrary: ZERO_ADDRESS'
      _14 = sha3(address(cd[(path + 36)]), address(cd[(path + 68)]))
      _25 = sha3(0, 4894420617473177672, _14, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
      mem[321] = call.value
      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transfer(address recipient, uint256 amount) with:
           gas gas_remaining wei
          args address(_25), call.value
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      require return_data.size >=′ 32
      require ext_call.return_data[0] == bool(ext_call.return_data[0])
      if not ext_call.return_data[0]:
          revert with Panic(1)  # If you call assert with an argument that evaluates to false.
      if path.length < 1:
          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
      if path.length - 1 >= path.length:
          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
      require cd[((32 * path.length - 1) + path + 36)] == address(cd[((32 * path.length - 1) + path + 36)])
      mem[ceil32(return_data.size) + 289] = to
      static call address(cd[((32 * path.length - 1) + path + 36)]).balanceOf(address account) with:
              gas gas_remaining wei
             args to
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      require return_data.size >=′ 32
      _43 = ext_call.return_data[0]
      mem[(2 * ceil32(return_data.size)) + 317 len 32 * path.length] = call.data[path + 36 len 32 * path.length]
      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 317] = 0
      if path.length < 1:
          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
      if 0 >= path.length - 1:
          if path.length < 1:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if path.length - 1 >= path.length:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          require cd[((32 * path.length - 1) + path + 36)] == address(cd[((32 * path.length - 1) + path + 36)])
          static call address(cd[((32 * path.length - 1) + path + 36)]).balanceOf(address account) with:
                  gas gas_remaining wei
                 args to
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          require return_data.size >=′ 32
          if ext_call.return_data[0] < _43:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if ext_call.return_data[0] - _43 < amountOutMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_OUTPUT_AMOUNT'
          stop
      if 0 >= path.length:
          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
      _51 = mem[(2 * ceil32(return_data.size)) + 317]
      if 1 >= path.length:
          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
      _55 = mem[(2 * ceil32(return_data.size)) + 349]
      if not mem[(2 * ceil32(return_data.size)) + 329 len 20] - mem[(2 * ceil32(return_data.size)) + 361 len 20]:
          revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
      if mem[(2 * ceil32(return_data.size)) + 329 len 20] < mem[(2 * ceil32(return_data.size)) + 361 len 20]:
          if not mem[(2 * ceil32(return_data.size)) + 329 len 20]:
              revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
          if not mem[(2 * ceil32(return_data.size)) + 329 len 20] - mem[(2 * ceil32(return_data.size)) + 361 len 20]:
              revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
          if mem[(2 * ceil32(return_data.size)) + 329 len 20] < mem[(2 * ceil32(return_data.size)) + 361 len 20]:
              if not mem[(2 * ceil32(return_data.size)) + 329 len 20]:
                  revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              _96 = sha3(mem[(2 * ceil32(return_data.size)) + 329 len 20], address(_55))
              _143 = sha3(0, 4894420617473177672, _96, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
              if not address(_51) - address(_55):
                  revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
              if address(_51) < address(_55):
                  if not address(_51):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                  if not address(_51) - address(_55):
                      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
                  if address(_51) < address(_55):
                      if not address(_51):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _284 = sha3(address(_51), address(_55))
                      _475 = sha3(0, 4894420617473177672, _284, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
                      require ext_code.size(address(_475))
                      call address(_475).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call address(_475).getTwammReserves() with:
                              gas gas_remaining wei
                      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 695 len 192] = ext_call.return_data[0 len 192]
                      require return_data.size >=′ 192
                      _729 = ext_call.return_data[0]
                      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                      _761 = ext_call.return_data[32]
                      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                      _825 = ext_call.return_data[96]
                      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
                      _857 = ext_call.return_data[128]
                      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
                      mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = address(_143)
                      static call address(_51).balanceOf(address account) with:
                              gas gas_remaining wei
                             args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (5 * ceil32(return_data.size)) + 32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if address(_51) == address(_51):
                          _1113 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _729):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _729) < Mask(112, 0, _825):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1113 - Mask(112, 0, _729) - Mask(112, 0, _825)
                      else:
                          _1114 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _761):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _761) < Mask(112, 0, _857):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1114 - Mask(112, 0, _761) - Mask(112, 0, _857)
                  else:
                      if not address(_55):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _290 = sha3(address(_55), address(_51))
                      _478 = sha3(0, 4894420617473177672, _290, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
                      require ext_code.size(address(_478))
                      call address(_478).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call address(_478).getTwammReserves() with:
                              gas gas_remaining wei
                      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 695 len 192] = ext_call.return_data[0 len 192]
                      require return_data.size >=′ 192
                      _730 = ext_call.return_data[0]
                      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                      _762 = ext_call.return_data[32]
                      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                      _826 = ext_call.return_data[96]
                      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
                      _858 = ext_call.return_data[128]
                      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
                      mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = address(_143)
                      static call address(_51).balanceOf(address account) with:
                              gas gas_remaining wei
                             args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (5 * ceil32(return_data.size)) + 32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if address(_51) == address(_51):
                          _1115 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _730):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _730) < Mask(112, 0, _826):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1115 - Mask(112, 0, _730) - Mask(112, 0, _826)
                      else:
                          _1116 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _762):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _762) < Mask(112, 0, _858):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1116 - Mask(112, 0, _762) - Mask(112, 0, _858)
              else:
                  if not address(_55):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                  if not address(_51) - address(_55):
                      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
                  if address(_51) < address(_55):
                      if not address(_51):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _296 = sha3(address(_51), address(_55))
                      _481 = sha3(0, 4894420617473177672, _296, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
                      require ext_code.size(address(_481))
                      call address(_481).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call address(_481).getTwammReserves() with:
                              gas gas_remaining wei
                      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 695 len 192] = ext_call.return_data[0 len 192]
                      require return_data.size >=′ 192
                      _731 = ext_call.return_data[0]
                      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                      _763 = ext_call.return_data[32]
                      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                      _827 = ext_call.return_data[96]
                      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
                      _859 = ext_call.return_data[128]
                      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
                      mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = address(_143)
                      static call address(_51).balanceOf(address account) with:
                              gas gas_remaining wei
                             args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (5 * ceil32(return_data.size)) + 32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if address(_51) == address(_55):
                          _1117 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _731):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _731) < Mask(112, 0, _827):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1117 - Mask(112, 0, _731) - Mask(112, 0, _827)
                      else:
                          _1118 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _763):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _763) < Mask(112, 0, _859):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1118 - Mask(112, 0, _763) - Mask(112, 0, _859)
                  else:
                      if not address(_55):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _302 = sha3(address(_55), address(_51))
                      _484 = sha3(0, 4894420617473177672, _302, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
                      require ext_code.size(address(_484))
                      call address(_484).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call address(_484).getTwammReserves() with:
                              gas gas_remaining wei
                      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 695 len 192] = ext_call.return_data[0 len 192]
                      require return_data.size >=′ 192
                      _732 = ext_call.return_data[0]
                      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                      _764 = ext_call.return_data[32]
                      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                      _828 = ext_call.return_data[96]
                      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
                      _860 = ext_call.return_data[128]
                      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
                      mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = address(_143)
                      static call address(_51).balanceOf(address account) with:
                              gas gas_remaining wei
                             args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (5 * ceil32(return_data.size)) + 32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if address(_51) == address(_55):
                          _1119 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _732):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _732) < Mask(112, 0, _828):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1119 - Mask(112, 0, _732) - Mask(112, 0, _828)
                      else:
                          _1120 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _764):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _764) < Mask(112, 0, _860):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1120 - Mask(112, 0, _764) - Mask(112, 0, _860)
              mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 731] = address(_51)
              static call address(_143).getAmountOut(uint256 amountIn, address tokenIn) with:
                      gas gas_remaining wei
                     args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (7 * ceil32(return_data.size)) + 64]
          else:
              if not mem[(2 * ceil32(return_data.size)) + 361 len 20]:
                  revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 349] = address(mem[(2 * ceil32(return_data.size)) + 349])
              _102 = sha3(mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 349 len 20], mem[(2 * ceil32(return_data.size)) + 329 len 20])
              _146 = sha3(0, 4894420617473177672, _102, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
              if not address(_51) - address(_55):
                  revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
              if address(_51) < address(_55):
                  if not address(_51):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                  if not address(_51) - address(_55):
                      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
                  if address(_51) < address(_55):
                      if not address(_51):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _308 = sha3(address(_51), address(_55))
                      _487 = sha3(0, 4894420617473177672, _308, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
                      require ext_code.size(address(_487))
                      call address(_487).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call address(_487).getTwammReserves() with:
                              gas gas_remaining wei
                      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 695 len 192] = ext_call.return_data[0 len 192]
                      require return_data.size >=′ 192
                      _733 = ext_call.return_data[0]
                      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                      _765 = ext_call.return_data[32]
                      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                      _829 = ext_call.return_data[96]
                      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
                      _861 = ext_call.return_data[128]
                      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
                      mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = address(_146)
                      static call address(_51).balanceOf(address account) with:
                              gas gas_remaining wei
                             args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (5 * ceil32(return_data.size)) + 32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if address(_51) == address(_51):
                          _1121 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _733):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _733) < Mask(112, 0, _829):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1121 - Mask(112, 0, _733) - Mask(112, 0, _829)
                      else:
                          _1122 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _765):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _765) < Mask(112, 0, _861):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1122 - Mask(112, 0, _765) - Mask(112, 0, _861)
                  else:
                      if not address(_55):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _314 = sha3(address(_55), address(_51))
                      _490 = sha3(0, 4894420617473177672, _314, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
                      require ext_code.size(address(_490))
                      call address(_490).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call address(_490).getTwammReserves() with:
                              gas gas_remaining wei
                      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 695 len 192] = ext_call.return_data[0 len 192]
                      require return_data.size >=′ 192
                      _734 = ext_call.return_data[0]
                      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                      _766 = ext_call.return_data[32]
                      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                      _830 = ext_call.return_data[96]
                      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
                      _862 = ext_call.return_data[128]
                      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
                      mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = address(_146)
                      static call address(_51).balanceOf(address account) with:
                              gas gas_remaining wei
                             args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (5 * ceil32(return_data.size)) + 32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if address(_51) == address(_51):
                          _1123 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _734):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _734) < Mask(112, 0, _830):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1123 - Mask(112, 0, _734) - Mask(112, 0, _830)
                      else:
                          _1124 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _766):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _766) < Mask(112, 0, _862):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1124 - Mask(112, 0, _766) - Mask(112, 0, _862)
              else:
                  if not address(_55):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                  if not address(_51) - address(_55):
                      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
                  if address(_51) < address(_55):
                      if not address(_51):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _320 = sha3(address(_51), address(_55))
                      _493 = sha3(0, 4894420617473177672, _320, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
                      require ext_code.size(address(_493))
                      call address(_493).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call address(_493).getTwammReserves() with:
                              gas gas_remaining wei
                      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 695 len 192] = ext_call.return_data[0 len 192]
                      require return_data.size >=′ 192
                      _735 = ext_call.return_data[0]
                      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                      _767 = ext_call.return_data[32]
                      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                      _831 = ext_call.return_data[96]
                      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
                      _863 = ext_call.return_data[128]
                      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
                      mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = address(_146)
                      static call address(_51).balanceOf(address account) with:
                              gas gas_remaining wei
                             args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (5 * ceil32(return_data.size)) + 32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if address(_51) == address(_55):
                          _1125 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _735):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _735) < Mask(112, 0, _831):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1125 - Mask(112, 0, _735) - Mask(112, 0, _831)
                      else:
                          _1126 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _767):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _767) < Mask(112, 0, _863):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1126 - Mask(112, 0, _767) - Mask(112, 0, _863)
                  else:
                      if not address(_55):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _326 = sha3(address(_55), address(_51))
                      _496 = sha3(0, 4894420617473177672, _326, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
                      require ext_code.size(address(_496))
                      call address(_496).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call address(_496).getTwammReserves() with:
                              gas gas_remaining wei
                      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 695 len 192] = ext_call.return_data[0 len 192]
                      require return_data.size >=′ 192
                      _736 = ext_call.return_data[0]
                      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                      _768 = ext_call.return_data[32]
                      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                      _832 = ext_call.return_data[96]
                      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
                      _864 = ext_call.return_data[128]
                      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
                      mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = address(_146)
                      static call address(_51).balanceOf(address account) with:
                              gas gas_remaining wei
                             args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (5 * ceil32(return_data.size)) + 32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if address(_51) == address(_55):
                          _1127 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _736):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _736) < Mask(112, 0, _832):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1127 - Mask(112, 0, _736) - Mask(112, 0, _832)
                      else:
                          _1128 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _768):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _768) < Mask(112, 0, _864):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1128 - Mask(112, 0, _768) - Mask(112, 0, _864)
              mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 731] = address(_51)
              static call address(_146).getAmountOut(uint256 amountIn, address tokenIn) with:
                      gas gas_remaining wei
                     args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (7 * ceil32(return_data.size)) + 64]
      else:
          if not mem[(2 * ceil32(return_data.size)) + 361 len 20]:
              revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
          if not mem[(2 * ceil32(return_data.size)) + 329 len 20] - mem[(2 * ceil32(return_data.size)) + 361 len 20]:
              revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
          if mem[(2 * ceil32(return_data.size)) + 329 len 20] < mem[(2 * ceil32(return_data.size)) + 361 len 20]:
              if not mem[(2 * ceil32(return_data.size)) + 329 len 20]:
                  revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              _108 = sha3(mem[(2 * ceil32(return_data.size)) + 329 len 20], address(_55))
              _149 = sha3(0, 4894420617473177672, _108, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
              if not address(_51) - address(_55):
                  revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
              if address(_51) < address(_55):
                  if not address(_51):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                  if not address(_51) - address(_55):
                      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
                  if address(_51) < address(_55):
                      if not address(_51):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _332 = sha3(address(_51), address(_55))
                      _499 = sha3(0, 4894420617473177672, _332, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
                      require ext_code.size(address(_499))
                      call address(_499).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call address(_499).getTwammReserves() with:
                              gas gas_remaining wei
                      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 695 len 192] = ext_call.return_data[0 len 192]
                      require return_data.size >=′ 192
                      _737 = ext_call.return_data[0]
                      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                      _769 = ext_call.return_data[32]
                      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                      _833 = ext_call.return_data[96]
                      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
                      _865 = ext_call.return_data[128]
                      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
                      mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = address(_149)
                      static call address(_51).balanceOf(address account) with:
                              gas gas_remaining wei
                             args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (5 * ceil32(return_data.size)) + 32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if address(_51) == address(_51):
                          _1129 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _737):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _737) < Mask(112, 0, _833):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1129 - Mask(112, 0, _737) - Mask(112, 0, _833)
                      else:
                          _1130 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _769):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _769) < Mask(112, 0, _865):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1130 - Mask(112, 0, _769) - Mask(112, 0, _865)
                  else:
                      if not address(_55):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _338 = sha3(address(_55), address(_51))
                      _502 = sha3(0, 4894420617473177672, _338, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
                      require ext_code.size(address(_502))
                      call address(_502).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call address(_502).getTwammReserves() with:
                              gas gas_remaining wei
                      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 695 len 192] = ext_call.return_data[0 len 192]
                      require return_data.size >=′ 192
                      _738 = ext_call.return_data[0]
                      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                      _770 = ext_call.return_data[32]
                      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                      _834 = ext_call.return_data[96]
                      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
                      _866 = ext_call.return_data[128]
                      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
                      mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = address(_149)
                      static call address(_51).balanceOf(address account) with:
                              gas gas_remaining wei
                             args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (5 * ceil32(return_data.size)) + 32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if address(_51) == address(_51):
                          _1131 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _738):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _738) < Mask(112, 0, _834):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1131 - Mask(112, 0, _738) - Mask(112, 0, _834)
                      else:
                          _1132 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _770):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _770) < Mask(112, 0, _866):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1132 - Mask(112, 0, _770) - Mask(112, 0, _866)
              else:
                  if not address(_55):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                  if not address(_51) - address(_55):
                      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
                  if address(_51) < address(_55):
                      if not address(_51):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _344 = sha3(address(_51), address(_55))
                      _505 = sha3(0, 4894420617473177672, _344, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
                      require ext_code.size(address(_505))
                      call address(_505).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call address(_505).getTwammReserves() with:
                              gas gas_remaining wei
                      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 695 len 192] = ext_call.return_data[0 len 192]
                      require return_data.size >=′ 192
                      _739 = ext_call.return_data[0]
                      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                      _771 = ext_call.return_data[32]
                      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                      _835 = ext_call.return_data[96]
                      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
                      _867 = ext_call.return_data[128]
                      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
                      mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = address(_149)
                      static call address(_51).balanceOf(address account) with:
                              gas gas_remaining wei
                             args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (5 * ceil32(return_data.size)) + 32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if address(_51) == address(_55):
                          _1133 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _739):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _739) < Mask(112, 0, _835):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1133 - Mask(112, 0, _739) - Mask(112, 0, _835)
                      else:
                          _1134 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _771):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _771) < Mask(112, 0, _867):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1134 - Mask(112, 0, _771) - Mask(112, 0, _867)
                  else:
                      if not address(_55):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _350 = sha3(address(_55), address(_51))
                      _508 = sha3(0, 4894420617473177672, _350, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
                      require ext_code.size(address(_508))
                      call address(_508).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call address(_508).getTwammReserves() with:
                              gas gas_remaining wei
                      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 695 len 192] = ext_call.return_data[0 len 192]
                      require return_data.size >=′ 192
                      _740 = ext_call.return_data[0]
                      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                      _772 = ext_call.return_data[32]
                      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                      _836 = ext_call.return_data[96]
                      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
                      _868 = ext_call.return_data[128]
                      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
                      mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = address(_149)
                      static call address(_51).balanceOf(address account) with:
                              gas gas_remaining wei
                             args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (5 * ceil32(return_data.size)) + 32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if address(_51) == address(_55):
                          _1135 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _740):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _740) < Mask(112, 0, _836):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1135 - Mask(112, 0, _740) - Mask(112, 0, _836)
                      else:
                          _1136 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _772):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _772) < Mask(112, 0, _868):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1136 - Mask(112, 0, _772) - Mask(112, 0, _868)
              mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 731] = address(_51)
              static call address(_149).getAmountOut(uint256 amountIn, address tokenIn) with:
                      gas gas_remaining wei
                     args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (7 * ceil32(return_data.size)) + 64]
          else:
              if not mem[(2 * ceil32(return_data.size)) + 361 len 20]:
                  revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 349] = address(mem[(2 * ceil32(return_data.size)) + 349])
              _114 = sha3(mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 349 len 20], mem[(2 * ceil32(return_data.size)) + 329 len 20])
              _152 = sha3(0, 4894420617473177672, _114, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
              if not address(_51) - address(_55):
                  revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
              if address(_51) < address(_55):
                  if not address(_51):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                  if not address(_51) - address(_55):
                      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
                  if address(_51) < address(_55):
                      if not address(_51):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _356 = sha3(address(_51), address(_55))
                      _511 = sha3(0, 4894420617473177672, _356, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
                      require ext_code.size(address(_511))
                      call address(_511).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call address(_511).getTwammReserves() with:
                              gas gas_remaining wei
                      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 695 len 192] = ext_call.return_data[0 len 192]
                      require return_data.size >=′ 192
                      _741 = ext_call.return_data[0]
                      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                      _773 = ext_call.return_data[32]
                      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                      _837 = ext_call.return_data[96]
                      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
                      _869 = ext_call.return_data[128]
                      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
                      mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = address(_152)
                      static call address(_51).balanceOf(address account) with:
                              gas gas_remaining wei
                             args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (5 * ceil32(return_data.size)) + 32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if address(_51) == address(_51):
                          _1137 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _741):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _741) < Mask(112, 0, _837):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1137 - Mask(112, 0, _741) - Mask(112, 0, _837)
                      else:
                          _1138 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _773):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _773) < Mask(112, 0, _869):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1138 - Mask(112, 0, _773) - Mask(112, 0, _869)
                  else:
                      if not address(_55):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _362 = sha3(address(_55), address(_51))
                      _514 = sha3(0, 4894420617473177672, _362, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
                      require ext_code.size(address(_514))
                      call address(_514).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call address(_514).getTwammReserves() with:
                              gas gas_remaining wei
                      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 695 len 192] = ext_call.return_data[0 len 192]
                      require return_data.size >=′ 192
                      _742 = ext_call.return_data[0]
                      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                      _774 = ext_call.return_data[32]
                      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                      _838 = ext_call.return_data[96]
                      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
                      _870 = ext_call.return_data[128]
                      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
                      mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = address(_152)
                      static call address(_51).balanceOf(address account) with:
                              gas gas_remaining wei
                             args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (5 * ceil32(return_data.size)) + 32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if address(_51) == address(_51):
                          _1139 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _742):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _742) < Mask(112, 0, _838):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1139 - Mask(112, 0, _742) - Mask(112, 0, _838)
                      else:
                          _1140 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _774):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _774) < Mask(112, 0, _870):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1140 - Mask(112, 0, _774) - Mask(112, 0, _870)
              else:
                  if not address(_55):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                  if not address(_51) - address(_55):
                      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
                  if address(_51) < address(_55):
                      if not address(_51):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _368 = sha3(address(_51), address(_55))
                      _517 = sha3(0, 4894420617473177672, _368, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
                      require ext_code.size(address(_517))
                      call address(_517).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call address(_517).getTwammReserves() with:
                              gas gas_remaining wei
                      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 695 len 192] = ext_call.return_data[0 len 192]
                      require return_data.size >=′ 192
                      _743 = ext_call.return_data[0]
                      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                      _775 = ext_call.return_data[32]
                      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                      _839 = ext_call.return_data[96]
                      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
                      _871 = ext_call.return_data[128]
                      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
                      mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = address(_152)
                      static call address(_51).balanceOf(address account) with:
                              gas gas_remaining wei
                             args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (5 * ceil32(return_data.size)) + 32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if address(_51) == address(_55):
                          _1141 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _743):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _743) < Mask(112, 0, _839):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1141 - Mask(112, 0, _743) - Mask(112, 0, _839)
                      else:
                          _1142 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _775):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _775) < Mask(112, 0, _871):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1142 - Mask(112, 0, _775) - Mask(112, 0, _871)
                  else:
                      if not address(_55):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _374 = sha3(address(_55), address(_51))
                      _520 = sha3(0, 4894420617473177672, _374, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
                      require ext_code.size(address(_520))
                      call address(_520).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call address(_520).getTwammReserves() with:
                              gas gas_remaining wei
                      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 695 len 192] = ext_call.return_data[0 len 192]
                      require return_data.size >=′ 192
                      _744 = ext_call.return_data[0]
                      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                      _776 = ext_call.return_data[32]
                      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                      _840 = ext_call.return_data[96]
                      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
                      _872 = ext_call.return_data[128]
                      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
                      mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = address(_152)
                      static call address(_51).balanceOf(address account) with:
                              gas gas_remaining wei
                             args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (5 * ceil32(return_data.size)) + 32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if address(_51) == address(_55):
                          _1143 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _744):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _744) < Mask(112, 0, _840):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1143 - Mask(112, 0, _744) - Mask(112, 0, _840)
                      else:
                          _1144 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _776):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _776) < Mask(112, 0, _872):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1144 - Mask(112, 0, _776) - Mask(112, 0, _872)
              mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 731] = address(_51)
              static call address(_152).getAmountOut(uint256 amountIn, address tokenIn) with:
                      gas gas_remaining wei
                     args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (7 * ceil32(return_data.size)) + 64]
  else:
      if not address(cd[(path + 68)]):
          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'FraxswapRouterLibrary: ZERO_ADDRESS'
      _20 = sha3(address(cd[(path + 68)]), address(cd[(path + 36)]))
      _28 = sha3(0, 4894420617473177672, _20, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
      mem[321] = call.value
      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transfer(address recipient, uint256 amount) with:
           gas gas_remaining wei
          args address(_28), call.value
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      require return_data.size >=′ 32
      require ext_call.return_data[0] == bool(ext_call.return_data[0])
      if not ext_call.return_data[0]:
          revert with Panic(1)  # If you call assert with an argument that evaluates to false.
      if path.length < 1:
          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
      if path.length - 1 >= path.length:
          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
      require cd[((32 * path.length - 1) + path + 36)] == address(cd[((32 * path.length - 1) + path + 36)])
      mem[ceil32(return_data.size) + 289] = to
      static call address(cd[((32 * path.length - 1) + path + 36)]).balanceOf(address account) with:
              gas gas_remaining wei
             args to
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      require return_data.size >=′ 32
      _44 = ext_call.return_data[0]
      mem[(2 * ceil32(return_data.size)) + 317 len 32 * path.length] = call.data[path + 36 len 32 * path.length]
      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 317] = 0
      if path.length < 1:
          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
      if 0 >= path.length - 1:
          if path.length < 1:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if path.length - 1 >= path.length:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          require cd[((32 * path.length - 1) + path + 36)] == address(cd[((32 * path.length - 1) + path + 36)])
          static call address(cd[((32 * path.length - 1) + path + 36)]).balanceOf(address account) with:
                  gas gas_remaining wei
                 args to
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          require return_data.size >=′ 32
          if ext_call.return_data[0] < _44:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if ext_call.return_data[0] - _44 < amountOutMin:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_OUTPUT_AMOUNT'
          stop
      if 0 >= path.length:
          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
      _52 = mem[(2 * ceil32(return_data.size)) + 317]
      if 1 >= path.length:
          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
      _56 = mem[(2 * ceil32(return_data.size)) + 349]
      if not mem[(2 * ceil32(return_data.size)) + 329 len 20] - mem[(2 * ceil32(return_data.size)) + 361 len 20]:
          revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
      if mem[(2 * ceil32(return_data.size)) + 329 len 20] < mem[(2 * ceil32(return_data.size)) + 361 len 20]:
          if not mem[(2 * ceil32(return_data.size)) + 329 len 20]:
              revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
          if not mem[(2 * ceil32(return_data.size)) + 329 len 20] - mem[(2 * ceil32(return_data.size)) + 361 len 20]:
              revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
          if mem[(2 * ceil32(return_data.size)) + 329 len 20] < mem[(2 * ceil32(return_data.size)) + 361 len 20]:
              if not mem[(2 * ceil32(return_data.size)) + 329 len 20]:
                  revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              _120 = sha3(mem[(2 * ceil32(return_data.size)) + 329 len 20], address(_56))
              _155 = sha3(0, 4894420617473177672, _120, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
              if not address(_52) - address(_56):
                  revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
              if address(_52) < address(_56):
                  if not address(_52):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                  if not address(_52) - address(_56):
                      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
                  if address(_52) < address(_56):
                      if not address(_52):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _380 = sha3(address(_52), address(_56))
                      _523 = sha3(0, 4894420617473177672, _380, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
                      require ext_code.size(address(_523))
                      call address(_523).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call address(_523).getTwammReserves() with:
                              gas gas_remaining wei
                      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 695 len 192] = ext_call.return_data[0 len 192]
                      require return_data.size >=′ 192
                      _745 = ext_call.return_data[0]
                      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                      _777 = ext_call.return_data[32]
                      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                      _841 = ext_call.return_data[96]
                      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
                      _873 = ext_call.return_data[128]
                      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
                      mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = address(_155)
                      static call address(_52).balanceOf(address account) with:
                              gas gas_remaining wei
                             args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (5 * ceil32(return_data.size)) + 32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if address(_52) == address(_52):
                          _1145 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _745):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _745) < Mask(112, 0, _841):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1145 - Mask(112, 0, _745) - Mask(112, 0, _841)
                      else:
                          _1146 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _777):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _777) < Mask(112, 0, _873):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1146 - Mask(112, 0, _777) - Mask(112, 0, _873)
                  else:
                      if not address(_56):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _386 = sha3(address(_56), address(_52))
                      _526 = sha3(0, 4894420617473177672, _386, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
                      require ext_code.size(address(_526))
                      call address(_526).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call address(_526).getTwammReserves() with:
                              gas gas_remaining wei
                      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 695 len 192] = ext_call.return_data[0 len 192]
                      require return_data.size >=′ 192
                      _746 = ext_call.return_data[0]
                      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                      _778 = ext_call.return_data[32]
                      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                      _842 = ext_call.return_data[96]
                      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
                      _874 = ext_call.return_data[128]
                      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
                      mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = address(_155)
                      static call address(_52).balanceOf(address account) with:
                              gas gas_remaining wei
                             args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (5 * ceil32(return_data.size)) + 32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if address(_52) == address(_52):
                          _1147 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _746):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _746) < Mask(112, 0, _842):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1147 - Mask(112, 0, _746) - Mask(112, 0, _842)
                      else:
                          _1148 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _778):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _778) < Mask(112, 0, _874):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1148 - Mask(112, 0, _778) - Mask(112, 0, _874)
              else:
                  if not address(_56):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                  if not address(_52) - address(_56):
                      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
                  if address(_52) < address(_56):
                      if not address(_52):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _392 = sha3(address(_52), address(_56))
                      _529 = sha3(0, 4894420617473177672, _392, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
                      require ext_code.size(address(_529))
                      call address(_529).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call address(_529).getTwammReserves() with:
                              gas gas_remaining wei
                      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 695 len 192] = ext_call.return_data[0 len 192]
                      require return_data.size >=′ 192
                      _747 = ext_call.return_data[0]
                      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                      _779 = ext_call.return_data[32]
                      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                      _843 = ext_call.return_data[96]
                      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
                      _875 = ext_call.return_data[128]
                      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
                      mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = address(_155)
                      static call address(_52).balanceOf(address account) with:
                              gas gas_remaining wei
                             args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (5 * ceil32(return_data.size)) + 32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if address(_52) == address(_56):
                          _1149 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _747):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _747) < Mask(112, 0, _843):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1149 - Mask(112, 0, _747) - Mask(112, 0, _843)
                      else:
                          _1150 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _779):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _779) < Mask(112, 0, _875):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1150 - Mask(112, 0, _779) - Mask(112, 0, _875)
                  else:
                      if not address(_56):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _398 = sha3(address(_56), address(_52))
                      _532 = sha3(0, 4894420617473177672, _398, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
                      require ext_code.size(address(_532))
                      call address(_532).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call address(_532).getTwammReserves() with:
                              gas gas_remaining wei
                      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 695 len 192] = ext_call.return_data[0 len 192]
                      require return_data.size >=′ 192
                      _748 = ext_call.return_data[0]
                      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                      _780 = ext_call.return_data[32]
                      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                      _844 = ext_call.return_data[96]
                      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
                      _876 = ext_call.return_data[128]
                      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
                      mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = address(_155)
                      static call address(_52).balanceOf(address account) with:
                              gas gas_remaining wei
                             args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (5 * ceil32(return_data.size)) + 32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if address(_52) == address(_56):
                          _1151 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _748):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _748) < Mask(112, 0, _844):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1151 - Mask(112, 0, _748) - Mask(112, 0, _844)
                      else:
                          _1152 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _780):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _780) < Mask(112, 0, _876):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1152 - Mask(112, 0, _780) - Mask(112, 0, _876)
              mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 731] = address(_52)
              static call address(_155).getAmountOut(uint256 amountIn, address tokenIn) with:
                      gas gas_remaining wei
                     args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (7 * ceil32(return_data.size)) + 64]
          else:
              if not mem[(2 * ceil32(return_data.size)) + 361 len 20]:
                  revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 349] = address(mem[(2 * ceil32(return_data.size)) + 349])
              _126 = sha3(mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 349 len 20], mem[(2 * ceil32(return_data.size)) + 329 len 20])
              _158 = sha3(0, 4894420617473177672, _126, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
              if not address(_52) - address(_56):
                  revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
              if address(_52) < address(_56):
                  if not address(_52):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                  if not address(_52) - address(_56):
                      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
                  if address(_52) < address(_56):
                      if not address(_52):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _404 = sha3(address(_52), address(_56))
                      _535 = sha3(0, 4894420617473177672, _404, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
                      require ext_code.size(address(_535))
                      call address(_535).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call address(_535).getTwammReserves() with:
                              gas gas_remaining wei
                      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 695 len 192] = ext_call.return_data[0 len 192]
                      require return_data.size >=′ 192
                      _749 = ext_call.return_data[0]
                      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                      _781 = ext_call.return_data[32]
                      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                      _845 = ext_call.return_data[96]
                      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
                      _877 = ext_call.return_data[128]
                      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
                      mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = address(_158)
                      static call address(_52).balanceOf(address account) with:
                              gas gas_remaining wei
                             args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (5 * ceil32(return_data.size)) + 32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if address(_52) == address(_52):
                          _1153 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _749):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _749) < Mask(112, 0, _845):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1153 - Mask(112, 0, _749) - Mask(112, 0, _845)
                      else:
                          _1154 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _781):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _781) < Mask(112, 0, _877):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1154 - Mask(112, 0, _781) - Mask(112, 0, _877)
                  else:
                      if not address(_56):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _410 = sha3(address(_56), address(_52))
                      _538 = sha3(0, 4894420617473177672, _410, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
                      require ext_code.size(address(_538))
                      call address(_538).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call address(_538).getTwammReserves() with:
                              gas gas_remaining wei
                      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 695 len 192] = ext_call.return_data[0 len 192]
                      require return_data.size >=′ 192
                      _750 = ext_call.return_data[0]
                      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                      _782 = ext_call.return_data[32]
                      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                      _846 = ext_call.return_data[96]
                      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
                      _878 = ext_call.return_data[128]
                      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
                      mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = address(_158)
                      static call address(_52).balanceOf(address account) with:
                              gas gas_remaining wei
                             args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (5 * ceil32(return_data.size)) + 32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if address(_52) == address(_52):
                          _1155 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _750):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _750) < Mask(112, 0, _846):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1155 - Mask(112, 0, _750) - Mask(112, 0, _846)
                      else:
                          _1156 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _782):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _782) < Mask(112, 0, _878):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1156 - Mask(112, 0, _782) - Mask(112, 0, _878)
              else:
                  if not address(_56):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                  if not address(_52) - address(_56):
                      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
                  if address(_52) < address(_56):
                      if not address(_52):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _416 = sha3(address(_52), address(_56))
                      _541 = sha3(0, 4894420617473177672, _416, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
                      require ext_code.size(address(_541))
                      call address(_541).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call address(_541).getTwammReserves() with:
                              gas gas_remaining wei
                      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 695 len 192] = ext_call.return_data[0 len 192]
                      require return_data.size >=′ 192
                      _751 = ext_call.return_data[0]
                      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                      _783 = ext_call.return_data[32]
                      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                      _847 = ext_call.return_data[96]
                      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
                      _879 = ext_call.return_data[128]
                      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
                      mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = address(_158)
                      static call address(_52).balanceOf(address account) with:
                              gas gas_remaining wei
                             args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (5 * ceil32(return_data.size)) + 32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if address(_52) == address(_56):
                          _1157 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _751):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _751) < Mask(112, 0, _847):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1157 - Mask(112, 0, _751) - Mask(112, 0, _847)
                      else:
                          _1158 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _783):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _783) < Mask(112, 0, _879):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1158 - Mask(112, 0, _783) - Mask(112, 0, _879)
                  else:
                      if not address(_56):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _422 = sha3(address(_56), address(_52))
                      _544 = sha3(0, 4894420617473177672, _422, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
                      require ext_code.size(address(_544))
                      call address(_544).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call address(_544).getTwammReserves() with:
                              gas gas_remaining wei
                      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 695 len 192] = ext_call.return_data[0 len 192]
                      require return_data.size >=′ 192
                      _752 = ext_call.return_data[0]
                      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                      _784 = ext_call.return_data[32]
                      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                      _848 = ext_call.return_data[96]
                      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
                      _880 = ext_call.return_data[128]
                      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
                      mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = address(_158)
                      static call address(_52).balanceOf(address account) with:
                              gas gas_remaining wei
                             args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (5 * ceil32(return_data.size)) + 32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if address(_52) == address(_56):
                          _1159 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _752):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _752) < Mask(112, 0, _848):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1159 - Mask(112, 0, _752) - Mask(112, 0, _848)
                      else:
                          _1160 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _784):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _784) < Mask(112, 0, _880):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1160 - Mask(112, 0, _784) - Mask(112, 0, _880)
              mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 731] = address(_52)
              static call address(_158).getAmountOut(uint256 amountIn, address tokenIn) with:
                      gas gas_remaining wei
                     args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (7 * ceil32(return_data.size)) + 64]
      else:
          if not mem[(2 * ceil32(return_data.size)) + 361 len 20]:
              revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
          if not mem[(2 * ceil32(return_data.size)) + 329 len 20] - mem[(2 * ceil32(return_data.size)) + 361 len 20]:
              revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
          if mem[(2 * ceil32(return_data.size)) + 329 len 20] < mem[(2 * ceil32(return_data.size)) + 361 len 20]:
              if not mem[(2 * ceil32(return_data.size)) + 329 len 20]:
                  revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              _132 = sha3(mem[(2 * ceil32(return_data.size)) + 329 len 20], address(_56))
              _161 = sha3(0, 4894420617473177672, _132, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
              if not address(_52) - address(_56):
                  revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
              if address(_52) < address(_56):
                  if not address(_52):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                  if not address(_52) - address(_56):
                      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
                  if address(_52) < address(_56):
                      if not address(_52):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _428 = sha3(address(_52), address(_56))
                      _547 = sha3(0, 4894420617473177672, _428, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
                      require ext_code.size(address(_547))
                      call address(_547).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call address(_547).getTwammReserves() with:
                              gas gas_remaining wei
                      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 695 len 192] = ext_call.return_data[0 len 192]
                      require return_data.size >=′ 192
                      _753 = ext_call.return_data[0]
                      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                      _785 = ext_call.return_data[32]
                      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                      _849 = ext_call.return_data[96]
                      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
                      _881 = ext_call.return_data[128]
                      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
                      mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = address(_161)
                      static call address(_52).balanceOf(address account) with:
                              gas gas_remaining wei
                             args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (5 * ceil32(return_data.size)) + 32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if address(_52) == address(_52):
                          _1161 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _753):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _753) < Mask(112, 0, _849):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1161 - Mask(112, 0, _753) - Mask(112, 0, _849)
                      else:
                          _1162 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _785):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _785) < Mask(112, 0, _881):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1162 - Mask(112, 0, _785) - Mask(112, 0, _881)
                  else:
                      if not address(_56):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _434 = sha3(address(_56), address(_52))
                      _550 = sha3(0, 4894420617473177672, _434, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
                      require ext_code.size(address(_550))
                      call address(_550).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call address(_550).getTwammReserves() with:
                              gas gas_remaining wei
                      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 695 len 192] = ext_call.return_data[0 len 192]
                      require return_data.size >=′ 192
                      _754 = ext_call.return_data[0]
                      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                      _786 = ext_call.return_data[32]
                      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                      _850 = ext_call.return_data[96]
                      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
                      _882 = ext_call.return_data[128]
                      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
                      mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = address(_161)
                      static call address(_52).balanceOf(address account) with:
                              gas gas_remaining wei
                             args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (5 * ceil32(return_data.size)) + 32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if address(_52) == address(_52):
                          _1163 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _754):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _754) < Mask(112, 0, _850):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1163 - Mask(112, 0, _754) - Mask(112, 0, _850)
                      else:
                          _1164 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _786):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _786) < Mask(112, 0, _882):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1164 - Mask(112, 0, _786) - Mask(112, 0, _882)
              else:
                  if not address(_56):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                  if not address(_52) - address(_56):
                      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
                  if address(_52) < address(_56):
                      if not address(_52):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _440 = sha3(address(_52), address(_56))
                      _553 = sha3(0, 4894420617473177672, _440, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
                      require ext_code.size(address(_553))
                      call address(_553).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call address(_553).getTwammReserves() with:
                              gas gas_remaining wei
                      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 695 len 192] = ext_call.return_data[0 len 192]
                      require return_data.size >=′ 192
                      _755 = ext_call.return_data[0]
                      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                      _787 = ext_call.return_data[32]
                      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                      _851 = ext_call.return_data[96]
                      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
                      _883 = ext_call.return_data[128]
                      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
                      mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = address(_161)
                      static call address(_52).balanceOf(address account) with:
                              gas gas_remaining wei
                             args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (5 * ceil32(return_data.size)) + 32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if address(_52) == address(_56):
                          _1165 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _755):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _755) < Mask(112, 0, _851):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1165 - Mask(112, 0, _755) - Mask(112, 0, _851)
                      else:
                          _1166 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _787):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _787) < Mask(112, 0, _883):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1166 - Mask(112, 0, _787) - Mask(112, 0, _883)
                  else:
                      if not address(_56):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _446 = sha3(address(_56), address(_52))
                      _556 = sha3(0, 4894420617473177672, _446, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
                      require ext_code.size(address(_556))
                      call address(_556).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call address(_556).getTwammReserves() with:
                              gas gas_remaining wei
                      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 695 len 192] = ext_call.return_data[0 len 192]
                      require return_data.size >=′ 192
                      _756 = ext_call.return_data[0]
                      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                      _788 = ext_call.return_data[32]
                      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                      _852 = ext_call.return_data[96]
                      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
                      _884 = ext_call.return_data[128]
                      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
                      mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = address(_161)
                      static call address(_52).balanceOf(address account) with:
                              gas gas_remaining wei
                             args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (5 * ceil32(return_data.size)) + 32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if address(_52) == address(_56):
                          _1167 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _756):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _756) < Mask(112, 0, _852):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1167 - Mask(112, 0, _756) - Mask(112, 0, _852)
                      else:
                          _1168 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _788):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _788) < Mask(112, 0, _884):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1168 - Mask(112, 0, _788) - Mask(112, 0, _884)
              mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 731] = address(_52)
              static call address(_161).getAmountOut(uint256 amountIn, address tokenIn) with:
                      gas gas_remaining wei
                     args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (7 * ceil32(return_data.size)) + 64]
          else:
              if not mem[(2 * ceil32(return_data.size)) + 361 len 20]:
                  revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 349] = address(mem[(2 * ceil32(return_data.size)) + 349])
              _138 = sha3(mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 349 len 20], mem[(2 * ceil32(return_data.size)) + 329 len 20])
              _164 = sha3(0, 4894420617473177672, _138, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
              if not address(_52) - address(_56):
                  revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
              if address(_52) < address(_56):
                  if not address(_52):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                  if not address(_52) - address(_56):
                      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
                  if address(_52) < address(_56):
                      if not address(_52):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _452 = sha3(address(_52), address(_56))
                      _559 = sha3(0, 4894420617473177672, _452, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
                      require ext_code.size(address(_559))
                      call address(_559).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call address(_559).getTwammReserves() with:
                              gas gas_remaining wei
                      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 695 len 192] = ext_call.return_data[0 len 192]
                      require return_data.size >=′ 192
                      _757 = ext_call.return_data[0]
                      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                      _789 = ext_call.return_data[32]
                      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                      _853 = ext_call.return_data[96]
                      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
                      _885 = ext_call.return_data[128]
                      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
                      mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = address(_164)
                      static call address(_52).balanceOf(address account) with:
                              gas gas_remaining wei
                             args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (5 * ceil32(return_data.size)) + 32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if address(_52) == address(_52):
                          _1169 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _757):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _757) < Mask(112, 0, _853):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1169 - Mask(112, 0, _757) - Mask(112, 0, _853)
                      else:
                          _1170 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _789):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _789) < Mask(112, 0, _885):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1170 - Mask(112, 0, _789) - Mask(112, 0, _885)
                  else:
                      if not address(_56):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _458 = sha3(address(_56), address(_52))
                      _562 = sha3(0, 4894420617473177672, _458, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
                      require ext_code.size(address(_562))
                      call address(_562).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call address(_562).getTwammReserves() with:
                              gas gas_remaining wei
                      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 695 len 192] = ext_call.return_data[0 len 192]
                      require return_data.size >=′ 192
                      _758 = ext_call.return_data[0]
                      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                      _790 = ext_call.return_data[32]
                      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                      _854 = ext_call.return_data[96]
                      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
                      _886 = ext_call.return_data[128]
                      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
                      mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = address(_164)
                      static call address(_52).balanceOf(address account) with:
                              gas gas_remaining wei
                             args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (5 * ceil32(return_data.size)) + 32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if address(_52) == address(_52):
                          _1171 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _758):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _758) < Mask(112, 0, _854):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1171 - Mask(112, 0, _758) - Mask(112, 0, _854)
                      else:
                          _1172 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _790):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _790) < Mask(112, 0, _886):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1172 - Mask(112, 0, _790) - Mask(112, 0, _886)
              else:
                  if not address(_56):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                  if not address(_52) - address(_56):
                      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
                  if address(_52) < address(_56):
                      if not address(_52):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _464 = sha3(address(_52), address(_56))
                      _565 = sha3(0, 4894420617473177672, _464, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
                      require ext_code.size(address(_565))
                      call address(_565).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call address(_565).getTwammReserves() with:
                              gas gas_remaining wei
                      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 695 len 192] = ext_call.return_data[0 len 192]
                      require return_data.size >=′ 192
                      _759 = ext_call.return_data[0]
                      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                      _791 = ext_call.return_data[32]
                      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                      _855 = ext_call.return_data[96]
                      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
                      _887 = ext_call.return_data[128]
                      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
                      mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = address(_164)
                      static call address(_52).balanceOf(address account) with:
                              gas gas_remaining wei
                             args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (5 * ceil32(return_data.size)) + 32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if address(_52) == address(_56):
                          _1173 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _759):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _759) < Mask(112, 0, _855):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1173 - Mask(112, 0, _759) - Mask(112, 0, _855)
                      else:
                          _1174 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _791):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _791) < Mask(112, 0, _887):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1174 - Mask(112, 0, _791) - Mask(112, 0, _887)
                  else:
                      if not address(_56):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      _470 = sha3(address(_56), address(_52))
                      _568 = sha3(0, 4894420617473177672, _470, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)
                      require ext_code.size(address(_568))
                      call address(_568).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call address(_568).getTwammReserves() with:
                              gas gas_remaining wei
                      mem[(2 * ceil32(return_data.size)) + (32 * path.length) + 695 len 192] = ext_call.return_data[0 len 192]
                      require return_data.size >=′ 192
                      _760 = ext_call.return_data[0]
                      require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                      _792 = ext_call.return_data[32]
                      require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                      require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                      _856 = ext_call.return_data[96]
                      require ext_call.return_data[96] == ext_call.return_data[114 len 14]
                      _888 = ext_call.return_data[128]
                      require ext_call.return_data[128] == ext_call.return_data[146 len 14]
                      mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = address(_164)
                      static call address(_52).balanceOf(address account) with:
                              gas gas_remaining wei
                             args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (5 * ceil32(return_data.size)) + 32]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if address(_52) == address(_56):
                          _1175 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _760):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _760) < Mask(112, 0, _856):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1175 - Mask(112, 0, _760) - Mask(112, 0, _856)
                      else:
                          _1176 = ext_call.return_data[0]
                          if ext_call.return_data[0] < Mask(112, 0, _792):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ext_call.return_data[0] - Mask(112, 0, _792) < Mask(112, 0, _888):
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699] = _1176 - Mask(112, 0, _792) - Mask(112, 0, _888)
              mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 731] = address(_52)
              static call address(_164).getAmountOut(uint256 amountIn, address tokenIn) with:
                      gas gas_remaining wei
                     args mem[(4 * ceil32(return_data.size)) + (32 * path.length) + 699 len (7 * ceil32(return_data.size)) + 64]
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  require return_data.size >=′ 32
  if path.length < 2:
      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def _fallback(?) payable: # default function
  if calldata.size < 4:
      require not calldata.size
      if caller != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
          revert with Panic(1)  # If you call assert with an argument that evaluates to false.
      stop
  if swapTokensForExactTokens(uint256 amountOut, uint256 amountInMax, address[] path, address to, uint256 deadline) > uint32(call.func_hash) >> 224:
      if swapTokensForExactETH(uint256 amountOut, uint256 amountInMax, address[] path, address to, uint256 deadline) > uint32(call.func_hash) >> 224:
          if getAmountsIn(uint256 amountOut, address[] path) > uint32(call.func_hash) >> 224:
              if removeLiquidityETH(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline) == uint32(call.func_hash) >> 224:
                  require not call.value
                  require calldata.size - 4 >=′ 192
                  require cd[4] == address(cd[4])
                  require cd[132] == address(cd[132])
                  if cd[164] < block.timestamp:
                      revert with 0, 'FraxswapV1Router: EXPIRED'
                  if not address(cd[4]) - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
                  if address(cd[4]) >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).transferFrom(address sender, address recipient, uint256 amount) with:
                           gas gas_remaining wei
                          args caller, address(sha3(0, 4894420617473177672, sha3(13847067169082572429, address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)), cd[36]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      require ext_call.return_data[0] == bool(ext_call.return_data[0])
                      call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).burn(address to) with:
                           gas gas_remaining wei
                          args this.address
                  else:
                      if not address(cd[4]):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      call address(sha3(0, 4894420617473177672, sha3(address(cd[4]), 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).transferFrom(address sender, address recipient, uint256 amount) with:
                           gas gas_remaining wei
                          args caller, address(sha3(0, 4894420617473177672, sha3(address(cd[4]), 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)), cd[36]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      require ext_call.return_data[0] == bool(ext_call.return_data[0])
                      call address(sha3(0, 4894420617473177672, sha3(address(cd[4]), 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).burn(address to) with:
                           gas gas_remaining wei
                          args this.address
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >=′ 64
                  if not address(cd[4]) - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
                  if address(cd[4]) >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      if address(cd[4]) == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                          if ext_call.return_data[0] < cd[68]:
                              revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
                          if ext_call.return_data[32] < cd[100]:
                              revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
                      else:
                          if ext_call.return_data[32] < cd[68]:
                              revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
                          if ext_call.return_data[0] < cd[100]:
                              revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
                  else:
                      if not address(cd[4]):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      if address(cd[4]) == address(cd[4]):
                          if ext_call.return_data[0] < cd[68]:
                              revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
                          if ext_call.return_data[32] < cd[100]:
                              revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
                      else:
                          if ext_call.return_data[32] < cd[68]:
                              revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
                          if ext_call.return_data[0] < cd[100]:
                              revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              if getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) == uint32(call.func_hash) >> 224:
                  require not call.value
                  require calldata.size - 4 >=′ 96
                  revert with 0, 'Deprecated: Use getAmountsOut'
              require swapExactTokensForETH(uint256 amountIn, uint256 amountOutMin, address[] path, address to, uint256 deadline) == uint32(call.func_hash) >> 224
              require not call.value
              require calldata.size - 4 >=′ 160
              require cd[68] <= LOCK8605463013()
              require cd[68] + 35 <′ calldata.size
              require ('cd', 68).length <= LOCK8605463013()
              require cd[68] + (32 * ('cd', 68).length) + 36 <= calldata.size
              require cd[100] == address(cd[100])
              if cd[132] < block.timestamp:
                  revert with 0, 'FraxswapV1Router: EXPIRED'
              if ('cd', 68).length < 1:
                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
              if ('cd', 68).length - 1 >= ('cd', 68).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              require cd[((32 * ('cd', 68).length - 1) + cd[68] + 36)] == address(cd[((32 * ('cd', 68).length - 1) + cd[68] + 36)])
              if address(cd[((32 * ('cd', 68).length - 1) + cd[68] + 36)]) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                  revert with 0, 'FraxswapV1Router: INVALID_PATH'
              mem[160 len 32 * ('cd', 68).length] = call.data[cd[68] + 36 len 32 * ('cd', 68).length]
              if ('cd', 68).length < 2:
                  revert with 0, 'FraxswapRouterLibrary: INVALID_PATH'
              if ('cd', 68).length > LOCK8605463013():
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              mem[(32 * ('cd', 68).length) + 160] = ('cd', 68).length
              if not ('cd', 68).length:
                  if 0 >= ('cd', 68).length:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  mem[(32 * ('cd', 68).length) + 192] = cd[4]
                  if ('cd', 68).length < 1:
                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                  if 0 >= ('cd', 68).length - 1:
                      if ('cd', 68).length < 1:
                          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                      if ('cd', 68).length - 1 >= ('cd', 68).length:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      if mem[(32 * ('cd', 68).length - 1) + (32 * ('cd', 68).length) + 192] >= cd[36]:
                          if 0 >= ('cd', 68).length:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          require ('cd', 68)[0] == address(('cd', 68)[0])
                          if 0 >= ('cd', 68).length:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                      mem[(64 * ('cd', 68).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(64 * ('cd', 68).length) + 196] = 32
                      mem[(64 * ('cd', 68).length) + 228] = 44
                      mem[(64 * ('cd', 68).length) + 260] = 'FraxswapV1Router: INSUFFICIENT_O'
                      mem[(64 * ('cd', 68).length) + 292] = 'UTPUT_AMOUNT'
                  else:
                      if 0 >= ('cd', 68).length:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      if 1 >= ('cd', 68).length:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      if not mem[172 len 20] - mem[204 len 20]:
                          mem[(64 * ('cd', 68).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(64 * ('cd', 68).length) + 196] = 32
                          mem[(64 * ('cd', 68).length) + 228] = 42
                          mem[(64 * ('cd', 68).length) + 260] = 'FraxswapRouterLibrary: IDENTICAL'
                          mem[(64 * ('cd', 68).length) + 292] = '_ADDRESSES'
                      else:
                          if mem[172 len 20] < mem[204 len 20]:
                              if mem[172 len 20]:
                                  mem[(64 * ('cd', 68).length) + 224] = address(mem[160])
                                  mem[(64 * ('cd', 68).length) + 244] = address(mem[192])
                                  require ext_code.size(address(sha3(0, 4894420617473177672, sha3(mem[(64 * ('cd', 68).length) + 224 len (127 * ('cd', 68).length) + 40]), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
                                  call address(sha3(0, 4894420617473177672, sha3(mem[(64 * ('cd', 68).length) + 224 len (127 * ('cd', 68).length) + 40]), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                                       gas gas_remaining wei
                                      args block.timestamp
                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                          else:
                              if mem[204 len 20]:
                                  mem[(64 * ('cd', 68).length) + 224] = address(mem[192])
                                  mem[(64 * ('cd', 68).length) + 244] = address(mem[160])
                                  require ext_code.size(address(sha3(0, 4894420617473177672, sha3(mem[(64 * ('cd', 68).length) + 224 len (127 * ('cd', 68).length) + 40]), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
                                  call address(sha3(0, 4894420617473177672, sha3(mem[(64 * ('cd', 68).length) + 224 len (127 * ('cd', 68).length) + 40]), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                                       gas gas_remaining wei
                                      args block.timestamp
                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                          mem[(64 * ('cd', 68).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(64 * ('cd', 68).length) + 196] = 32
                          mem[(64 * ('cd', 68).length) + 228] = 35
                          mem[(64 * ('cd', 68).length) + 260] = 'FraxswapRouterLibrary: ZERO_ADDR'
                          mem[(64 * ('cd', 68).length) + 292] = 'ESS'
              else:
                  mem[(32 * ('cd', 68).length) + 192 len 32 * ('cd', 68).length] = call.data[calldata.size len 32 * ('cd', 68).length]
                  if 0 >= ('cd', 68).length:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  mem[(32 * ('cd', 68).length) + 192] = cd[4]
                  if ('cd', 68).length < 1:
                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                  if 0 >= ('cd', 68).length - 1:
                      if ('cd', 68).length < 1:
                          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                      if ('cd', 68).length - 1 >= ('cd', 68).length:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      if mem[(32 * ('cd', 68).length - 1) + (32 * ('cd', 68).length) + 192] >= cd[36]:
                          if 0 >= ('cd', 68).length:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          require ('cd', 68)[0] == address(('cd', 68)[0])
                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                      mem[(64 * ('cd', 68).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(64 * ('cd', 68).length) + 196] = 32
                      mem[(64 * ('cd', 68).length) + 228] = 44
                      mem[(64 * ('cd', 68).length) + 260] = 'FraxswapV1Router: INSUFFICIENT_O'
                      mem[(64 * ('cd', 68).length) + 292] = 'UTPUT_AMOUNT'
                  else:
                      if 0 >= ('cd', 68).length:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      if 1 >= ('cd', 68).length:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      if not mem[172 len 20] - mem[204 len 20]:
                          mem[(64 * ('cd', 68).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(64 * ('cd', 68).length) + 196] = 32
                          mem[(64 * ('cd', 68).length) + 228] = 42
                          mem[(64 * ('cd', 68).length) + 260] = 'FraxswapRouterLibrary: IDENTICAL'
                          mem[(64 * ('cd', 68).length) + 292] = '_ADDRESSES'
                      else:
                          if mem[172 len 20] < mem[204 len 20]:
                              if mem[172 len 20]:
                                  mem[(64 * ('cd', 68).length) + 224] = address(mem[160])
                                  mem[(64 * ('cd', 68).length) + 244] = address(mem[192])
                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                          else:
                              if mem[204 len 20]:
                                  mem[(64 * ('cd', 68).length) + 224] = address(mem[192])
                                  mem[(64 * ('cd', 68).length) + 244] = address(mem[160])
                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                          mem[(64 * ('cd', 68).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(64 * ('cd', 68).length) + 196] = 32
                          mem[(64 * ('cd', 68).length) + 228] = 35
                          mem[(64 * ('cd', 68).length) + 260] = 'FraxswapRouterLibrary: ZERO_ADDR'
                          mem[(64 * ('cd', 68).length) + 292] = 'ESS'
              revert with memory
                from (64 * ('cd', 68).length) + 192
                 len (127 * ('cd', 68).length) + 132
          if getAmountsIn(uint256 amountOut, address[] path) == uint32(call.func_hash) >> 224:
              require not call.value
              require calldata.size - 4 >=′ 64
              require cd[36] <= LOCK8605463013()
              require cd[36] + 35 <′ calldata.size
              if ('cd', 36).length > LOCK8605463013():
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              if ceil32(32 * ('cd', 36).length) + 129 > LOCK8605463013() or ceil32(32 * ('cd', 36).length) + 129 < 128:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              require (32 * ('cd', 36).length) + cd[36] + 36 <= calldata.size
          else:
              if removeLiquidityWithPermit(address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) == uint32(call.func_hash) >> 224:
                  require not call.value
                  require calldata.size - 4 >=′ 352
                  require cd[4] == address(cd[4])
                  require cd[36] == address(cd[36])
                  require cd[164] == address(cd[164])
                  require cd[228] == bool(cd[228])
                  require cd[260] == uint8(cd[260])
                  if not address(cd[4]) - address(cd[36]):
                      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
                  if address(cd[4]) < address(cd[36]):
                      if not address(cd[4]):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      require ext_code.size(address(sha3(0, 4894420617473177672, sha3(address(cd[4]), address(cd[36])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
                      if cd[228]:
                          call address(sha3(0, 4894420617473177672, sha3(address(cd[4]), address(cd[36])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
                               gas gas_remaining wei
                              args caller, this.address, -1, cd[196], cd[260] << 248, cd[292], cd[324]
                      else:
                          call address(sha3(0, 4894420617473177672, sha3(address(cd[4]), address(cd[36])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
                               gas gas_remaining wei
                              args caller, this.address, cd[68], cd[196], cd[260] << 248, cd[292], cd[324]
                  else:
                      if not address(cd[36]):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      require ext_code.size(address(sha3(0, 4894420617473177672, sha3(address(cd[36]), address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
                      if cd[228]:
                          call address(sha3(0, 4894420617473177672, sha3(address(cd[36]), address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
                               gas gas_remaining wei
                              args caller, this.address, -1, cd[196], cd[260] << 248, cd[292], cd[324]
                      else:
                          call address(sha3(0, 4894420617473177672, sha3(address(cd[36]), address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
                               gas gas_remaining wei
                              args caller, this.address, cd[68], cd[196], cd[260] << 248, cd[292], cd[324]
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if cd[196] < block.timestamp:
                      revert with 0, 'FraxswapV1Router: EXPIRED'
                  if not address(cd[4]) - address(cd[36]):
                      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
                  if address(cd[4]) < address(cd[36]):
                      if not address(cd[4]):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      call address(sha3(0, 4894420617473177672, sha3(address(cd[4]), address(cd[36])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).transferFrom(address sender, address recipient, uint256 amount) with:
                           gas gas_remaining wei
                          args caller, address(sha3(0, 4894420617473177672, sha3(address(cd[4]), address(cd[36])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)), cd[68]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      require ext_call.return_data[0] == bool(ext_call.return_data[0])
                      call address(sha3(0, 4894420617473177672, sha3(address(cd[4]), address(cd[36])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).burn(address to) with:
                           gas gas_remaining wei
                          args address(cd[164])
                  else:
                      if not address(cd[36]):
                          revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                      call address(sha3(0, 4894420617473177672, sha3(address(cd[36]), address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).transferFrom(address sender, address recipient, uint256 amount) with:
                           gas gas_remaining wei
                          args caller, address(sha3(0, 4894420617473177672, sha3(address(cd[36]), address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)), cd[68]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      require ext_call.return_data[0] == bool(ext_call.return_data[0])
                      call address(sha3(0, 4894420617473177672, sha3(address(cd[36]), address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).burn(address to) with:
                           gas gas_remaining wei
                          args address(cd[164])
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
              else:
                  require swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] path, address to, uint256 deadline) == uint32(call.func_hash) >> 224
                  require not call.value
                  require calldata.size - 4 >=′ 160
                  require cd[68] <= LOCK8605463013()
                  require cd[68] + 35 <′ calldata.size
                  require ('cd', 68).length <= LOCK8605463013()
                  require cd[68] + (32 * ('cd', 68).length) + 36 <= calldata.size
                  require cd[100] == address(cd[100])
                  if cd[132] < block.timestamp:
                      revert with 0, 'FraxswapV1Router: EXPIRED'
                  mem[160 len 32 * ('cd', 68).length] = call.data[cd[68] + 36 len 32 * ('cd', 68).length]
                  if ('cd', 68).length < 2:
                      revert with 0, 'FraxswapRouterLibrary: INVALID_PATH'
                  if ('cd', 68).length > LOCK8605463013():
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  mem[(32 * ('cd', 68).length) + 160] = ('cd', 68).length
                  if ('cd', 68).length:
                      mem[(32 * ('cd', 68).length) + 192 len 32 * ('cd', 68).length] = call.data[calldata.size len 32 * ('cd', 68).length]
                  if 0 >= ('cd', 68).length:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  mem[(32 * ('cd', 68).length) + 192] = cd[4]
                  if ('cd', 68).length < 1:
                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                  if 0 >= ('cd', 68).length - 1:
                      if ('cd', 68).length < 1:
                          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                      if ('cd', 68).length - 1 >= ('cd', 68).length:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      if mem[(32 * ('cd', 68).length - 1) + (32 * ('cd', 68).length) + 192] < cd[36]:
                          mem[(64 * ('cd', 68).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(64 * ('cd', 68).length) + 196] = 32
                          mem[(64 * ('cd', 68).length) + 228] = 44
                          mem[(64 * ('cd', 68).length) + 260] = 'FraxswapV1Router: INSUFFICIENT_O'
                          mem[(64 * ('cd', 68).length) + 292] = 'UTPUT_AMOUNT'
                          revert with memory
                            from (64 * ('cd', 68).length) + 192
                             len (127 * ('cd', 68).length) + 132
                      if 0 >= ('cd', 68).length:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      require ('cd', 68)[0] == address(('cd', 68)[0])
                      if 0 >= ('cd', 68).length:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      require ('cd', 68)[0] == address(('cd', 68)[0])
                      if 1 >= ('cd', 68).length:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      require ('cd', 68)[1] == address(('cd', 68)[1])
                  else:
                      if 0 >= ('cd', 68).length:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      if 1 >= ('cd', 68).length:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      if not mem[172 len 20] - mem[204 len 20]:
                          mem[(64 * ('cd', 68).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                          mem[(64 * ('cd', 68).length) + 196] = 32
                          mem[(64 * ('cd', 68).length) + 228] = 42
                          mem[(64 * ('cd', 68).length) + 260] = 'FraxswapRouterLibrary: IDENTICAL'
                          mem[(64 * ('cd', 68).length) + 292] = '_ADDRESSES'
                          revert with memory
                            from (64 * ('cd', 68).length) + 192
                             len (127 * ('cd', 68).length) + 132
                      if mem[172 len 20] < mem[204 len 20]:
                          if not mem[172 len 20]:
                              mem[(64 * ('cd', 68).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(64 * ('cd', 68).length) + 196] = 32
                              mem[(64 * ('cd', 68).length) + 228] = 35
                              mem[(64 * ('cd', 68).length) + 260] = 'FraxswapRouterLibrary: ZERO_ADDR'
                              mem[(64 * ('cd', 68).length) + 292] = 'ESS'
                              revert with memory
                                from (64 * ('cd', 68).length) + 192
                                 len (127 * ('cd', 68).length) + 132
                          mem[(64 * ('cd', 68).length) + 224] = address(mem[160])
                          mem[(64 * ('cd', 68).length) + 244] = address(mem[192])
                      else:
                          if not mem[204 len 20]:
                              mem[(64 * ('cd', 68).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(64 * ('cd', 68).length) + 196] = 32
                              mem[(64 * ('cd', 68).length) + 228] = 35
                              mem[(64 * ('cd', 68).length) + 260] = 'FraxswapRouterLibrary: ZERO_ADDR'
                              mem[(64 * ('cd', 68).length) + 292] = 'ESS'
                              revert with memory
                                from (64 * ('cd', 68).length) + 192
                                 len (127 * ('cd', 68).length) + 132
                          mem[(64 * ('cd', 68).length) + 224] = address(mem[192])
                          mem[(64 * ('cd', 68).length) + 244] = address(mem[160])
                      require ext_code.size(address(sha3(0, 4894420617473177672, sha3(mem[(64 * ('cd', 68).length) + 224 len (127 * ('cd', 68).length) + 40]), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
                      call address(sha3(0, 4894420617473177672, sha3(mem[(64 * ('cd', 68).length) + 224 len (127 * ('cd', 68).length) + 40]), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      if 0 >= ('cd', 68).length:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      if 0 >= ('cd', 68).length:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      static call address(sha3(0, 4894420617473177672, sha3(mem[(64 * ('cd', 68).length) + 224 len (127 * ('cd', 68).length) + 40]), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getAmountOut(uint256 amountIn, address tokenIn) with:
                              gas gas_remaining wei
                             args cd[4], mem[172 len 20]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
      if getAmountsOutWithTwamm(uint256 amountIn, address[] path) <= uint32(call.func_hash) >> 224:
          if getAmountsOutWithTwamm(uint256 amountIn, address[] path) == uint32(call.func_hash) >> 224:
              require not call.value
              require calldata.size - 4 >=′ 64
              require cd[36] <= LOCK8605463013()
              require cd[36] + 35 <′ calldata.size
              if ('cd', 36).length > LOCK8605463013():
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              if ceil32(32 * ('cd', 36).length) + 129 > LOCK8605463013() or ceil32(32 * ('cd', 36).length) + 129 < 128:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              require (32 * ('cd', 36).length) + cd[36] + 36 <= calldata.size
          else:
              if swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] path, address to, uint256 deadline) == uint32(call.func_hash) >> 224:
                  require not call.value
                  require calldata.size - 4 >=′ 160
                  require cd[68] <= LOCK8605463013()
                  require cd[68] + 35 <′ calldata.size
                  require ('cd', 68).length <= LOCK8605463013()
                  require cd[68] + (32 * ('cd', 68).length) + 36 <= calldata.size
                  require cd[100] == address(cd[100])
                  if cd[132] < block.timestamp:
                      revert with 0, 'FraxswapV1Router: EXPIRED'
                  if ('cd', 68).length < 1:
                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                  if ('cd', 68).length - 1 >= ('cd', 68).length:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  require cd[((32 * ('cd', 68).length - 1) + cd[68] + 36)] == address(cd[((32 * ('cd', 68).length - 1) + cd[68] + 36)])
                  if address(cd[((32 * ('cd', 68).length - 1) + cd[68] + 36)]) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      revert with 0, 'FraxswapV1Router: INVALID_PATH'
                  if 0 >= ('cd', 68).length:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  require ('cd', 68)[0] == address(('cd', 68)[0])
                  if 0 >= ('cd', 68).length:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  require ('cd', 68)[0] == address(('cd', 68)[0])
                  if 1 >= ('cd', 68).length:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  require ('cd', 68)[1] == address(('cd', 68)[1])
                  if not address(('cd', 68)[0]) - address(('cd', 68)[1]):
                      revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
                  if address(('cd', 68)[0]) >= address(('cd', 68)[1]):
              else:
                  if uint32(call.func_hash) >> 224 != swapExactETHForTokens(uint256 amountOutMin, address[] path, address to, uint256 deadline):
                      require getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut) == uint32(call.func_hash) >> 224
                      require not call.value
                      require calldata.size - 4 >=′ 96
                      revert with 0, 'Deprecated: Use getAmountsIn'
                  require calldata.size - 4 >=′ 128
                  require cd[36] <= LOCK8605463013()
                  require cd[36] + 35 <′ calldata.size
                  require ('cd', 36).length <= LOCK8605463013()
                  require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
                  require cd[68] == address(cd[68])
                  if cd[100] < block.timestamp:
                      revert with 0, 'FraxswapV1Router: EXPIRED'
                  if 0 >= ('cd', 36).length:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  require ('cd', 36)[0] == address(('cd', 36)[0])
                  if address(('cd', 36)[0]) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      revert with 0, 'FraxswapV1Router: INVALID_PATH'
                  mem[160 len 32 * ('cd', 36).length] = call.data[cd[36] + 36 len 32 * ('cd', 36).length]
                  if ('cd', 36).length < 2:
                      revert with 0, 'FraxswapRouterLibrary: INVALID_PATH'
                  if ('cd', 36).length > LOCK8605463013():
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  mem[(32 * ('cd', 36).length) + 160] = ('cd', 36).length
                  if ('cd', 36).length:
                      mem[(32 * ('cd', 36).length) + 192 len 32 * ('cd', 36).length] = call.data[calldata.size len 32 * ('cd', 36).length]
                      if 0 >= ('cd', 36).length:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      mem[(32 * ('cd', 36).length) + 192] = call.value
                      if ('cd', 36).length < 1:
                          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                      if 0 >= ('cd', 36).length - 1:
                          if ('cd', 36).length < 1:
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ('cd', 36).length - 1 >= ('cd', 36).length:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          if mem[(32 * ('cd', 36).length - 1) + (32 * ('cd', 36).length) + 192] < cd[4]:
                              mem[(64 * ('cd', 36).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(64 * ('cd', 36).length) + 196] = 32
                              mem[(64 * ('cd', 36).length) + 228] = 44
                              mem[(64 * ('cd', 36).length) + 260] = 'FraxswapV1Router: INSUFFICIENT_O'
                              mem[(64 * ('cd', 36).length) + 292] = 'UTPUT_AMOUNT'
                              revert with memory
                                from (64 * ('cd', 36).length) + 192
                                 len (127 * ('cd', 36).length) + 132
                          if 0 >= ('cd', 36).length:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          mem[(64 * ('cd', 36).length) + 192] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                          require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
                             value call.value wei
                               gas gas_remaining wei
                              args mem[(64 * ('cd', 36).length) + 196 len 127 * ('cd', 36).length]
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          if 0 >= ('cd', 36).length:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          require ('cd', 36)[0] == address(('cd', 36)[0])
                          if 1 >= ('cd', 36).length:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      else:
                          if 0 >= ('cd', 36).length:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          if 1 >= ('cd', 36).length:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          if not mem[172 len 20] - mem[204 len 20]:
                              mem[(64 * ('cd', 36).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(64 * ('cd', 36).length) + 196] = 32
                              mem[(64 * ('cd', 36).length) + 228] = 42
                              mem[(64 * ('cd', 36).length) + 260] = 'FraxswapRouterLibrary: IDENTICAL'
                              mem[(64 * ('cd', 36).length) + 292] = '_ADDRESSES'
                              revert with memory
                                from (64 * ('cd', 36).length) + 192
                                 len (127 * ('cd', 36).length) + 132
                          if mem[172 len 20] < mem[204 len 20]:
                              if not mem[172 len 20]:
                                  mem[(64 * ('cd', 36).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(64 * ('cd', 36).length) + 196] = 32
                                  mem[(64 * ('cd', 36).length) + 228] = 35
                                  mem[(64 * ('cd', 36).length) + 260] = 'FraxswapRouterLibrary: ZERO_ADDR'
                                  mem[(64 * ('cd', 36).length) + 292] = 'ESS'
                                  revert with memory
                                    from (64 * ('cd', 36).length) + 192
                                     len (127 * ('cd', 36).length) + 132
                              mem[(64 * ('cd', 36).length) + 224] = address(mem[160])
                              mem[(64 * ('cd', 36).length) + 244] = address(mem[192])
                          else:
                              if not mem[204 len 20]:
                                  mem[(64 * ('cd', 36).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(64 * ('cd', 36).length) + 196] = 32
                                  mem[(64 * ('cd', 36).length) + 228] = 35
                                  mem[(64 * ('cd', 36).length) + 260] = 'FraxswapRouterLibrary: ZERO_ADDR'
                                  mem[(64 * ('cd', 36).length) + 292] = 'ESS'
                                  revert with memory
                                    from (64 * ('cd', 36).length) + 192
                                     len (127 * ('cd', 36).length) + 132
                              mem[(64 * ('cd', 36).length) + 224] = address(mem[192])
                              mem[(64 * ('cd', 36).length) + 244] = address(mem[160])
                          require ext_code.size(address(sha3(0, 4894420617473177672, sha3(mem[(64 * ('cd', 36).length) + 224 len (127 * ('cd', 36).length) + 40]), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
                          call address(sha3(0, 4894420617473177672, sha3(mem[(64 * ('cd', 36).length) + 224 len (127 * ('cd', 36).length) + 40]), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                               gas gas_remaining wei
                              args block.timestamp
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          if 0 >= ('cd', 36).length:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  else:
                      if 0 >= ('cd', 36).length:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      mem[(32 * ('cd', 36).length) + 192] = call.value
                      if ('cd', 36).length < 1:
                          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                      if 0 >= ('cd', 36).length - 1:
                          if ('cd', 36).length < 1:
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          if ('cd', 36).length - 1 >= ('cd', 36).length:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          if mem[(32 * ('cd', 36).length - 1) + (32 * ('cd', 36).length) + 192] < cd[4]:
                              mem[(64 * ('cd', 36).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(64 * ('cd', 36).length) + 196] = 32
                              mem[(64 * ('cd', 36).length) + 228] = 44
                              mem[(64 * ('cd', 36).length) + 260] = 'FraxswapV1Router: INSUFFICIENT_O'
                              mem[(64 * ('cd', 36).length) + 292] = 'UTPUT_AMOUNT'
                              revert with memory
                                from (64 * ('cd', 36).length) + 192
                                 len (127 * ('cd', 36).length) + 132
                          if 0 >= ('cd', 36).length:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          mem[(64 * ('cd', 36).length) + 192] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                          require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
                             value call.value wei
                               gas gas_remaining wei
                              args mem[(64 * ('cd', 36).length) + 196 len 127 * ('cd', 36).length]
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          if 0 >= ('cd', 36).length:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          require ('cd', 36)[0] == address(('cd', 36)[0])
                          if 1 >= ('cd', 36).length:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      else:
                          if 0 >= ('cd', 36).length:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          if 1 >= ('cd', 36).length:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          if not mem[172 len 20] - mem[204 len 20]:
                              mem[(64 * ('cd', 36).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                              mem[(64 * ('cd', 36).length) + 196] = 32
                              mem[(64 * ('cd', 36).length) + 228] = 42
                              mem[(64 * ('cd', 36).length) + 260] = 'FraxswapRouterLibrary: IDENTICAL'
                              mem[(64 * ('cd', 36).length) + 292] = '_ADDRESSES'
                              revert with memory
                                from (64 * ('cd', 36).length) + 192
                                 len (127 * ('cd', 36).length) + 132
                          if mem[172 len 20] < mem[204 len 20]:
                              if not mem[172 len 20]:
                                  mem[(64 * ('cd', 36).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(64 * ('cd', 36).length) + 196] = 32
                                  mem[(64 * ('cd', 36).length) + 228] = 35
                                  mem[(64 * ('cd', 36).length) + 260] = 'FraxswapRouterLibrary: ZERO_ADDR'
                                  mem[(64 * ('cd', 36).length) + 292] = 'ESS'
                                  revert with memory
                                    from (64 * ('cd', 36).length) + 192
                                     len (127 * ('cd', 36).length) + 132
                              mem[(64 * ('cd', 36).length) + 224] = address(mem[160])
                              mem[(64 * ('cd', 36).length) + 244] = address(mem[192])
                          else:
                              if not mem[204 len 20]:
                                  mem[(64 * ('cd', 36).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                  mem[(64 * ('cd', 36).length) + 196] = 32
                                  mem[(64 * ('cd', 36).length) + 228] = 35
                                  mem[(64 * ('cd', 36).length) + 260] = 'FraxswapRouterLibrary: ZERO_ADDR'
                                  mem[(64 * ('cd', 36).length) + 292] = 'ESS'
                                  revert with memory
                                    from (64 * ('cd', 36).length) + 192
                                     len (127 * ('cd', 36).length) + 132
                              mem[(64 * ('cd', 36).length) + 224] = address(mem[192])
                              mem[(64 * ('cd', 36).length) + 244] = address(mem[160])
                          require ext_code.size(address(sha3(0, 4894420617473177672, sha3(mem[(64 * ('cd', 36).length) + 224 len (127 * ('cd', 36).length) + 40]), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
                          call address(sha3(0, 4894420617473177672, sha3(mem[(64 * ('cd', 36).length) + 224 len (127 * ('cd', 36).length) + 40]), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                               gas gas_remaining wei
                              args block.timestamp
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          if 0 >= ('cd', 36).length:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          if 0 >= ('cd', 36).length:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          static call address(sha3(0, 4894420617473177672, sha3(mem[(64 * ('cd', 36).length) + 224 len (127 * ('cd', 36).length) + 40]), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getAmountOut(uint256 amountIn, address tokenIn) with:
                                  gas gas_remaining wei
                                 args call.value, mem[172 len 20]
          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
      if uint32(call.func_hash) >> 224 != swapTokensForExactETH(uint256 amountOut, uint256 amountInMax, address[] path, address to, uint256 deadline):
          if uint32(call.func_hash) >> 224 != removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s):
              require swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] path, address to, uint256 deadline) == uint32(call.func_hash) >> 224
              require not call.value
              require calldata.size - 4 >=′ 160
              require cd[68] <= LOCK8605463013()
              require cd[68] + 35 <′ calldata.size
              require ('cd', 68).length <= LOCK8605463013()
              require cd[68] + (32 * ('cd', 68).length) + 36 <= calldata.size
              require cd[100] == address(cd[100])
              if cd[132] < block.timestamp:
                  revert with 0, 'FraxswapV1Router: EXPIRED'
              if 0 >= ('cd', 68).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              require ('cd', 68)[0] == address(('cd', 68)[0])
              if 0 >= ('cd', 68).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              require ('cd', 68)[0] == address(('cd', 68)[0])
              if 1 >= ('cd', 68).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              require ('cd', 68)[1] == address(('cd', 68)[1])
              if not address(('cd', 68)[0]) - address(('cd', 68)[1]):
                  revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
              if address(('cd', 68)[0]) < address(('cd', 68)[1]):
                  if not address(('cd', 68)[0]):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              else:
                  if not address(('cd', 68)[1]):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
          else:
              require not call.value
              require calldata.size - 4 >=′ 320
              require cd[4] == address(cd[4])
              require cd[132] == address(cd[132])
              require cd[196] == bool(cd[196])
              require cd[228] == uint8(cd[228])
              if not address(cd[4]) - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                  revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
              if address(cd[4]) >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                  require ext_code.size(address(sha3(0, 4894420617473177672, sha3(13847067169082572429, address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
                  if cd[196]:
                      call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
                           gas gas_remaining wei
                          args caller, this.address, -1, cd[164], cd[228] << 248, cd[260], cd[292]
                  else:
                      call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
                           gas gas_remaining wei
                          args caller, this.address, cd[36], cd[164], cd[228] << 248, cd[260], cd[292]
              else:
                  if not address(cd[4]):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                  require ext_code.size(address(sha3(0, 4894420617473177672, sha3(address(cd[4]), 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
                  if cd[196]:
                      call address(sha3(0, 4894420617473177672, sha3(address(cd[4]), 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
                           gas gas_remaining wei
                          args caller, this.address, -1, cd[164], cd[228] << 248, cd[260], cd[292]
                  else:
                      call address(sha3(0, 4894420617473177672, sha3(address(cd[4]), 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
                           gas gas_remaining wei
                          args caller, this.address, cd[36], cd[164], cd[228] << 248, cd[260], cd[292]
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              if cd[164] < block.timestamp:
                  revert with 0, 'FraxswapV1Router: EXPIRED'
              if not address(cd[4]) - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                  revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
              if address(cd[4]) >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                  call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).transferFrom(address sender, address recipient, uint256 amount) with:
                       gas gas_remaining wei
                      args caller, address(sha3(0, 4894420617473177672, sha3(13847067169082572429, address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)), cd[36]
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >=′ 32
                  require ext_call.return_data[0] == bool(ext_call.return_data[0])
                  call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).burn(address to) with:
                       gas gas_remaining wei
                      args this.address
              else:
                  if not address(cd[4]):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                  call address(sha3(0, 4894420617473177672, sha3(address(cd[4]), 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).transferFrom(address sender, address recipient, uint256 amount) with:
                       gas gas_remaining wei
                      args caller, address(sha3(0, 4894420617473177672, sha3(address(cd[4]), 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)), cd[36]
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >=′ 32
                  require ext_call.return_data[0] == bool(ext_call.return_data[0])
                  call address(sha3(0, 4894420617473177672, sha3(address(cd[4]), 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).burn(address to) with:
                       gas gas_remaining wei
                      args this.address
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
      require not call.value
      require calldata.size - 4 >=′ 160
      require cd[68] <= LOCK8605463013()
      require cd[68] + 35 <′ calldata.size
      require ('cd', 68).length <= LOCK8605463013()
      require cd[68] + (32 * ('cd', 68).length) + 36 <= calldata.size
      require cd[100] == address(cd[100])
      if cd[132] < block.timestamp:
          revert with 0, 'FraxswapV1Router: EXPIRED'
      if ('cd', 68).length < 1:
          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
      if ('cd', 68).length - 1 >= ('cd', 68).length:
          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
      require cd[((32 * ('cd', 68).length - 1) + cd[68] + 36)] == address(cd[((32 * ('cd', 68).length - 1) + cd[68] + 36)])
      if address(cd[((32 * ('cd', 68).length - 1) + cd[68] + 36)]) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
          revert with 0, 'FraxswapV1Router: INVALID_PATH'
      mem[128] = ('cd', 68).length
      mem[160 len 32 * ('cd', 68).length] = call.data[cd[68] + 36 len 32 * ('cd', 68).length]
      if ('cd', 68).length < 2:
          revert with 0, 'FraxswapRouterLibrary: INVALID_PATH'
      if ('cd', 68).length > LOCK8605463013():
          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
      mem[(32 * ('cd', 68).length) + 160] = ('cd', 68).length
      if ('cd', 68).length:
          mem[(32 * ('cd', 68).length) + 192 len 32 * ('cd', 68).length] = call.data[calldata.size len 32 * ('cd', 68).length]
          if ('cd', 68).length < 1:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if ('cd', 68).length - 1 >= ('cd', 68).length:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          mem[(32 * ('cd', 68).length - 1) + (32 * ('cd', 68).length) + 192] = cd[4]
          if ('cd', 68).length < 1:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if not ('cd', 68).length - 1:
              if 0 >= ('cd', 68).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              if mem[(32 * ('cd', 68).length) + 192] <= cd[36]:
                  if 0 >= ('cd', 68).length:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  require ('cd', 68)[0] == address(('cd', 68)[0])
                  if 0 >= ('cd', 68).length:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              mem[(64 * ('cd', 68).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
              mem[(64 * ('cd', 68).length) + 196] = 32
              mem[(64 * ('cd', 68).length) + 228] = 40
              mem[(64 * ('cd', 68).length) + 260] = 'FraxswapV1Router: EXCESSIVE_INPU'
              mem[(64 * ('cd', 68).length) + 292] = 'T_AMOUNT'
          else:
              if ('cd', 68).length - 1 < 1:
                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
              if ('cd', 68).length - 2 >= ('cd', 68).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              if ('cd', 68).length - 1 >= ('cd', 68).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              if not mem[(32 * ('cd', 68).length - 2) + 172 len 20] - mem[(32 * ('cd', 68).length - 1) + 172 len 20]:
                  mem[(64 * ('cd', 68).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                  mem[(64 * ('cd', 68).length) + 196] = 32
                  mem[(64 * ('cd', 68).length) + 228] = 42
                  mem[(64 * ('cd', 68).length) + 260] = 'FraxswapRouterLibrary: IDENTICAL'
                  mem[(64 * ('cd', 68).length) + 292] = '_ADDRESSES'
              else:
                  if mem[(32 * ('cd', 68).length - 2) + 172 len 20] < mem[(32 * ('cd', 68).length - 1) + 172 len 20]:
                      if mem[(32 * ('cd', 68).length - 2) + 172 len 20]:
                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                  else:
                      if mem[(32 * ('cd', 68).length - 1) + 172 len 20]:
                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                  mem[(64 * ('cd', 68).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                  mem[(64 * ('cd', 68).length) + 196] = 32
                  mem[(64 * ('cd', 68).length) + 228] = 35
                  mem[(64 * ('cd', 68).length) + 260] = 'FraxswapRouterLibrary: ZERO_ADDR'
                  mem[(64 * ('cd', 68).length) + 292] = 'ESS'
      else:
          if ('cd', 68).length < 1:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if ('cd', 68).length - 1 >= ('cd', 68).length:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          mem[(32 * ('cd', 68).length - 1) + (32 * ('cd', 68).length) + 192] = cd[4]
          if ('cd', 68).length < 1:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if not ('cd', 68).length - 1:
              if 0 >= ('cd', 68).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              if mem[(32 * ('cd', 68).length) + 192] <= cd[36]:
                  if 0 >= ('cd', 68).length:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  require ('cd', 68)[0] == address(('cd', 68)[0])
                  if 0 >= ('cd', 68).length:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              mem[(64 * ('cd', 68).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
              mem[(64 * ('cd', 68).length) + 196] = 32
              mem[(64 * ('cd', 68).length) + 228] = 40
              mem[(64 * ('cd', 68).length) + 260] = 'FraxswapV1Router: EXCESSIVE_INPU'
              mem[(64 * ('cd', 68).length) + 292] = 'T_AMOUNT'
          else:
              if ('cd', 68).length - 1 < 1:
                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
              if ('cd', 68).length - 2 >= ('cd', 68).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              _1299 = mem[(32 * ('cd', 68).length - 2) + 160]
              if ('cd', 68).length - 1 >= ('cd', 68).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              _1432 = mem[(32 * ('cd', 68).length - 1) + 160]
              if not mem[(32 * ('cd', 68).length - 2) + 172 len 20] - mem[(32 * ('cd', 68).length - 1) + 172 len 20]:
                  mem[(64 * ('cd', 68).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                  mem[(64 * ('cd', 68).length) + 196] = 32
                  mem[(64 * ('cd', 68).length) + 228] = 42
                  mem[(64 * ('cd', 68).length) + 260] = 'FraxswapRouterLibrary: IDENTICAL'
                  mem[(64 * ('cd', 68).length) + 292] = '_ADDRESSES'
              else:
                  if mem[(32 * ('cd', 68).length - 2) + 172 len 20] < mem[(32 * ('cd', 68).length - 1) + 172 len 20]:
                      if mem[(32 * ('cd', 68).length - 2) + 172 len 20]:
                          mem[(64 * ('cd', 68).length) + 224] = address(mem[(32 * ('cd', 68).length - 2) + 160])
                          mem[(64 * ('cd', 68).length) + 244] = address(_1432)
                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                  else:
                      if mem[(32 * ('cd', 68).length - 1) + 172 len 20]:
                          mem[(64 * ('cd', 68).length) + 224] = address(mem[(32 * ('cd', 68).length - 1) + 160])
                          mem[(64 * ('cd', 68).length) + 244] = address(_1299)
                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                  mem[(64 * ('cd', 68).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                  mem[(64 * ('cd', 68).length) + 196] = 32
                  mem[(64 * ('cd', 68).length) + 228] = 35
                  mem[(64 * ('cd', 68).length) + 260] = 'FraxswapRouterLibrary: ZERO_ADDR'
                  mem[(64 * ('cd', 68).length) + 292] = 'ESS'
      revert with memory
        from (64 * ('cd', 68).length) + 192
         len (127 * ('cd', 68).length) + 132
  if removeLiquidity(address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) <= uint32(call.func_hash) >> 224:
      if removeLiquidityETHWithPermit(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) > uint32(call.func_hash) >> 224:
          if uint32(call.func_hash) >> 224 != removeLiquidity(address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline):
              if factory() == uint32(call.func_hash) >> 224:
                  require not call.value
                  return 0x43ec799eadd63848443e2347c49f5f52e8fe0f6f
              require getAmountsOut(uint256 amountIn, address[] path) == uint32(call.func_hash) >> 224
              require not call.value
              require calldata.size - 4 >=′ 64
              require cd[36] <= LOCK8605463013()
              require cd[36] + 35 <′ calldata.size
              if ('cd', 36).length > LOCK8605463013():
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              if ceil32(32 * ('cd', 36).length) + 129 > LOCK8605463013() or ceil32(32 * ('cd', 36).length) + 129 < 128:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              require (32 * ('cd', 36).length) + cd[36] + 36 <= calldata.size
              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
          require not call.value
          require calldata.size - 4 >=′ 224
          require cd[4] == address(cd[4])
          require cd[36] == address(cd[36])
          require cd[164] == address(cd[164])
          if cd[196] < block.timestamp:
              revert with 0, 'FraxswapV1Router: EXPIRED'
          if not address(cd[4]) - address(cd[36]):
              revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
          if address(cd[4]) < address(cd[36]):
              if not address(cd[4]):
                  revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              call address(sha3(0, 4894420617473177672, sha3(address(cd[4]), address(cd[36])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).transferFrom(address sender, address recipient, uint256 amount) with:
                   gas gas_remaining wei
                  args caller, address(sha3(0, 4894420617473177672, sha3(address(cd[4]), address(cd[36])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)), cd[68]
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 32
              require ext_call.return_data[0] == bool(ext_call.return_data[0])
              call address(sha3(0, 4894420617473177672, sha3(address(cd[4]), address(cd[36])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).burn(address to) with:
                   gas gas_remaining wei
                  args address(cd[164])
          else:
              if not address(cd[36]):
                  revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              call address(sha3(0, 4894420617473177672, sha3(address(cd[36]), address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).transferFrom(address sender, address recipient, uint256 amount) with:
                   gas gas_remaining wei
                  args caller, address(sha3(0, 4894420617473177672, sha3(address(cd[36]), address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)), cd[68]
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 32
              require ext_call.return_data[0] == bool(ext_call.return_data[0])
              call address(sha3(0, 4894420617473177672, sha3(address(cd[36]), address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).burn(address to) with:
                   gas gas_remaining wei
                  args address(cd[164])
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          require return_data.size >=′ 64
          if not address(cd[4]) - address(cd[36]):
              revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
          if address(cd[4]) < address(cd[36]):
              if not address(cd[4]):
                  revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              if address(cd[4]) == address(cd[4]):
                  if ext_call.return_data[0] < cd[100]:
                      revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
                  if ext_call.return_data[32] < cd[132]:
                      revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
                  return ext_call.return_data[0], ext_call.return_data[32]
          else:
              if not address(cd[36]):
                  revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              if address(cd[4]) == address(cd[36]):
                  if ext_call.return_data[0] < cd[100]:
                      revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
                  if ext_call.return_data[32] < cd[132]:
                      revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
                  return ext_call.return_data[0], ext_call.return_data[32]
          if ext_call.return_data[32] < cd[100]:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
          if ext_call.return_data[0] < cd[132]:
              revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
          return ext_call.return_data[32], ext_call.return_data[0]
      if removeLiquidityETHWithPermit(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) == uint32(call.func_hash) >> 224:
          require not call.value
          require calldata.size - 4 >=′ 320
          require cd[4] == address(cd[4])
          require cd[132] == address(cd[132])
          require cd[196] == bool(cd[196])
          require cd[228] == uint8(cd[228])
          if not address(cd[4]) - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
              revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
          if address(cd[4]) >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
              require ext_code.size(address(sha3(0, 4894420617473177672, sha3(13847067169082572429, address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
              if cd[196]:
                  call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
                       gas gas_remaining wei
                      args caller, this.address, -1, cd[164], cd[228] << 248, cd[260], cd[292]
              else:
                  call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
                       gas gas_remaining wei
                      args caller, this.address, cd[36], cd[164], cd[228] << 248, cd[260], cd[292]
          else:
              if not address(cd[4]):
                  revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              require ext_code.size(address(sha3(0, 4894420617473177672, sha3(address(cd[4]), 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
              if cd[196]:
                  call address(sha3(0, 4894420617473177672, sha3(address(cd[4]), 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
                       gas gas_remaining wei
                      args caller, this.address, -1, cd[164], cd[228] << 248, cd[260], cd[292]
              else:
                  call address(sha3(0, 4894420617473177672, sha3(address(cd[4]), 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
                       gas gas_remaining wei
                      args caller, this.address, cd[36], cd[164], cd[228] << 248, cd[260], cd[292]
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          if cd[164] < block.timestamp:
              revert with 0, 'FraxswapV1Router: EXPIRED'
          if not address(cd[4]) - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
              revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
          if address(cd[4]) >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
              call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).transferFrom(address sender, address recipient, uint256 amount) with:
                   gas gas_remaining wei
                  args caller, address(sha3(0, 4894420617473177672, sha3(13847067169082572429, address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)), cd[36]
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 32
              require ext_call.return_data[0] == bool(ext_call.return_data[0])
              call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).burn(address to) with:
                   gas gas_remaining wei
                  args this.address
          else:
              if not address(cd[4]):
                  revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              call address(sha3(0, 4894420617473177672, sha3(address(cd[4]), 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).transferFrom(address sender, address recipient, uint256 amount) with:
                   gas gas_remaining wei
                  args caller, address(sha3(0, 4894420617473177672, sha3(address(cd[4]), 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)), cd[36]
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 32
              require ext_call.return_data[0] == bool(ext_call.return_data[0])
              call address(sha3(0, 4894420617473177672, sha3(address(cd[4]), 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).burn(address to) with:
                   gas gas_remaining wei
                  args this.address
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          require return_data.size >=′ 64
          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
      if addLiquidity(address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) == uint32(call.func_hash) >> 224:
          require not call.value
          require calldata.size - 4 >=′ 256
          require cd[4] == address(cd[4])
          require cd[36] == address(cd[36])
          require cd[196] == address(cd[196])
          if cd[228] < block.timestamp:
              revert with 0, 'FraxswapV1Router: EXPIRED'
          static call 0x43ec799eadd63848443e2347c49f5f52e8fe0f6f.getPair(address , address ) with:
                  gas gas_remaining wei
                 args address(cd[4]), address(cd[36])
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          require return_data.size >=′ 32
          require ext_call.return_data[0] == ext_call.return_data[12 len 20]
          if ext_call.return_data[12 len 20]:
              if not address(cd[4]) - address(cd[36]):
                  revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
              if address(cd[4]) < address(cd[36]):
                  if not address(cd[4]):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              else:
                  if not address(cd[36]):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              if not address(cd[4]) - address(cd[36]):
                  revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
              if address(cd[4]) < address(cd[36]):
                  if not address(cd[4]):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                  require ext_code.size(address(sha3(0, 4894420617473177672, sha3(address(cd[4]), address(cd[36])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
                  call address(sha3(0, 4894420617473177672, sha3(address(cd[4]), address(cd[36])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                       gas gas_remaining wei
                      args block.timestamp
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  static call address(sha3(0, 4894420617473177672, sha3(address(cd[4]), address(cd[36])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getTwammReserves() with:
                          gas gas_remaining wei
              else:
                  if not address(cd[36]):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                  require ext_code.size(address(sha3(0, 4894420617473177672, sha3(address(cd[36]), address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
                  call address(sha3(0, 4894420617473177672, sha3(address(cd[36]), address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                       gas gas_remaining wei
                      args block.timestamp
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  static call address(sha3(0, 4894420617473177672, sha3(address(cd[36]), address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getTwammReserves() with:
                          gas gas_remaining wei
              require return_data.size >=′ 192
              require ext_call.return_data[0] == ext_call.return_data[18 len 14]
              require ext_call.return_data[32] == ext_call.return_data[50 len 14]
              require ext_call.return_data[64] == ext_call.return_data[92 len 4]
          else:
              call 0x43ec799eadd63848443e2347c49f5f52e8fe0f6f.createPair(address tokenA, address tokenB) with:
                   gas gas_remaining wei
                  args address(cd[4]), address(cd[36])
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 32
              require ext_call.return_data[0] == ext_call.return_data[12 len 20]
              if not address(cd[4]) - address(cd[36]):
                  revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
              if address(cd[4]) < address(cd[36]):
                  if not address(cd[4]):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              else:
                  if not address(cd[36]):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              if not address(cd[4]) - address(cd[36]):
                  revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
              if address(cd[4]) < address(cd[36]):
                  if not address(cd[4]):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                  require ext_code.size(address(sha3(0, 4894420617473177672, sha3(address(cd[4]), address(cd[36])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
                  call address(sha3(0, 4894420617473177672, sha3(address(cd[4]), address(cd[36])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                       gas gas_remaining wei
                      args block.timestamp
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  static call address(sha3(0, 4894420617473177672, sha3(address(cd[4]), address(cd[36])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getTwammReserves() with:
                          gas gas_remaining wei
              else:
                  if not address(cd[36]):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                  require ext_code.size(address(sha3(0, 4894420617473177672, sha3(address(cd[36]), address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
                  call address(sha3(0, 4894420617473177672, sha3(address(cd[36]), address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                       gas gas_remaining wei
                      args block.timestamp
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  static call address(sha3(0, 4894420617473177672, sha3(address(cd[36]), address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getTwammReserves() with:
                          gas gas_remaining wei
          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
      if addLiquidityETH(address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline) == uint32(call.func_hash) >> 224:
          require calldata.size - 4 >=′ 192
          require cd[4] == address(cd[4])
          require cd[132] == address(cd[132])
          if cd[164] < block.timestamp:
              revert with 0, 'FraxswapV1Router: EXPIRED'
          static call 0x43ec799eadd63848443e2347c49f5f52e8fe0f6f.getPair(address , address ) with:
                  gas gas_remaining wei
                 args address(cd[4]), 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          require return_data.size >=′ 32
          require ext_call.return_data[0] == ext_call.return_data[12 len 20]
          if ext_call.return_data[12 len 20]:
              if not address(cd[4]) - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                  revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
              if address(cd[4]) < 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                  if not address(cd[4]):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              if not address(cd[4]) - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                  revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
              if address(cd[4]) >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                  require ext_code.size(address(sha3(0, 4894420617473177672, sha3(13847067169082572429, address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
                  call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                       gas gas_remaining wei
                      args block.timestamp
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  static call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getTwammReserves() with:
                          gas gas_remaining wei
              else:
                  if not address(cd[4]):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                  require ext_code.size(address(sha3(0, 4894420617473177672, sha3(address(cd[4]), 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
                  call address(sha3(0, 4894420617473177672, sha3(address(cd[4]), 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                       gas gas_remaining wei
                      args block.timestamp
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  static call address(sha3(0, 4894420617473177672, sha3(address(cd[4]), 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getTwammReserves() with:
                          gas gas_remaining wei
              require return_data.size >=′ 192
              require ext_call.return_data[0] == ext_call.return_data[18 len 14]
              require ext_call.return_data[32] == ext_call.return_data[50 len 14]
              require ext_call.return_data[64] == ext_call.return_data[92 len 4]
              require ext_call.return_data[96] == ext_call.return_data[114 len 14]
          else:
              call 0x43ec799eadd63848443e2347c49f5f52e8fe0f6f.createPair(address tokenA, address tokenB) with:
                   gas gas_remaining wei
                  args address(cd[4]), 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 32
              require ext_call.return_data[0] == ext_call.return_data[12 len 20]
              if not address(cd[4]) - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                  revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
              if address(cd[4]) < 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                  if not address(cd[4]):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              if not address(cd[4]) - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                  revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
              if address(cd[4]) >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                  require ext_code.size(address(sha3(0, 4894420617473177672, sha3(13847067169082572429, address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
                  call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                       gas gas_remaining wei
                      args block.timestamp
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  static call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getTwammReserves() with:
                          gas gas_remaining wei
              else:
                  if not address(cd[4]):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                  require ext_code.size(address(sha3(0, 4894420617473177672, sha3(address(cd[4]), 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
                  call address(sha3(0, 4894420617473177672, sha3(address(cd[4]), 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                       gas gas_remaining wei
                      args block.timestamp
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  static call address(sha3(0, 4894420617473177672, sha3(address(cd[4]), 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getTwammReserves() with:
                          gas gas_remaining wei
              require return_data.size >=′ 192
              require ext_call.return_data[0] == ext_call.return_data[18 len 14]
          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
      require swapETHForExactTokens(uint256 amountOut, address[] path, address to, uint256 deadline) == uint32(call.func_hash) >> 224
      require calldata.size - 4 >=′ 128
      require cd[36] <= LOCK8605463013()
      require cd[36] + 35 <′ calldata.size
      require ('cd', 36).length <= LOCK8605463013()
      require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
      require cd[68] == address(cd[68])
      if cd[100] < block.timestamp:
          revert with 0, 'FraxswapV1Router: EXPIRED'
      if 0 >= ('cd', 36).length:
          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
      require ('cd', 36)[0] == address(('cd', 36)[0])
      if address(('cd', 36)[0]) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
          revert with 0, 'FraxswapV1Router: INVALID_PATH'
      mem[128] = ('cd', 36).length
      mem[160 len 32 * ('cd', 36).length] = call.data[cd[36] + 36 len 32 * ('cd', 36).length]
      if ('cd', 36).length < 2:
          revert with 0, 'FraxswapRouterLibrary: INVALID_PATH'
      if ('cd', 36).length > LOCK8605463013():
          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
      mem[(32 * ('cd', 36).length) + 160] = ('cd', 36).length
      if not ('cd', 36).length:
          if ('cd', 36).length < 1:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if ('cd', 36).length - 1 >= ('cd', 36).length:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          mem[(32 * ('cd', 36).length - 1) + (32 * ('cd', 36).length) + 192] = cd[4]
          if ('cd', 36).length < 1:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if not ('cd', 36).length - 1:
              if 0 >= ('cd', 36).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              if mem[(32 * ('cd', 36).length) + 192] > call.value:
                  mem[(64 * ('cd', 36).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                  mem[(64 * ('cd', 36).length) + 196] = 32
                  mem[(64 * ('cd', 36).length) + 228] = 40
                  mem[(64 * ('cd', 36).length) + 260] = 'FraxswapV1Router: EXCESSIVE_INPU'
                  mem[(64 * ('cd', 36).length) + 292] = 'T_AMOUNT'
                  revert with memory
                    from (64 * ('cd', 36).length) + 192
                     len (127 * ('cd', 36).length) + 132
              if 0 >= ('cd', 36).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              _1225 = mem[(32 * ('cd', 36).length) + 192]
              mem[(64 * ('cd', 36).length) + 192] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
              require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
              call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
                 value _1225 wei
                   gas gas_remaining wei
                  args mem[(64 * ('cd', 36).length) + 196 len 127 * ('cd', 36).length]
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              if 0 >= ('cd', 36).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              require ('cd', 36)[0] == address(('cd', 36)[0])
              if 1 >= ('cd', 36).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
          if ('cd', 36).length - 1 < 1:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if ('cd', 36).length - 2 >= ('cd', 36).length:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          _1229 = mem[(32 * ('cd', 36).length - 2) + 160]
          if ('cd', 36).length - 1 >= ('cd', 36).length:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          _1376 = mem[(32 * ('cd', 36).length - 1) + 160]
          if not mem[(32 * ('cd', 36).length - 2) + 172 len 20] - mem[(32 * ('cd', 36).length - 1) + 172 len 20]:
              mem[(64 * ('cd', 36).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
              mem[(64 * ('cd', 36).length) + 196] = 32
              mem[(64 * ('cd', 36).length) + 228] = 42
              mem[(64 * ('cd', 36).length) + 260] = 'FraxswapRouterLibrary: IDENTICAL'
              mem[(64 * ('cd', 36).length) + 292] = '_ADDRESSES'
          else:
              if mem[(32 * ('cd', 36).length - 2) + 172 len 20] < mem[(32 * ('cd', 36).length - 1) + 172 len 20]:
                  if mem[(32 * ('cd', 36).length - 2) + 172 len 20]:
                      mem[(64 * ('cd', 36).length) + 224] = address(mem[(32 * ('cd', 36).length - 2) + 160])
                      mem[(64 * ('cd', 36).length) + 244] = address(_1376)
                      require ext_code.size(address(sha3(0, 4894420617473177672, sha3(mem[(64 * ('cd', 36).length) + 224 len (127 * ('cd', 36).length) + 40]), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
                      call address(sha3(0, 4894420617473177672, sha3(mem[(64 * ('cd', 36).length) + 224 len (127 * ('cd', 36).length) + 40]), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              else:
                  if mem[(32 * ('cd', 36).length - 1) + 172 len 20]:
                      mem[(64 * ('cd', 36).length) + 224] = address(mem[(32 * ('cd', 36).length - 1) + 160])
                      mem[(64 * ('cd', 36).length) + 244] = address(_1229)
                      require ext_code.size(address(sha3(0, 4894420617473177672, sha3(mem[(64 * ('cd', 36).length) + 224 len (127 * ('cd', 36).length) + 40]), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
                      call address(sha3(0, 4894420617473177672, sha3(mem[(64 * ('cd', 36).length) + 224 len (127 * ('cd', 36).length) + 40]), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                           gas gas_remaining wei
                          args block.timestamp
                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              mem[(64 * ('cd', 36).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
              mem[(64 * ('cd', 36).length) + 196] = 32
              mem[(64 * ('cd', 36).length) + 228] = 35
              mem[(64 * ('cd', 36).length) + 260] = 'FraxswapRouterLibrary: ZERO_ADDR'
              mem[(64 * ('cd', 36).length) + 292] = 'ESS'
      else:
          mem[(32 * ('cd', 36).length) + 192 len 32 * ('cd', 36).length] = call.data[calldata.size len 32 * ('cd', 36).length]
          if ('cd', 36).length < 1:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if ('cd', 36).length - 1 >= ('cd', 36).length:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          mem[(32 * ('cd', 36).length - 1) + (32 * ('cd', 36).length) + 192] = cd[4]
          if ('cd', 36).length < 1:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if not ('cd', 36).length - 1:
              if 0 >= ('cd', 36).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              if mem[(32 * ('cd', 36).length) + 192] > call.value:
                  mem[(64 * ('cd', 36).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                  mem[(64 * ('cd', 36).length) + 196] = 32
                  mem[(64 * ('cd', 36).length) + 228] = 40
                  mem[(64 * ('cd', 36).length) + 260] = 'FraxswapV1Router: EXCESSIVE_INPU'
                  mem[(64 * ('cd', 36).length) + 292] = 'T_AMOUNT'
                  revert with memory
                    from (64 * ('cd', 36).length) + 192
                     len (127 * ('cd', 36).length) + 132
              if 0 >= ('cd', 36).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              _1377 = mem[(32 * ('cd', 36).length) + 192]
              mem[(64 * ('cd', 36).length) + 192] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
              require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
              call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
                 value _1377 wei
                   gas gas_remaining wei
                  args mem[(64 * ('cd', 36).length) + 196 len 127 * ('cd', 36).length]
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              if 0 >= ('cd', 36).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              require ('cd', 36)[0] == address(('cd', 36)[0])
              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
          if ('cd', 36).length - 1 < 1:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if ('cd', 36).length - 2 >= ('cd', 36).length:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          _1381 = mem[(32 * ('cd', 36).length - 2) + 160]
          if ('cd', 36).length - 1 >= ('cd', 36).length:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          _1526 = mem[(32 * ('cd', 36).length - 1) + 160]
          if not mem[(32 * ('cd', 36).length - 2) + 172 len 20] - mem[(32 * ('cd', 36).length - 1) + 172 len 20]:
              mem[(64 * ('cd', 36).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
              mem[(64 * ('cd', 36).length) + 196] = 32
              mem[(64 * ('cd', 36).length) + 228] = 42
              mem[(64 * ('cd', 36).length) + 260] = 'FraxswapRouterLibrary: IDENTICAL'
              mem[(64 * ('cd', 36).length) + 292] = '_ADDRESSES'
          else:
              if mem[(32 * ('cd', 36).length - 2) + 172 len 20] < mem[(32 * ('cd', 36).length - 1) + 172 len 20]:
                  if mem[(32 * ('cd', 36).length - 2) + 172 len 20]:
                      mem[(64 * ('cd', 36).length) + 224] = address(mem[(32 * ('cd', 36).length - 2) + 160])
                      mem[(64 * ('cd', 36).length) + 244] = address(_1526)
                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              else:
                  if mem[(32 * ('cd', 36).length - 1) + 172 len 20]:
                      mem[(64 * ('cd', 36).length) + 224] = address(mem[(32 * ('cd', 36).length - 1) + 160])
                      mem[(64 * ('cd', 36).length) + 244] = address(_1381)
                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              mem[(64 * ('cd', 36).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
              mem[(64 * ('cd', 36).length) + 196] = 32
              mem[(64 * ('cd', 36).length) + 228] = 35
              mem[(64 * ('cd', 36).length) + 260] = 'FraxswapRouterLibrary: ZERO_ADDR'
              mem[(64 * ('cd', 36).length) + 292] = 'ESS'
      revert with memory
        from (64 * ('cd', 36).length) + 192
         len (127 * ('cd', 36).length) + 132
  if removeLiquidityETHSupportingFeeOnTransferTokens(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline) <= uint32(call.func_hash) >> 224:
      if removeLiquidityETHSupportingFeeOnTransferTokens(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline) == uint32(call.func_hash) >> 224:
          require not call.value
          require calldata.size - 4 >=′ 192
          require cd[4] == address(cd[4])
          require cd[132] == address(cd[132])
          if cd[164] < block.timestamp:
              revert with 0, 'FraxswapV1Router: EXPIRED'
          if not address(cd[4]) - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
              revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
          if address(cd[4]) >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
              call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).transferFrom(address sender, address recipient, uint256 amount) with:
                   gas gas_remaining wei
                  args caller, address(sha3(0, 4894420617473177672, sha3(13847067169082572429, address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)), cd[36]
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 32
              require ext_call.return_data[0] == bool(ext_call.return_data[0])
              call address(sha3(0, 4894420617473177672, sha3(13847067169082572429, address(cd[4])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).burn(address to) with:
                   gas gas_remaining wei
                  args this.address
          else:
              if not address(cd[4]):
                  revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              call address(sha3(0, 4894420617473177672, sha3(address(cd[4]), 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).transferFrom(address sender, address recipient, uint256 amount) with:
                   gas gas_remaining wei
                  args caller, address(sha3(0, 4894420617473177672, sha3(address(cd[4]), 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)), cd[36]
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 32
              require ext_call.return_data[0] == bool(ext_call.return_data[0])
              call address(sha3(0, 4894420617473177672, sha3(address(cd[4]), 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).burn(address to) with:
                   gas gas_remaining wei
                  args this.address
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          require return_data.size >=′ 64
          if not address(cd[4]) - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
              revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
          if address(cd[4]) >= 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
              if address(cd[4]) == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                  if ext_call.return_data[0] < cd[68]:
                      revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
                  if ext_call.return_data[32] < cd[100]:
                      revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
              else:
                  if ext_call.return_data[32] < cd[68]:
                      revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
                  if ext_call.return_data[0] < cd[100]:
                      revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
          else:
              if not address(cd[4]):
                  revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
              if address(cd[4]) == address(cd[4]):
                  if ext_call.return_data[0] < cd[68]:
                      revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
                  if ext_call.return_data[32] < cd[100]:
                      revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
              else:
                  if ext_call.return_data[32] < cd[68]:
                      revert with 0, 'FraxswapV1Router: INSUFFICIENT_A_AMOUNT'
                  if ext_call.return_data[0] < cd[100]:
                      revert with 0, 'FraxswapV1Router: INSUFFICIENT_B_AMOUNT'
          static call address(cd[4]).balanceOf(address account) with:
                  gas gas_remaining wei
                 args this.address
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          require return_data.size >=′ 32
      else:
          if getAmountsInWithTwamm(uint256 amountOut, address[] path) == uint32(call.func_hash) >> 224:
              require not call.value
              require calldata.size - 4 >=′ 64
              require cd[36] <= LOCK8605463013()
              require cd[36] + 35 <′ calldata.size
              if ('cd', 36).length > LOCK8605463013():
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              if ceil32(32 * ('cd', 36).length) + 129 > LOCK8605463013() or ceil32(32 * ('cd', 36).length) + 129 < 128:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              require (32 * ('cd', 36).length) + cd[36] + 36 <= calldata.size
          else:
              require swapExactETHForTokensSupportingFeeOnTransferTokens(uint256 amountOutMin, address[] path, address to, uint256 deadline) == uint32(call.func_hash) >> 224
              require calldata.size - 4 >=′ 128
              require cd[36] <= LOCK8605463013()
              require cd[36] + 35 <′ calldata.size
              require ('cd', 36).length <= LOCK8605463013()
              require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
              require cd[68] == address(cd[68])
              if cd[100] < block.timestamp:
                  revert with 0, 'FraxswapV1Router: EXPIRED'
              if 0 >= ('cd', 36).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              require ('cd', 36)[0] == address(('cd', 36)[0])
              if address(('cd', 36)[0]) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                  revert with 0, 'FraxswapV1Router: INVALID_PATH'
              require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
              call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
                 value call.value wei
                   gas gas_remaining wei
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              if 0 >= ('cd', 36).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              require ('cd', 36)[0] == address(('cd', 36)[0])
              if 1 >= ('cd', 36).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              require ('cd', 36)[1] == address(('cd', 36)[1])
              if not address(('cd', 36)[0]) - address(('cd', 36)[1]):
                  revert with 0, 'FraxswapRouterLibrary: IDENTICAL_ADDRESSES'
              if address(('cd', 36)[0]) < address(('cd', 36)[1]):
                  if not address(('cd', 36)[0]):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transfer(address recipient, uint256 amount) with:
                       gas gas_remaining wei
                      args address(sha3(0, 4894420617473177672, sha3(address(('cd', 36)[0]), address(('cd', 36)[1])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)), call.value
              else:
                  if not address(('cd', 36)[1]):
                      revert with 0, 'FraxswapRouterLibrary: ZERO_ADDRESS'
                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transfer(address recipient, uint256 amount) with:
                       gas gas_remaining wei
                      args address(sha3(0, 4894420617473177672, sha3(address(('cd', 36)[1]), address(('cd', 36)[0])), 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)), call.value
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 32
  else:
      if uint32(call.func_hash) >> 224 != swapTokensForExactTokens(uint256 amountOut, uint256 amountInMax, address[] path, address to, uint256 deadline):
          if WETH() == uint32(call.func_hash) >> 224:
              require not call.value
              return 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
          require quote(uint256 amountA, uint256 reserveA, uint256 reserveB) == uint32(call.func_hash) >> 224
          require not call.value
          require calldata.size - 4 >=′ 96
          if cd[4] <= 0:
              revert with 0, 'FraxswapRouterLibrary: INSUFFICIENT_AMOUNT'
          if cd[36] <= 0:
              revert with 0, 'FraxswapRouterLibrary: INSUFFICIENT_LIQUIDITY'
          if cd[68] <= 0:
              revert with 0, 'FraxswapRouterLibrary: INSUFFICIENT_LIQUIDITY'
          if cd[4] and cd[68] > -1 / cd[4]:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if not cd[36]:
              revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
          return (cd[4] * cd[68] / cd[36])
      require not call.value
      require calldata.size - 4 >=′ 160
      require cd[68] <= LOCK8605463013()
      require cd[68] + 35 <′ calldata.size
      require ('cd', 68).length <= LOCK8605463013()
      require cd[68] + (32 * ('cd', 68).length) + 36 <= calldata.size
      require cd[100] == address(cd[100])
      if cd[132] < block.timestamp:
          revert with 0, 'FraxswapV1Router: EXPIRED'
      mem[128] = ('cd', 68).length
      mem[160 len 32 * ('cd', 68).length] = call.data[cd[68] + 36 len 32 * ('cd', 68).length]
      if ('cd', 68).length < 2:
          revert with 0, 'FraxswapRouterLibrary: INVALID_PATH'
      if ('cd', 68).length > LOCK8605463013():
          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
      mem[(32 * ('cd', 68).length) + 160] = ('cd', 68).length
      if not ('cd', 68).length:
          if ('cd', 68).length < 1:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if ('cd', 68).length - 1 >= ('cd', 68).length:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          mem[(32 * ('cd', 68).length - 1) + (32 * ('cd', 68).length) + 192] = cd[4]
          if ('cd', 68).length < 1:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if not ('cd', 68).length - 1:
              if 0 >= ('cd', 68).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              if mem[(32 * ('cd', 68).length) + 192] > cd[36]:
                  mem[(64 * ('cd', 68).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                  mem[(64 * ('cd', 68).length) + 196] = 32
                  mem[(64 * ('cd', 68).length) + 228] = 40
                  mem[(64 * ('cd', 68).length) + 260] = 'FraxswapV1Router: EXCESSIVE_INPU'
                  mem[(64 * ('cd', 68).length) + 292] = 'T_AMOUNT'
                  revert with memory
                    from (64 * ('cd', 68).length) + 192
                     len (127 * ('cd', 68).length) + 132
              if 0 >= ('cd', 68).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              require ('cd', 68)[0] == address(('cd', 68)[0])
              if 0 >= ('cd', 68).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              require ('cd', 68)[0] == address(('cd', 68)[0])
              if 1 >= ('cd', 68).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              require ('cd', 68)[1] == address(('cd', 68)[1])
          else:
              if ('cd', 68).length - 1 < 1:
                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
              if ('cd', 68).length - 2 >= ('cd', 68).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              _453 = mem[(32 * ('cd', 68).length - 2) + 160]
              if ('cd', 68).length - 1 >= ('cd', 68).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              _488 = mem[(32 * ('cd', 68).length - 1) + 160]
              if not mem[(32 * ('cd', 68).length - 2) + 172 len 20] - mem[(32 * ('cd', 68).length - 1) + 172 len 20]:
                  mem[(64 * ('cd', 68).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                  mem[(64 * ('cd', 68).length) + 196] = 32
                  mem[(64 * ('cd', 68).length) + 228] = 42
                  mem[(64 * ('cd', 68).length) + 260] = 'FraxswapRouterLibrary: IDENTICAL'
                  mem[(64 * ('cd', 68).length) + 292] = '_ADDRESSES'
                  revert with memory
                    from (64 * ('cd', 68).length) + 192
                     len (127 * ('cd', 68).length) + 132
              if mem[(32 * ('cd', 68).length - 2) + 172 len 20] < mem[(32 * ('cd', 68).length - 1) + 172 len 20]:
                  if not mem[(32 * ('cd', 68).length - 2) + 172 len 20]:
                      mem[(64 * ('cd', 68).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(64 * ('cd', 68).length) + 196] = 32
                      mem[(64 * ('cd', 68).length) + 228] = 35
                      mem[(64 * ('cd', 68).length) + 260] = 'FraxswapRouterLibrary: ZERO_ADDR'
                      mem[(64 * ('cd', 68).length) + 292] = 'ESS'
                      revert with memory
                        from (64 * ('cd', 68).length) + 192
                         len (127 * ('cd', 68).length) + 132
                  mem[(64 * ('cd', 68).length) + 224] = address(mem[(32 * ('cd', 68).length - 2) + 160])
                  mem[(64 * ('cd', 68).length) + 244] = address(_488)
                  mem[(64 * ('cd', 68).length) + 192] = (127 * ('cd', 68).length) + 40
                  _934 = sha3(mem[(64 * ('cd', 68).length) + 224 len (127 * ('cd', 68).length) + 40])
                  mem[(64 * ('cd', 68).length) + 296] = 0xff00000000000000000000000000000000000000000000000000000000000000
                  mem[(64 * ('cd', 68).length) + 297] = 0x43ec799eadd63848443e2347c49f5f52e8fe0f6f000000000000000000000000
                  mem[(64 * ('cd', 68).length) + 317] = _934
                  mem[(64 * ('cd', 68).length) + 349] = 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3
                  mem[(64 * ('cd', 68).length) + 264] = 85
                  mem[(64 * ('cd', 68).length) + 381] = 0x2e0ae37500000000000000000000000000000000000000000000000000000000
                  mem[(64 * ('cd', 68).length) + 385] = block.timestamp
                  require ext_code.size(address(sha3(0, 4894420617473177672, _934, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
                  call address(sha3(0, 4894420617473177672, _934, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                       gas gas_remaining wei
                      args block.timestamp
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if ('cd', 68).length - 1 >= ('cd', 68).length:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  if ('cd', 68).length - 1 < 1:
                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                  if ('cd', 68).length - 2 >= ('cd', 68).length:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  static call address(sha3(0, 4894420617473177672, _934, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getAmountIn(uint256 amountOut, address tokenOut) with:
                          gas gas_remaining wei
                         args cd[4], mem[(32 * ('cd', 68).length - 2) + 172 len 20]
              else:
                  if not mem[(32 * ('cd', 68).length - 1) + 172 len 20]:
                      mem[(64 * ('cd', 68).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(64 * ('cd', 68).length) + 196] = 32
                      mem[(64 * ('cd', 68).length) + 228] = 35
                      mem[(64 * ('cd', 68).length) + 260] = 'FraxswapRouterLibrary: ZERO_ADDR'
                      mem[(64 * ('cd', 68).length) + 292] = 'ESS'
                      revert with memory
                        from (64 * ('cd', 68).length) + 192
                         len (127 * ('cd', 68).length) + 132
                  mem[(64 * ('cd', 68).length) + 224] = address(mem[(32 * ('cd', 68).length - 1) + 160])
                  mem[(64 * ('cd', 68).length) + 244] = address(_453)
                  mem[(64 * ('cd', 68).length) + 192] = (127 * ('cd', 68).length) + 40
                  _940 = sha3(mem[(64 * ('cd', 68).length) + 224 len (127 * ('cd', 68).length) + 40])
                  mem[(64 * ('cd', 68).length) + 296] = 0xff00000000000000000000000000000000000000000000000000000000000000
                  mem[(64 * ('cd', 68).length) + 297] = 0x43ec799eadd63848443e2347c49f5f52e8fe0f6f000000000000000000000000
                  mem[(64 * ('cd', 68).length) + 317] = _940
                  mem[(64 * ('cd', 68).length) + 349] = 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3
                  mem[(64 * ('cd', 68).length) + 264] = 85
                  mem[(64 * ('cd', 68).length) + 381] = 0x2e0ae37500000000000000000000000000000000000000000000000000000000
                  mem[(64 * ('cd', 68).length) + 385] = block.timestamp
                  require ext_code.size(address(sha3(0, 4894420617473177672, _940, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
                  call address(sha3(0, 4894420617473177672, _940, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                       gas gas_remaining wei
                      args block.timestamp
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if ('cd', 68).length - 1 >= ('cd', 68).length:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  if ('cd', 68).length - 1 < 1:
                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                  if ('cd', 68).length - 2 >= ('cd', 68).length:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  static call address(sha3(0, 4894420617473177672, _940, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getAmountIn(uint256 amountOut, address tokenOut) with:
                          gas gas_remaining wei
                         args cd[4], mem[(32 * ('cd', 68).length - 2) + 172 len 20]
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 32
      else:
          mem[(32 * ('cd', 68).length) + 192 len 32 * ('cd', 68).length] = call.data[calldata.size len 32 * ('cd', 68).length]
          if ('cd', 68).length < 1:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if ('cd', 68).length - 1 >= ('cd', 68).length:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          mem[(32 * ('cd', 68).length - 1) + (32 * ('cd', 68).length) + 192] = cd[4]
          if ('cd', 68).length < 1:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if not ('cd', 68).length - 1:
              if 0 >= ('cd', 68).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              if mem[(32 * ('cd', 68).length) + 192] > cd[36]:
                  mem[(64 * ('cd', 68).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                  mem[(64 * ('cd', 68).length) + 196] = 32
                  mem[(64 * ('cd', 68).length) + 228] = 40
                  mem[(64 * ('cd', 68).length) + 260] = 'FraxswapV1Router: EXCESSIVE_INPU'
                  mem[(64 * ('cd', 68).length) + 292] = 'T_AMOUNT'
                  revert with memory
                    from (64 * ('cd', 68).length) + 192
                     len (127 * ('cd', 68).length) + 132
              if 0 >= ('cd', 68).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              require ('cd', 68)[0] == address(('cd', 68)[0])
              if 0 >= ('cd', 68).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              require ('cd', 68)[0] == address(('cd', 68)[0])
              if 1 >= ('cd', 68).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              require ('cd', 68)[1] == address(('cd', 68)[1])
          else:
              if ('cd', 68).length - 1 < 1:
                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
              if ('cd', 68).length - 2 >= ('cd', 68).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              _490 = mem[(32 * ('cd', 68).length - 2) + 160]
              if ('cd', 68).length - 1 >= ('cd', 68).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              _534 = mem[(32 * ('cd', 68).length - 1) + 160]
              if not mem[(32 * ('cd', 68).length - 2) + 172 len 20] - mem[(32 * ('cd', 68).length - 1) + 172 len 20]:
                  mem[(64 * ('cd', 68).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                  mem[(64 * ('cd', 68).length) + 196] = 32
                  mem[(64 * ('cd', 68).length) + 228] = 42
                  mem[(64 * ('cd', 68).length) + 260] = 'FraxswapRouterLibrary: IDENTICAL'
                  mem[(64 * ('cd', 68).length) + 292] = '_ADDRESSES'
                  revert with memory
                    from (64 * ('cd', 68).length) + 192
                     len (127 * ('cd', 68).length) + 132
              if mem[(32 * ('cd', 68).length - 2) + 172 len 20] < mem[(32 * ('cd', 68).length - 1) + 172 len 20]:
                  if not mem[(32 * ('cd', 68).length - 2) + 172 len 20]:
                      mem[(64 * ('cd', 68).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(64 * ('cd', 68).length) + 196] = 32
                      mem[(64 * ('cd', 68).length) + 228] = 35
                      mem[(64 * ('cd', 68).length) + 260] = 'FraxswapRouterLibrary: ZERO_ADDR'
                      mem[(64 * ('cd', 68).length) + 292] = 'ESS'
                      revert with memory
                        from (64 * ('cd', 68).length) + 192
                         len (127 * ('cd', 68).length) + 132
                  mem[(64 * ('cd', 68).length) + 224] = address(mem[(32 * ('cd', 68).length - 2) + 160])
                  mem[(64 * ('cd', 68).length) + 244] = address(_534)
                  mem[(64 * ('cd', 68).length) + 192] = (127 * ('cd', 68).length) + 40
                  _1033 = sha3(mem[(64 * ('cd', 68).length) + 224 len (127 * ('cd', 68).length) + 40])
                  mem[(64 * ('cd', 68).length) + 296] = 0xff00000000000000000000000000000000000000000000000000000000000000
                  mem[(64 * ('cd', 68).length) + 297] = 0x43ec799eadd63848443e2347c49f5f52e8fe0f6f000000000000000000000000
                  mem[(64 * ('cd', 68).length) + 317] = _1033
                  mem[(64 * ('cd', 68).length) + 349] = 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3
                  mem[(64 * ('cd', 68).length) + 264] = 85
                  mem[(64 * ('cd', 68).length) + 381] = 0x2e0ae37500000000000000000000000000000000000000000000000000000000
                  mem[(64 * ('cd', 68).length) + 385] = block.timestamp
                  require ext_code.size(address(sha3(0, 4894420617473177672, _1033, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
                  call address(sha3(0, 4894420617473177672, _1033, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                       gas gas_remaining wei
                      args block.timestamp
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if ('cd', 68).length - 1 >= ('cd', 68).length:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  if ('cd', 68).length - 1 < 1:
                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                  if ('cd', 68).length - 2 >= ('cd', 68).length:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  static call address(sha3(0, 4894420617473177672, _1033, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getAmountIn(uint256 amountOut, address tokenOut) with:
                          gas gas_remaining wei
                         args cd[4], mem[(32 * ('cd', 68).length - 2) + 172 len 20]
              else:
                  if not mem[(32 * ('cd', 68).length - 1) + 172 len 20]:
                      mem[(64 * ('cd', 68).length) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                      mem[(64 * ('cd', 68).length) + 196] = 32
                      mem[(64 * ('cd', 68).length) + 228] = 35
                      mem[(64 * ('cd', 68).length) + 260] = 'FraxswapRouterLibrary: ZERO_ADDR'
                      mem[(64 * ('cd', 68).length) + 292] = 'ESS'
                      revert with memory
                        from (64 * ('cd', 68).length) + 192
                         len (127 * ('cd', 68).length) + 132
                  mem[(64 * ('cd', 68).length) + 224] = address(mem[(32 * ('cd', 68).length - 1) + 160])
                  mem[(64 * ('cd', 68).length) + 244] = address(_490)
                  mem[(64 * ('cd', 68).length) + 192] = (127 * ('cd', 68).length) + 40
                  _1039 = sha3(mem[(64 * ('cd', 68).length) + 224 len (127 * ('cd', 68).length) + 40])
                  mem[(64 * ('cd', 68).length) + 296] = 0xff00000000000000000000000000000000000000000000000000000000000000
                  mem[(64 * ('cd', 68).length) + 297] = 0x43ec799eadd63848443e2347c49f5f52e8fe0f6f000000000000000000000000
                  mem[(64 * ('cd', 68).length) + 317] = _1039
                  mem[(64 * ('cd', 68).length) + 349] = 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3
                  mem[(64 * ('cd', 68).length) + 264] = 85
                  mem[(64 * ('cd', 68).length) + 381] = 0x2e0ae37500000000000000000000000000000000000000000000000000000000
                  mem[(64 * ('cd', 68).length) + 385] = block.timestamp
                  require ext_code.size(address(sha3(0, 4894420617473177672, _1039, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)))
                  call address(sha3(0, 4894420617473177672, _1039, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).executeVirtualOrders(uint256 blockTimestamp) with:
                       gas gas_remaining wei
                      args block.timestamp
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if ('cd', 68).length - 1 >= ('cd', 68).length:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  if ('cd', 68).length - 1 < 1:
                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                  if ('cd', 68).length - 2 >= ('cd', 68).length:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  static call address(sha3(0, 4894420617473177672, _1039, 0x4ce0b4ab368f39e4bd03ec712dfc405eb5a36cdb0294b3887b441cd1c743ced3)).getAmountIn(uint256 amountOut, address tokenOut) with:
                          gas gas_remaining wei
                         args cd[4], mem[(32 * ('cd', 68).length - 2) + 172 len 20]
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)


