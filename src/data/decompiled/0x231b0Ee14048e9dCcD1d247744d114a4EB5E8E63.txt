# Palkeoramix decompiler. 

def storage:
  recordVersions is mapping of uint64 at storage 0
  stor1 is mapping of struct at storage 1
  stor2 is mapping of struct at storage 2
  stor3 is mapping of struct at storage 3
  stor4 is mapping of struct at storage 4
  stor5 is mapping of struct at storage 5
  stor6 is mapping of uint16 at storage 6
  stor7 is mapping of address at storage 7
  stor8 is mapping of struct at storage 8
  pubkey is mapping of struct at storage 9
  stor10 is mapping of struct at storage 10
  stor11 is mapping of uint8 at storage 11
  stor12 is mapping of uint8 at storage 12

def hasDNSRecords(bytes32 node, bytes32 name) payable: 
  require calldata.size - 4 >=′ 64
  return bool(stor6[stor0[node]][node][name])

def isApprovedFor(address _param1, bytes32 _param2, address _param3) payable: 
  require calldata.size - 4 >=′ 96
  require _param1 == _param1
  require _param3 == _param3
  return bool(stor12[address(_param1)][_param2][address(_param3)])

def pubkey(bytes32 node) payable: 
  require calldata.size - 4 >=′ 32
  return pubkey[stor0[node]][node].field_0, pubkey[stor0[node]][node].field_256

def recordVersions(bytes32 _param1) payable: 
  require calldata.size - 4 >=′ 32
  return recordVersions[_param1]

def isApprovedForAll(address owner, address operator) payable: 
  require calldata.size - 4 >=′ 64
  require owner == owner
  require operator == operator
  return bool(stor11[address(owner)][address(operator)])

#
#  Regular functions
#

def _fallback(?) payable: # default function
  revert

def approve(bytes32 _param1, address _param2, bool _param3) payable: 
  require calldata.size - 4 >=′ 96
  require _param2 == _param2
  require _param3 == _param3
  if not caller - _param2:
      revert with 0, 'Setting delegate status for self'
  stor12[caller][_param1][address(_param2)] = uint8(_param3)
  log 0xf0ddb3b0: caller, _param1, _param2, _param3

def setApprovalForAll(address operator, bool approved) payable: 
  require calldata.size - 4 >=′ 64
  require operator == operator
  require approved == approved
  if not caller - operator:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC1155: setting approval status for self'
  stor11[caller][address(operator)] = uint8(approved)
  log ApprovalForAll(
        address owner=approved,
        address operator=caller,
        bool approved=operator)

def clearRecords(bytes32 node) payable: 
  require calldata.size - 4 >=′ 32
  if caller != 0x253553366da8546fc250f225fe3d25d0c782303b:
      if caller != 0xa58e81fe9b61b5c3fe2afd33cf304c454abfc7cb:
          static call 0xc2e074ec69a0dfb2997ba6c7d2e1e.owner(bytes32 node) with:
                  gas gas_remaining wei
                 args node
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          require return_data.size >=′ 32
          require ext_call.return_data[0] == ext_call.return_data[12 len 20]
          if not ext_call.return_data[12 len 20] - 0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401:
              static call 0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401.ownerOf(uint256 tokenId) with:
                      gas gas_remaining wei
                     args node
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 32
              require ext_call.return_data[0] == ext_call.return_data[12 len 20]
          if ext_call.return_data[12 len 20] != caller:
              if not stor11[ext_call.return_data[12 len 20]][caller]:
                  require stor12[address(ext_call.return_data[0])][node][caller]
  if not recordVersions[node] - LOCK8605463013():
      revert with 0, 17
  recordVersions[node] = uint64(recordVersions[node] + 1)
  log VersionChanged(
        bytes32 node=recordVersions[node],
        uint64 newVersion=node)

def supportsInterface(bytes4 interfaceId) payable: 
  require calldata.size - 4 >=′ 32
  require interfaceId == Mask(32, 224, interfaceId)
  if 0x59d1d43c00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, interfaceId):
      return True
  if 0xc869023300000000000000000000000000000000000000000000000000000000 == Mask(32, 224, interfaceId):
      return True
  if 0x691f343100000000000000000000000000000000000000000000000000000000 == Mask(32, 224, interfaceId):
      return True
  if 0x124a319c00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, interfaceId):
      return True
  if 0xa8fa568200000000000000000000000000000000000000000000000000000000 == Mask(32, 224, interfaceId):
      return True
  if 0x5c98042b00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, interfaceId):
      return True
  if 0xbc1c58d100000000000000000000000000000000000000000000000000000000 == Mask(32, 224, interfaceId):
      return True
  if 0x3b3b57de00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, interfaceId):
      return True
  if 0xf1cb7e0600000000000000000000000000000000000000000000000000000000 == Mask(32, 224, interfaceId):
      return True
  if 0x2203ab5600000000000000000000000000000000000000000000000000000000 == Mask(32, 224, interfaceId):
      return True
  if 0xd700ff3300000000000000000000000000000000000000000000000000000000 == Mask(32, 224, interfaceId):
      return True
  if 0x4fbf043300000000000000000000000000000000000000000000000000000000 == Mask(32, 224, interfaceId):
      return True
  return (Mask(32, 224, interfaceId) == 0x1ffc9a700000000000000000000000000000000000000000000000000000000)

def setPubkey(bytes32 node, bytes32 x, bytes32 y) payable: 
  require calldata.size - 4 >=′ 96
  if caller != 0x253553366da8546fc250f225fe3d25d0c782303b:
      if caller != 0xa58e81fe9b61b5c3fe2afd33cf304c454abfc7cb:
          static call 0xc2e074ec69a0dfb2997ba6c7d2e1e.owner(bytes32 node) with:
                  gas gas_remaining wei
                 args node
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          require return_data.size >=′ 32
          require ext_call.return_data[0] == ext_call.return_data[12 len 20]
          if not ext_call.return_data[12 len 20] - 0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401:
              static call 0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401.ownerOf(uint256 tokenId) with:
                      gas gas_remaining wei
                     args node
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 32
              require ext_call.return_data[0] == ext_call.return_data[12 len 20]
          if ext_call.return_data[12 len 20] != caller:
              if not stor11[ext_call.return_data[12 len 20]][caller]:
                  require stor12[address(ext_call.return_data[0])][node][caller]
  pubkey[stor0[node]][node].field_0 = x
  pubkey[stor0[node]][node].field_256 = y
  log PubkeyChanged(
        bytes32 node=x,
        bytes32 x=y,
        bytes32 y=node)

def setInterface(bytes32 node, bytes4 interfaceID, address implementer) payable: 
  require calldata.size - 4 >=′ 96
  require interfaceID == Mask(32, 224, interfaceID)
  require implementer == implementer
  if caller != 0x253553366da8546fc250f225fe3d25d0c782303b:
      if caller != 0xa58e81fe9b61b5c3fe2afd33cf304c454abfc7cb:
          static call 0xc2e074ec69a0dfb2997ba6c7d2e1e.owner(bytes32 node) with:
                  gas gas_remaining wei
                 args node
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          require return_data.size >=′ 32
          require ext_call.return_data[0] == ext_call.return_data[12 len 20]
          if not ext_call.return_data[12 len 20] - 0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401:
              static call 0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401.ownerOf(uint256 tokenId) with:
                      gas gas_remaining wei
                     args node
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 32
              require ext_call.return_data[0] == ext_call.return_data[12 len 20]
          if ext_call.return_data[12 len 20] != caller:
              if not stor11[ext_call.return_data[12 len 20]][caller]:
                  require stor12[address(ext_call.return_data[0])][node][caller]
  stor7[stor0[node]][node][Mask(32, 224, interfaceID)] = implementer
  log InterfaceChanged(
        bytes32 node=implementer,
        bytes4 interfaceID=node,
        address implementer=Mask(32, 224, interfaceID))

def multicall(bytes[] data) payable: 
  require calldata.size - 4 >=′ 32
  require data <= LOCK8605463013()
  require data + 35 <′ calldata.size
  require data.length <= LOCK8605463013()
  require data + (32 * data.length) + 36 <= calldata.size
  if data.length > LOCK8605463013():
      revert with 0, 65
  mem[96] = data.length
  mem[64] = (32 * data.length) + 128
  if not data.length:
      idx = 0
      while idx < data.length:
          if idx >= data.length:
              revert with 0, 50
          require cd[(data + (32 * idx) + 36)] <′ calldata.size + -data - 67
          require cd[(data + cd[(data + (32 * idx) + 36)] + 36)] <= LOCK8605463013()
          require data + cd[(data + (32 * idx) + 36)] + 68 <=′ calldata.size - cd[(data + cd[(data + (32 * idx) + 36)] + 36)]
          mem[mem[64] len cd[(data + cd[(data + (32 * idx) + 36)] + 36)]] = call.data[data + cd[(data + (32 * idx) + 36)] + 68 len cd[(data + cd[(data + (32 * idx) + 36)] + 36)]]
          mem[cd[(data + cd[(data + (32 * idx) + 36)] + 36)] + mem[64]] = 0
          delegate this.address with:
               gas gas_remaining wei
              args call.data[data + cd[(data + (32 * idx) + 36)] + 68 len cd[(data + cd[(data + (32 * idx) + 36)] + 36)]]
          if not return_data.size:
              require delegate.return_code
              if idx >= mem[96]:
                  revert with 0, 50
              mem[(32 * idx) + 128] = 96
          else:
              _37 = mem[64]
              mem[64] = mem[64] + ceil32(return_data.size) + 1
              mem[_37] = return_data.size
              mem[_37 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
              require delegate.return_code
              if idx >= mem[96]:
                  revert with 0, 50
              mem[(32 * idx) + 128] = _37
          if not idx + 1:
              revert with 0, 17
          idx = idx + 1
          continue 
      _24 = mem[64]
      mem[mem[64]] = 32
      _25 = mem[96]
      mem[mem[64] + 32] = mem[96]
      idx = 0
      s = 128
      t = mem[64] + 64
      u = mem[64] + (32 * mem[96]) + 64
      while idx < _25:
          mem[t] = u + -_24 - 64
          _46 = mem[s]
          _48 = mem[mem[s]]
          mem[u] = mem[mem[s]]
          v = 0
          while v < _48:
              mem[v + u + 32] = mem[v + _46 + 32]
              v = v + 32
              continue 
          mem[_48 + u + 32] = 0
          idx = idx + 1
          s = s + 32
          t = t + 32
          u = ceil32(_48) + u + 32
          continue 
  else:
      mem[128] = 96
      s = 128
      idx = data.length
      while idx - 1:
          mem[s + 32] = 96
          s = s + 32
          idx = idx - 1
          continue 
      idx = 0
      while idx < data.length:
          if idx >= data.length:
              revert with 0, 50
          require cd[(data + (32 * idx) + 36)] <′ calldata.size + -data - 67
          require cd[(data + cd[(data + (32 * idx) + 36)] + 36)] <= LOCK8605463013()
          require data + cd[(data + (32 * idx) + 36)] + 68 <=′ calldata.size - cd[(data + cd[(data + (32 * idx) + 36)] + 36)]
          _55 = mem[64]
          mem[mem[64] len cd[(data + cd[(data + (32 * idx) + 36)] + 36)]] = call.data[data + cd[(data + (32 * idx) + 36)] + 68 len cd[(data + cd[(data + (32 * idx) + 36)] + 36)]]
          mem[cd[(data + cd[(data + (32 * idx) + 36)] + 36)] + mem[64]] = 0
          delegate this.address.mem[mem[64] len 4] with:
               gas gas_remaining wei
              args mem[mem[64] + 4 len cd[(data + cd[(data + (32 * idx) + 36)] + 36)] + _55 + -mem[64] - 4]
          if not return_data.size:
              require delegate.return_code
              if idx >= mem[96]:
                  revert with 0, 50
              mem[(32 * idx) + 128] = 96
          else:
              _58 = mem[64]
              mem[64] = mem[64] + ceil32(return_data.size) + 1
              mem[_58] = return_data.size
              mem[_58 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
              require delegate.return_code
              if idx >= mem[96]:
                  revert with 0, 50
              mem[(32 * idx) + 128] = _58
          if not idx + 1:
              revert with 0, 17
          idx = idx + 1
          continue 
      _49 = mem[64]
      mem[mem[64]] = 32
      _50 = mem[96]
      mem[mem[64] + 32] = mem[96]
      idx = 0
      s = 128
      t = mem[64] + 64
      u = mem[64] + (32 * mem[96]) + 64
      while idx < _50:
          mem[t] = u + -_49 - 64
          _62 = mem[s]
          _64 = mem[mem[s]]
          mem[u] = mem[mem[s]]
          v = 0
          while v < _64:
              mem[v + u + 32] = mem[v + _62 + 32]
              v = v + 32
              continue 
          mem[_64 + u + 32] = 0
          idx = idx + 1
          s = s + 32
          t = t + 32
          u = ceil32(_64) + u + 32
          continue 
  return memory
    from mem[64]
     len u - mem[64]

def setAddr(bytes32 node, address a) payable: 
  require calldata.size - 4 >=′ 64
  require a == a
  if 0x253553366da8546fc250f225fe3d25d0c782303b == caller:
      if caller != 0x253553366da8546fc250f225fe3d25d0c782303b:
          if caller != 0xa58e81fe9b61b5c3fe2afd33cf304c454abfc7cb:
              static call 0xc2e074ec69a0dfb2997ba6c7d2e1e.owner(bytes32 node) with:
                      gas gas_remaining wei
                     args node
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 32
              require ext_call.return_data[0] == ext_call.return_data[12 len 20]
              if not ext_call.return_data[12 len 20] - 0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401:
                  static call 0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401.ownerOf(uint256 tokenId) with:
                          gas gas_remaining wei
                         args node
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >=′ 32
                  require ext_call.return_data[0] == ext_call.return_data[12 len 20]
              if ext_call.return_data[12 len 20] != caller:
                  if not stor11[ext_call.return_data[12 len 20]][caller]:
                      require stor12[address(ext_call.return_data[0])][node][caller]
  else:
      if 0xa58e81fe9b61b5c3fe2afd33cf304c454abfc7cb == caller:
          if caller != 0x253553366da8546fc250f225fe3d25d0c782303b:
              if caller != 0xa58e81fe9b61b5c3fe2afd33cf304c454abfc7cb:
                  static call 0xc2e074ec69a0dfb2997ba6c7d2e1e.owner(bytes32 node) with:
                          gas gas_remaining wei
                         args node
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >=′ 32
                  require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                  if not ext_call.return_data[12 len 20] - 0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401:
                      static call 0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401.ownerOf(uint256 tokenId) with:
                              gas gas_remaining wei
                             args node
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                  if ext_call.return_data[12 len 20] != caller:
                      if not stor11[ext_call.return_data[12 len 20]][caller]:
                          require stor12[address(ext_call.return_data[0])][node][caller]
      else:
          static call 0xc2e074ec69a0dfb2997ba6c7d2e1e.owner(bytes32 node) with:
                  gas gas_remaining wei
                 args node
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          require return_data.size >=′ 32
          require ext_call.return_data[0] == ext_call.return_data[12 len 20]
          if ext_call.return_data[12 len 20] - 0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401:
              if ext_call.return_data[12 len 20] != caller:
                  if not stor11[ext_call.return_data[12 len 20]][caller]:
                      require stor12[address(ext_call.return_data[0])][node][caller]
              if caller != 0x253553366da8546fc250f225fe3d25d0c782303b:
                  if caller != 0xa58e81fe9b61b5c3fe2afd33cf304c454abfc7cb:
                      mem[ceil32(return_data.size) + 164] = node
                      static call 0xc2e074ec69a0dfb2997ba6c7d2e1e.owner(bytes32 node) with:
                              gas gas_remaining wei
                             args node
                      mem[ceil32(return_data.size) + 160] = ext_call.return_data[0]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                      if not ext_call.return_data[12 len 20] - 0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401:
                          mem[(2 * ceil32(return_data.size)) + 164] = node
                          static call 0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401.ownerOf(uint256 tokenId) with:
                                  gas gas_remaining wei
                                 args mem[(2 * ceil32(return_data.size)) + 164 len ceil32(return_data.size) + 32]
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          require return_data.size >=′ 32
                          require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                      if ext_call.return_data[12 len 20] != caller:
                          if not stor11[ext_call.return_data[12 len 20]][caller]:
                              require stor12[address(ext_call.return_data[0])][node][caller]
          else:
              static call 0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401.ownerOf(uint256 tokenId) with:
                      gas gas_remaining wei
                     args node
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 32
              require ext_call.return_data[0] == ext_call.return_data[12 len 20]
              if ext_call.return_data[12 len 20] != caller:
                  if not stor11[ext_call.return_data[12 len 20]][caller]:
                      require stor12[address(ext_call.return_data[0])][node][caller]
              if caller != 0x253553366da8546fc250f225fe3d25d0c782303b:
                  if caller != 0xa58e81fe9b61b5c3fe2afd33cf304c454abfc7cb:
                      mem[(2 * ceil32(return_data.size)) + 164] = node
                      static call 0xc2e074ec69a0dfb2997ba6c7d2e1e.owner(bytes32 node) with:
                              gas gas_remaining wei
                             args node
                      mem[(2 * ceil32(return_data.size)) + 160] = ext_call.return_data[0]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                      if not ext_call.return_data[12 len 20] - 0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401:
                          mem[(4 * ceil32(return_data.size)) + 164] = node
                          static call 0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401.ownerOf(uint256 tokenId) with:
                                  gas gas_remaining wei
                                 args mem[(4 * ceil32(return_data.size)) + 164 len (5 * ceil32(return_data.size)) + 32]
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          require return_data.size >=′ 32
                          require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                      if ext_call.return_data[12 len 20] != caller:
                          if not stor11[ext_call.return_data[12 len 20]][caller]:
                              require stor12[address(ext_call.return_data[0])][node][caller]
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def text(bytes32 node, string key) payable: 
  require calldata.size - 4 >=′ 64
  require key <= LOCK8605463013()
  require key + 35 <′ calldata.size
  require key.length <= LOCK8605463013()
  require key + key.length + 36 <= calldata.size
  mem[96 len key.length] = key[all]
  mem[key.length + 96] = sha3(node, sha3(recordVersions[node], 10))
  if stor10[stor0[node]][node][key[all]].field_0:
      if not stor10[stor0[node]][node][key[all]].field_0 - (uint255(stor10[stor0[node]][node][key[all]].field_0) * 0.5 < 32):
          revert with 0, 34
      if stor10[stor0[node]][node][key[all]].field_0:
          if not stor10[stor0[node]][node][key[all]].field_0 - (uint255(stor10[stor0[node]][node][key[all]].field_0) * 0.5 < 32):
              revert with 0, 34
          if Mask(256, -1, stor10[stor0[node]][node][key[all]].field_0):
              if 31 >= uint255(stor10[stor0[node]][node][key[all]].field_0) * 0.5:
                  mem[128] = 256 * stor10[stor0[node]][node][key[all]].field_8
              else:
                  mem[128] = stor10[stor0[node]][node][key[all]].field_0
                  idx = 128
                  s = 0
                  while (uint255(stor10[stor0[node]][node][key[all]].field_0) * 0.5) + 96 > idx:
                      mem[idx + 32] = stor10[stor0[node]][node][key[all]][s].field_256
                      idx = idx + 32
                      s = s + 1
                      continue 
      else:
          if not stor10[stor0[node]][node][key[all]].field_0 - (stor10[stor0[node]][node][key[all]].field_1 < 32):
              revert with 0, 34
          if stor10[stor0[node]][node][key[all]].field_1:
              if 31 >= stor10[stor0[node]][node][key[all]].field_1:
                  mem[128] = 256 * stor10[stor0[node]][node][key[all]].field_8
              else:
                  mem[128] = stor10[stor0[node]][node][key[all]].field_0
                  idx = 128
                  s = 0
                  while stor10[stor0[node]][node][key[all]].field_1 + 96 > idx:
                      mem[idx + 32] = stor10[stor0[node]][node][key[all]][s].field_256
                      idx = idx + 32
                      s = s + 1
                      continue 
      return Array(len=2 * Mask(256, -1, stor10[stor0[node]][node][key[all]].field_0), data=mem[128 len ceil32(uint255(stor10[stor0[node]][node][key[all]].field_0) * 0.5)]), 
  if not stor10[stor0[node]][node][key[all]].field_0 - (stor10[stor0[node]][node][key[all]].field_1 < 32):
      revert with 0, 34
  if stor10[stor0[node]][node][key[all]].field_0:
      if not stor10[stor0[node]][node][key[all]].field_0 - (uint255(stor10[stor0[node]][node][key[all]].field_0) * 0.5 < 32):
          revert with 0, 34
      if Mask(256, -1, stor10[stor0[node]][node][key[all]].field_0):
          if 31 >= uint255(stor10[stor0[node]][node][key[all]].field_0) * 0.5:
              mem[128] = 256 * stor10[stor0[node]][node][key[all]].field_8
          else:
              mem[128] = stor10[stor0[node]][node][key[all]].field_0
              idx = 128
              s = 0
              while (uint255(stor10[stor0[node]][node][key[all]].field_0) * 0.5) + 96 > idx:
                  mem[idx + 32] = stor10[stor0[node]][node][key[all]][s].field_256
                  idx = idx + 32
                  s = s + 1
                  continue 
  else:
      if not stor10[stor0[node]][node][key[all]].field_0 - (stor10[stor0[node]][node][key[all]].field_1 < 32):
          revert with 0, 34
      if stor10[stor0[node]][node][key[all]].field_1:
          if 31 >= stor10[stor0[node]][node][key[all]].field_1:
              mem[128] = 256 * stor10[stor0[node]][node][key[all]].field_8
          else:
              mem[128] = stor10[stor0[node]][node][key[all]].field_0
              idx = 128
              s = 0
              while stor10[stor0[node]][node][key[all]].field_1 + 96 > idx:
                  mem[idx + 32] = stor10[stor0[node]][node][key[all]][s].field_256
                  idx = idx + 32
                  s = s + 1
                  continue 
  return Array(len=stor10[stor0[node]][node][key[all]].field_0, data=mem[128 len ceil32(stor10[stor0[node]][node][key[all]].field_1)]), 

def addr(bytes32 node) payable: 
  require calldata.size - 4 >=′ 32
  if stor2[stor0[node]][node][60].field_0:
      if not stor2[stor0[node]][node][60].field_0 - (uint255(stor2[stor0[node]][node][60].field_0) * 0.5 < 32):
          revert with 0, 34
      if stor2[stor0[node]][node][60].field_0:
          if not stor2[stor0[node]][node][60].field_0 - (uint255(stor2[stor0[node]][node][60].field_0) * 0.5 < 32):
              revert with 0, 34
          if Mask(256, -1, stor2[stor0[node]][node][60].field_0):
              if 31 >= uint255(stor2[stor0[node]][node][60].field_0) * 0.5:
                  if not -uint255(stor2[stor0[node]][node][60].field_0) * 0.5:
                      return 0
                  require 20 == uint255(stor2[stor0[node]][node][60].field_0) * 0.5
                  return stor2[stor0[node]][node][60].field_96
              mem[128] = stor2[stor0[node]][node][60].field_0
              idx = 128
              s = 0
              while (uint255(stor2[stor0[node]][node][60].field_0) * 0.5) + 96 > idx:
                  mem[idx + 32] = stor2[stor0[node]][node][60][s].field_256
                  idx = idx + 32
                  s = s + 1
                  continue 
      else:
          if not stor2[stor0[node]][node][60].field_0 - (stor2[stor0[node]][node][60].field_1 < 32):
              revert with 0, 34
          if stor2[stor0[node]][node][60].field_1:
              if 31 >= stor2[stor0[node]][node][60].field_1:
                  if not -uint255(stor2[stor0[node]][node][60].field_0) * 0.5:
                      return 0
                  require 20 == uint255(stor2[stor0[node]][node][60].field_0) * 0.5
                  return stor2[stor0[node]][node][60].field_96
              mem[128] = stor2[stor0[node]][node][60].field_0
              idx = 128
              s = 0
              while stor2[stor0[node]][node][60].field_1 + 96 > idx:
                  mem[idx + 32] = stor2[stor0[node]][node][60][s].field_256
                  idx = idx + 32
                  s = s + 1
                  continue 
      if not -uint255(stor2[stor0[node]][node][60].field_0) * 0.5:
          return 0
      require 20 == uint255(stor2[stor0[node]][node][60].field_0) * 0.5
      mem[ceil32(uint255(stor2[stor0[node]][node][60].field_0) * 0.5) + 128] = mem[128 len 20]
      return memory
        from ceil32(uint255(stor2[stor0[node]][node][60].field_0) * 0.5) + 128
         len 32
  if not stor2[stor0[node]][node][60].field_0 - (stor2[stor0[node]][node][60].field_1 < 32):
      revert with 0, 34
  if stor2[stor0[node]][node][60].field_0:
      if not stor2[stor0[node]][node][60].field_0 - (uint255(stor2[stor0[node]][node][60].field_0) * 0.5 < 32):
          revert with 0, 34
      if Mask(256, -1, stor2[stor0[node]][node][60].field_0):
          if 31 >= uint255(stor2[stor0[node]][node][60].field_0) * 0.5:
              if not -stor2[stor0[node]][node][60].field_1:
                  return 0
              require 20 == stor2[stor0[node]][node][60].field_1
              return stor2[stor0[node]][node][60].field_96
          mem[128] = stor2[stor0[node]][node][60].field_0
          idx = 128
          s = 0
          while (uint255(stor2[stor0[node]][node][60].field_0) * 0.5) + 96 > idx:
              mem[idx + 32] = stor2[stor0[node]][node][60][s].field_256
              idx = idx + 32
              s = s + 1
              continue 
  else:
      if not stor2[stor0[node]][node][60].field_0 - (stor2[stor0[node]][node][60].field_1 < 32):
          revert with 0, 34
      if stor2[stor0[node]][node][60].field_1:
          if 31 >= stor2[stor0[node]][node][60].field_1:
              if not -stor2[stor0[node]][node][60].field_1:
                  return 0
              require 20 == stor2[stor0[node]][node][60].field_1
              return stor2[stor0[node]][node][60].field_96
          mem[128] = stor2[stor0[node]][node][60].field_0
          idx = 128
          s = 0
          while stor2[stor0[node]][node][60].field_1 + 96 > idx:
              mem[idx + 32] = stor2[stor0[node]][node][60][s].field_256
              idx = idx + 32
              s = s + 1
              continue 
  if not -stor2[stor0[node]][node][60].field_1:
      return 0
  require 20 == stor2[stor0[node]][node][60].field_1
  mem[ceil32(stor2[stor0[node]][node][60].field_1) + 128] = mem[128 len 20]
  return memory
    from ceil32(stor2[stor0[node]][node][60].field_1) + 128
     len 32

def setName(bytes32 node, string name) payable: 
  require calldata.size - 4 >=′ 64
  require name <= LOCK8605463013()
  require name + 35 <′ calldata.size
  require name.length <= LOCK8605463013()
  require name + name.length + 36 <= calldata.size
  if caller != 0x253553366da8546fc250f225fe3d25d0c782303b:
      if caller != 0xa58e81fe9b61b5c3fe2afd33cf304c454abfc7cb:
          static call 0xc2e074ec69a0dfb2997ba6c7d2e1e.owner(bytes32 node) with:
                  gas gas_remaining wei
                 args node
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          require return_data.size >=′ 32
          require ext_call.return_data[0] == ext_call.return_data[12 len 20]
          if not ext_call.return_data[12 len 20] - 0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401:
              static call 0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401.ownerOf(uint256 tokenId) with:
                      gas gas_remaining wei
                     args node
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 32
              require ext_call.return_data[0] == ext_call.return_data[12 len 20]
          if ext_call.return_data[12 len 20] != caller:
              if not stor11[ext_call.return_data[12 len 20]][caller]:
                  require stor12[address(ext_call.return_data[0])][node][caller]
  if name.length > LOCK8605463013():
      revert with 0, 65
  if stor8[stor0[node]][node].field_0:
      if not stor8[stor0[node]][node].field_0 - (uint255(stor8[stor0[node]][node].field_0) * 0.5 < 32):
          revert with 0, 34
      if uint255(stor8[stor0[node]][node].field_0) * 0.5 <= 31:
          if name.length > 31 != 1:
              if not name.length:
                  stor8[stor0[node]][node].field_0 = 2 * name.length
              else:
                  stor8[stor0[node]][node].field_0 = name.length
          else:
              idx = 0
              s = 0
              t = 0
              while idx < floor32(name.length):
                  stor8[stor0[node]][node][s].field_0 = cd[(t + name + 36)]
                  idx = idx + 32
                  s = s + 1
                  t = t + 32
                  continue 
              if floor32(name.length) < name.length:
                  stor8[stor0[node]][node][Mask(251, 0, floor32(name.length) + 31) >> 5].field_0 = cd[(name + ceil32(floor32(name.length)) + 36)] and !(Mask(256, -8 * name.length % 32, -1) >> 8 * name.length % 32)
              stor8[stor0[node]][node].field_0 = (2 * name.length) + 1
      else:
          if name.length >= 32:
              idx = Mask(251, 0, name.length + 31) * 0.03125
              while idx < Mask(251, 0, (uint255(stor8[stor0[node]][node].field_0) * 0.5) + 31) * 0.03125:
                  stor8[stor0[node]][node][idx].field_0 = 0
                  idx = idx + 1
                  continue 
          else:
              idx = 0
              while idx < Mask(251, 0, (uint255(stor8[stor0[node]][node].field_0) * 0.5) + 31) * 0.03125:
                  stor8[stor0[node]][node][idx].field_0 = 0
                  idx = idx + 1
                  continue 
          if name.length > 31 != 1:
              if not name.length:
                  stor8[stor0[node]][node].field_0 = 2 * name.length
              else:
                  stor8[stor0[node]][node].field_0 = name.length
          else:
              idx = 0
              s = 0
              t = 0
              while idx < floor32(name.length):
                  stor8[stor0[node]][node][s].field_0 = cd[(t + name + 36)]
                  idx = idx + 32
                  s = s + 1
                  t = t + 32
                  continue 
              if floor32(name.length) < name.length:
                  stor8[stor0[node]][node][Mask(251, 0, floor32(name.length) + 31) >> 5].field_0 = cd[(name + ceil32(floor32(name.length)) + 36)] and !(Mask(256, -8 * name.length % 32, -1) >> 8 * name.length % 32)
              stor8[stor0[node]][node].field_0 = (2 * name.length) + 1
  else:
      if not stor8[stor0[node]][node].field_0 - (stor8[stor0[node]][node].field_1 < 32):
          revert with 0, 34
      if stor8[stor0[node]][node].field_1 <= 31:
          if name.length > 31 != 1:
              if not name.length:
                  stor8[stor0[node]][node].field_0 = 2 * name.length
              else:
                  stor8[stor0[node]][node].field_0 = name.length
          else:
              idx = 0
              s = 0
              t = 0
              while idx < floor32(name.length):
                  stor8[stor0[node]][node][s].field_0 = cd[(t + name + 36)]
                  idx = idx + 32
                  s = s + 1
                  t = t + 32
                  continue 
              if floor32(name.length) < name.length:
                  stor8[stor0[node]][node][Mask(251, 0, floor32(name.length) + 31) >> 5].field_0 = cd[(name + ceil32(floor32(name.length)) + 36)] and !(Mask(256, -8 * name.length % 32, -1) >> 8 * name.length % 32)
              stor8[stor0[node]][node].field_0 = (2 * name.length) + 1
      else:
          if name.length >= 32:
              idx = Mask(251, 0, name.length + 31) * 0.03125
              while idx < Mask(251, 0, stor8[stor0[node]][node].field_1 + 31) * 0.03125:
                  stor8[stor0[node]][node][idx].field_0 = 0
                  idx = idx + 1
                  continue 
          else:
              idx = 0
              while idx < Mask(251, 0, stor8[stor0[node]][node].field_1 + 31) * 0.03125:
                  stor8[stor0[node]][node][idx].field_0 = 0
                  idx = idx + 1
                  continue 
          if name.length > 31 != 1:
              if not name.length:
                  stor8[stor0[node]][node].field_0 = 2 * name.length
              else:
                  stor8[stor0[node]][node].field_0 = name.length
          else:
              idx = 0
              s = 0
              t = 0
              while idx < floor32(name.length):
                  stor8[stor0[node]][node][s].field_0 = cd[(t + name + 36)]
                  idx = idx + 32
                  s = s + 1
                  t = t + 32
                  continue 
              if floor32(name.length) < name.length:
                  stor8[stor0[node]][node][Mask(251, 0, floor32(name.length) + 31) >> 5].field_0 = cd[(name + ceil32(floor32(name.length)) + 36)] and !(Mask(256, -8 * name.length % 32, -1) >> 8 * name.length % 32)
              stor8[stor0[node]][node].field_0 = (2 * name.length) + 1
  log NameChanged(
        bytes32 node=Array(len=name.length, data=name[all]),
        string name=node)

def setContenthash(bytes32 node, bytes hash) payable: 
  require calldata.size - 4 >=′ 64
  require hash <= LOCK8605463013()
  require hash + 35 <′ calldata.size
  require hash.length <= LOCK8605463013()
  require hash + hash.length + 36 <= calldata.size
  if caller != 0x253553366da8546fc250f225fe3d25d0c782303b:
      if caller != 0xa58e81fe9b61b5c3fe2afd33cf304c454abfc7cb:
          static call 0xc2e074ec69a0dfb2997ba6c7d2e1e.owner(bytes32 node) with:
                  gas gas_remaining wei
                 args node
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          require return_data.size >=′ 32
          require ext_call.return_data[0] == ext_call.return_data[12 len 20]
          if not ext_call.return_data[12 len 20] - 0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401:
              static call 0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401.ownerOf(uint256 tokenId) with:
                      gas gas_remaining wei
                     args node
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 32
              require ext_call.return_data[0] == ext_call.return_data[12 len 20]
          if ext_call.return_data[12 len 20] != caller:
              if not stor11[ext_call.return_data[12 len 20]][caller]:
                  require stor12[address(ext_call.return_data[0])][node][caller]
  if hash.length > LOCK8605463013():
      revert with 0, 65
  if stor3[stor0[node]][node].field_0:
      if not stor3[stor0[node]][node].field_0 - (uint255(stor3[stor0[node]][node].field_0) * 0.5 < 32):
          revert with 0, 34
      if uint255(stor3[stor0[node]][node].field_0) * 0.5 <= 31:
          if hash.length > 31 != 1:
              if not hash.length:
                  stor3[stor0[node]][node].field_0 = 2 * hash.length
              else:
                  stor3[stor0[node]][node].field_0 = hash.length
          else:
              idx = 0
              s = 0
              t = 0
              while idx < floor32(hash.length):
                  stor3[stor0[node]][node][s].field_0 = cd[(t + hash + 36)]
                  idx = idx + 32
                  s = s + 1
                  t = t + 32
                  continue 
              if floor32(hash.length) < hash.length:
                  stor3[stor0[node]][node][Mask(251, 0, floor32(hash.length) + 31) >> 5].field_0 = cd[(hash + ceil32(floor32(hash.length)) + 36)] and !(Mask(256, -8 * hash.length % 32, -1) >> 8 * hash.length % 32)
              stor3[stor0[node]][node].field_0 = (2 * hash.length) + 1
      else:
          if hash.length >= 32:
              idx = Mask(251, 0, hash.length + 31) * 0.03125
              while idx < Mask(251, 0, (uint255(stor3[stor0[node]][node].field_0) * 0.5) + 31) * 0.03125:
                  stor3[stor0[node]][node][idx].field_0 = 0
                  idx = idx + 1
                  continue 
          else:
              idx = 0
              while idx < Mask(251, 0, (uint255(stor3[stor0[node]][node].field_0) * 0.5) + 31) * 0.03125:
                  stor3[stor0[node]][node][idx].field_0 = 0
                  idx = idx + 1
                  continue 
          if hash.length > 31 != 1:
              if not hash.length:
                  stor3[stor0[node]][node].field_0 = 2 * hash.length
              else:
                  stor3[stor0[node]][node].field_0 = hash.length
          else:
              idx = 0
              s = 0
              t = 0
              while idx < floor32(hash.length):
                  stor3[stor0[node]][node][s].field_0 = cd[(t + hash + 36)]
                  idx = idx + 32
                  s = s + 1
                  t = t + 32
                  continue 
              if floor32(hash.length) < hash.length:
                  stor3[stor0[node]][node][Mask(251, 0, floor32(hash.length) + 31) >> 5].field_0 = cd[(hash + ceil32(floor32(hash.length)) + 36)] and !(Mask(256, -8 * hash.length % 32, -1) >> 8 * hash.length % 32)
              stor3[stor0[node]][node].field_0 = (2 * hash.length) + 1
  else:
      if not stor3[stor0[node]][node].field_0 - (stor3[stor0[node]][node].field_1 < 32):
          revert with 0, 34
      if stor3[stor0[node]][node].field_1 <= 31:
          if hash.length > 31 != 1:
              if not hash.length:
                  stor3[stor0[node]][node].field_0 = 2 * hash.length
              else:
                  stor3[stor0[node]][node].field_0 = hash.length
          else:
              idx = 0
              s = 0
              t = 0
              while idx < floor32(hash.length):
                  stor3[stor0[node]][node][s].field_0 = cd[(t + hash + 36)]
                  idx = idx + 32
                  s = s + 1
                  t = t + 32
                  continue 
              if floor32(hash.length) < hash.length:
                  stor3[stor0[node]][node][Mask(251, 0, floor32(hash.length) + 31) >> 5].field_0 = cd[(hash + ceil32(floor32(hash.length)) + 36)] and !(Mask(256, -8 * hash.length % 32, -1) >> 8 * hash.length % 32)
              stor3[stor0[node]][node].field_0 = (2 * hash.length) + 1
      else:
          if hash.length >= 32:
              idx = Mask(251, 0, hash.length + 31) * 0.03125
              while idx < Mask(251, 0, stor3[stor0[node]][node].field_1 + 31) * 0.03125:
                  stor3[stor0[node]][node][idx].field_0 = 0
                  idx = idx + 1
                  continue 
          else:
              idx = 0
              while idx < Mask(251, 0, stor3[stor0[node]][node].field_1 + 31) * 0.03125:
                  stor3[stor0[node]][node][idx].field_0 = 0
                  idx = idx + 1
                  continue 
          if hash.length > 31 != 1:
              if not hash.length:
                  stor3[stor0[node]][node].field_0 = 2 * hash.length
              else:
                  stor3[stor0[node]][node].field_0 = hash.length
          else:
              idx = 0
              s = 0
              t = 0
              while idx < floor32(hash.length):
                  stor3[stor0[node]][node][s].field_0 = cd[(t + hash + 36)]
                  idx = idx + 32
                  s = s + 1
                  t = t + 32
                  continue 
              if floor32(hash.length) < hash.length:
                  stor3[stor0[node]][node][Mask(251, 0, floor32(hash.length) + 31) >> 5].field_0 = cd[(hash + ceil32(floor32(hash.length)) + 36)] and !(Mask(256, -8 * hash.length % 32, -1) >> 8 * hash.length % 32)
              stor3[stor0[node]][node].field_0 = (2 * hash.length) + 1
  log ContenthashChanged(
        bytes32 node=Array(len=hash.length, data=hash[all]),
        bytes hash=node)

def name(bytes32 node) payable: 
  require calldata.size - 4 >=′ 32
  if stor8[stor0[node]][node].field_0:
      if not stor8[stor0[node]][node].field_0 - (uint255(stor8[stor0[node]][node].field_0) * 0.5 < 32):
          revert with 0, 34
      if stor8[stor0[node]][node].field_0:
          if not stor8[stor0[node]][node].field_0 - (uint255(stor8[stor0[node]][node].field_0) * 0.5 < 32):
              revert with 0, 34
          if Mask(256, -1, stor8[stor0[node]][node].field_0):
              if 31 < uint255(stor8[stor0[node]][node].field_0) * 0.5:
                  mem[128] = stor8[stor0[node]][node].field_0
                  idx = 128
                  s = 0
                  while (uint255(stor8[stor0[node]][node].field_0) * 0.5) + 96 > idx:
                      mem[idx + 32] = stor8[stor0[node]][node][s].field_256
                      idx = idx + 32
                      s = s + 1
                      continue 
                  return Array(len=2 * Mask(256, -1, stor8[stor0[node]][node].field_0), data=mem[128 len ceil32(uint255(stor8[stor0[node]][node].field_0) * 0.5)]), 
              mem[128] = 256 * stor8[stor0[node]][node].field_8
      else:
          if not stor8[stor0[node]][node].field_0 - (stor8[stor0[node]][node].field_1 < 32):
              revert with 0, 34
          if stor8[stor0[node]][node].field_1:
              if 31 < stor8[stor0[node]][node].field_1:
                  mem[128] = stor8[stor0[node]][node].field_0
                  idx = 128
                  s = 0
                  while stor8[stor0[node]][node].field_1 + 96 > idx:
                      mem[idx + 32] = stor8[stor0[node]][node][s].field_256
                      idx = idx + 32
                      s = s + 1
                      continue 
                  return Array(len=2 * Mask(256, -1, stor8[stor0[node]][node].field_0), data=mem[128 len ceil32(uint255(stor8[stor0[node]][node].field_0) * 0.5)]), 
              mem[128] = 256 * stor8[stor0[node]][node].field_8
      mem[ceil32(uint255(stor8[stor0[node]][node].field_0) * 0.5) + 192 len ceil32(uint255(stor8[stor0[node]][node].field_0) * 0.5)] = mem[128 len ceil32(uint255(stor8[stor0[node]][node].field_0) * 0.5)]
      mem[(uint255(stor8[stor0[node]][node].field_0) * 0.5) + ceil32(uint255(stor8[stor0[node]][node].field_0) * 0.5) + 192] = 0
      return Array(len=2 * Mask(256, -1, stor8[stor0[node]][node].field_0), data=mem[128 len ceil32(uint255(stor8[stor0[node]][node].field_0) * 0.5)], mem[(2 * ceil32(uint255(stor8[stor0[node]][node].field_0) * 0.5)) + 192 len 2 * ceil32(uint255(stor8[stor0[node]][node].field_0) * 0.5)]), 
  if not stor8[stor0[node]][node].field_0 - (stor8[stor0[node]][node].field_1 < 32):
      revert with 0, 34
  if stor8[stor0[node]][node].field_0:
      if not stor8[stor0[node]][node].field_0 - (uint255(stor8[stor0[node]][node].field_0) * 0.5 < 32):
          revert with 0, 34
      if Mask(256, -1, stor8[stor0[node]][node].field_0):
          if 31 < uint255(stor8[stor0[node]][node].field_0) * 0.5:
              mem[128] = stor8[stor0[node]][node].field_0
              idx = 128
              s = 0
              while (uint255(stor8[stor0[node]][node].field_0) * 0.5) + 96 > idx:
                  mem[idx + 32] = stor8[stor0[node]][node][s].field_256
                  idx = idx + 32
                  s = s + 1
                  continue 
              return Array(len=stor8[stor0[node]][node].field_0, data=mem[128 len ceil32(stor8[stor0[node]][node].field_1)])
          mem[128] = 256 * stor8[stor0[node]][node].field_8
  else:
      if not stor8[stor0[node]][node].field_0 - (stor8[stor0[node]][node].field_1 < 32):
          revert with 0, 34
      if stor8[stor0[node]][node].field_1:
          if 31 < stor8[stor0[node]][node].field_1:
              mem[128] = stor8[stor0[node]][node].field_0
              idx = 128
              s = 0
              while stor8[stor0[node]][node].field_1 + 96 > idx:
                  mem[idx + 32] = stor8[stor0[node]][node][s].field_256
                  idx = idx + 32
                  s = s + 1
                  continue 
              return Array(len=stor8[stor0[node]][node].field_0, data=mem[128 len ceil32(stor8[stor0[node]][node].field_1)])
          mem[128] = 256 * stor8[stor0[node]][node].field_8
  mem[ceil32(stor8[stor0[node]][node].field_1) + 192 len ceil32(stor8[stor0[node]][node].field_1)] = mem[128 len ceil32(stor8[stor0[node]][node].field_1)]
  mem[stor8[stor0[node]][node].field_1 + ceil32(stor8[stor0[node]][node].field_1) + 192] = 0
  return Array(len=stor8[stor0[node]][node].field_0, data=mem[128 len ceil32(stor8[stor0[node]][node].field_1)], mem[(2 * ceil32(stor8[stor0[node]][node].field_1)) + 192 len 2 * ceil32(stor8[stor0[node]][node].field_1)]), 

def zonehash(bytes32 node) payable: 
  require calldata.size - 4 >=′ 32
  if stor4[stor0[node]][node].field_0:
      if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
          revert with 0, 34
      if stor4[stor0[node]][node].field_0:
          if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
              revert with 0, 34
          if Mask(256, -1, stor4[stor0[node]][node].field_0):
              if 31 < uint255(stor4[stor0[node]][node].field_0) * 0.5:
                  mem[128] = stor4[stor0[node]][node].field_0
                  idx = 128
                  s = 0
                  while (uint255(stor4[stor0[node]][node].field_0) * 0.5) + 96 > idx:
                      mem[idx + 32] = stor4[stor0[node]][node][s].field_256
                      idx = idx + 32
                      s = s + 1
                      continue 
                  return Array(len=2 * Mask(256, -1, stor4[stor0[node]][node].field_0), data=mem[128 len ceil32(uint255(stor4[stor0[node]][node].field_0) * 0.5)]), 
              mem[128] = 256 * stor4[stor0[node]][node].field_8
      else:
          if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
              revert with 0, 34
          if stor4[stor0[node]][node].field_1:
              if 31 < stor4[stor0[node]][node].field_1:
                  mem[128] = stor4[stor0[node]][node].field_0
                  idx = 128
                  s = 0
                  while stor4[stor0[node]][node].field_1 + 96 > idx:
                      mem[idx + 32] = stor4[stor0[node]][node][s].field_256
                      idx = idx + 32
                      s = s + 1
                      continue 
                  return Array(len=2 * Mask(256, -1, stor4[stor0[node]][node].field_0), data=mem[128 len ceil32(uint255(stor4[stor0[node]][node].field_0) * 0.5)]), 
              mem[128] = 256 * stor4[stor0[node]][node].field_8
      mem[ceil32(uint255(stor4[stor0[node]][node].field_0) * 0.5) + 192 len ceil32(uint255(stor4[stor0[node]][node].field_0) * 0.5)] = mem[128 len ceil32(uint255(stor4[stor0[node]][node].field_0) * 0.5)]
      mem[(uint255(stor4[stor0[node]][node].field_0) * 0.5) + ceil32(uint255(stor4[stor0[node]][node].field_0) * 0.5) + 192] = 0
      return Array(len=2 * Mask(256, -1, stor4[stor0[node]][node].field_0), data=mem[128 len ceil32(uint255(stor4[stor0[node]][node].field_0) * 0.5)], mem[(2 * ceil32(uint255(stor4[stor0[node]][node].field_0) * 0.5)) + 192 len 2 * ceil32(uint255(stor4[stor0[node]][node].field_0) * 0.5)]), 
  if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
      revert with 0, 34
  if stor4[stor0[node]][node].field_0:
      if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
          revert with 0, 34
      if Mask(256, -1, stor4[stor0[node]][node].field_0):
          if 31 < uint255(stor4[stor0[node]][node].field_0) * 0.5:
              mem[128] = stor4[stor0[node]][node].field_0
              idx = 128
              s = 0
              while (uint255(stor4[stor0[node]][node].field_0) * 0.5) + 96 > idx:
                  mem[idx + 32] = stor4[stor0[node]][node][s].field_256
                  idx = idx + 32
                  s = s + 1
                  continue 
              return Array(len=stor4[stor0[node]][node].field_0, data=mem[128 len ceil32(stor4[stor0[node]][node].field_1)])
          mem[128] = 256 * stor4[stor0[node]][node].field_8
  else:
      if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
          revert with 0, 34
      if stor4[stor0[node]][node].field_1:
          if 31 < stor4[stor0[node]][node].field_1:
              mem[128] = stor4[stor0[node]][node].field_0
              idx = 128
              s = 0
              while stor4[stor0[node]][node].field_1 + 96 > idx:
                  mem[idx + 32] = stor4[stor0[node]][node][s].field_256
                  idx = idx + 32
                  s = s + 1
                  continue 
              return Array(len=stor4[stor0[node]][node].field_0, data=mem[128 len ceil32(stor4[stor0[node]][node].field_1)])
          mem[128] = 256 * stor4[stor0[node]][node].field_8
  mem[ceil32(stor4[stor0[node]][node].field_1) + 192 len ceil32(stor4[stor0[node]][node].field_1)] = mem[128 len ceil32(stor4[stor0[node]][node].field_1)]
  mem[stor4[stor0[node]][node].field_1 + ceil32(stor4[stor0[node]][node].field_1) + 192] = 0
  return Array(len=stor4[stor0[node]][node].field_0, data=mem[128 len ceil32(stor4[stor0[node]][node].field_1)], mem[(2 * ceil32(stor4[stor0[node]][node].field_1)) + 192 len 2 * ceil32(stor4[stor0[node]][node].field_1)]), 

def contenthash(bytes32 node) payable: 
  require calldata.size - 4 >=′ 32
  if stor3[stor0[node]][node].field_0:
      if not stor3[stor0[node]][node].field_0 - (uint255(stor3[stor0[node]][node].field_0) * 0.5 < 32):
          revert with 0, 34
      if stor3[stor0[node]][node].field_0:
          if not stor3[stor0[node]][node].field_0 - (uint255(stor3[stor0[node]][node].field_0) * 0.5 < 32):
              revert with 0, 34
          if Mask(256, -1, stor3[stor0[node]][node].field_0):
              if 31 < uint255(stor3[stor0[node]][node].field_0) * 0.5:
                  mem[128] = stor3[stor0[node]][node].field_0
                  idx = 128
                  s = 0
                  while (uint255(stor3[stor0[node]][node].field_0) * 0.5) + 96 > idx:
                      mem[idx + 32] = stor3[stor0[node]][node][s].field_256
                      idx = idx + 32
                      s = s + 1
                      continue 
                  return Array(len=2 * Mask(256, -1, stor3[stor0[node]][node].field_0), data=mem[128 len ceil32(uint255(stor3[stor0[node]][node].field_0) * 0.5)]), 
              mem[128] = 256 * stor3[stor0[node]][node].field_8
      else:
          if not stor3[stor0[node]][node].field_0 - (stor3[stor0[node]][node].field_1 < 32):
              revert with 0, 34
          if stor3[stor0[node]][node].field_1:
              if 31 < stor3[stor0[node]][node].field_1:
                  mem[128] = stor3[stor0[node]][node].field_0
                  idx = 128
                  s = 0
                  while stor3[stor0[node]][node].field_1 + 96 > idx:
                      mem[idx + 32] = stor3[stor0[node]][node][s].field_256
                      idx = idx + 32
                      s = s + 1
                      continue 
                  return Array(len=2 * Mask(256, -1, stor3[stor0[node]][node].field_0), data=mem[128 len ceil32(uint255(stor3[stor0[node]][node].field_0) * 0.5)]), 
              mem[128] = 256 * stor3[stor0[node]][node].field_8
      mem[ceil32(uint255(stor3[stor0[node]][node].field_0) * 0.5) + 192 len ceil32(uint255(stor3[stor0[node]][node].field_0) * 0.5)] = mem[128 len ceil32(uint255(stor3[stor0[node]][node].field_0) * 0.5)]
      mem[(uint255(stor3[stor0[node]][node].field_0) * 0.5) + ceil32(uint255(stor3[stor0[node]][node].field_0) * 0.5) + 192] = 0
      return Array(len=2 * Mask(256, -1, stor3[stor0[node]][node].field_0), data=mem[128 len ceil32(uint255(stor3[stor0[node]][node].field_0) * 0.5)], mem[(2 * ceil32(uint255(stor3[stor0[node]][node].field_0) * 0.5)) + 192 len 2 * ceil32(uint255(stor3[stor0[node]][node].field_0) * 0.5)]), 
  if not stor3[stor0[node]][node].field_0 - (stor3[stor0[node]][node].field_1 < 32):
      revert with 0, 34
  if stor3[stor0[node]][node].field_0:
      if not stor3[stor0[node]][node].field_0 - (uint255(stor3[stor0[node]][node].field_0) * 0.5 < 32):
          revert with 0, 34
      if Mask(256, -1, stor3[stor0[node]][node].field_0):
          if 31 < uint255(stor3[stor0[node]][node].field_0) * 0.5:
              mem[128] = stor3[stor0[node]][node].field_0
              idx = 128
              s = 0
              while (uint255(stor3[stor0[node]][node].field_0) * 0.5) + 96 > idx:
                  mem[idx + 32] = stor3[stor0[node]][node][s].field_256
                  idx = idx + 32
                  s = s + 1
                  continue 
              return Array(len=stor3[stor0[node]][node].field_0, data=mem[128 len ceil32(stor3[stor0[node]][node].field_1)])
          mem[128] = 256 * stor3[stor0[node]][node].field_8
  else:
      if not stor3[stor0[node]][node].field_0 - (stor3[stor0[node]][node].field_1 < 32):
          revert with 0, 34
      if stor3[stor0[node]][node].field_1:
          if 31 < stor3[stor0[node]][node].field_1:
              mem[128] = stor3[stor0[node]][node].field_0
              idx = 128
              s = 0
              while stor3[stor0[node]][node].field_1 + 96 > idx:
                  mem[idx + 32] = stor3[stor0[node]][node][s].field_256
                  idx = idx + 32
                  s = s + 1
                  continue 
              return Array(len=stor3[stor0[node]][node].field_0, data=mem[128 len ceil32(stor3[stor0[node]][node].field_1)])
          mem[128] = 256 * stor3[stor0[node]][node].field_8
  mem[ceil32(stor3[stor0[node]][node].field_1) + 192 len ceil32(stor3[stor0[node]][node].field_1)] = mem[128 len ceil32(stor3[stor0[node]][node].field_1)]
  mem[stor3[stor0[node]][node].field_1 + ceil32(stor3[stor0[node]][node].field_1) + 192] = 0
  return Array(len=stor3[stor0[node]][node].field_0, data=mem[128 len ceil32(stor3[stor0[node]][node].field_1)], mem[(2 * ceil32(stor3[stor0[node]][node].field_1)) + 192 len 2 * ceil32(stor3[stor0[node]][node].field_1)]), 

def setABI(bytes32 node, uint256 contentType, bytes data) payable: 
  require calldata.size - 4 >=′ 96
  require data <= LOCK8605463013()
  require data + 35 <′ calldata.size
  require data.length <= LOCK8605463013()
  require data + data.length + 36 <= calldata.size
  if caller != 0x253553366da8546fc250f225fe3d25d0c782303b:
      if caller != 0xa58e81fe9b61b5c3fe2afd33cf304c454abfc7cb:
          static call 0xc2e074ec69a0dfb2997ba6c7d2e1e.owner(bytes32 node) with:
                  gas gas_remaining wei
                 args node
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          require return_data.size >=′ 32
          require ext_call.return_data[0] == ext_call.return_data[12 len 20]
          if not ext_call.return_data[12 len 20] - 0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401:
              static call 0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401.ownerOf(uint256 tokenId) with:
                      gas gas_remaining wei
                     args node
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 32
              require ext_call.return_data[0] == ext_call.return_data[12 len 20]
          if ext_call.return_data[12 len 20] != caller:
              if not stor11[ext_call.return_data[12 len 20]][caller]:
                  require stor12[address(ext_call.return_data[0])][node][caller]
  if contentType - 1 > contentType:
      revert with 0, 17
  require not contentType - 1 or not contentType
  if data.length > LOCK8605463013():
      revert with 0, 65
  if stor1[stor0[node]][node][contentType].field_0:
      if not stor1[stor0[node]][node][contentType].field_0 - (uint255(stor1[stor0[node]][node][contentType].field_0) * 0.5 < 32):
          revert with 0, 34
      if uint255(stor1[stor0[node]][node][contentType].field_0) * 0.5 <= 31:
          if data.length > 31 != 1:
              if not data.length:
                  stor1[stor0[node]][node][contentType].field_0 = 2 * data.length
              else:
                  stor1[stor0[node]][node][contentType].field_0 = data.length
          else:
              idx = 0
              s = 0
              t = 0
              while idx < floor32(data.length):
                  stor1[stor0[node]][node][contentType][s].field_0 = cd[(t + data + 36)]
                  idx = idx + 32
                  s = s + 1
                  t = t + 32
                  continue 
              if floor32(data.length) < data.length:
                  stor1[stor0[node]][node][contentType][Mask(251, 0, floor32(data.length) + 31) >> 5].field_0 = cd[(data + ceil32(floor32(data.length)) + 36)] and !(Mask(256, -8 * data.length % 32, -1) >> 8 * data.length % 32)
              stor1[stor0[node]][node][contentType].field_0 = (2 * data.length) + 1
      else:
          if data.length >= 32:
              idx = Mask(251, 0, data.length + 31) * 0.03125
              while idx < Mask(251, 0, (uint255(stor1[stor0[node]][node][contentType].field_0) * 0.5) + 31) * 0.03125:
                  stor1[stor0[node]][node][contentType][idx].field_0 = 0
                  idx = idx + 1
                  continue 
          else:
              idx = 0
              while idx < Mask(251, 0, (uint255(stor1[stor0[node]][node][contentType].field_0) * 0.5) + 31) * 0.03125:
                  stor1[stor0[node]][node][contentType][idx].field_0 = 0
                  idx = idx + 1
                  continue 
          if data.length > 31 != 1:
              if not data.length:
                  stor1[stor0[node]][node][contentType].field_0 = 2 * data.length
              else:
                  stor1[stor0[node]][node][contentType].field_0 = data.length
          else:
              idx = 0
              s = 0
              t = 0
              while idx < floor32(data.length):
                  stor1[stor0[node]][node][contentType][s].field_0 = cd[(t + data + 36)]
                  idx = idx + 32
                  s = s + 1
                  t = t + 32
                  continue 
              if floor32(data.length) < data.length:
                  stor1[stor0[node]][node][contentType][Mask(251, 0, floor32(data.length) + 31) >> 5].field_0 = cd[(data + ceil32(floor32(data.length)) + 36)] and !(Mask(256, -8 * data.length % 32, -1) >> 8 * data.length % 32)
              stor1[stor0[node]][node][contentType].field_0 = (2 * data.length) + 1
  else:
      if not stor1[stor0[node]][node][contentType].field_0 - (stor1[stor0[node]][node][contentType].field_1 < 32):
          revert with 0, 34
      if stor1[stor0[node]][node][contentType].field_1 <= 31:
          if data.length > 31 != 1:
              if not data.length:
                  stor1[stor0[node]][node][contentType].field_0 = 2 * data.length
              else:
                  stor1[stor0[node]][node][contentType].field_0 = data.length
          else:
              idx = 0
              s = 0
              t = 0
              while idx < floor32(data.length):
                  stor1[stor0[node]][node][contentType][s].field_0 = cd[(t + data + 36)]
                  idx = idx + 32
                  s = s + 1
                  t = t + 32
                  continue 
              if floor32(data.length) < data.length:
                  stor1[stor0[node]][node][contentType][Mask(251, 0, floor32(data.length) + 31) >> 5].field_0 = cd[(data + ceil32(floor32(data.length)) + 36)] and !(Mask(256, -8 * data.length % 32, -1) >> 8 * data.length % 32)
              stor1[stor0[node]][node][contentType].field_0 = (2 * data.length) + 1
      else:
          if data.length >= 32:
              idx = Mask(251, 0, data.length + 31) * 0.03125
              while idx < Mask(251, 0, stor1[stor0[node]][node][contentType].field_1 + 31) * 0.03125:
                  stor1[stor0[node]][node][contentType][idx].field_0 = 0
                  idx = idx + 1
                  continue 
          else:
              idx = 0
              while idx < Mask(251, 0, stor1[stor0[node]][node][contentType].field_1 + 31) * 0.03125:
                  stor1[stor0[node]][node][contentType][idx].field_0 = 0
                  idx = idx + 1
                  continue 
          if data.length > 31 != 1:
              if not data.length:
                  stor1[stor0[node]][node][contentType].field_0 = 2 * data.length
              else:
                  stor1[stor0[node]][node][contentType].field_0 = data.length
          else:
              idx = 0
              s = 0
              t = 0
              while idx < floor32(data.length):
                  stor1[stor0[node]][node][contentType][s].field_0 = cd[(t + data + 36)]
                  idx = idx + 32
                  s = s + 1
                  t = t + 32
                  continue 
              if floor32(data.length) < data.length:
                  stor1[stor0[node]][node][contentType][Mask(251, 0, floor32(data.length) + 31) >> 5].field_0 = cd[(data + ceil32(floor32(data.length)) + 36)] and !(Mask(256, -8 * data.length % 32, -1) >> 8 * data.length % 32)
              stor1[stor0[node]][node][contentType].field_0 = (2 * data.length) + 1
  log ABIChanged(
        bytes32 node=node,
        uint256 contentType=contentType)

def multicallWithNodeCheck(bytes32 nodehash, bytes[] data) payable: 
  require calldata.size - 4 >=′ 64
  require data <= LOCK8605463013()
  require data + 35 <′ calldata.size
  require data.length <= LOCK8605463013()
  require data + (32 * data.length) + 36 <= calldata.size
  if data.length > LOCK8605463013():
      revert with 0, 65
  mem[96] = data.length
  mem[64] = (32 * data.length) + 128
  if not data.length:
      idx = 0
      while idx < data.length:
          if idx >= data.length:
              revert with 0, 50
          require cd[(data + (32 * idx) + 36)] <′ calldata.size + -data - 67
          require cd[(data + cd[(data + (32 * idx) + 36)] + 36)] <= LOCK8605463013()
          require data + cd[(data + (32 * idx) + 36)] + 68 <=′ calldata.size - cd[(data + cd[(data + (32 * idx) + 36)] + 36)]
          if not nodehash:
              _45 = mem[64]
              mem[mem[64] len cd[(data + cd[(data + (32 * idx) + 36)] + 36)]] = call.data[data + cd[(data + (32 * idx) + 36)] + 68 len cd[(data + cd[(data + (32 * idx) + 36)] + 36)]]
              mem[cd[(data + cd[(data + (32 * idx) + 36)] + 36)] + mem[64]] = 0
              delegate this.address.mem[mem[64] len 4] with:
                   gas gas_remaining wei
                  args mem[mem[64] + 4 len cd[(data + cd[(data + (32 * idx) + 36)] + 36)] + _45 + -mem[64] - 4]
              if not return_data.size:
                  require delegate.return_code
                  if idx >= mem[96]:
                      revert with 0, 50
                  mem[(32 * idx) + 128] = 96
              else:
                  _51 = mem[64]
                  mem[64] = mem[64] + ceil32(return_data.size) + 1
                  mem[_51] = return_data.size
                  mem[_51 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                  require delegate.return_code
                  if idx >= mem[96]:
                      revert with 0, 50
                  mem[(32 * idx) + 128] = _51
          else:
              require 36 <= cd[(data + cd[(data + (32 * idx) + 36)] + 36)]
              if cd[(data + cd[(data + (32 * idx) + 36)] + 72)] != nodehash:
                  revert with 0, 'multicall: All records must have a matching namehash'
              if idx >= data.length:
                  revert with 0, 50
              require cd[(data + (32 * idx) + 36)] <′ calldata.size + -data - 67
              require cd[(data + cd[(data + (32 * idx) + 36)] + 36)] <= LOCK8605463013()
              require data + cd[(data + (32 * idx) + 36)] + 68 <=′ calldata.size - cd[(data + cd[(data + (32 * idx) + 36)] + 36)]
              _64 = mem[64]
              mem[mem[64] len cd[(data + cd[(data + (32 * idx) + 36)] + 36)]] = call.data[data + cd[(data + (32 * idx) + 36)] + 68 len cd[(data + cd[(data + (32 * idx) + 36)] + 36)]]
              mem[cd[(data + cd[(data + (32 * idx) + 36)] + 36)] + mem[64]] = 0
              delegate this.address.mem[mem[64] len 4] with:
                   gas gas_remaining wei
                  args mem[mem[64] + 4 len cd[(data + cd[(data + (32 * idx) + 36)] + 36)] + _64 + -mem[64] - 4]
              if not return_data.size:
                  require delegate.return_code
                  if idx >= mem[96]:
                      revert with 0, 50
                  mem[(32 * idx) + 128] = 96
              else:
                  _66 = mem[64]
                  mem[64] = mem[64] + ceil32(return_data.size) + 1
                  mem[_66] = return_data.size
                  mem[_66 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                  require delegate.return_code
                  if idx >= mem[96]:
                      revert with 0, 50
                  mem[(32 * idx) + 128] = _66
          if not idx + 1:
              revert with 0, 17
          idx = idx + 1
          continue 
      _38 = mem[64]
      mem[mem[64]] = 32
      _39 = mem[96]
      mem[mem[64] + 32] = mem[96]
      idx = 0
      s = 128
      t = mem[64] + 64
      u = mem[64] + (32 * mem[96]) + 64
      while idx < _39:
          mem[t] = u + -_38 - 64
          _74 = mem[s]
          _76 = mem[mem[s]]
          mem[u] = mem[mem[s]]
          v = 0
          while v < _76:
              mem[v + u + 32] = mem[v + _74 + 32]
              v = v + 32
              continue 
          mem[_76 + u + 32] = 0
          idx = idx + 1
          s = s + 32
          t = t + 32
          u = ceil32(_76) + u + 32
          continue 
  else:
      mem[128] = 96
      s = 128
      idx = data.length
      while idx - 1:
          mem[s + 32] = 96
          s = s + 32
          idx = idx - 1
          continue 
      idx = 0
      while idx < data.length:
          if idx >= data.length:
              revert with 0, 50
          require cd[(data + (32 * idx) + 36)] <′ calldata.size + -data - 67
          require cd[(data + cd[(data + (32 * idx) + 36)] + 36)] <= LOCK8605463013()
          require data + cd[(data + (32 * idx) + 36)] + 68 <=′ calldata.size - cd[(data + cd[(data + (32 * idx) + 36)] + 36)]
          if not nodehash:
              _83 = mem[64]
              mem[mem[64] len cd[(data + cd[(data + (32 * idx) + 36)] + 36)]] = call.data[data + cd[(data + (32 * idx) + 36)] + 68 len cd[(data + cd[(data + (32 * idx) + 36)] + 36)]]
              mem[cd[(data + cd[(data + (32 * idx) + 36)] + 36)] + mem[64]] = 0
              delegate this.address.mem[mem[64] len 4] with:
                   gas gas_remaining wei
                  args mem[mem[64] + 4 len cd[(data + cd[(data + (32 * idx) + 36)] + 36)] + _83 + -mem[64] - 4]
              if not return_data.size:
                  require delegate.return_code
                  if idx >= mem[96]:
                      revert with 0, 50
                  mem[(32 * idx) + 128] = 96
              else:
                  _86 = mem[64]
                  mem[64] = mem[64] + ceil32(return_data.size) + 1
                  mem[_86] = return_data.size
                  mem[_86 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                  require delegate.return_code
                  if idx >= mem[96]:
                      revert with 0, 50
                  mem[(32 * idx) + 128] = _86
          else:
              require 36 <= cd[(data + cd[(data + (32 * idx) + 36)] + 36)]
              if cd[(data + cd[(data + (32 * idx) + 36)] + 72)] != nodehash:
                  revert with 0, 'multicall: All records must have a matching namehash'
              if idx >= data.length:
                  revert with 0, 50
              require cd[(data + (32 * idx) + 36)] <′ calldata.size + -data - 67
              require cd[(data + cd[(data + (32 * idx) + 36)] + 36)] <= LOCK8605463013()
              require data + cd[(data + (32 * idx) + 36)] + 68 <=′ calldata.size - cd[(data + cd[(data + (32 * idx) + 36)] + 36)]
              _91 = mem[64]
              mem[mem[64] len cd[(data + cd[(data + (32 * idx) + 36)] + 36)]] = call.data[data + cd[(data + (32 * idx) + 36)] + 68 len cd[(data + cd[(data + (32 * idx) + 36)] + 36)]]
              mem[cd[(data + cd[(data + (32 * idx) + 36)] + 36)] + mem[64]] = 0
              delegate this.address.mem[mem[64] len 4] with:
                   gas gas_remaining wei
                  args mem[mem[64] + 4 len cd[(data + cd[(data + (32 * idx) + 36)] + 36)] + _91 + -mem[64] - 4]
              if not return_data.size:
                  require delegate.return_code
                  if idx >= mem[96]:
                      revert with 0, 50
                  mem[(32 * idx) + 128] = 96
              else:
                  _93 = mem[64]
                  mem[64] = mem[64] + ceil32(return_data.size) + 1
                  mem[_93] = return_data.size
                  mem[_93 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                  require delegate.return_code
                  if idx >= mem[96]:
                      revert with 0, 50
                  mem[(32 * idx) + 128] = _93
          if not idx + 1:
              revert with 0, 17
          idx = idx + 1
          continue 
      _77 = mem[64]
      mem[mem[64]] = 32
      _78 = mem[96]
      mem[mem[64] + 32] = mem[96]
      idx = 0
      s = 128
      t = mem[64] + 64
      u = mem[64] + (32 * mem[96]) + 64
      while idx < _78:
          mem[t] = u + -_77 - 64
          _97 = mem[s]
          _99 = mem[mem[s]]
          mem[u] = mem[mem[s]]
          v = 0
          while v < _99:
              mem[v + u + 32] = mem[v + _97 + 32]
              v = v + 32
              continue 
          mem[_99 + u + 32] = 0
          idx = idx + 1
          s = s + 32
          t = t + 32
          u = ceil32(_99) + u + 32
          continue 
  return memory
    from mem[64]
     len u - mem[64]

def addr(bytes32 node, uint256 coinType) payable: 
  require calldata.size - 4 >=′ 64
  if stor2[stor0[node]][node][coinType].field_0:
      if not stor2[stor0[node]][node][coinType].field_0 - (uint255(stor2[stor0[node]][node][coinType].field_0) * 0.5 < 32):
          revert with 0, 34
      if stor2[stor0[node]][node][coinType].field_0:
          if not stor2[stor0[node]][node][coinType].field_0 - (uint255(stor2[stor0[node]][node][coinType].field_0) * 0.5 < 32):
              revert with 0, 34
          if Mask(256, -1, stor2[stor0[node]][node][coinType].field_0):
              if 31 < uint255(stor2[stor0[node]][node][coinType].field_0) * 0.5:
                  mem[128] = stor2[stor0[node]][node][coinType].field_0
                  idx = 128
                  s = 0
                  while (uint255(stor2[stor0[node]][node][coinType].field_0) * 0.5) + 96 > idx:
                      mem[idx + 32] = stor2[stor0[node]][node][coinType][s].field_256
                      idx = idx + 32
                      s = s + 1
                      continue 
                  return Array(len=2 * Mask(256, -1, stor2[stor0[node]][node][coinType].field_0), data=mem[128 len ceil32(uint255(stor2[stor0[node]][node][coinType].field_0) * 0.5)]), 
              mem[128] = 256 * stor2[stor0[node]][node][coinType].field_8
      else:
          if not stor2[stor0[node]][node][coinType].field_0 - (stor2[stor0[node]][node][coinType].field_1 < 32):
              revert with 0, 34
          if stor2[stor0[node]][node][coinType].field_1:
              if 31 < stor2[stor0[node]][node][coinType].field_1:
                  mem[128] = stor2[stor0[node]][node][coinType].field_0
                  idx = 128
                  s = 0
                  while stor2[stor0[node]][node][coinType].field_1 + 96 > idx:
                      mem[idx + 32] = stor2[stor0[node]][node][coinType][s].field_256
                      idx = idx + 32
                      s = s + 1
                      continue 
                  return Array(len=2 * Mask(256, -1, stor2[stor0[node]][node][coinType].field_0), data=mem[128 len ceil32(uint255(stor2[stor0[node]][node][coinType].field_0) * 0.5)]), 
              mem[128] = 256 * stor2[stor0[node]][node][coinType].field_8
      mem[ceil32(uint255(stor2[stor0[node]][node][coinType].field_0) * 0.5) + 192 len ceil32(uint255(stor2[stor0[node]][node][coinType].field_0) * 0.5)] = mem[128 len ceil32(uint255(stor2[stor0[node]][node][coinType].field_0) * 0.5)]
      mem[(uint255(stor2[stor0[node]][node][coinType].field_0) * 0.5) + ceil32(uint255(stor2[stor0[node]][node][coinType].field_0) * 0.5) + 192] = 0
      return Array(len=2 * Mask(256, -1, stor2[stor0[node]][node][coinType].field_0), data=mem[128 len ceil32(uint255(stor2[stor0[node]][node][coinType].field_0) * 0.5)], mem[(2 * ceil32(uint255(stor2[stor0[node]][node][coinType].field_0) * 0.5)) + 192 len 2 * ceil32(uint255(stor2[stor0[node]][node][coinType].field_0) * 0.5)]), 
  if not stor2[stor0[node]][node][coinType].field_0 - (stor2[stor0[node]][node][coinType].field_1 < 32):
      revert with 0, 34
  if stor2[stor0[node]][node][coinType].field_0:
      if not stor2[stor0[node]][node][coinType].field_0 - (uint255(stor2[stor0[node]][node][coinType].field_0) * 0.5 < 32):
          revert with 0, 34
      if Mask(256, -1, stor2[stor0[node]][node][coinType].field_0):
          if 31 < uint255(stor2[stor0[node]][node][coinType].field_0) * 0.5:
              mem[128] = stor2[stor0[node]][node][coinType].field_0
              idx = 128
              s = 0
              while (uint255(stor2[stor0[node]][node][coinType].field_0) * 0.5) + 96 > idx:
                  mem[idx + 32] = stor2[stor0[node]][node][coinType][s].field_256
                  idx = idx + 32
                  s = s + 1
                  continue 
              return Array(len=stor2[stor0[node]][node][coinType].field_0, data=mem[128 len ceil32(stor2[stor0[node]][node][coinType].field_1)]), 
          mem[128] = 256 * stor2[stor0[node]][node][coinType].field_8
  else:
      if not stor2[stor0[node]][node][coinType].field_0 - (stor2[stor0[node]][node][coinType].field_1 < 32):
          revert with 0, 34
      if stor2[stor0[node]][node][coinType].field_1:
          if 31 < stor2[stor0[node]][node][coinType].field_1:
              mem[128] = stor2[stor0[node]][node][coinType].field_0
              idx = 128
              s = 0
              while stor2[stor0[node]][node][coinType].field_1 + 96 > idx:
                  mem[idx + 32] = stor2[stor0[node]][node][coinType][s].field_256
                  idx = idx + 32
                  s = s + 1
                  continue 
              return Array(len=stor2[stor0[node]][node][coinType].field_0, data=mem[128 len ceil32(stor2[stor0[node]][node][coinType].field_1)]), 
          mem[128] = 256 * stor2[stor0[node]][node][coinType].field_8
  mem[ceil32(stor2[stor0[node]][node][coinType].field_1) + 192 len ceil32(stor2[stor0[node]][node][coinType].field_1)] = mem[128 len ceil32(stor2[stor0[node]][node][coinType].field_1)]
  mem[stor2[stor0[node]][node][coinType].field_1 + ceil32(stor2[stor0[node]][node][coinType].field_1) + 192] = 0
  return Array(len=stor2[stor0[node]][node][coinType].field_0, data=mem[128 len ceil32(stor2[stor0[node]][node][coinType].field_1)], mem[(2 * ceil32(stor2[stor0[node]][node][coinType].field_1)) + 192 len 2 * ceil32(stor2[stor0[node]][node][coinType].field_1)]), 

def dnsRecord(bytes32 node, bytes32 name, uint16 resource) payable: 
  require calldata.size - 4 >=′ 96
  require resource == resource
  if stor5[stor0[node]][node][name][resource << 240].field_0:
      if not stor5[stor0[node]][node][name][resource << 240].field_0 - (uint255(stor5[stor0[node]][node][name][resource << 240].field_0) * 0.5 < 32):
          revert with 0, 34
      if stor5[stor0[node]][node][name][resource << 240].field_0:
          if not stor5[stor0[node]][node][name][resource << 240].field_0 - (uint255(stor5[stor0[node]][node][name][resource << 240].field_0) * 0.5 < 32):
              revert with 0, 34
          if Mask(256, -1, stor5[stor0[node]][node][name][resource << 240].field_0):
              if 31 < uint255(stor5[stor0[node]][node][name][resource << 240].field_0) * 0.5:
                  mem[128] = stor5[stor0[node]][node][name][resource << 240].field_0
                  idx = 128
                  s = 0
                  while (uint255(stor5[stor0[node]][node][name][resource << 240].field_0) * 0.5) + 96 > idx:
                      mem[idx + 32] = stor5[stor0[node]][node][name][resource << 240][s].field_256
                      idx = idx + 32
                      s = s + 1
                      continue 
                  return Array(len=2 * Mask(256, -1, stor5[stor0[node]][node][name][resource << 240].field_0), data=mem[128 len ceil32(uint255(stor5[stor0[node]][node][name][resource << 240].field_0) * 0.5)]), 
              mem[128] = 256 * stor5[stor0[node]][node][name][resource << 240].field_8
      else:
          if not stor5[stor0[node]][node][name][resource << 240].field_0 - (stor5[stor0[node]][node][name][resource << 240].field_1 < 32):
              revert with 0, 34
          if stor5[stor0[node]][node][name][resource << 240].field_1:
              if 31 < stor5[stor0[node]][node][name][resource << 240].field_1:
                  mem[128] = stor5[stor0[node]][node][name][resource << 240].field_0
                  idx = 128
                  s = 0
                  while stor5[stor0[node]][node][name][resource << 240].field_1 + 96 > idx:
                      mem[idx + 32] = stor5[stor0[node]][node][name][resource << 240][s].field_256
                      idx = idx + 32
                      s = s + 1
                      continue 
                  return Array(len=2 * Mask(256, -1, stor5[stor0[node]][node][name][resource << 240].field_0), data=mem[128 len ceil32(uint255(stor5[stor0[node]][node][name][resource << 240].field_0) * 0.5)]), 
              mem[128] = 256 * stor5[stor0[node]][node][name][resource << 240].field_8
      mem[ceil32(uint255(stor5[stor0[node]][node][name][resource << 240].field_0) * 0.5) + 192 len ceil32(uint255(stor5[stor0[node]][node][name][resource << 240].field_0) * 0.5)] = mem[128 len ceil32(uint255(stor5[stor0[node]][node][name][resource << 240].field_0) * 0.5)]
      mem[(uint255(stor5[stor0[node]][node][name][resource << 240].field_0) * 0.5) + ceil32(uint255(stor5[stor0[node]][node][name][resource << 240].field_0) * 0.5) + 192] = 0
      return Array(len=2 * Mask(256, -1, stor5[stor0[node]][node][name][resource << 240].field_0), data=mem[128 len ceil32(uint255(stor5[stor0[node]][node][name][resource << 240].field_0) * 0.5)], mem[(2 * ceil32(uint255(stor5[stor0[node]][node][name][resource << 240].field_0) * 0.5)) + 192 len 2 * ceil32(uint255(stor5[stor0[node]][node][name][resource << 240].field_0) * 0.5)]), 
  if not stor5[stor0[node]][node][name][resource << 240].field_0 - (stor5[stor0[node]][node][name][resource << 240].field_1 < 32):
      revert with 0, 34
  if stor5[stor0[node]][node][name][resource << 240].field_0:
      if not stor5[stor0[node]][node][name][resource << 240].field_0 - (uint255(stor5[stor0[node]][node][name][resource << 240].field_0) * 0.5 < 32):
          revert with 0, 34
      if Mask(256, -1, stor5[stor0[node]][node][name][resource << 240].field_0):
          if 31 < uint255(stor5[stor0[node]][node][name][resource << 240].field_0) * 0.5:
              mem[128] = stor5[stor0[node]][node][name][resource << 240].field_0
              idx = 128
              s = 0
              while (uint255(stor5[stor0[node]][node][name][resource << 240].field_0) * 0.5) + 96 > idx:
                  mem[idx + 32] = stor5[stor0[node]][node][name][resource << 240][s].field_256
                  idx = idx + 32
                  s = s + 1
                  continue 
              return Array(len=stor5[stor0[node]][node][name][resource << 240].field_0, data=mem[128 len ceil32(stor5[stor0[node]][node][name][resource << 240].field_1)]), 
          mem[128] = 256 * stor5[stor0[node]][node][name][resource << 240].field_8
  else:
      if not stor5[stor0[node]][node][name][resource << 240].field_0 - (stor5[stor0[node]][node][name][resource << 240].field_1 < 32):
          revert with 0, 34
      if stor5[stor0[node]][node][name][resource << 240].field_1:
          if 31 < stor5[stor0[node]][node][name][resource << 240].field_1:
              mem[128] = stor5[stor0[node]][node][name][resource << 240].field_0
              idx = 128
              s = 0
              while stor5[stor0[node]][node][name][resource << 240].field_1 + 96 > idx:
                  mem[idx + 32] = stor5[stor0[node]][node][name][resource << 240][s].field_256
                  idx = idx + 32
                  s = s + 1
                  continue 
              return Array(len=stor5[stor0[node]][node][name][resource << 240].field_0, data=mem[128 len ceil32(stor5[stor0[node]][node][name][resource << 240].field_1)]), 
          mem[128] = 256 * stor5[stor0[node]][node][name][resource << 240].field_8
  mem[ceil32(stor5[stor0[node]][node][name][resource << 240].field_1) + 192 len ceil32(stor5[stor0[node]][node][name][resource << 240].field_1)] = mem[128 len ceil32(stor5[stor0[node]][node][name][resource << 240].field_1)]
  mem[stor5[stor0[node]][node][name][resource << 240].field_1 + ceil32(stor5[stor0[node]][node][name][resource << 240].field_1) + 192] = 0
  return Array(len=stor5[stor0[node]][node][name][resource << 240].field_0, data=mem[128 len ceil32(stor5[stor0[node]][node][name][resource << 240].field_1)], mem[(2 * ceil32(stor5[stor0[node]][node][name][resource << 240].field_1)) + 192 len 2 * ceil32(stor5[stor0[node]][node][name][resource << 240].field_1)]), 

def setAddr(bytes32 node, uint256 coinType, bytes a) payable: 
  require calldata.size - 4 >=′ 96
  require a <= LOCK8605463013()
  require a + 35 <′ calldata.size
  if a.length > LOCK8605463013():
      revert with 0, 65
  if ceil32(ceil32(a.length)) + 97 < 96 or ceil32(ceil32(a.length)) + 97 > LOCK8605463013():
      revert with 0, 65
  mem[96] = a.length
  require a + a.length + 36 <= calldata.size
  mem[128 len a.length] = a[all]
  mem[a.length + 128] = 0
  if 0x253553366da8546fc250f225fe3d25d0c782303b == caller:
      mem[ceil32(ceil32(a.length)) + 97] = coinType
      mem[ceil32(ceil32(a.length)) + 129] = 64
      log AddressChanged(
            bytes32 node=coinType,
            uint256 coinType=Array(len=a.length, data=a[all]),
            bytes newAddress=node)
      if coinType - 60:
          if a.length > LOCK8605463013():
              revert with 0, 65
          if stor2[stor0[node]][node][coinType].field_0:
              if not stor2[stor0[node]][node][coinType].field_0 - (uint255(stor2[stor0[node]][node][coinType].field_0) * 0.5 < 32):
                  revert with 0, 34
              if uint255(stor2[stor0[node]][node][coinType].field_0) * 0.5 > 31:
                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
          else:
              if not stor2[stor0[node]][node][coinType].field_0 - (stor2[stor0[node]][node][coinType].field_1 < 32):
                  revert with 0, 34
              if stor2[stor0[node]][node][coinType].field_1 > 31:
                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
          if a.length > 31 == 1:
              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
          if not a.length:
              stor2[stor0[node]][node][coinType].field_0 = 2 * a.length
          else:
              stor2[stor0[node]][node][coinType].field_0 = a.length
          stop
      require 20 == a.length
      mem[ceil32(ceil32(a.length)) + 97] = mem[128 len 20]
      log AddrChanged(
            bytes32 node=mem[ceil32(ceil32(a.length)) + 97],
            address a=node)
  else:
      if 0xa58e81fe9b61b5c3fe2afd33cf304c454abfc7cb == caller:
          mem[ceil32(ceil32(a.length)) + 97] = coinType
          mem[ceil32(ceil32(a.length)) + 129] = 64
          log AddressChanged(
                bytes32 node=coinType,
                uint256 coinType=Array(len=a.length, data=a[all]),
                bytes newAddress=node)
          if coinType - 60:
              if a.length > LOCK8605463013():
                  revert with 0, 65
              if stor2[stor0[node]][node][coinType].field_0:
                  if not stor2[stor0[node]][node][coinType].field_0 - (uint255(stor2[stor0[node]][node][coinType].field_0) * 0.5 < 32):
                      revert with 0, 34
                  if uint255(stor2[stor0[node]][node][coinType].field_0) * 0.5 > 31:
                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              else:
                  if not stor2[stor0[node]][node][coinType].field_0 - (stor2[stor0[node]][node][coinType].field_1 < 32):
                      revert with 0, 34
                  if stor2[stor0[node]][node][coinType].field_1 > 31:
                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              if a.length > 31 == 1:
                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              if not a.length:
                  stor2[stor0[node]][node][coinType].field_0 = 2 * a.length
              else:
                  stor2[stor0[node]][node][coinType].field_0 = a.length
              stop
          require 20 == a.length
          mem[ceil32(ceil32(a.length)) + 97] = mem[128 len 20]
          log AddrChanged(
                bytes32 node=mem[ceil32(ceil32(a.length)) + 97],
                address a=node)
      else:
          mem[ceil32(ceil32(a.length)) + 101] = node
          static call 0xc2e074ec69a0dfb2997ba6c7d2e1e.owner(bytes32 node) with:
                  gas gas_remaining wei
                 args node
          mem[ceil32(ceil32(a.length)) + 97] = ext_call.return_data[0]
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          require return_data.size >=′ 32
          require ext_call.return_data[0] == ext_call.return_data[12 len 20]
          if ext_call.return_data[12 len 20] - 0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401:
              if ext_call.return_data[12 len 20] != caller:
                  if not stor11[ext_call.return_data[12 len 20]][caller]:
                      require stor12[address(ext_call.return_data[0])][node][caller]
              mem[ceil32(ceil32(a.length)) + ceil32(return_data.size) + 97] = coinType
              mem[ceil32(ceil32(a.length)) + ceil32(return_data.size) + 129] = 64
              log AddressChanged(
                    bytes32 node=coinType,
                    uint256 coinType=Array(len=a.length, data=a[all]),
                    bytes newAddress=node)
              if coinType - 60:
                  if a.length > LOCK8605463013():
                      revert with 0, 65
                  if stor2[stor0[node]][node][coinType].field_0:
                      if not stor2[stor0[node]][node][coinType].field_0 - (uint255(stor2[stor0[node]][node][coinType].field_0) * 0.5 < 32):
                          revert with 0, 34
                      if uint255(stor2[stor0[node]][node][coinType].field_0) * 0.5 > 31:
                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                  else:
                      if not stor2[stor0[node]][node][coinType].field_0 - (stor2[stor0[node]][node][coinType].field_1 < 32):
                          revert with 0, 34
                      if stor2[stor0[node]][node][coinType].field_1 > 31:
                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                  if a.length > 31 == 1:
                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                  if not a.length:
                      stor2[stor0[node]][node][coinType].field_0 = 2 * a.length
                  else:
                      stor2[stor0[node]][node][coinType].field_0 = a.length
                  stop
              require 20 == a.length
              mem[ceil32(ceil32(a.length)) + ceil32(return_data.size) + 97] = mem[128 len 20]
              log AddrChanged(
                    bytes32 node=mem[ceil32(ceil32(a.length)) + ceil32(return_data.size) + 97],
                    address a=node)
          else:
              mem[ceil32(ceil32(a.length)) + ceil32(return_data.size) + 101] = node
              static call 0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401.ownerOf(uint256 tokenId) with:
                      gas gas_remaining wei
                     args node
              mem[ceil32(ceil32(a.length)) + ceil32(return_data.size) + 97] = ext_call.return_data[0]
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 32
              require ext_call.return_data[0] == ext_call.return_data[12 len 20]
              if ext_call.return_data[12 len 20] != caller:
                  if not stor11[ext_call.return_data[12 len 20]][caller]:
                      require stor12[address(ext_call.return_data[0])][node][caller]
              mem[ceil32(ceil32(a.length)) + (2 * ceil32(return_data.size)) + 97] = coinType
              mem[ceil32(ceil32(a.length)) + (2 * ceil32(return_data.size)) + 129] = 64
              log AddressChanged(
                    bytes32 node=coinType,
                    uint256 coinType=Array(len=a.length, data=a[all]),
                    bytes newAddress=node)
              if coinType - 60:
                  if a.length > LOCK8605463013():
                      revert with 0, 65
                  if stor2[stor0[node]][node][coinType].field_0:
                      if not stor2[stor0[node]][node][coinType].field_0 - (uint255(stor2[stor0[node]][node][coinType].field_0) * 0.5 < 32):
                          revert with 0, 34
                      if uint255(stor2[stor0[node]][node][coinType].field_0) * 0.5 > 31:
                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                  else:
                      if not stor2[stor0[node]][node][coinType].field_0 - (stor2[stor0[node]][node][coinType].field_1 < 32):
                          revert with 0, 34
                      if stor2[stor0[node]][node][coinType].field_1 > 31:
                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                  if a.length > 31 == 1:
                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                  if not a.length:
                      stor2[stor0[node]][node][coinType].field_0 = 2 * a.length
                  else:
                      stor2[stor0[node]][node][coinType].field_0 = a.length
                  stop
              require 20 == a.length
              mem[ceil32(ceil32(a.length)) + (2 * ceil32(return_data.size)) + 97] = mem[128 len 20]
              log AddrChanged(
                    bytes32 node=mem[ceil32(ceil32(a.length)) + (2 * ceil32(return_data.size)) + 97],
                    address a=node)
  if a.length > LOCK8605463013():
      revert with 0, 65
  if stor2[stor0[node]][node][coinType].field_0:
      if not stor2[stor0[node]][node][coinType].field_0 - (uint255(stor2[stor0[node]][node][coinType].field_0) * 0.5 < 32):
          revert with 0, 34
      if uint255(stor2[stor0[node]][node][coinType].field_0) * 0.5 <= 31:
          if a.length > 31 != 1:
              if not a.length:
                  stor2[stor0[node]][node][coinType].field_0 = 2 * a.length
              else:
                  stor2[stor0[node]][node][coinType].field_0 = a.length
  else:
      if not stor2[stor0[node]][node][coinType].field_0 - (stor2[stor0[node]][node][coinType].field_1 < 32):
          revert with 0, 34
      if stor2[stor0[node]][node][coinType].field_1 <= 31:
          if a.length > 31 != 1:
              if not a.length:
                  stor2[stor0[node]][node][coinType].field_0 = 2 * a.length
              else:
                  stor2[stor0[node]][node][coinType].field_0 = a.length
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def setDNSRecords(bytes32 node, bytes data) payable: 
  require calldata.size - 4 >=′ 64
  require data <= LOCK8605463013()
  require data + 35 <′ calldata.size
  require data.length <= LOCK8605463013()
  require data + data.length + 36 <= calldata.size
  if 0x253553366da8546fc250f225fe3d25d0c782303b == caller:
      if data.length > 0:
          if 0 >= data.length:
              revert with 0, 1
          if 0 >= data.length:
              revert with 0, 50
          require 3 <= data.length
          require 5 <= data.length
          require 9 <= data.length
      else:
          if 0 < data.length:
              if 0 >= data.length:
                  revert with 0, 1
              if 0 >= data.length:
                  revert with 0, 50
              require 1 <= data.length
          else:
              if not data.length:
                  stop
              if data.length > data.length:
                  revert with 0, 17
              if 0 > data.length:
                  revert with 0, 17
              require data.length <= data.length
              if data.length > LOCK8605463013():
                  revert with 0, 65
  else:
      if 0xa58e81fe9b61b5c3fe2afd33cf304c454abfc7cb == caller:
          if data.length > 0:
              if 0 >= data.length:
                  revert with 0, 1
              if 0 >= data.length:
                  revert with 0, 50
              require 3 <= data.length
              require 5 <= data.length
          else:
              if 0 < data.length:
                  if 0 >= data.length:
                      revert with 0, 1
                  if 0 >= data.length:
                      revert with 0, 50
                  require 1 <= data.length
              else:
                  if not data.length:
                      stop
                  if data.length > data.length:
                      revert with 0, 17
                  if 0 > data.length:
                      revert with 0, 17
                  require data.length <= data.length
                  if data.length > LOCK8605463013():
                      revert with 0, 65
      else:
          mem[100] = node
          static call 0xc2e074ec69a0dfb2997ba6c7d2e1e.owner(bytes32 node) with:
                  gas gas_remaining wei
                 args node
          mem[96] = ext_call.return_data[0]
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          require return_data.size >=′ 32
          require ext_call.return_data[0] == ext_call.return_data[12 len 20]
          if ext_call.return_data[12 len 20] - 0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401:
              if ext_call.return_data[12 len 20] != caller:
                  if not stor11[ext_call.return_data[12 len 20]][caller]:
                      require stor12[address(ext_call.return_data[0])][node][caller]
              if data.length > 0:
                  if 0 >= data.length:
                      revert with 0, 1
                  if 0 >= data.length:
                      revert with 0, 50
                  require 3 <= data.length
              else:
                  if 0 < data.length:
                      if 0 >= data.length:
                          revert with 0, 1
                      if 0 >= data.length:
                          revert with 0, 50
                      require 1 <= data.length
                  else:
                      if not ext_call.return_data[0]:
                          stop
                      if data.length > data.length:
                          revert with 0, 17
                      if 0 > data.length:
                          revert with 0, 17
                      require data.length <= data.length
                      if data.length > LOCK8605463013():
                          revert with 0, 65
          else:
              mem[ceil32(return_data.size) + 100] = node
              static call 0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401.ownerOf(uint256 tokenId) with:
                      gas gas_remaining wei
                     args node
              mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 32
              require ext_call.return_data[0] == ext_call.return_data[12 len 20]
              if caller == ext_call.return_data[12 len 20]:
                  mem[(2 * ceil32(return_data.size)) + 96] = data.length
                  mem[(2 * ceil32(return_data.size)) + 128 len data.length] = data[all]
                  mem[(2 * ceil32(return_data.size)) + data.length + 128] = 0
                  mem[(2 * ceil32(return_data.size)) + ceil32(data.length) + 192] = 0
                  mem[(2 * ceil32(return_data.size)) + ceil32(data.length) + 224] = 0
                  mem[(2 * ceil32(return_data.size)) + ceil32(data.length) + 256] = 0
                  mem[(2 * ceil32(return_data.size)) + ceil32(data.length) + 288] = 0
                  mem[(2 * ceil32(return_data.size)) + ceil32(data.length) + 128] = (2 * ceil32(return_data.size)) + 96
                  mem[(2 * ceil32(return_data.size)) + ceil32(data.length) + 320] = 0
                  mem[(2 * ceil32(return_data.size)) + ceil32(data.length) + 160] = 0
                  if data.length > 0:
                      if 0 >= data.length:
                          revert with 0, 1
                      if 0 >= data.length:
                          revert with 0, 50
                  else:
                      if 0 < data.length:
                          if 0 >= data.length:
                              revert with 0, 1
                          if 0 >= data.length:
                              revert with 0, 50
                      else:
                          if not ext_call.return_data[0]:
                              stop
                          mem[(2 * ceil32(return_data.size)) + ceil32(data.length) + 352] = data.length
                          mem[(2 * ceil32(return_data.size)) + ceil32(data.length) + 384 len data.length] = data[all]
                          mem[(2 * ceil32(return_data.size)) + ceil32(data.length) + data.length + 384] = 0
                          if data.length > data.length:
                              revert with 0, 17
                          if 0 > data.length:
                              revert with 0, 17
                          require data.length <= data.length
                          if data.length > LOCK8605463013():
                              revert with 0, 65
                          if data.length:
                              if data.length < 32:
                                  if stor5[stor0[node]][node][sha3(mem[128 len ext_call.return_data[0]])][0].field_0:
                                      if not stor5[stor0[node]][node][sha3(mem[128 len ext_call.return_data[0]])][0].field_0 - (uint255(stor5[stor0[node]][node][sha3(mem[128 len ext_call.return_data[0]])][0].field_0) * 0.5 < 32):
                                          revert with 0, 34
                                  else:
                          else:
                              if data.length < 32:
                                  if not ext_call.return_data[0]:
                                  if not stor5[stor0[node]][node][sha3(mem[128 len ext_call.return_data[0]])][0].field_0:
                                      if not stor5[stor0[node]][node][sha3(mem[128 len ext_call.return_data[0]])][0].field_0 - (stor5[stor0[node]][node][sha3(mem[128 len ext_call.return_data[0]])][0].field_1 < 32):
                                          revert with 0, 34
                                  else:
                                      if not stor5[stor0[node]][node][sha3(mem[128 len ext_call.return_data[0]])][0].field_0 - (uint255(stor5[stor0[node]][node][sha3(mem[128 len ext_call.return_data[0]])][0].field_0) * 0.5 < 32):
                                          revert with 0, 34
              else:
                  if stor11[ext_call.return_data[12 len 20]][caller]:
                      mem[(2 * ceil32(return_data.size)) + 96] = data.length
                      mem[(2 * ceil32(return_data.size)) + 128 len data.length] = data[all]
                      mem[(2 * ceil32(return_data.size)) + data.length + 128] = 0
                      mem[(2 * ceil32(return_data.size)) + ceil32(data.length) + 192] = 0
                      mem[(2 * ceil32(return_data.size)) + ceil32(data.length) + 224] = 0
                      mem[(2 * ceil32(return_data.size)) + ceil32(data.length) + 256] = 0
                      mem[(2 * ceil32(return_data.size)) + ceil32(data.length) + 288] = 0
                      mem[(2 * ceil32(return_data.size)) + ceil32(data.length) + 128] = (2 * ceil32(return_data.size)) + 96
                      mem[(2 * ceil32(return_data.size)) + ceil32(data.length) + 320] = 0
                      mem[(2 * ceil32(return_data.size)) + ceil32(data.length) + 160] = 0
                      if data.length > 0:
                          if 0 >= data.length:
                              revert with 0, 1
                          if 0 >= data.length:
                              revert with 0, 50
                      else:
                          if 0 < data.length:
                              if 0 >= data.length:
                                  revert with 0, 1
                              if 0 >= data.length:
                                  revert with 0, 50
                          else:
                              if not ext_call.return_data[0]:
                                  stop
                              mem[(2 * ceil32(return_data.size)) + ceil32(data.length) + 352] = data.length
                              mem[(2 * ceil32(return_data.size)) + ceil32(data.length) + 384 len data.length] = data[all]
                              mem[(2 * ceil32(return_data.size)) + ceil32(data.length) + data.length + 384] = 0
                              if data.length > data.length:
                                  revert with 0, 17
                              if 0 > data.length:
                                  revert with 0, 17
                              require data.length <= data.length
                              if data.length > LOCK8605463013():
                                  revert with 0, 65
                              if not data.length:
                                  if data.length < 32:
                                      if stor5[stor0[node]][node][sha3(mem[128 len ext_call.return_data[0]])][0].field_0:
                                          if not stor5[stor0[node]][node][sha3(mem[128 len ext_call.return_data[0]])][0].field_0 - (uint255(stor5[stor0[node]][node][sha3(mem[128 len ext_call.return_data[0]])][0].field_0) * 0.5 < 32):
                                              revert with 0, 34
                                      else:
                              else:
                                  if data.length < 32:
                                      if stor5[stor0[node]][node][sha3(mem[128 len ext_call.return_data[0]])][0].field_0:
                  else:
                      require stor12[address(ext_call.return_data[0])][node][caller]
                      mem[(2 * ceil32(return_data.size)) + 96] = data.length
                      mem[(2 * ceil32(return_data.size)) + 128 len data.length] = data[all]
                      mem[(2 * ceil32(return_data.size)) + data.length + 128] = 0
                      mem[(2 * ceil32(return_data.size)) + ceil32(data.length) + 192] = 0
                      mem[(2 * ceil32(return_data.size)) + ceil32(data.length) + 224] = 0
                      mem[(2 * ceil32(return_data.size)) + ceil32(data.length) + 256] = 0
                      mem[(2 * ceil32(return_data.size)) + ceil32(data.length) + 288] = 0
                      mem[(2 * ceil32(return_data.size)) + ceil32(data.length) + 128] = (2 * ceil32(return_data.size)) + 96
                      mem[(2 * ceil32(return_data.size)) + ceil32(data.length) + 320] = 0
                      mem[(2 * ceil32(return_data.size)) + ceil32(data.length) + 160] = 0
                      if data.length > 0:
                          if 0 >= data.length:
                              revert with 0, 1
                          if 0 >= data.length:
                              revert with 0, 50
                      else:
                          if 0 < data.length:
                              if 0 >= data.length:
                                  revert with 0, 1
                              if 0 >= data.length:
                                  revert with 0, 50
                          else:
                              if not ext_call.return_data[0]:
                                  stop
                              mem[(2 * ceil32(return_data.size)) + ceil32(data.length) + 352] = data.length
                              mem[(2 * ceil32(return_data.size)) + ceil32(data.length) + 384 len data.length] = data[all]
                              mem[(2 * ceil32(return_data.size)) + ceil32(data.length) + data.length + 384] = 0
                              if data.length > data.length:
                                  revert with 0, 17
                              if 0 > data.length:
                                  revert with 0, 17
                              require data.length <= data.length
                              if data.length > LOCK8605463013():
                                  revert with 0, 65
                              if data.length:
                                  if data.length < 32:
                              else:
                                  if data.length < 32:
                                      if stor5[stor0[node]][node][sha3(mem[128 len ext_call.return_data[0]])][0].field_0:
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def interfaceImplementer(bytes32 node, bytes4 interfaceID) payable: 
  require calldata.size - 4 >=′ 64
  require interfaceID == Mask(32, 224, interfaceID)
  if stor7[stor0[node]][node][Mask(32, 224, interfaceID)]:
      return stor7[stor0[node]][node][Mask(32, 224, interfaceID)]
  if stor2[stor0[node]][node][60].field_0:
      if not stor2[stor0[node]][node][60].field_0 - (uint255(stor2[stor0[node]][node][60].field_0) * 0.5 < 32):
          revert with 0, 34
      if stor2[stor0[node]][node][60].field_0:
          if not stor2[stor0[node]][node][60].field_0 - (uint255(stor2[stor0[node]][node][60].field_0) * 0.5 < 32):
              revert with 0, 34
          if Mask(256, -1, stor2[stor0[node]][node][60].field_0):
              if 31 < uint255(stor2[stor0[node]][node][60].field_0) * 0.5:
                  mem[128] = stor2[stor0[node]][node][60].field_0
                  idx = 128
                  s = 0
                  while (uint255(stor2[stor0[node]][node][60].field_0) * 0.5) + 96 > idx:
                      mem[idx + 32] = stor2[stor0[node]][node][60][s].field_256
                      idx = idx + 32
                      s = s + 1
                      continue 
                  if -uint255(stor2[stor0[node]][node][60].field_0) * 0.5:
                      require 20 == uint255(stor2[stor0[node]][node][60].field_0) * 0.5
                      if mem[128 len 20]:
                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              else:
                  if -uint255(stor2[stor0[node]][node][60].field_0) * 0.5:
                      require 20 == uint255(stor2[stor0[node]][node][60].field_0) * 0.5
                      if stor2[stor0[node]][node][60].field_96:
                          mem[ceil32(uint255(stor2[stor0[node]][node][60].field_0) * 0.5) + 196 len 64] = supportsInterface(bytes4 interfaceId), 0x1ffc9a70000000000000000000000000000000000000000, 0, mem[ceil32(uint255(stor2[stor0[node]][node][60].field_0) * 0.5) + 196 len 28]
                          static call stor2[stor0[node]][node][60].field_96.mem[ceil32(uint255(stor2[stor0[node]][node][60].field_0) * 0.5) + 196 len 4] with:
                                  gas gas_remaining wei
                                 args mem[ceil32(uint255(stor2[stor0[node]][node][60].field_0) * 0.5) + 200]
                          if not return_data.size:
                              if ext_call.success:
                                  if uint255(stor2[stor0[node]][node][60].field_0) * 0.5 >= 32:
                                      if 31 >= uint255(stor2[stor0[node]][node][60].field_0) * 0.5:
                                          revert with 0, 50
                          else:
                              if ext_call.success:
                                  if return_data.size >= 32:
                                      if 31 >= return_data.size:
                                          revert with 0, 50
          else:
              if -uint255(stor2[stor0[node]][node][60].field_0) * 0.5:
                  require 20 == uint255(stor2[stor0[node]][node][60].field_0) * 0.5
                  _23 = mem[128]
                  if mem[128 len 20]:
                      mem[ceil32(uint255(stor2[stor0[node]][node][60].field_0) * 0.5) + 128] = 36
                      mem[ceil32(uint255(stor2[stor0[node]][node][60].field_0) * 0.5) + 164 len 28] = 0x1ffc9a7000000000000000000000000000000000000000000000000
                      mem[ceil32(uint255(stor2[stor0[node]][node][60].field_0) * 0.5) + 160 len 4] = supportsInterface(bytes4 interfaceId)
                      mem[ceil32(uint255(stor2[stor0[node]][node][60].field_0) * 0.5) + 196 len 64] = supportsInterface(bytes4 interfaceId), 0x1ffc9a70000000000000000000000000000000000000000, 0, mem[ceil32(uint255(stor2[stor0[node]][node][60].field_0) * 0.5) + 196 len 28]
                      static call Mask(160, 96, _23) >> 96.mem[ceil32(uint255(stor2[stor0[node]][node][60].field_0) * 0.5) + 196 len 4] with:
                              gas gas_remaining wei
                             args mem[ceil32(uint255(stor2[stor0[node]][node][60].field_0) * 0.5) + 200]
                      if return_data.size:
                          if ext_call.success:
                              if return_data.size >= 32:
                                  if 31 >= return_data.size:
                                      revert with 0, 50
                      else:
                          if ext_call.success:
                              if uint255(stor2[stor0[node]][node][60].field_0) * 0.5 >= 32:
                                  if 31 >= uint255(stor2[stor0[node]][node][60].field_0) * 0.5:
                                      revert with 0, 50
                                  if Mask(8, 248, mem[159]):
                                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
      else:
          if not stor2[stor0[node]][node][60].field_0 - (stor2[stor0[node]][node][60].field_1 < 32):
              revert with 0, 34
          if stor2[stor0[node]][node][60].field_1:
              if 31 < stor2[stor0[node]][node][60].field_1:
                  mem[128] = stor2[stor0[node]][node][60].field_0
                  idx = 128
                  s = 0
                  while stor2[stor0[node]][node][60].field_1 + 96 > idx:
                      mem[idx + 32] = stor2[stor0[node]][node][60][s].field_256
                      idx = idx + 32
                      s = s + 1
                      continue 
                  if -uint255(stor2[stor0[node]][node][60].field_0) * 0.5:
                      require 20 == uint255(stor2[stor0[node]][node][60].field_0) * 0.5
                      if mem[128 len 20]:
                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              else:
                  if -uint255(stor2[stor0[node]][node][60].field_0) * 0.5:
                      require 20 == uint255(stor2[stor0[node]][node][60].field_0) * 0.5
                      if stor2[stor0[node]][node][60].field_96:
                          mem[ceil32(uint255(stor2[stor0[node]][node][60].field_0) * 0.5) + 196 len 64] = supportsInterface(bytes4 interfaceId), 0x1ffc9a70000000000000000000000000000000000000000, 0, mem[ceil32(uint255(stor2[stor0[node]][node][60].field_0) * 0.5) + 196 len 28]
                          static call stor2[stor0[node]][node][60].field_96.mem[ceil32(uint255(stor2[stor0[node]][node][60].field_0) * 0.5) + 196 len 4] with:
                                  gas gas_remaining wei
                                 args mem[ceil32(uint255(stor2[stor0[node]][node][60].field_0) * 0.5) + 200]
                          if not return_data.size:
                              if ext_call.success:
                                  if uint255(stor2[stor0[node]][node][60].field_0) * 0.5 >= 32:
                                      if 31 >= uint255(stor2[stor0[node]][node][60].field_0) * 0.5:
                                          revert with 0, 50
                          else:
                              if ext_call.success:
                                  if return_data.size >= 32:
                                      if 31 >= return_data.size:
                                          revert with 0, 50
          else:
              if -uint255(stor2[stor0[node]][node][60].field_0) * 0.5:
                  require 20 == uint255(stor2[stor0[node]][node][60].field_0) * 0.5
                  _30 = mem[128]
                  if mem[128 len 20]:
                      mem[ceil32(uint255(stor2[stor0[node]][node][60].field_0) * 0.5) + 128] = 36
                      mem[ceil32(uint255(stor2[stor0[node]][node][60].field_0) * 0.5) + 164 len 28] = 0x1ffc9a7000000000000000000000000000000000000000000000000
                      mem[ceil32(uint255(stor2[stor0[node]][node][60].field_0) * 0.5) + 160 len 4] = supportsInterface(bytes4 interfaceId)
                      mem[ceil32(uint255(stor2[stor0[node]][node][60].field_0) * 0.5) + 196 len 64] = supportsInterface(bytes4 interfaceId), 0x1ffc9a70000000000000000000000000000000000000000, 0, mem[ceil32(uint255(stor2[stor0[node]][node][60].field_0) * 0.5) + 196 len 28]
                      static call Mask(160, 96, _30) >> 96.mem[ceil32(uint255(stor2[stor0[node]][node][60].field_0) * 0.5) + 196 len 4] with:
                              gas gas_remaining wei
                             args mem[ceil32(uint255(stor2[stor0[node]][node][60].field_0) * 0.5) + 200]
                      if return_data.size:
                          if ext_call.success:
                              if return_data.size >= 32:
                                  if 31 >= return_data.size:
                                      revert with 0, 50
                      else:
                          if ext_call.success:
                              if uint255(stor2[stor0[node]][node][60].field_0) * 0.5 >= 32:
                                  if 31 >= uint255(stor2[stor0[node]][node][60].field_0) * 0.5:
                                      revert with 0, 50
                                  if Mask(8, 248, mem[159]):
                                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
  else:
      if not stor2[stor0[node]][node][60].field_0 - (stor2[stor0[node]][node][60].field_1 < 32):
          revert with 0, 34
      if stor2[stor0[node]][node][60].field_0:
          if not stor2[stor0[node]][node][60].field_0 - (uint255(stor2[stor0[node]][node][60].field_0) * 0.5 < 32):
              revert with 0, 34
          if Mask(256, -1, stor2[stor0[node]][node][60].field_0):
              if 31 < uint255(stor2[stor0[node]][node][60].field_0) * 0.5:
                  mem[128] = stor2[stor0[node]][node][60].field_0
                  idx = 128
                  s = 0
                  while (uint255(stor2[stor0[node]][node][60].field_0) * 0.5) + 96 > idx:
                      mem[idx + 32] = stor2[stor0[node]][node][60][s].field_256
                      idx = idx + 32
                      s = s + 1
                      continue 
                  if -stor2[stor0[node]][node][60].field_1:
                      require 20 == stor2[stor0[node]][node][60].field_1
                      if mem[128 len 20]:
                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              else:
                  if -stor2[stor0[node]][node][60].field_1:
                      require 20 == stor2[stor0[node]][node][60].field_1
                      if stor2[stor0[node]][node][60].field_96:
                          mem[ceil32(stor2[stor0[node]][node][60].field_1) + 196 len 64] = supportsInterface(bytes4 interfaceId), 0x1ffc9a70000000000000000000000000000000000000000, 0, mem[ceil32(stor2[stor0[node]][node][60].field_1) + 196 len 28]
                          static call stor2[stor0[node]][node][60].field_96.mem[ceil32(stor2[stor0[node]][node][60].field_1) + 196 len 4] with:
                                  gas gas_remaining wei
                                 args mem[ceil32(stor2[stor0[node]][node][60].field_1) + 200]
                          if not return_data.size:
                              if ext_call.success:
                                  if stor2[stor0[node]][node][60].field_1 >= 32:
                                      if 31 >= stor2[stor0[node]][node][60].field_1:
                                          revert with 0, 50
                          else:
                              if ext_call.success:
                                  if return_data.size >= 32:
                                      if 31 >= return_data.size:
                                          revert with 0, 50
          else:
              if -stor2[stor0[node]][node][60].field_1:
                  require 20 == stor2[stor0[node]][node][60].field_1
                  _31 = mem[128]
                  if mem[128 len 20]:
                      mem[ceil32(stor2[stor0[node]][node][60].field_1) + 128] = 36
                      mem[ceil32(stor2[stor0[node]][node][60].field_1) + 164 len 28] = 0x1ffc9a7000000000000000000000000000000000000000000000000
                      mem[ceil32(stor2[stor0[node]][node][60].field_1) + 160 len 4] = supportsInterface(bytes4 interfaceId)
                      mem[ceil32(stor2[stor0[node]][node][60].field_1) + 196 len 64] = supportsInterface(bytes4 interfaceId), 0x1ffc9a70000000000000000000000000000000000000000, 0, mem[ceil32(stor2[stor0[node]][node][60].field_1) + 196 len 28]
                      static call Mask(160, 96, _31) >> 96.mem[ceil32(stor2[stor0[node]][node][60].field_1) + 196 len 4] with:
                              gas gas_remaining wei
                             args mem[ceil32(stor2[stor0[node]][node][60].field_1) + 200]
                      if return_data.size:
                          if ext_call.success:
                              if return_data.size >= 32:
                                  if 31 >= return_data.size:
                                      revert with 0, 50
                      else:
                          if ext_call.success:
                              if stor2[stor0[node]][node][60].field_1 >= 32:
                                  if 31 >= stor2[stor0[node]][node][60].field_1:
                                      revert with 0, 50
                                  if Mask(8, 248, mem[159]):
                                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
      else:
          if not stor2[stor0[node]][node][60].field_0 - (stor2[stor0[node]][node][60].field_1 < 32):
              revert with 0, 34
          if stor2[stor0[node]][node][60].field_1:
              if 31 < stor2[stor0[node]][node][60].field_1:
                  mem[128] = stor2[stor0[node]][node][60].field_0
                  idx = 128
                  s = 0
                  while stor2[stor0[node]][node][60].field_1 + 96 > idx:
                      mem[idx + 32] = stor2[stor0[node]][node][60][s].field_256
                      idx = idx + 32
                      s = s + 1
                      continue 
                  if -stor2[stor0[node]][node][60].field_1:
                      require 20 == stor2[stor0[node]][node][60].field_1
                      if mem[128 len 20]:
                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              else:
                  if -stor2[stor0[node]][node][60].field_1:
                      require 20 == stor2[stor0[node]][node][60].field_1
                      if stor2[stor0[node]][node][60].field_96:
                          mem[ceil32(stor2[stor0[node]][node][60].field_1) + 196 len 64] = supportsInterface(bytes4 interfaceId), 0x1ffc9a70000000000000000000000000000000000000000, 0, mem[ceil32(stor2[stor0[node]][node][60].field_1) + 196 len 28]
                          static call stor2[stor0[node]][node][60].field_96.mem[ceil32(stor2[stor0[node]][node][60].field_1) + 196 len 4] with:
                                  gas gas_remaining wei
                                 args mem[ceil32(stor2[stor0[node]][node][60].field_1) + 200]
                          if not return_data.size:
                              if ext_call.success:
                                  if stor2[stor0[node]][node][60].field_1 >= 32:
                                      if 31 >= stor2[stor0[node]][node][60].field_1:
                                          revert with 0, 50
                          else:
                              if ext_call.success:
                                  if return_data.size >= 32:
                                      if 31 >= return_data.size:
                                          revert with 0, 50
          else:
              if -stor2[stor0[node]][node][60].field_1:
                  require 20 == stor2[stor0[node]][node][60].field_1
                  _40 = mem[128]
                  if mem[128 len 20]:
                      mem[ceil32(stor2[stor0[node]][node][60].field_1) + 128] = 36
                      mem[ceil32(stor2[stor0[node]][node][60].field_1) + 164 len 28] = 0x1ffc9a7000000000000000000000000000000000000000000000000
                      mem[ceil32(stor2[stor0[node]][node][60].field_1) + 160 len 4] = supportsInterface(bytes4 interfaceId)
                      mem[ceil32(stor2[stor0[node]][node][60].field_1) + 196 len 64] = supportsInterface(bytes4 interfaceId), 0x1ffc9a70000000000000000000000000000000000000000, 0, mem[ceil32(stor2[stor0[node]][node][60].field_1) + 196 len 28]
                      static call Mask(160, 96, _40) >> 96.mem[ceil32(stor2[stor0[node]][node][60].field_1) + 196 len 4] with:
                              gas gas_remaining wei
                             args mem[ceil32(stor2[stor0[node]][node][60].field_1) + 200]
                      if return_data.size:
                          if ext_call.success:
                              if return_data.size >= 32:
                                  if 31 >= return_data.size:
                                      revert with 0, 50
                      else:
                          if ext_call.success:
                              if stor2[stor0[node]][node][60].field_1 >= 32:
                                  if 31 >= stor2[stor0[node]][node][60].field_1:
                                      revert with 0, 50
                                  if Mask(8, 248, mem[159]):
                                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
  return 0

def setText(bytes32 node, string key, string value) payable: 
  require calldata.size - 4 >=′ 96
  require key <= LOCK8605463013()
  require key + 35 <′ calldata.size
  require key.length <= LOCK8605463013()
  require key + key.length + 36 <= calldata.size
  require value <= LOCK8605463013()
  require value + 35 <′ calldata.size
  require value.length <= LOCK8605463013()
  require value + value.length + 36 <= calldata.size
  if 0x253553366da8546fc250f225fe3d25d0c782303b == caller:
      if value.length > LOCK8605463013():
          revert with 0, 65
      if stor10[stor0[node]][node][key[all]].field_0:
          if not stor10[stor0[node]][node][key[all]].field_0 - (uint255(stor10[stor0[node]][node][key[all]].field_0) * 0.5 < 32):
              revert with 0, 34
          if uint255(stor10[stor0[node]][node][key[all]].field_0) * 0.5 > 31:
              if value.length >= 32:
                  idx = Mask(251, 0, value.length + 31) * 0.03125
                  while idx < Mask(251, 0, (uint255(stor10[stor0[node]][node][key[all]].field_0) * 0.5) + 31) * 0.03125:
                      stor10[stor0[node]][node][key[all]][idx].field_0 = 0
                      idx = idx + 1
                      continue 
              else:
                  idx = 0
                  while idx < Mask(251, 0, (uint255(stor10[stor0[node]][node][key[all]].field_0) * 0.5) + 31) * 0.03125:
                      stor10[stor0[node]][node][key[all]][idx].field_0 = 0
                      idx = idx + 1
                      continue 
              if value.length > 31 != 1:
                  if not value.length:
                      stor10[stor0[node]][node][key[all]].field_0 = 2 * value.length
                  else:
                      stor10[stor0[node]][node][key[all]].field_0 = value.length
              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
      else:
          if not stor10[stor0[node]][node][key[all]].field_0 - (stor10[stor0[node]][node][key[all]].field_1 < 32):
              revert with 0, 34
          if stor10[stor0[node]][node][key[all]].field_1 > 31:
              if value.length >= 32:
                  idx = Mask(251, 0, value.length + 31) * 0.03125
                  while idx < Mask(251, 0, stor10[stor0[node]][node][key[all]].field_1 + 31) * 0.03125:
                      stor10[stor0[node]][node][key[all]][idx].field_0 = 0
                      idx = idx + 1
                      continue 
              else:
                  idx = 0
                  while idx < Mask(251, 0, stor10[stor0[node]][node][key[all]].field_1 + 31) * 0.03125:
                      stor10[stor0[node]][node][key[all]][idx].field_0 = 0
                      idx = idx + 1
                      continue 
              if value.length > 31 != 1:
                  if not value.length:
                      stor10[stor0[node]][node][key[all]].field_0 = 2 * value.length
                  else:
                      stor10[stor0[node]][node][key[all]].field_0 = value.length
              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
      if value.length > 31 != 1:
          if not value.length:
              stor10[stor0[node]][node][key[all]].field_0 = 2 * value.length
          else:
              stor10[stor0[node]][node][key[all]].field_0 = value.length
      else:
          idx = 0
          s = 0
          t = 0
          while idx < floor32(value.length):
              stor10[stor0[node]][node][key[all]][s].field_0 = cd[(t + value + 36)]
              idx = idx + 32
              s = s + 1
              t = t + 32
              continue 
          if floor32(value.length) < value.length:
              stor10[stor0[node]][node][key[all]][Mask(251, 0, floor32(value.length) + 31) >> 5].field_0 = cd[(value + ceil32(floor32(value.length)) + 36)] and !(Mask(256, -8 * value.length % 32, -1) >> 8 * value.length % 32)
          stor10[stor0[node]][node][key[all]].field_0 = (2 * value.length) + 1
      mem[ceil32(key.length) + 192] = value.length
      mem[ceil32(key.length) + 224 len value.length] = value[all]
      mem[value.length + ceil32(key.length) + 224] = 0
      log TextChanged(bytes32 node, string indexedKey, string key, string value):
                      64,
                      ceil32(key.length) + 96,
                      key.length,
                      key[all],
                      0,
                      mem[key.length + 224 len ceil32(key.length) + ceil32(value.length) - key.length],
                      node,
                      sha3(key[all]),
  else:
      if 0xa58e81fe9b61b5c3fe2afd33cf304c454abfc7cb == caller:
          if value.length > LOCK8605463013():
              revert with 0, 65
          if stor10[stor0[node]][node][key[all]].field_0:
              if not stor10[stor0[node]][node][key[all]].field_0 - (uint255(stor10[stor0[node]][node][key[all]].field_0) * 0.5 < 32):
                  revert with 0, 34
              if uint255(stor10[stor0[node]][node][key[all]].field_0) * 0.5 > 31:
                  if value.length >= 32:
                      idx = Mask(251, 0, value.length + 31) * 0.03125
                      while idx < Mask(251, 0, (uint255(stor10[stor0[node]][node][key[all]].field_0) * 0.5) + 31) * 0.03125:
                          stor10[stor0[node]][node][key[all]][idx].field_0 = 0
                          idx = idx + 1
                          continue 
                  else:
                      idx = 0
                      while idx < Mask(251, 0, (uint255(stor10[stor0[node]][node][key[all]].field_0) * 0.5) + 31) * 0.03125:
                          stor10[stor0[node]][node][key[all]][idx].field_0 = 0
                          idx = idx + 1
                          continue 
                  if value.length > 31 != 1:
                      if not value.length:
                          stor10[stor0[node]][node][key[all]].field_0 = 2 * value.length
                      else:
                          stor10[stor0[node]][node][key[all]].field_0 = value.length
                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
          else:
              if not stor10[stor0[node]][node][key[all]].field_0 - (stor10[stor0[node]][node][key[all]].field_1 < 32):
                  revert with 0, 34
              if stor10[stor0[node]][node][key[all]].field_1 > 31:
                  if value.length >= 32:
                      idx = Mask(251, 0, value.length + 31) * 0.03125
                      while idx < Mask(251, 0, stor10[stor0[node]][node][key[all]].field_1 + 31) * 0.03125:
                          stor10[stor0[node]][node][key[all]][idx].field_0 = 0
                          idx = idx + 1
                          continue 
                  else:
                      idx = 0
                      while idx < Mask(251, 0, stor10[stor0[node]][node][key[all]].field_1 + 31) * 0.03125:
                          stor10[stor0[node]][node][key[all]][idx].field_0 = 0
                          idx = idx + 1
                          continue 
                  if value.length > 31 != 1:
                      if not value.length:
                          stor10[stor0[node]][node][key[all]].field_0 = 2 * value.length
                      else:
                          stor10[stor0[node]][node][key[all]].field_0 = value.length
                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
          if value.length > 31 != 1:
              if not value.length:
                  stor10[stor0[node]][node][key[all]].field_0 = 2 * value.length
              else:
                  stor10[stor0[node]][node][key[all]].field_0 = value.length
          else:
              idx = 0
              s = 0
              t = 0
              while idx < floor32(value.length):
                  stor10[stor0[node]][node][key[all]][s].field_0 = cd[(t + value + 36)]
                  idx = idx + 32
                  s = s + 1
                  t = t + 32
                  continue 
              if floor32(value.length) < value.length:
                  stor10[stor0[node]][node][key[all]][Mask(251, 0, floor32(value.length) + 31) >> 5].field_0 = cd[(value + ceil32(floor32(value.length)) + 36)] and !(Mask(256, -8 * value.length % 32, -1) >> 8 * value.length % 32)
              stor10[stor0[node]][node][key[all]].field_0 = (2 * value.length) + 1
          mem[ceil32(key.length) + 192] = value.length
          mem[ceil32(key.length) + 224 len value.length] = value[all]
          mem[value.length + ceil32(key.length) + 224] = 0
          log TextChanged(bytes32 node, string indexedKey, string key, string value):
                          64,
                          ceil32(key.length) + 96,
                          key.length,
                          key[all],
                          0,
                          mem[key.length + 224 len ceil32(key.length) + ceil32(value.length) - key.length],
                          node,
                          sha3(key[all]),
      else:
          static call 0xc2e074ec69a0dfb2997ba6c7d2e1e.owner(bytes32 node) with:
                  gas gas_remaining wei
                 args node
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          require return_data.size >=′ 32
          require ext_call.return_data[0] == ext_call.return_data[12 len 20]
          if ext_call.return_data[12 len 20] - 0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401:
              if ext_call.return_data[12 len 20] != caller:
                  if not stor11[ext_call.return_data[12 len 20]][caller]:
                      require stor12[address(ext_call.return_data[0])][node][caller]
              if value.length > LOCK8605463013():
                  revert with 0, 65
              if stor10[stor0[node]][node][key[all]].field_0:
                  if not stor10[stor0[node]][node][key[all]].field_0 - (uint255(stor10[stor0[node]][node][key[all]].field_0) * 0.5 < 32):
                      revert with 0, 34
                  if uint255(stor10[stor0[node]][node][key[all]].field_0) * 0.5 > 31:
                      if value.length >= 32:
                          idx = Mask(251, 0, value.length + 31) * 0.03125
                          while idx < Mask(251, 0, (uint255(stor10[stor0[node]][node][key[all]].field_0) * 0.5) + 31) * 0.03125:
                              stor10[stor0[node]][node][key[all]][idx].field_0 = 0
                              idx = idx + 1
                              continue 
                      else:
                          idx = 0
                          while idx < Mask(251, 0, (uint255(stor10[stor0[node]][node][key[all]].field_0) * 0.5) + 31) * 0.03125:
                              stor10[stor0[node]][node][key[all]][idx].field_0 = 0
                              idx = idx + 1
                              continue 
                      if value.length > 31 != 1:
                          if not value.length:
                              stor10[stor0[node]][node][key[all]].field_0 = 2 * value.length
                          else:
                              stor10[stor0[node]][node][key[all]].field_0 = value.length
                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              else:
                  if not stor10[stor0[node]][node][key[all]].field_0 - (stor10[stor0[node]][node][key[all]].field_1 < 32):
                      revert with 0, 34
                  if stor10[stor0[node]][node][key[all]].field_1 > 31:
                      if value.length >= 32:
                          idx = Mask(251, 0, value.length + 31) * 0.03125
                          while idx < Mask(251, 0, stor10[stor0[node]][node][key[all]].field_1 + 31) * 0.03125:
                              stor10[stor0[node]][node][key[all]][idx].field_0 = 0
                              idx = idx + 1
                              continue 
                      else:
                          idx = 0
                          while idx < Mask(251, 0, stor10[stor0[node]][node][key[all]].field_1 + 31) * 0.03125:
                              stor10[stor0[node]][node][key[all]][idx].field_0 = 0
                              idx = idx + 1
                              continue 
                      if value.length > 31 != 1:
                          if not value.length:
                              stor10[stor0[node]][node][key[all]].field_0 = 2 * value.length
                          else:
                              stor10[stor0[node]][node][key[all]].field_0 = value.length
                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              if value.length > 31 != 1:
                  if not value.length:
                      stor10[stor0[node]][node][key[all]].field_0 = 2 * value.length
                  else:
                      stor10[stor0[node]][node][key[all]].field_0 = value.length
              else:
                  idx = 0
                  s = 0
                  t = 0
                  while idx < floor32(value.length):
                      stor10[stor0[node]][node][key[all]][s].field_0 = cd[(t + value + 36)]
                      idx = idx + 32
                      s = s + 1
                      t = t + 32
                      continue 
                  if floor32(value.length) < value.length:
                      stor10[stor0[node]][node][key[all]][Mask(251, 0, floor32(value.length) + 31) >> 5].field_0 = cd[(value + ceil32(floor32(value.length)) + 36)] and !(Mask(256, -8 * value.length % 32, -1) >> 8 * value.length % 32)
                  stor10[stor0[node]][node][key[all]].field_0 = (2 * value.length) + 1
              mem[ceil32(return_data.size) + ceil32(key.length) + 192] = value.length
              mem[ceil32(return_data.size) + ceil32(key.length) + 224 len value.length] = value[all]
              mem[value.length + ceil32(return_data.size) + ceil32(key.length) + 224] = 0
              log TextChanged(bytes32 node, string indexedKey, string key, string value):
                              64,
                              ceil32(key.length) + 96,
                              key.length,
                              key[all],
                              0,
                              mem[ceil32(return_data.size) + key.length + 224 len ceil32(key.length) + ceil32(value.length) - key.length],
                              node,
                              sha3(key[all]),
          else:
              static call 0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401.ownerOf(uint256 tokenId) with:
                      gas gas_remaining wei
                     args node
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 32
              require ext_call.return_data[0] == ext_call.return_data[12 len 20]
              if ext_call.return_data[12 len 20] != caller:
                  if not stor11[ext_call.return_data[12 len 20]][caller]:
                      require stor12[address(ext_call.return_data[0])][node][caller]
              if value.length > LOCK8605463013():
                  revert with 0, 65
              if stor10[stor0[node]][node][key[all]].field_0:
                  if not stor10[stor0[node]][node][key[all]].field_0 - (uint255(stor10[stor0[node]][node][key[all]].field_0) * 0.5 < 32):
                      revert with 0, 34
                  if uint255(stor10[stor0[node]][node][key[all]].field_0) * 0.5 > 31:
                      if value.length >= 32:
                          idx = Mask(251, 0, value.length + 31) * 0.03125
                          while idx < Mask(251, 0, (uint255(stor10[stor0[node]][node][key[all]].field_0) * 0.5) + 31) * 0.03125:
                              stor10[stor0[node]][node][key[all]][idx].field_0 = 0
                              idx = idx + 1
                              continue 
                      else:
                          idx = 0
                          while idx < Mask(251, 0, (uint255(stor10[stor0[node]][node][key[all]].field_0) * 0.5) + 31) * 0.03125:
                              stor10[stor0[node]][node][key[all]][idx].field_0 = 0
                              idx = idx + 1
                              continue 
                      if value.length > 31 != 1:
                          if not value.length:
                              stor10[stor0[node]][node][key[all]].field_0 = 2 * value.length
                          else:
                              stor10[stor0[node]][node][key[all]].field_0 = value.length
                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              else:
                  if not stor10[stor0[node]][node][key[all]].field_0 - (stor10[stor0[node]][node][key[all]].field_1 < 32):
                      revert with 0, 34
                  if stor10[stor0[node]][node][key[all]].field_1 > 31:
                      if value.length >= 32:
                          idx = Mask(251, 0, value.length + 31) * 0.03125
                          while idx < Mask(251, 0, stor10[stor0[node]][node][key[all]].field_1 + 31) * 0.03125:
                              stor10[stor0[node]][node][key[all]][idx].field_0 = 0
                              idx = idx + 1
                              continue 
                      else:
                          idx = 0
                          while idx < Mask(251, 0, stor10[stor0[node]][node][key[all]].field_1 + 31) * 0.03125:
                              stor10[stor0[node]][node][key[all]][idx].field_0 = 0
                              idx = idx + 1
                              continue 
                      if value.length > 31 != 1:
                          if not value.length:
                              stor10[stor0[node]][node][key[all]].field_0 = 2 * value.length
                          else:
                              stor10[stor0[node]][node][key[all]].field_0 = value.length
                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              if value.length > 31 != 1:
                  if not value.length:
                      stor10[stor0[node]][node][key[all]].field_0 = 2 * value.length
                  else:
                      stor10[stor0[node]][node][key[all]].field_0 = value.length
              else:
                  idx = 0
                  s = 0
                  t = 0
                  while idx < floor32(value.length):
                      stor10[stor0[node]][node][key[all]][s].field_0 = cd[(t + value + 36)]
                      idx = idx + 32
                      s = s + 1
                      t = t + 32
                      continue 
                  if floor32(value.length) < value.length:
                      stor10[stor0[node]][node][key[all]][Mask(251, 0, floor32(value.length) + 31) >> 5].field_0 = cd[(value + ceil32(floor32(value.length)) + 36)] and !(Mask(256, -8 * value.length % 32, -1) >> 8 * value.length % 32)
                  stor10[stor0[node]][node][key[all]].field_0 = (2 * value.length) + 1
              mem[(2 * ceil32(return_data.size)) + ceil32(key.length) + 192] = value.length
              mem[(2 * ceil32(return_data.size)) + ceil32(key.length) + 224 len value.length] = value[all]
              mem[value.length + (2 * ceil32(return_data.size)) + ceil32(key.length) + 224] = 0
              log TextChanged(bytes32 node, string indexedKey, string key, string value):
                              64,
                              ceil32(key.length) + 96,
                              key.length,
                              key[all],
                              0,
                              mem[(2 * ceil32(return_data.size)) + key.length + 224 len ceil32(key.length) + ceil32(value.length) - key.length],
                              node,
                              sha3(key[all]),

def ABI(bytes32 node, uint256 contentTypes) payable: 
  mem[64] = 96
  require calldata.size - 4 >=′ 64
  mem[0] = node
  mem[32] = sha3(recordVersions[node], 1)
  idx = 1
  while idx <= contentTypes:
      if not contentTypes or not idx:
          idx = 2 * idx
          continue 
      mem[0] = idx
      mem[32] = sha3(node, sha3(recordVersions[node], 1))
      if stor1[stor0[node]][node][idx].field_0:
          if not stor1[stor0[node]][node][idx].field_0 - (uint255(stor1[stor0[node]][node][idx].field_0) * 0.5 < 32):
              revert with 0, 34
          if uint255(stor1[stor0[node]][node][idx].field_0) * 0.5 <= 0:
              idx = 2 * idx
              continue 
          mem[0] = idx
          mem[32] = sha3(node, sha3(recordVersions[node], 1))
          if stor1[stor0[node]][node][idx].field_0:
              if not stor1[stor0[node]][node][idx].field_0 - (uint255(stor1[stor0[node]][node][idx].field_0) * 0.5 < 32):
                  revert with 0, 34
              mem[64] = ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 128
              mem[96] = uint255(stor1[stor0[node]][node][idx].field_0) * 0.5
              if stor1[stor0[node]][node][idx].field_0:
                  if not stor1[stor0[node]][node][idx].field_0 - (uint255(stor1[stor0[node]][node][idx].field_0) * 0.5 < 32):
                      revert with 0, 34
                  if not Mask(256, -1, stor1[stor0[node]][node][idx].field_0):
                      mem[ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 128] = idx
                      mem[ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 160] = 64
                      mem[ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 192] = uint255(stor1[stor0[node]][node][idx].field_0) * 0.5
                      s = 0
                      while s < uint255(stor1[stor0[node]][node][idx].field_0) * 0.5:
                          mem[s + ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 224] = mem[s + 128]
                          s = s + 32
                          continue 
                      mem[(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 224] = 0
                      return idx, 
                             Array(len=2 * Mask(256, -1, stor1[stor0[node]][node][idx].field_0), data=mem[ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 224 len ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5)])
                  if 31 >= uint255(stor1[stor0[node]][node][idx].field_0) * 0.5:
                      mem[128] = 256 * stor1[stor0[node]][node][idx].field_8
                      mem[ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 128] = idx
                      mem[ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 160] = 64
                      mem[ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 192] = uint255(stor1[stor0[node]][node][idx].field_0) * 0.5
                      s = 0
                      while s < uint255(stor1[stor0[node]][node][idx].field_0) * 0.5:
                          mem[s + ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 224] = mem[s + 128]
                          s = s + 32
                          continue 
                      mem[(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 224] = 0
                      return idx, 
                             Array(len=2 * Mask(256, -1, stor1[stor0[node]][node][idx].field_0), data=mem[ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 224 len ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5)])
                  mem[128] = stor1[stor0[node]][node][idx].field_0
                  s = 128
                  t = sha3(sha3(idx, sha3(node, sha3(recordVersions[node], 1))))
                  while (uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 96 > s:
                      mem[s + 32] = stor1[t].field_0
                      s = s + 32
                      t = t + 1
                      continue 
                  mem[mem[64]] = idx
                  mem[mem[64] + 32] = 64
                  mem[mem[64] + 64] = uint255(stor1[stor0[node]][node][idx].field_0) * 0.5
                  s = 0
                  while s < uint255(stor1[stor0[node]][node][idx].field_0) * 0.5:
                      mem[s + mem[64] + 96] = mem[s + 128]
                      s = s + 32
                      continue 
                  mem[(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + mem[64] + 96] = 0
                  return idx, 
                         Array(len=2 * Mask(256, -1, stor1[stor0[node]][node][idx].field_0), data=mem[mem[64] + 96 len ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5)])
              if not stor1[stor0[node]][node][idx].field_0 - (stor1[stor0[node]][node][idx].field_1 < 32):
                  revert with 0, 34
              if not stor1[stor0[node]][node][idx].field_1:
                  mem[ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 128] = idx
                  mem[ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 160] = 64
                  mem[ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 192] = uint255(stor1[stor0[node]][node][idx].field_0) * 0.5
                  s = 0
                  while s < uint255(stor1[stor0[node]][node][idx].field_0) * 0.5:
                      mem[s + ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 224] = mem[s + 128]
                      s = s + 32
                      continue 
                  mem[(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 224] = 0
                  return idx, 
                         Array(len=2 * Mask(256, -1, stor1[stor0[node]][node][idx].field_0), data=mem[ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 224 len ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5)])
              if 31 >= stor1[stor0[node]][node][idx].field_1:
                  mem[128] = 256 * stor1[stor0[node]][node][idx].field_8
                  mem[ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 128] = idx
                  mem[ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 160] = 64
                  mem[ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 192] = uint255(stor1[stor0[node]][node][idx].field_0) * 0.5
                  s = 0
                  while s < uint255(stor1[stor0[node]][node][idx].field_0) * 0.5:
                      mem[s + ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 224] = mem[s + 128]
                      s = s + 32
                      continue 
                  mem[(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 224] = 0
                  return idx, 
                         Array(len=2 * Mask(256, -1, stor1[stor0[node]][node][idx].field_0), data=mem[ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 224 len ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5)])
              mem[128] = stor1[stor0[node]][node][idx].field_0
              s = 128
              t = sha3(sha3(idx, sha3(node, sha3(recordVersions[node], 1))))
              while stor1[stor0[node]][node][idx].field_1 + 96 > s:
                  mem[s + 32] = stor1[t].field_0
                  s = s + 32
                  t = t + 1
                  continue 
              _258 = mem[64]
              mem[mem[64]] = idx
              mem[mem[64] + 32] = 64
              mem[mem[64] + 64] = uint255(stor1[stor0[node]][node][idx].field_0) * 0.5
              s = 0
              while s < uint255(stor1[stor0[node]][node][idx].field_0) * 0.5:
                  mem[s + mem[64] + 96] = mem[s + 128]
                  s = s + 32
                  continue 
              mem[(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + _258 + 96] = 0
              return memory
                from mem[64]
                 len ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + _258 + -mem[64] + 96
          if not stor1[stor0[node]][node][idx].field_0 - (stor1[stor0[node]][node][idx].field_1 < 32):
              revert with 0, 34
          mem[64] = ceil32(stor1[stor0[node]][node][idx].field_1) + 128
          mem[96] = stor1[stor0[node]][node][idx].field_1
          if stor1[stor0[node]][node][idx].field_0:
              if not stor1[stor0[node]][node][idx].field_0 - (uint255(stor1[stor0[node]][node][idx].field_0) * 0.5 < 32):
                  revert with 0, 34
              if not Mask(256, -1, stor1[stor0[node]][node][idx].field_0):
                  mem[ceil32(stor1[stor0[node]][node][idx].field_1) + 128] = idx
                  mem[ceil32(stor1[stor0[node]][node][idx].field_1) + 160] = 64
                  mem[ceil32(stor1[stor0[node]][node][idx].field_1) + 192] = stor1[stor0[node]][node][idx].field_1
                  s = 0
                  while s < stor1[stor0[node]][node][idx].field_1:
                      mem[s + ceil32(stor1[stor0[node]][node][idx].field_1) + 224] = mem[s + 128]
                      s = s + 32
                      continue 
                  mem[stor1[stor0[node]][node][idx].field_1 + ceil32(stor1[stor0[node]][node][idx].field_1) + 224] = 0
                  return idx, 
                         Array(len=stor1[stor0[node]][node][idx].field_0, data=mem[ceil32(stor1[stor0[node]][node][idx].field_1) + 224 len ceil32(stor1[stor0[node]][node][idx].field_1)])
              if 31 >= uint255(stor1[stor0[node]][node][idx].field_0) * 0.5:
                  mem[128] = 256 * stor1[stor0[node]][node][idx].field_8
                  mem[ceil32(stor1[stor0[node]][node][idx].field_1) + 128] = idx
                  mem[ceil32(stor1[stor0[node]][node][idx].field_1) + 160] = 64
                  mem[ceil32(stor1[stor0[node]][node][idx].field_1) + 192] = stor1[stor0[node]][node][idx].field_1
                  s = 0
                  while s < stor1[stor0[node]][node][idx].field_1:
                      mem[s + ceil32(stor1[stor0[node]][node][idx].field_1) + 224] = mem[s + 128]
                      s = s + 32
                      continue 
                  mem[stor1[stor0[node]][node][idx].field_1 + ceil32(stor1[stor0[node]][node][idx].field_1) + 224] = 0
                  return idx, 
                         Array(len=stor1[stor0[node]][node][idx].field_0, data=mem[ceil32(stor1[stor0[node]][node][idx].field_1) + 224 len ceil32(stor1[stor0[node]][node][idx].field_1)])
              mem[128] = stor1[stor0[node]][node][idx].field_0
              s = 128
              t = sha3(sha3(idx, sha3(node, sha3(recordVersions[node], 1))))
              while (uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 96 > s:
                  mem[s + 32] = stor1[t].field_0
                  s = s + 32
                  t = t + 1
                  continue 
              _261 = mem[64]
              mem[mem[64]] = idx
              mem[mem[64] + 32] = 64
              mem[mem[64] + 64] = stor1[stor0[node]][node][idx].field_1
              s = 0
              while s < stor1[stor0[node]][node][idx].field_1:
                  mem[s + mem[64] + 96] = mem[s + 128]
                  s = s + 32
                  continue 
              mem[stor1[stor0[node]][node][idx].field_1 + _261 + 96] = 0
              return memory
                from mem[64]
                 len ceil32(stor1[stor0[node]][node][idx].field_1) + _261 + -mem[64] + 96
          if not stor1[stor0[node]][node][idx].field_0 - (stor1[stor0[node]][node][idx].field_1 < 32):
              revert with 0, 34
          if not stor1[stor0[node]][node][idx].field_1:
              mem[ceil32(stor1[stor0[node]][node][idx].field_1) + 128] = idx
              mem[ceil32(stor1[stor0[node]][node][idx].field_1) + 160] = 64
              mem[ceil32(stor1[stor0[node]][node][idx].field_1) + 192] = stor1[stor0[node]][node][idx].field_1
              s = 0
              while s < stor1[stor0[node]][node][idx].field_1:
                  mem[s + ceil32(stor1[stor0[node]][node][idx].field_1) + 224] = mem[s + 128]
                  s = s + 32
                  continue 
              mem[stor1[stor0[node]][node][idx].field_1 + ceil32(stor1[stor0[node]][node][idx].field_1) + 224] = 0
              return idx, 
                     Array(len=stor1[stor0[node]][node][idx].field_0, data=mem[ceil32(stor1[stor0[node]][node][idx].field_1) + 224 len ceil32(stor1[stor0[node]][node][idx].field_1)])
          if 31 >= stor1[stor0[node]][node][idx].field_1:
              mem[128] = 256 * stor1[stor0[node]][node][idx].field_8
              mem[ceil32(stor1[stor0[node]][node][idx].field_1) + 128] = idx
              mem[ceil32(stor1[stor0[node]][node][idx].field_1) + 160] = 64
              mem[ceil32(stor1[stor0[node]][node][idx].field_1) + 192] = stor1[stor0[node]][node][idx].field_1
              s = 0
              while s < stor1[stor0[node]][node][idx].field_1:
                  mem[s + ceil32(stor1[stor0[node]][node][idx].field_1) + 224] = mem[s + 128]
                  s = s + 32
                  continue 
              mem[stor1[stor0[node]][node][idx].field_1 + ceil32(stor1[stor0[node]][node][idx].field_1) + 224] = 0
              return idx, 
                     Array(len=stor1[stor0[node]][node][idx].field_0, data=mem[ceil32(stor1[stor0[node]][node][idx].field_1) + 224 len ceil32(stor1[stor0[node]][node][idx].field_1)])
          mem[128] = stor1[stor0[node]][node][idx].field_0
          s = 128
          t = sha3(sha3(idx, sha3(node, sha3(recordVersions[node], 1))))
          while stor1[stor0[node]][node][idx].field_1 + 96 > s:
              mem[s + 32] = stor1[t].field_0
              s = s + 32
              t = t + 1
              continue 
          _264 = mem[64]
          mem[mem[64]] = idx
          mem[mem[64] + 32] = 64
          mem[mem[64] + 64] = stor1[stor0[node]][node][idx].field_1
          s = 0
          while s < stor1[stor0[node]][node][idx].field_1:
              mem[s + mem[64] + 96] = mem[s + 128]
              s = s + 32
              continue 
          mem[stor1[stor0[node]][node][idx].field_1 + _264 + 96] = 0
          return memory
            from mem[64]
             len ceil32(stor1[stor0[node]][node][idx].field_1) + _264 + -mem[64] + 96
      if not stor1[stor0[node]][node][idx].field_0 - (stor1[stor0[node]][node][idx].field_1 < 32):
          revert with 0, 34
      if stor1[stor0[node]][node][idx].field_1 <= 0:
          idx = 2 * idx
          continue 
      mem[0] = idx
      mem[32] = sha3(node, sha3(recordVersions[node], 1))
      if stor1[stor0[node]][node][idx].field_0:
          if not stor1[stor0[node]][node][idx].field_0 - (uint255(stor1[stor0[node]][node][idx].field_0) * 0.5 < 32):
              revert with 0, 34
          mem[64] = ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 128
          mem[96] = uint255(stor1[stor0[node]][node][idx].field_0) * 0.5
          if stor1[stor0[node]][node][idx].field_0:
              if not stor1[stor0[node]][node][idx].field_0 - (uint255(stor1[stor0[node]][node][idx].field_0) * 0.5 < 32):
                  revert with 0, 34
              if not Mask(256, -1, stor1[stor0[node]][node][idx].field_0):
                  mem[ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 128] = idx
                  mem[ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 160] = 64
                  mem[ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 192] = uint255(stor1[stor0[node]][node][idx].field_0) * 0.5
                  s = 0
                  while s < uint255(stor1[stor0[node]][node][idx].field_0) * 0.5:
                      mem[s + ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 224] = mem[s + 128]
                      s = s + 32
                      continue 
                  mem[(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 224] = 0
                  return idx, 
                         Array(len=2 * Mask(256, -1, stor1[stor0[node]][node][idx].field_0), data=mem[ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 224 len ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5)])
              if 31 >= uint255(stor1[stor0[node]][node][idx].field_0) * 0.5:
                  mem[128] = 256 * stor1[stor0[node]][node][idx].field_8
                  mem[ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 128] = idx
                  mem[ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 160] = 64
                  mem[ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 192] = uint255(stor1[stor0[node]][node][idx].field_0) * 0.5
                  s = 0
                  while s < uint255(stor1[stor0[node]][node][idx].field_0) * 0.5:
                      mem[s + ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 224] = mem[s + 128]
                      s = s + 32
                      continue 
                  mem[(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 224] = 0
                  return idx, 
                         Array(len=2 * Mask(256, -1, stor1[stor0[node]][node][idx].field_0), data=mem[ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 224 len ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5)])
              mem[128] = stor1[stor0[node]][node][idx].field_0
              s = 128
              t = sha3(sha3(idx, sha3(node, sha3(recordVersions[node], 1))))
              while (uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 96 > s:
                  mem[s + 32] = stor1[t].field_0
                  s = s + 32
                  t = t + 1
                  continue 
              _267 = mem[64]
              mem[mem[64]] = idx
              mem[mem[64] + 32] = 64
              mem[mem[64] + 64] = uint255(stor1[stor0[node]][node][idx].field_0) * 0.5
              s = 0
              while s < uint255(stor1[stor0[node]][node][idx].field_0) * 0.5:
                  mem[s + mem[64] + 96] = mem[s + 128]
                  s = s + 32
                  continue 
              mem[(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + _267 + 96] = 0
              return memory
                from mem[64]
                 len ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + _267 + -mem[64] + 96
          if not stor1[stor0[node]][node][idx].field_0 - (stor1[stor0[node]][node][idx].field_1 < 32):
              revert with 0, 34
          if not stor1[stor0[node]][node][idx].field_1:
              mem[ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 128] = idx
              mem[ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 160] = 64
              mem[ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 192] = uint255(stor1[stor0[node]][node][idx].field_0) * 0.5
              s = 0
              while s < uint255(stor1[stor0[node]][node][idx].field_0) * 0.5:
                  mem[s + ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 224] = mem[s + 128]
                  s = s + 32
                  continue 
              mem[(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 224] = 0
              return idx, 
                     Array(len=2 * Mask(256, -1, stor1[stor0[node]][node][idx].field_0), data=mem[ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 224 len ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5)])
          if 31 >= stor1[stor0[node]][node][idx].field_1:
              mem[128] = 256 * stor1[stor0[node]][node][idx].field_8
              mem[ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 128] = idx
              mem[ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 160] = 64
              mem[ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 192] = uint255(stor1[stor0[node]][node][idx].field_0) * 0.5
              s = 0
              while s < uint255(stor1[stor0[node]][node][idx].field_0) * 0.5:
                  mem[s + ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 224] = mem[s + 128]
                  s = s + 32
                  continue 
              mem[(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 224] = 0
              return idx, 
                     Array(len=2 * Mask(256, -1, stor1[stor0[node]][node][idx].field_0), data=mem[ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 224 len ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5)])
          mem[128] = stor1[stor0[node]][node][idx].field_0
          s = 128
          t = sha3(sha3(idx, sha3(node, sha3(recordVersions[node], 1))))
          while stor1[stor0[node]][node][idx].field_1 + 96 > s:
              mem[s + 32] = stor1[t].field_0
              s = s + 32
              t = t + 1
              continue 
          _270 = mem[64]
          mem[mem[64]] = idx
          mem[mem[64] + 32] = 64
          mem[mem[64] + 64] = uint255(stor1[stor0[node]][node][idx].field_0) * 0.5
          s = 0
          while s < uint255(stor1[stor0[node]][node][idx].field_0) * 0.5:
              mem[s + mem[64] + 96] = mem[s + 128]
              s = s + 32
              continue 
          mem[(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + _270 + 96] = 0
          return memory
            from mem[64]
             len ceil32(uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + _270 + -mem[64] + 96
      if not stor1[stor0[node]][node][idx].field_0 - (stor1[stor0[node]][node][idx].field_1 < 32):
          revert with 0, 34
      mem[64] = ceil32(stor1[stor0[node]][node][idx].field_1) + 128
      mem[96] = stor1[stor0[node]][node][idx].field_1
      if stor1[stor0[node]][node][idx].field_0:
          if not stor1[stor0[node]][node][idx].field_0 - (uint255(stor1[stor0[node]][node][idx].field_0) * 0.5 < 32):
              revert with 0, 34
          if not Mask(256, -1, stor1[stor0[node]][node][idx].field_0):
              mem[ceil32(stor1[stor0[node]][node][idx].field_1) + 128] = idx
              mem[ceil32(stor1[stor0[node]][node][idx].field_1) + 160] = 64
              mem[ceil32(stor1[stor0[node]][node][idx].field_1) + 192] = stor1[stor0[node]][node][idx].field_1
              s = 0
              while s < stor1[stor0[node]][node][idx].field_1:
                  mem[s + ceil32(stor1[stor0[node]][node][idx].field_1) + 224] = mem[s + 128]
                  s = s + 32
                  continue 
              mem[stor1[stor0[node]][node][idx].field_1 + ceil32(stor1[stor0[node]][node][idx].field_1) + 224] = 0
              return idx, 
                     Array(len=stor1[stor0[node]][node][idx].field_0, data=mem[ceil32(stor1[stor0[node]][node][idx].field_1) + 224 len ceil32(stor1[stor0[node]][node][idx].field_1)])
          if 31 >= uint255(stor1[stor0[node]][node][idx].field_0) * 0.5:
              mem[128] = 256 * stor1[stor0[node]][node][idx].field_8
              mem[ceil32(stor1[stor0[node]][node][idx].field_1) + 128] = idx
              mem[ceil32(stor1[stor0[node]][node][idx].field_1) + 160] = 64
              mem[ceil32(stor1[stor0[node]][node][idx].field_1) + 192] = stor1[stor0[node]][node][idx].field_1
              s = 0
              while s < stor1[stor0[node]][node][idx].field_1:
                  mem[s + ceil32(stor1[stor0[node]][node][idx].field_1) + 224] = mem[s + 128]
                  s = s + 32
                  continue 
              mem[stor1[stor0[node]][node][idx].field_1 + ceil32(stor1[stor0[node]][node][idx].field_1) + 224] = 0
              return idx, 
                     Array(len=stor1[stor0[node]][node][idx].field_0, data=mem[ceil32(stor1[stor0[node]][node][idx].field_1) + 224 len ceil32(stor1[stor0[node]][node][idx].field_1)])
          mem[128] = stor1[stor0[node]][node][idx].field_0
          s = 128
          t = sha3(sha3(idx, sha3(node, sha3(recordVersions[node], 1))))
          while (uint255(stor1[stor0[node]][node][idx].field_0) * 0.5) + 96 > s:
              mem[s + 32] = stor1[t].field_0
              s = s + 32
              t = t + 1
              continue 
          _273 = mem[64]
          mem[mem[64]] = idx
          mem[mem[64] + 32] = 64
          mem[mem[64] + 64] = stor1[stor0[node]][node][idx].field_1
          s = 0
          while s < stor1[stor0[node]][node][idx].field_1:
              mem[s + mem[64] + 96] = mem[s + 128]
              s = s + 32
              continue 
          mem[stor1[stor0[node]][node][idx].field_1 + _273 + 96] = 0
          return memory
            from mem[64]
             len ceil32(stor1[stor0[node]][node][idx].field_1) + _273 + -mem[64] + 96
      if not stor1[stor0[node]][node][idx].field_0 - (stor1[stor0[node]][node][idx].field_1 < 32):
          revert with 0, 34
      if not stor1[stor0[node]][node][idx].field_1:
          mem[ceil32(stor1[stor0[node]][node][idx].field_1) + 128] = idx
          mem[ceil32(stor1[stor0[node]][node][idx].field_1) + 160] = 64
          mem[ceil32(stor1[stor0[node]][node][idx].field_1) + 192] = stor1[stor0[node]][node][idx].field_1
          s = 0
          while s < stor1[stor0[node]][node][idx].field_1:
              mem[s + ceil32(stor1[stor0[node]][node][idx].field_1) + 224] = mem[s + 128]
              s = s + 32
              continue 
          mem[stor1[stor0[node]][node][idx].field_1 + ceil32(stor1[stor0[node]][node][idx].field_1) + 224] = 0
          return idx, 
                 Array(len=stor1[stor0[node]][node][idx].field_0, data=mem[ceil32(stor1[stor0[node]][node][idx].field_1) + 224 len ceil32(stor1[stor0[node]][node][idx].field_1)])
      if 31 >= stor1[stor0[node]][node][idx].field_1:
          mem[128] = 256 * stor1[stor0[node]][node][idx].field_8
          mem[ceil32(stor1[stor0[node]][node][idx].field_1) + 128] = idx
          mem[ceil32(stor1[stor0[node]][node][idx].field_1) + 160] = 64
          mem[ceil32(stor1[stor0[node]][node][idx].field_1) + 192] = stor1[stor0[node]][node][idx].field_1
          s = 0
          while s < stor1[stor0[node]][node][idx].field_1:
              mem[s + ceil32(stor1[stor0[node]][node][idx].field_1) + 224] = mem[s + 128]
              s = s + 32
              continue 
          mem[stor1[stor0[node]][node][idx].field_1 + ceil32(stor1[stor0[node]][node][idx].field_1) + 224] = 0
          return idx, 
                 Array(len=stor1[stor0[node]][node][idx].field_0, data=mem[ceil32(stor1[stor0[node]][node][idx].field_1) + 224 len ceil32(stor1[stor0[node]][node][idx].field_1)])
      mem[128] = stor1[stor0[node]][node][idx].field_0
      s = 128
      t = sha3(sha3(idx, sha3(node, sha3(recordVersions[node], 1))))
      while stor1[stor0[node]][node][idx].field_1 + 96 > s:
          mem[s + 32] = stor1[t].field_0
          s = s + 32
          t = t + 1
          continue 
      _276 = mem[64]
      mem[mem[64]] = idx
      mem[mem[64] + 32] = 64
      mem[mem[64] + 64] = stor1[stor0[node]][node][idx].field_1
      s = 0
      while s < stor1[stor0[node]][node][idx].field_1:
          mem[s + mem[64] + 96] = mem[s + 128]
          s = s + 32
          continue 
      mem[stor1[stor0[node]][node][idx].field_1 + _276 + 96] = 0
      return memory
        from mem[64]
         len ceil32(stor1[stor0[node]][node][idx].field_1) + _276 + -mem[64] + 96
  return 0, 64, 0

def setZonehash(bytes32 node, bytes hash) payable: 
  require calldata.size - 4 >=′ 64
  require hash <= LOCK8605463013()
  require hash + 35 <′ calldata.size
  require hash.length <= LOCK8605463013()
  require hash + hash.length + 36 <= calldata.size
  if 0x253553366da8546fc250f225fe3d25d0c782303b == caller:
      if stor4[stor0[node]][node].field_0:
          if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
              revert with 0, 34
          if stor4[stor0[node]][node].field_0:
              if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                  revert with 0, 34
              if not Mask(256, -1, stor4[stor0[node]][node].field_0):
                  if hash.length > LOCK8605463013():
                      revert with 0, 65
                  if stor4[stor0[node]][node].field_0:
                      if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                          revert with 0, 34
                      if uint255(stor4[stor0[node]][node].field_0) * 0.5 <= 31:
                          if hash.length > 31 != 1:
                              if not hash.length:
                                  stor4[stor0[node]][node].field_0 = 2 * hash.length
                              else:
                                  stor4[stor0[node]][node].field_0 = hash.length
                  else:
                      if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                          revert with 0, 34
                      if stor4[stor0[node]][node].field_1 <= 31:
                          if hash.length > 31 != 1:
                              if not hash.length:
                                  stor4[stor0[node]][node].field_0 = 2 * hash.length
                              else:
                                  stor4[stor0[node]][node].field_0 = hash.length
              else:
                  if 31 >= uint255(stor4[stor0[node]][node].field_0) * 0.5:
                      if hash.length > LOCK8605463013():
                          revert with 0, 65
                      if stor4[stor0[node]][node].field_0:
                          if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                              revert with 0, 34
                          if uint255(stor4[stor0[node]][node].field_0) * 0.5 <= 31:
                              if hash.length > 31 != 1:
                                  if not hash.length:
                                      stor4[stor0[node]][node].field_0 = 2 * hash.length
                                  else:
                                      stor4[stor0[node]][node].field_0 = hash.length
                      else:
                          if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                              revert with 0, 34
                          if stor4[stor0[node]][node].field_1 <= 31:
                              if hash.length > 31 != 1:
                                  if hash.length:
                                      stor4[stor0[node]][node].field_0 = hash.length
                                  else:
                                      stor4[stor0[node]][node].field_0 = 2 * hash.length
          else:
              if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                  revert with 0, 34
              if not stor4[stor0[node]][node].field_1:
                  if hash.length > LOCK8605463013():
                      revert with 0, 65
                  if stor4[stor0[node]][node].field_0:
                      if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                          revert with 0, 34
                      if uint255(stor4[stor0[node]][node].field_0) * 0.5 <= 31:
                          if hash.length > 31 != 1:
                              if not hash.length:
                                  stor4[stor0[node]][node].field_0 = 2 * hash.length
                              else:
                                  stor4[stor0[node]][node].field_0 = hash.length
                  else:
                      if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                          revert with 0, 34
                      if stor4[stor0[node]][node].field_1 <= 31:
                          if hash.length > 31 != 1:
                              if not hash.length:
                                  stor4[stor0[node]][node].field_0 = 2 * hash.length
                              else:
                                  stor4[stor0[node]][node].field_0 = hash.length
              else:
                  if 31 >= stor4[stor0[node]][node].field_1:
                      if hash.length > LOCK8605463013():
                          revert with 0, 65
                      if not stor4[stor0[node]][node].field_0:
                          if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                              revert with 0, 34
                          if stor4[stor0[node]][node].field_1 <= 31:
                              if hash.length > 31 != 1:
                                  if not hash.length:
                                      stor4[stor0[node]][node].field_0 = 2 * hash.length
                                  else:
                                      stor4[stor0[node]][node].field_0 = hash.length
                      else:
                          if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                              revert with 0, 34
                          if uint255(stor4[stor0[node]][node].field_0) * 0.5 <= 31:
                              if hash.length > 31 != 1:
                                  if hash.length:
                                      stor4[stor0[node]][node].field_0 = hash.length
                                  else:
                                      stor4[stor0[node]][node].field_0 = 2 * hash.length
      else:
          if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
              revert with 0, 34
          if not stor4[stor0[node]][node].field_0:
              if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                  revert with 0, 34
              if not stor4[stor0[node]][node].field_1:
                  if hash.length > LOCK8605463013():
                      revert with 0, 65
                  if stor4[stor0[node]][node].field_0:
                      if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                          revert with 0, 34
                      if uint255(stor4[stor0[node]][node].field_0) * 0.5 <= 31:
                          if hash.length > 31 != 1:
                              if not hash.length:
                                  stor4[stor0[node]][node].field_0 = 2 * hash.length
                              else:
                                  stor4[stor0[node]][node].field_0 = hash.length
                  else:
                      if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                          revert with 0, 34
                      if stor4[stor0[node]][node].field_1 <= 31:
                          if hash.length > 31 != 1:
                              if hash.length:
                                  stor4[stor0[node]][node].field_0 = hash.length
                              else:
                                  stor4[stor0[node]][node].field_0 = 2 * hash.length
              else:
                  if 31 >= stor4[stor0[node]][node].field_1:
                      if hash.length > LOCK8605463013():
                          revert with 0, 65
                      if stor4[stor0[node]][node].field_0:
                          if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                              revert with 0, 34
                          if uint255(stor4[stor0[node]][node].field_0) * 0.5 <= 31:
                              if hash.length > 31 != 1:
                                  if not hash.length:
                                      stor4[stor0[node]][node].field_0 = 2 * hash.length
                                  else:
                                      stor4[stor0[node]][node].field_0 = hash.length
                      else:
                          if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                              revert with 0, 34
                          if stor4[stor0[node]][node].field_1 <= 31:
                              if hash.length > 31 != 1:
                                  if not hash.length:
                                      stor4[stor0[node]][node].field_0 = 2 * hash.length
                                  else:
                                      stor4[stor0[node]][node].field_0 = hash.length
          else:
              if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                  revert with 0, 34
              if not Mask(256, -1, stor4[stor0[node]][node].field_0):
                  if hash.length > LOCK8605463013():
                      revert with 0, 65
                  if stor4[stor0[node]][node].field_0:
                      if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                          revert with 0, 34
                      if uint255(stor4[stor0[node]][node].field_0) * 0.5 <= 31:
                          if hash.length > 31 != 1:
                              if not hash.length:
                                  stor4[stor0[node]][node].field_0 = 2 * hash.length
                              else:
                                  stor4[stor0[node]][node].field_0 = hash.length
                  else:
                      if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                          revert with 0, 34
                      if stor4[stor0[node]][node].field_1 <= 31:
                          if hash.length > 31 != 1:
                              if not hash.length:
                                  stor4[stor0[node]][node].field_0 = 2 * hash.length
                              else:
                                  stor4[stor0[node]][node].field_0 = hash.length
              else:
                  if 31 >= uint255(stor4[stor0[node]][node].field_0) * 0.5:
                      if hash.length > LOCK8605463013():
                          revert with 0, 65
                      if not stor4[stor0[node]][node].field_0:
                          if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                              revert with 0, 34
                          if stor4[stor0[node]][node].field_1 <= 31:
                              if hash.length > 31 != 1:
                                  if not hash.length:
                                      stor4[stor0[node]][node].field_0 = 2 * hash.length
                                  else:
                                      stor4[stor0[node]][node].field_0 = hash.length
                      else:
                          if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                              revert with 0, 34
                          if uint255(stor4[stor0[node]][node].field_0) * 0.5 <= 31:
                              if hash.length > 31 != 1:
                                  if hash.length:
                                      stor4[stor0[node]][node].field_0 = hash.length
                                  else:
                                      stor4[stor0[node]][node].field_0 = 2 * hash.length
  else:
      if 0xa58e81fe9b61b5c3fe2afd33cf304c454abfc7cb == caller:
          if not stor4[stor0[node]][node].field_0:
              if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                  revert with 0, 34
              if stor4[stor0[node]][node].field_0:
                  if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                      revert with 0, 34
                  if not Mask(256, -1, stor4[stor0[node]][node].field_0):
                      if hash.length > LOCK8605463013():
                          revert with 0, 65
                      if stor4[stor0[node]][node].field_0:
                          if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                              revert with 0, 34
                          if uint255(stor4[stor0[node]][node].field_0) * 0.5 <= 31:
                              if hash.length > 31 != 1:
                                  if not hash.length:
                                      stor4[stor0[node]][node].field_0 = 2 * hash.length
                                  else:
                                      stor4[stor0[node]][node].field_0 = hash.length
                      else:
                          if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                              revert with 0, 34
                          if stor4[stor0[node]][node].field_1 <= 31:
                              if hash.length > 31 != 1:
                                  if hash.length:
                                      stor4[stor0[node]][node].field_0 = hash.length
                                  else:
                                      stor4[stor0[node]][node].field_0 = 2 * hash.length
                  else:
                      if 31 >= uint255(stor4[stor0[node]][node].field_0) * 0.5:
                          if hash.length > LOCK8605463013():
                              revert with 0, 65
                          if stor4[stor0[node]][node].field_0:
                              if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                                  revert with 0, 34
                              if uint255(stor4[stor0[node]][node].field_0) * 0.5 <= 31:
                                  if hash.length > 31 != 1:
                                      if not hash.length:
                                          stor4[stor0[node]][node].field_0 = 2 * hash.length
                                      else:
                                          stor4[stor0[node]][node].field_0 = hash.length
                          else:
                              if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                                  revert with 0, 34
                              if stor4[stor0[node]][node].field_1 <= 31:
                                  if hash.length > 31 != 1:
                                      if not hash.length:
                                          stor4[stor0[node]][node].field_0 = 2 * hash.length
                                      else:
                                          stor4[stor0[node]][node].field_0 = hash.length
              else:
                  if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                      revert with 0, 34
                  if not stor4[stor0[node]][node].field_1:
                      if hash.length > LOCK8605463013():
                          revert with 0, 65
                      if not stor4[stor0[node]][node].field_0:
                          if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                              revert with 0, 34
                          if stor4[stor0[node]][node].field_1 <= 31:
                              if hash.length > 31 != 1:
                                  if not hash.length:
                                      stor4[stor0[node]][node].field_0 = 2 * hash.length
                                  else:
                                      stor4[stor0[node]][node].field_0 = hash.length
                      else:
                          if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                              revert with 0, 34
                          if uint255(stor4[stor0[node]][node].field_0) * 0.5 <= 31:
                              if hash.length > 31 != 1:
                                  if hash.length:
                                      stor4[stor0[node]][node].field_0 = hash.length
                                  else:
                                      stor4[stor0[node]][node].field_0 = 2 * hash.length
                  else:
                      if 31 >= stor4[stor0[node]][node].field_1:
                          if hash.length > LOCK8605463013():
                              revert with 0, 65
                          if stor4[stor0[node]][node].field_0:
                              if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                                  revert with 0, 34
                              if uint255(stor4[stor0[node]][node].field_0) * 0.5 <= 31:
                                  if hash.length > 31 != 1:
                                      if not hash.length:
                                          stor4[stor0[node]][node].field_0 = 2 * hash.length
                                      else:
                                          stor4[stor0[node]][node].field_0 = hash.length
                          else:
                              if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                                  revert with 0, 34
                              if stor4[stor0[node]][node].field_1 <= 31:
                                  if hash.length > 31 != 1:
                                      if not hash.length:
                                          stor4[stor0[node]][node].field_0 = 2 * hash.length
                                      else:
                                          stor4[stor0[node]][node].field_0 = hash.length
          else:
              if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                  revert with 0, 34
              if not stor4[stor0[node]][node].field_0:
                  if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                      revert with 0, 34
                  if not stor4[stor0[node]][node].field_1:
                      if hash.length > LOCK8605463013():
                          revert with 0, 65
                      if stor4[stor0[node]][node].field_0:
                          if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                              revert with 0, 34
                          if uint255(stor4[stor0[node]][node].field_0) * 0.5 <= 31:
                              if hash.length > 31 != 1:
                                  if not hash.length:
                                      stor4[stor0[node]][node].field_0 = 2 * hash.length
                                  else:
                                      stor4[stor0[node]][node].field_0 = hash.length
                      else:
                          if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                              revert with 0, 34
                          if stor4[stor0[node]][node].field_1 <= 31:
                              if hash.length > 31 != 1:
                                  if hash.length:
                                      stor4[stor0[node]][node].field_0 = hash.length
                                  else:
                                      stor4[stor0[node]][node].field_0 = 2 * hash.length
                  else:
                      if 31 >= stor4[stor0[node]][node].field_1:
                          if hash.length > LOCK8605463013():
                              revert with 0, 65
                          if stor4[stor0[node]][node].field_0:
                              if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                                  revert with 0, 34
                              if uint255(stor4[stor0[node]][node].field_0) * 0.5 <= 31:
                                  if hash.length > 31 != 1:
                                      if not hash.length:
                                          stor4[stor0[node]][node].field_0 = 2 * hash.length
                                      else:
                                          stor4[stor0[node]][node].field_0 = hash.length
                          else:
                              if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                                  revert with 0, 34
                              if stor4[stor0[node]][node].field_1 <= 31:
                                  if hash.length > 31 != 1:
                                      if not hash.length:
                                          stor4[stor0[node]][node].field_0 = 2 * hash.length
                                      else:
                                          stor4[stor0[node]][node].field_0 = hash.length
              else:
                  if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                      revert with 0, 34
                  if not Mask(256, -1, stor4[stor0[node]][node].field_0):
                      if hash.length > LOCK8605463013():
                          revert with 0, 65
                      if stor4[stor0[node]][node].field_0:
                          if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                              revert with 0, 34
                          if uint255(stor4[stor0[node]][node].field_0) * 0.5 <= 31:
                              if hash.length > 31 != 1:
                                  if not hash.length:
                                      stor4[stor0[node]][node].field_0 = 2 * hash.length
                                  else:
                                      stor4[stor0[node]][node].field_0 = hash.length
                      else:
                          if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                              revert with 0, 34
                          if stor4[stor0[node]][node].field_1 <= 31:
                              if hash.length > 31 != 1:
                                  if not hash.length:
                                      stor4[stor0[node]][node].field_0 = 2 * hash.length
                                  else:
                                      stor4[stor0[node]][node].field_0 = hash.length
                  else:
                      if 31 >= uint255(stor4[stor0[node]][node].field_0) * 0.5:
                          if hash.length > LOCK8605463013():
                              revert with 0, 65
                          if not stor4[stor0[node]][node].field_0:
                              if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                                  revert with 0, 34
                              if stor4[stor0[node]][node].field_1 <= 31:
                                  if hash.length > 31 != 1:
                                      if not hash.length:
                                          stor4[stor0[node]][node].field_0 = 2 * hash.length
                                      else:
                                          stor4[stor0[node]][node].field_0 = hash.length
                          else:
                              if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                                  revert with 0, 34
                              if uint255(stor4[stor0[node]][node].field_0) * 0.5 <= 31:
                                  if hash.length > 31 != 1:
                                      if hash.length:
                                          stor4[stor0[node]][node].field_0 = hash.length
                                      else:
                                          stor4[stor0[node]][node].field_0 = 2 * hash.length
      else:
          static call 0xc2e074ec69a0dfb2997ba6c7d2e1e.owner(bytes32 node) with:
                  gas gas_remaining wei
                 args node
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          require return_data.size >=′ 32
          require ext_call.return_data[0] == ext_call.return_data[12 len 20]
          if ext_call.return_data[12 len 20] - 0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401:
              if caller == ext_call.return_data[12 len 20]:
                  if stor4[stor0[node]][node].field_0:
                      if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                          revert with 0, 34
                      if stor4[stor0[node]][node].field_0:
                          if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                              revert with 0, 34
                          if not Mask(256, -1, stor4[stor0[node]][node].field_0):
                              if hash.length > LOCK8605463013():
                                  revert with 0, 65
                              if stor4[stor0[node]][node].field_0:
                                  if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                                      revert with 0, 34
                                  if uint255(stor4[stor0[node]][node].field_0) * 0.5 > 31:
                              else:
                                  if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                                      revert with 0, 34
                                  if stor4[stor0[node]][node].field_1 > 31:
                          else:
                              if 31 >= uint255(stor4[stor0[node]][node].field_0) * 0.5:
                                  if hash.length > LOCK8605463013():
                                      revert with 0, 65
                                  if not stor4[stor0[node]][node].field_0:
                                      if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                                          revert with 0, 34
                                  else:
                                      if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                                          revert with 0, 34
                      else:
                          if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                              revert with 0, 34
                          if stor4[stor0[node]][node].field_1:
                              if 31 >= stor4[stor0[node]][node].field_1:
                                  if hash.length > LOCK8605463013():
                                      revert with 0, 65
                                  if stor4[stor0[node]][node].field_0:
                                      if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                                          revert with 0, 34
                                  else:
                                      if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                                          revert with 0, 34
                          else:
                              if hash.length > LOCK8605463013():
                                  revert with 0, 65
                              if not stor4[stor0[node]][node].field_0:
                                  if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                                      revert with 0, 34
                              else:
                                  if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                                      revert with 0, 34
                                  if uint255(stor4[stor0[node]][node].field_0) * 0.5 > 31:
                  else:
                      if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                          revert with 0, 34
                      if not stor4[stor0[node]][node].field_0:
                          if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                              revert with 0, 34
                          if not stor4[stor0[node]][node].field_1:
                              if hash.length > LOCK8605463013():
                                  revert with 0, 65
                              if not stor4[stor0[node]][node].field_0:
                                  if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                                      revert with 0, 34
                              else:
                                  if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                                      revert with 0, 34
                          else:
                              if 31 >= stor4[stor0[node]][node].field_1:
                                  if hash.length > LOCK8605463013():
                                      revert with 0, 65
                                  if stor4[stor0[node]][node].field_0:
                                      if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                                          revert with 0, 34
                                  else:
                      else:
                          if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                              revert with 0, 34
                          if Mask(256, -1, stor4[stor0[node]][node].field_0):
                              if 31 >= uint255(stor4[stor0[node]][node].field_0) * 0.5:
                                  if hash.length > LOCK8605463013():
                                      revert with 0, 65
                                  if stor4[stor0[node]][node].field_0:
                                      if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                                          revert with 0, 34
                                  else:
                                      if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                                          revert with 0, 34
                          else:
                              if hash.length > LOCK8605463013():
                                  revert with 0, 65
                              if not stor4[stor0[node]][node].field_0:
                                  if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                                      revert with 0, 34
                              else:
                                  if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                                      revert with 0, 34
                                  if uint255(stor4[stor0[node]][node].field_0) * 0.5 > 31:
              else:
                  if stor11[ext_call.return_data[12 len 20]][caller]:
                      if not stor4[stor0[node]][node].field_0:
                          if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                              revert with 0, 34
                          if stor4[stor0[node]][node].field_0:
                              if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                                  revert with 0, 34
                              if not Mask(256, -1, stor4[stor0[node]][node].field_0):
                                  if hash.length > LOCK8605463013():
                                      revert with 0, 65
                                  if not stor4[stor0[node]][node].field_0:
                                      if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                                          revert with 0, 34
                                  else:
                                      if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                                          revert with 0, 34
                              else:
                                  if 31 >= uint255(stor4[stor0[node]][node].field_0) * 0.5:
                                      if hash.length > LOCK8605463013():
                                          revert with 0, 65
                                      if stor4[stor0[node]][node].field_0:
                                          if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                                              revert with 0, 34
                                      else:
                          else:
                              if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                                  revert with 0, 34
                              if not stor4[stor0[node]][node].field_1:
                                  if hash.length > LOCK8605463013():
                                      revert with 0, 65
                                  if stor4[stor0[node]][node].field_0:
                                      if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                                          revert with 0, 34
                                  else:
                                      if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                                          revert with 0, 34
                              else:
                                  if 31 >= stor4[stor0[node]][node].field_1:
                                      if hash.length > LOCK8605463013():
                                          revert with 0, 65
                                      if stor4[stor0[node]][node].field_0:
                      else:
                          if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                              revert with 0, 34
                          if not stor4[stor0[node]][node].field_0:
                              if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                                  revert with 0, 34
                              if not stor4[stor0[node]][node].field_1:
                                  if hash.length > LOCK8605463013():
                                      revert with 0, 65
                                  if not stor4[stor0[node]][node].field_0:
                                      if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                                          revert with 0, 34
                                  else:
                                      if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                                          revert with 0, 34
                              else:
                                  if 31 >= stor4[stor0[node]][node].field_1:
                                      if hash.length > LOCK8605463013():
                                          revert with 0, 65
                                      if stor4[stor0[node]][node].field_0:
                                          if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                                              revert with 0, 34
                                      else:
                          else:
                              if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                                  revert with 0, 34
                              if Mask(256, -1, stor4[stor0[node]][node].field_0):
                                  if 31 >= uint255(stor4[stor0[node]][node].field_0) * 0.5:
                                      if hash.length > LOCK8605463013():
                                          revert with 0, 65
                                      if stor4[stor0[node]][node].field_0:
                                          if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                                              revert with 0, 34
                                      else:
                                          if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                                              revert with 0, 34
                              else:
                                  if hash.length > LOCK8605463013():
                                      revert with 0, 65
                                  if not stor4[stor0[node]][node].field_0:
                                      if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                                          revert with 0, 34
                                  else:
                                      if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                                          revert with 0, 34
                                      if uint255(stor4[stor0[node]][node].field_0) * 0.5 > 31:
                  else:
                      require stor12[address(ext_call.return_data[0])][node][caller]
                      if stor4[stor0[node]][node].field_0:
                          if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                              revert with 0, 34
                          if stor4[stor0[node]][node].field_0:
                              if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                                  revert with 0, 34
                              if not Mask(256, -1, stor4[stor0[node]][node].field_0):
                                  if hash.length > LOCK8605463013():
                                      revert with 0, 65
                                  if not stor4[stor0[node]][node].field_0:
                                      if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                                          revert with 0, 34
                                  else:
                                      if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                                          revert with 0, 34
                              else:
                                  if 31 >= uint255(stor4[stor0[node]][node].field_0) * 0.5:
                                      if hash.length > LOCK8605463013():
                                          revert with 0, 65
                                      if stor4[stor0[node]][node].field_0:
                                          if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                                              revert with 0, 34
                                      else:
                          else:
                              if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                                  revert with 0, 34
                              if not stor4[stor0[node]][node].field_1:
                                  if hash.length > LOCK8605463013():
                                      revert with 0, 65
                                  if stor4[stor0[node]][node].field_0:
                                      if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                                          revert with 0, 34
                                  else:
                                      if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                                          revert with 0, 34
                              else:
                                  if 31 >= stor4[stor0[node]][node].field_1:
                                      if hash.length > LOCK8605463013():
                                          revert with 0, 65
                                      if stor4[stor0[node]][node].field_0:
                      else:
                          if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                              revert with 0, 34
                          if not stor4[stor0[node]][node].field_0:
                              if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                                  revert with 0, 34
                              if not stor4[stor0[node]][node].field_1:
                                  if hash.length > LOCK8605463013():
                                      revert with 0, 65
                                  if stor4[stor0[node]][node].field_0:
                                      if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                                          revert with 0, 34
                                  else:
                              else:
                                  if 31 >= stor4[stor0[node]][node].field_1:
                                      if hash.length > LOCK8605463013():
                                          revert with 0, 65
                          else:
                              if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                                  revert with 0, 34
                              if not Mask(256, -1, stor4[stor0[node]][node].field_0):
                                  if hash.length > LOCK8605463013():
                                      revert with 0, 65
                                  if stor4[stor0[node]][node].field_0:
                                      if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                                          revert with 0, 34
                                  else:
                                      if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                                          revert with 0, 34
                              else:
                                  if 31 >= uint255(stor4[stor0[node]][node].field_0) * 0.5:
                                      if hash.length > LOCK8605463013():
                                          revert with 0, 65
                                      if stor4[stor0[node]][node].field_0:
          else:
              static call 0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401.ownerOf(uint256 tokenId) with:
                      gas gas_remaining wei
                     args node
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 32
              require ext_call.return_data[0] == ext_call.return_data[12 len 20]
              if caller == ext_call.return_data[12 len 20]:
                  if stor4[stor0[node]][node].field_0:
                      if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                          revert with 0, 34
                      if stor4[stor0[node]][node].field_0:
                          if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                              revert with 0, 34
                          if Mask(256, -1, stor4[stor0[node]][node].field_0):
                      else:
                          if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                              revert with 0, 34
                          if stor4[stor0[node]][node].field_1:
                  else:
                      if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                          revert with 0, 34
                      if not stor4[stor0[node]][node].field_0:
                          if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                              revert with 0, 34
                      else:
                          if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                              revert with 0, 34
                          if Mask(256, -1, stor4[stor0[node]][node].field_0):
              else:
                  if stor11[ext_call.return_data[12 len 20]][caller]:
                      if not stor4[stor0[node]][node].field_0:
                          if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                              revert with 0, 34
                          if not stor4[stor0[node]][node].field_0:
                              if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                                  revert with 0, 34
                          else:
                              if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                                  revert with 0, 34
                      else:
                          if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                              revert with 0, 34
                          if not stor4[stor0[node]][node].field_0:
                              if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                                  revert with 0, 34
                          else:
                              if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                                  revert with 0, 34
                              if Mask(256, -1, stor4[stor0[node]][node].field_0):
                  else:
                      require stor12[address(ext_call.return_data[0])][node][caller]
                      if not stor4[stor0[node]][node].field_0:
                          if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                              revert with 0, 34
                          if stor4[stor0[node]][node].field_0:
                              if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                                  revert with 0, 34
                          else:
                      else:
                          if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                              revert with 0, 34
                          if not stor4[stor0[node]][node].field_0:
                              if not stor4[stor0[node]][node].field_0 - (stor4[stor0[node]][node].field_1 < 32):
                                  revert with 0, 34
                          else:
                              if not stor4[stor0[node]][node].field_0 - (uint255(stor4[stor0[node]][node].field_0) * 0.5 < 32):
                                  revert with 0, 34
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)


