# Palkeoramix decompiler. 

def storage:
  stor0 is mapping of uint8 at storage 0
  stor1 is mapping of uint8 at storage 1

def whitelist(address _param1): # not payable
  require calldata.size - 4 >=′ 32
  require _param1 == _param1
  return bool(stor0[_param1])

#
#  Regular functions
#

def addOwner(address owner): # not payable
  require calldata.size - 4 >=′ 32
  require owner == owner
  if not stor0[caller]:
      revert with 0, 'owner'
  stor0[address(owner)] = 1

def removeOwner(address owner): # not payable
  require calldata.size - 4 >=′ 32
  require owner == owner
  if not stor0[caller]:
      revert with 0, 'owner'
  stor0[address(owner)] = 0

def unknownae9779c6(uint256 _param1): # not payable
  require calldata.size - 4 >=′ 32
  if not stor0[caller]:
      revert with 0, 'owner'
  require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
     value _param1 wei
       gas gas_remaining wei
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]

def withdrawEth(uint256 amount, address to): # not payable
  require calldata.size - 4 >=′ 64
  require to == to
  if not stor0[caller]:
      revert with 0, 'owner'
  if not stor1[address(to)]:
      if to != caller:
          revert with 0, 'Invalid addr'
  call to with:
     value amount wei
       gas 2300 * is_zero(value) wei
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]

def withdrawToken(address token, uint256 amount, address sendTo): # not payable
  require calldata.size - 4 >=′ 96
  require token == token
  require sendTo == sendTo
  if not stor0[caller]:
      revert with 0, 'owner'
  if not stor1[address(sendTo)]:
      if sendTo != caller:
          revert with 0, 'Invalid addr'
  mem[196 len 96] = transfer(address recipient, uint256 amount), address(sendTo) << 64, 0, amount, mem[196 len 28]
  call token.mem[196 len 4] with:
       gas gas_remaining wei
      args mem[200 len 64]
  if not return_data.size:
      if not ext_call.success:
          revert with 0, 'TransferHelper::safeTransfer: transfer failed'
      require transfer(address recipient, uint256 amount), address(sendTo) << 64 == bool(transfer(address recipient, uint256 amount), address(sendTo) << 64)
      if not transfer(address recipient, uint256 amount), address(sendTo) << 64:
          revert with 0, 'TransferHelper::safeTransfer: transfer failed'
  else:
      mem[228 len return_data.size] = ext_call.return_data[0 len return_data.size]
      if not ext_call.success:
          revert with 0, 'TransferHelper::safeTransfer: transfer failed'
      if return_data.size:
          require return_data.size >=′ 32
          require mem[228] == bool(mem[228])
          if not mem[228]:
              revert with 0, 'TransferHelper::safeTransfer: transfer failed'
  log WithdrawToken(
        address token=address(token),
        uint256 amount=amount,
        address to=sendTo)

def unknownccf22927(uint256 _param1, uint256 _param2, uint256 _param3, uint256 _param4, uint256 _param5, uint256 _param6, uint256 _param7): # not payable
  require calldata.size - 4 >=′ 224
  if not stor0[caller]:
      revert with 0, 'owner'
  require _param5 == address(_param5)
  require _param7 == bool(_param7)
  require _param3 < 0x8000000000000000000000000000000000000000000000000000000000000000
  require _param7 == bool(_param7)
  require _param1 == address(_param1)
  require _param2 == address(_param2)
  require _param6 == _param6 % unknown01000000()
  if _param7:
      call address(_param5).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
           gas gas_remaining wei
          args address(this.address), bool(_param7), _param3, 4295128740, 160, 96, _param1 << 192, address(_param2), _param6 % unknown01000000()
  else:
      call address(_param5).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
           gas gas_remaining wei
          args address(this.address), bool(_param7), _param3, 0xfffd8963efd1fc6a506488495d951d5263988d25, 160, 96, _param1 << 192, address(_param2), _param6 % unknown01000000()
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  require return_data.size >=′ 64
  require _param7 == bool(_param7)
  if _param7:
      if not ext_call.return_data[32] - 0x8000000000000000000000000000000000000000000000000000000000000000:
          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
      if -ext_call.return_data[32] < _param4:
          revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
  else:
      if not ext_call.return_data[0] - 0x8000000000000000000000000000000000000000000000000000000000000000:
          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
      if -ext_call.return_data[0] < _param4:
          revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'

def uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes data): # not payable
  require calldata.size - 4 >=′ 96
  require data <= LOCK8605463013()
  require data + 35 <′ calldata.size
  require data.length <= LOCK8605463013()
  require data + data.length + 36 <= calldata.size
  require data.length >=′ 96
  require cd[(data + 36)] == address(cd[(data + 36)])
  require cd[(data + 68)] == address(cd[(data + 68)])
  require cd[(data + 100)] == cd[(data + 100)] % unknown01000000()
  if address(cd[(data + 36)]) < address(cd[(data + 68)]):
      require caller == address(sha3(0, 2276643401503442211, sha3(address(cd[(data + 36)]), address(cd[(data + 68)]), cd[(data + 100)] % unknown01000000()), 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54))
  else:
      require caller == address(sha3(0, 2276643401503442211, sha3(address(cd[(data + 68)]), address(cd[(data + 36)]), cd[(data + 100)] % unknown01000000()), 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54))
  if amount0Delta >′ 0:
      mem[537 len 96] = transfer(address recipient, uint256 amount), caller, amount0Delta, mem[537 len 28]
  else:
      mem[537 len 96] = transfer(address recipient, uint256 amount), caller, amount1Delta, mem[537 len 28]
  call address(cd[(data + 36)]).mem[537 len 4] with:
       gas gas_remaining wei
      args mem[541 len 64]
  if not return_data.size:
      if not ext_call.success:
          revert with 0, 'TransferHelper::safeTransfer: transfer failed'
      if cd[(data + 36)]:
          require cd[(data + 36)] >=′ 32
          require cd[(data + 68)] == bool(cd[(data + 68)])
          if not cd[(data + 68)]:
              revert with 0, 'TransferHelper::safeTransfer: transfer failed'
  else:
      mem[569 len return_data.size] = ext_call.return_data[0 len return_data.size]
      if not ext_call.success:
          revert with 0, 'TransferHelper::safeTransfer: transfer failed'
      if return_data.size:
          require return_data.size >=′ 32
          require mem[569] == bool(mem[569])
          if not mem[569]:
              revert with 0, 'TransferHelper::safeTransfer: transfer failed'

def unknownaaf1bbfb(): # not payable
  require calldata.size - 4 >=′ 64
  require cd[4] <= LOCK8605463013()
  require cd[4] + 35 <′ calldata.size
  require ('cd', 4).length <= LOCK8605463013()
  require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
  if cd[36] > LOCK8605463013():
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  mem[96] = cd[36]
  mem[64] = (32 * cd[36]) + 128
  if not cd[36]:
      idx = 0
      while idx < cd[36]:
          if idx >= ('cd', 4).length:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])
          static call address(cd[((32 * idx) + cd[4] + 36)]).decimals() with:
                  gas gas_remaining wei
          mem[mem[64]] = ext_call.return_data[0]
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          _32 = mem[64]
          mem[64] = mem[64] + ceil32(return_data.size)
          require return_data.size >=′ 32
          require mem[_32] == mem[_32 + 31 len 1]
          if idx >= mem[96]:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          mem[(32 * idx) + 128] = mem[_32 + 31 len 1]
          if not idx - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          idx = idx + 1
          continue 
  else:
      mem[128 len 32 * cd[36]] = call.data[calldata.size len 32 * cd[36]]
      idx = 0
      while idx < cd[36]:
          if idx >= ('cd', 4).length:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])
          static call address(cd[((32 * idx) + cd[4] + 36)]).decimals() with:
                  gas gas_remaining wei
          mem[mem[64]] = ext_call.return_data[0]
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          _33 = mem[64]
          mem[64] = mem[64] + ceil32(return_data.size)
          require return_data.size >=′ 32
          require mem[_33] == mem[_33 + 31 len 1]
          if idx >= mem[96]:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          mem[(32 * idx) + 128] = mem[_33 + 31 len 1]
          if not idx - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          idx = idx + 1
          continue 
  mem[mem[64]] = 32
  mem[mem[64] + 32] = mem[96]
  mem[mem[64] + 64 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
  return 32, mem[mem[64] + 32 len (32 * mem[96]) + 32]

def unknownf4b5eedc(): # not payable
  require calldata.size - 4 >=′ 96
  require cd[4] == address(cd[4])
  require cd[36] <= LOCK8605463013()
  require cd[36] + 35 <′ calldata.size
  require ('cd', 36).length <= LOCK8605463013()
  require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
  if cd[68] > LOCK8605463013():
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  mem[96] = cd[68]
  mem[64] = (32 * cd[68]) + 128
  if not cd[68]:
      idx = 0
      while idx < cd[68]:
          if idx >= ('cd', 36).length:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          require cd[((32 * idx) + cd[36] + 36)] == address(cd[((32 * idx) + cd[36] + 36)])
          mem[mem[64] + 4] = address(cd[4])
          static call address(cd[((32 * idx) + cd[36] + 36)]).balanceOf(address account) with:
                  gas gas_remaining wei
                 args address(cd[4])
          mem[mem[64]] = ext_call.return_data[0]
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          _32 = mem[64]
          mem[64] = mem[64] + ceil32(return_data.size)
          require return_data.size >=′ 32
          if idx >= mem[96]:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          mem[(32 * idx) + 128] = mem[_32]
          if not idx - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          idx = idx + 1
          continue 
  else:
      mem[128 len 32 * cd[68]] = call.data[calldata.size len 32 * cd[68]]
      idx = 0
      while idx < cd[68]:
          if idx >= ('cd', 36).length:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          require cd[((32 * idx) + cd[36] + 36)] == address(cd[((32 * idx) + cd[36] + 36)])
          mem[mem[64] + 4] = address(cd[4])
          static call address(cd[((32 * idx) + cd[36] + 36)]).balanceOf(address account) with:
                  gas gas_remaining wei
                 args address(cd[4])
          mem[mem[64]] = ext_call.return_data[0]
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          _33 = mem[64]
          mem[64] = mem[64] + ceil32(return_data.size)
          require return_data.size >=′ 32
          if idx >= mem[96]:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          mem[(32 * idx) + 128] = mem[_33]
          if not idx - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          idx = idx + 1
          continue 
  mem[mem[64]] = 32
  mem[mem[64] + 32] = mem[96]
  mem[mem[64] + 64 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
  return 32, mem[mem[64] + 32 len (32 * mem[96]) + 32]

def unknown98a108fc(uint256 _param1, uint256 _param2, uint256 _param3, uint256 _param4, uint256 _param5): # not payable
  require calldata.size - 4 >=′ 160
  require _param3 == address(_param3)
  require _param4 == address(_param4)
  require _param5 == bool(_param5)
  if not stor0[caller]:
      revert with 0, 'owner'
  static call address(_param3).getReserves() with:
          gas gas_remaining wei
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  require return_data.size >=′ 96
  require ext_call.return_data[0] == ext_call.return_data[18 len 14]
  require ext_call.return_data[32] == ext_call.return_data[50 len 14]
  require ext_call.return_data[64] == ext_call.return_data[92 len 4]
  if _param1 and 997 > -1 / _param1:
      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
  if 997 * _param1 / 997 != _param1:
      revert with 0, 'ds-math-mul-overflow'
  if _param5:
      if not ext_call.return_data[50 len 14]:
          if ext_call.return_data[18 len 14] and 1000 > -1 / ext_call.return_data[18 len 14]:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
              revert with 0, 'ds-math-mul-overflow'
          if 1000 * ext_call.return_data[18 len 14] > !(997 * _param1):
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if (1000 * ext_call.return_data[18 len 14]) + (997 * _param1) < 1000 * ext_call.return_data[18 len 14]:
              revert with 0, 'ds-math-add-overflow'
          if not (1000 * ext_call.return_data[18 len 14]) + (997 * _param1):
              revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
          if 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * _param1) < _param2:
              revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
      else:
          if 997 * _param1 and ext_call.return_data[50 len 14] > -1 / 997 * _param1:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if not ext_call.return_data[50 len 14]:
              revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
          if 997 * _param1 * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * _param1:
              revert with 0, 'ds-math-mul-overflow'
          if ext_call.return_data[18 len 14] and 1000 > -1 / ext_call.return_data[18 len 14]:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
              revert with 0, 'ds-math-mul-overflow'
          if 1000 * ext_call.return_data[18 len 14] > !(997 * _param1):
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if (1000 * ext_call.return_data[18 len 14]) + (997 * _param1) < 1000 * ext_call.return_data[18 len 14]:
              revert with 0, 'ds-math-add-overflow'
          if not (1000 * ext_call.return_data[18 len 14]) + (997 * _param1):
              revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
          if 997 * _param1 * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * _param1) < _param2:
              revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
  else:
      if not ext_call.return_data[18 len 14]:
          if ext_call.return_data[50 len 14] and 1000 > -1 / ext_call.return_data[50 len 14]:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
              revert with 0, 'ds-math-mul-overflow'
          if 1000 * ext_call.return_data[50 len 14] > !(997 * _param1):
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if (1000 * ext_call.return_data[50 len 14]) + (997 * _param1) < 1000 * ext_call.return_data[50 len 14]:
              revert with 0, 'ds-math-add-overflow'
          if not (1000 * ext_call.return_data[50 len 14]) + (997 * _param1):
              revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
          if 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * _param1) < _param2:
              revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
      else:
          if 997 * _param1 and ext_call.return_data[18 len 14] > -1 / 997 * _param1:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if not ext_call.return_data[18 len 14]:
              revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
          if 997 * _param1 * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * _param1:
              revert with 0, 'ds-math-mul-overflow'
          if ext_call.return_data[50 len 14] and 1000 > -1 / ext_call.return_data[50 len 14]:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
              revert with 0, 'ds-math-mul-overflow'
          if 1000 * ext_call.return_data[50 len 14] > !(997 * _param1):
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if (1000 * ext_call.return_data[50 len 14]) + (997 * _param1) < 1000 * ext_call.return_data[50 len 14]:
              revert with 0, 'ds-math-add-overflow'
          if not (1000 * ext_call.return_data[50 len 14]) + (997 * _param1):
              revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
          if 997 * _param1 * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * _param1) < _param2:
              revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
  mem[ceil32(return_data.size) + 196 len 96] = transfer(address recipient, uint256 amount), address(_param3) << 64, 0, _param1, mem[ceil32(return_data.size) + 196 len 28]
  call address(_param4).mem[ceil32(return_data.size) + 196 len 4] with:
       gas gas_remaining wei
      args mem[ceil32(return_data.size) + 200 len 64]
  if not return_data.size:
      if not ext_call.success:
          revert with 0, 'TransferHelper::safeTransfer: transfer failed'
      if ext_call.return_data[0]:
          require ext_call.return_data[0] >=′ 32
          require ext_call.return_data[32] == bool(ext_call.return_data[32])
          if not ext_call.return_data[32]:
              revert with 0, 'TransferHelper::safeTransfer: transfer failed'
  else:
      mem[ceil32(return_data.size) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
      if not ext_call.success:
          revert with 0, 'TransferHelper::safeTransfer: transfer failed'
      if return_data.size:
          require return_data.size >=′ 32
          require mem[ceil32(return_data.size) + 228] == bool(mem[ceil32(return_data.size) + 228])
          if not mem[ceil32(return_data.size) + 228]:
              revert with 0, 'TransferHelper::safeTransfer: transfer failed'
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def unknown1686f9c9(): # not payable
  require calldata.size - 4 >=′ 32
  require cd[4] <= LOCK8605463013()
  require calldata.size >′ cd[4] + 35
  if ('cd', 4).length > LOCK8605463013():
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > LOCK8605463013():
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  mem[96] = ('cd', 4).length
  require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
  s = 128
  idx = cd[4] + 36
  while idx < cd[4] + (32 * ('cd', 4).length) + 36:
      require cd[idx] == address(cd[idx])
      mem[s] = cd[idx]
      s = s + 32
      idx = idx + 32
      continue 
  if ('cd', 4).length > LOCK8605463013():
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  mem[ceil32(32 * ('cd', 4).length) + 97] = ('cd', 4).length
  if not ('cd', 4).length:
      if ('cd', 4).length > LOCK8605463013():
          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
      mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 129] = ('cd', 4).length
      if ('cd', 4).length > LOCK8605463013():
          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
      if ('cd', 4).length > LOCK8605463013():
          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
      if not ('cd', 4).length:
          if ('cd', 4).length > LOCK8605463013():
              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
          if not ('cd', 4).length:
              if not ('cd', 4).length:
                  if 0 < ('cd', 4).length:
                      if 0 >= ('cd', 4).length:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      mem[ceil32(32 * ('cd', 4).length) + (164 * ('cd', 4).length) + 257] = 0x3850c7bd00000000000000000000000000000000000000000000000000000000
                      static call mem[140 len 20].slot0() with:
                              gas gas_remaining wei
                             args mem[ceil32(32 * ('cd', 4).length) + (164 * ('cd', 4).length) + 261 len 64 * ('cd', 4).length]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 224
                      require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                      require ext_call.return_data[32] == ('signextend', 2, ('ext_call.return_data', 32, 32))
                      require ext_call.return_data[64] == ext_call.return_data[94 len 2]
          else:
              if not ('cd', 4).length:
                  if not ('cd', 4).length:
                      if 0 < ('cd', 4).length:
                          if 0 >= ('cd', 4).length:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          mem[ceil32(32 * ('cd', 4).length) + (164 * ('cd', 4).length) + 257] = 0x3850c7bd00000000000000000000000000000000000000000000000000000000
                          static call mem[140 len 20].slot0() with:
                                  gas gas_remaining wei
                                 args mem[ceil32(32 * ('cd', 4).length) + (164 * ('cd', 4).length) + 261 len 64 * ('cd', 4).length]
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          require return_data.size >=′ 224
                          require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                          require ext_call.return_data[32] == ('signextend', 2, ('ext_call.return_data', 32, 32))
                          require ext_call.return_data[64] == ext_call.return_data[94 len 2]
              else:
                  if not ('cd', 4).length:
                      if 0 < ('cd', 4).length:
                          if 0 >= ('cd', 4).length:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          mem[ceil32(32 * ('cd', 4).length) + (164 * ('cd', 4).length) + 257] = 0x3850c7bd00000000000000000000000000000000000000000000000000000000
                          static call mem[140 len 20].slot0() with:
                                  gas gas_remaining wei
                                 args mem[ceil32(32 * ('cd', 4).length) + (164 * ('cd', 4).length) + 261 len 64 * ('cd', 4).length]
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          require return_data.size >=′ 224
                          require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                          require ext_call.return_data[32] == ('signextend', 2, ('ext_call.return_data', 32, 32))
      else:
          if not ('cd', 4).length:
              if ('cd', 4).length > LOCK8605463013():
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              if not ('cd', 4).length:
                  if not ('cd', 4).length:
                      if 0 < ('cd', 4).length:
                          if 0 >= ('cd', 4).length:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          mem[ceil32(32 * ('cd', 4).length) + (164 * ('cd', 4).length) + 257] = 0x3850c7bd00000000000000000000000000000000000000000000000000000000
                          static call mem[140 len 20].slot0() with:
                                  gas gas_remaining wei
                                 args mem[ceil32(32 * ('cd', 4).length) + (164 * ('cd', 4).length) + 261 len 64 * ('cd', 4).length]
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          require return_data.size >=′ 224
                          require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                          require ext_call.return_data[32] == ('signextend', 2, ('ext_call.return_data', 32, 32))
                          require ext_call.return_data[64] == ext_call.return_data[94 len 2]
              else:
                  if not ('cd', 4).length:
                      if 0 < ('cd', 4).length:
                          if 0 >= ('cd', 4).length:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          mem[ceil32(32 * ('cd', 4).length) + (164 * ('cd', 4).length) + 257] = 0x3850c7bd00000000000000000000000000000000000000000000000000000000
                          static call mem[140 len 20].slot0() with:
                                  gas gas_remaining wei
                                 args mem[ceil32(32 * ('cd', 4).length) + (164 * ('cd', 4).length) + 261 len 64 * ('cd', 4).length]
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          require return_data.size >=′ 224
                          require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                          require ext_call.return_data[32] == ('signextend', 2, ('ext_call.return_data', 32, 32))
          else:
              if not ('cd', 4).length:
              if ('cd', 4).length > LOCK8605463013():
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              if not ('cd', 4).length:
                  if 0 < ('cd', 4).length:
                      if 0 >= ('cd', 4).length:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      mem[ceil32(32 * ('cd', 4).length) + (164 * ('cd', 4).length) + 257] = 0x3850c7bd00000000000000000000000000000000000000000000000000000000
                      static call mem[140 len 20].slot0() with:
                              gas gas_remaining wei
                             args mem[ceil32(32 * ('cd', 4).length) + (164 * ('cd', 4).length) + 261 len 64 * ('cd', 4).length]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 224
                      require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                      require ext_call.return_data[32] == ('signextend', 2, ('ext_call.return_data', 32, 32))
  else:
      mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 4).length] = call.data[calldata.size len 32 * ('cd', 4).length]
      if ('cd', 4).length > LOCK8605463013():
          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
      mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 129] = ('cd', 4).length
      if ('cd', 4).length > LOCK8605463013():
          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
      if ('cd', 4).length > LOCK8605463013():
          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
      if not ('cd', 4).length:
          if not ('cd', 4).length:
              if ('cd', 4).length > LOCK8605463013():
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              if not ('cd', 4).length:
                  if not ('cd', 4).length:
                      if 0 < ('cd', 4).length:
                          if 0 >= ('cd', 4).length:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          mem[ceil32(32 * ('cd', 4).length) + (164 * ('cd', 4).length) + 257] = 0x3850c7bd00000000000000000000000000000000000000000000000000000000
                          static call mem[140 len 20].slot0() with:
                                  gas gas_remaining wei
                                 args mem[ceil32(32 * ('cd', 4).length) + (164 * ('cd', 4).length) + 261 len 64 * ('cd', 4).length]
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          require return_data.size >=′ 224
                          require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                          require ext_call.return_data[32] == ('signextend', 2, ('ext_call.return_data', 32, 32))
                          require ext_call.return_data[64] == ext_call.return_data[94 len 2]
              else:
                  if not ('cd', 4).length:
                      if 0 < ('cd', 4).length:
                          if 0 >= ('cd', 4).length:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          mem[ceil32(32 * ('cd', 4).length) + (164 * ('cd', 4).length) + 257] = 0x3850c7bd00000000000000000000000000000000000000000000000000000000
                          static call mem[140 len 20].slot0() with:
                                  gas gas_remaining wei
                                 args mem[ceil32(32 * ('cd', 4).length) + (164 * ('cd', 4).length) + 261 len 64 * ('cd', 4).length]
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          require return_data.size >=′ 224
                          require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                          require ext_call.return_data[32] == ('signextend', 2, ('ext_call.return_data', 32, 32))
          else:
              if not ('cd', 4).length:
              if ('cd', 4).length > LOCK8605463013():
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              if not ('cd', 4).length:
                  if 0 < ('cd', 4).length:
                      if 0 >= ('cd', 4).length:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      mem[ceil32(32 * ('cd', 4).length) + (164 * ('cd', 4).length) + 257] = 0x3850c7bd00000000000000000000000000000000000000000000000000000000
                      static call mem[140 len 20].slot0() with:
                              gas gas_remaining wei
                             args mem[ceil32(32 * ('cd', 4).length) + (164 * ('cd', 4).length) + 261 len 64 * ('cd', 4).length]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 224
                      require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                      require ext_call.return_data[32] == ('signextend', 2, ('ext_call.return_data', 32, 32))
      else:
          if ('cd', 4).length:
          else:
              if not ('cd', 4).length:
          if ('cd', 4).length > LOCK8605463013():
              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
          if not ('cd', 4).length:
              if 0 < ('cd', 4).length:
                  if 0 >= ('cd', 4).length:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  mem[ceil32(32 * ('cd', 4).length) + (164 * ('cd', 4).length) + 257] = 0x3850c7bd00000000000000000000000000000000000000000000000000000000
                  static call mem[140 len 20].slot0() with:
                          gas gas_remaining wei
                         args mem[ceil32(32 * ('cd', 4).length) + (164 * ('cd', 4).length) + 261 len 64 * ('cd', 4).length]
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >=′ 224
                  require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                  require ext_call.return_data[32] == ('signextend', 2, ('ext_call.return_data', 32, 32))
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def _fallback(?) payable: # default function
  if calldata.size < 4:
      require not calldata.size
      stop
  if whitelist(address _param1) <= uint32(call.func_hash) >> 224:
      if unknownae9779c6(uint256 _param1) > uint32(call.func_hash) >> 224:
          if whitelist(address _param1) == uint32(call.func_hash) >> 224:
              require not call.value
              require calldata.size - 4 >=′ 32
              require cd[4] == address(cd[4])
              return bool(stor0[cd[4]])
          if withdrawEth(uint256 amount, address to) == uint32(call.func_hash) >> 224:
              require not call.value
              require calldata.size - 4 >=′ 64
              require cd[36] == address(cd[36])
              if not stor0[caller]:
                  revert with 0, 'owner'
              if not stor1[address(cd[36])]:
                  if address(cd[36]) != caller:
                      revert with 0, 'Invalid addr'
              call address(cd[36]) with:
                 value cd[4] wei
                   gas 2300 * is_zero(value) wei
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              stop
          require unknownaaf1bbfb() == uint32(call.func_hash) >> 224
          require not call.value
          require calldata.size - 4 >=′ 64
          require cd[4] <= LOCK8605463013()
          require cd[4] + 35 <′ calldata.size
          require ('cd', 4).length <= LOCK8605463013()
          require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
          if cd[36] > LOCK8605463013():
              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
      else:
          if unknownae9779c6(uint256 _param1) == uint32(call.func_hash) >> 224:
              require not call.value
              require calldata.size - 4 >=′ 32
              if not stor0[caller]:
                  revert with 0, 'owner'
              require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
              call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
                 value cd[4] wei
                   gas gas_remaining wei
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              stop
          if 3438422311 == uint32(call.func_hash) >> 224:
              require not call.value
              require calldata.size - 4 >=′ 224
              if not stor0[caller]:
                  revert with 0, 'owner'
              require cd[132] == address(cd[132])
              require cd[196] == bool(cd[196])
              require cd[68] < 0x8000000000000000000000000000000000000000000000000000000000000000
              require cd[196] == bool(cd[196])
              require cd[4] == address(cd[4])
              require cd[36] == address(cd[36])
              require cd[164] == cd[164] % unknown01000000()
          else:
              if unknownf4b5eedc() == uint32(call.func_hash) >> 224:
                  require not call.value
                  require calldata.size - 4 >=′ 96
                  require cd[4] == address(cd[4])
                  require cd[36] <= LOCK8605463013()
                  require cd[36] + 35 <′ calldata.size
                  require ('cd', 36).length <= LOCK8605463013()
                  require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
                  if cd[68] > LOCK8605463013():
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              else:
                  require uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes data) == uint32(call.func_hash) >> 224
                  require not call.value
                  require calldata.size - 4 >=′ 96
                  require cd[68] <= LOCK8605463013()
                  require cd[68] + 35 <′ calldata.size
                  require ('cd', 68).length <= LOCK8605463013()
                  require cd[68] + ('cd', 68).length + 36 <= calldata.size
                  require ('cd', 68).length >=′ 96
                  require ('cd', 68)[0] == address(('cd', 68)[0])
                  require ('cd', 68)[1] == address(('cd', 68)[1])
                  require ('cd', 68)[2] == ('cd', 68)[2] % unknown01000000()
                  if address(('cd', 68)[0]) < address(('cd', 68)[1]):
                      require caller == address(sha3(0, 2276643401503442211, sha3(address(('cd', 68)[0]), address(('cd', 68)[1]), ('cd', 68)[2] % unknown01000000()), 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54))
                  else:
                      require caller == address(sha3(0, 2276643401503442211, sha3(address(('cd', 68)[1]), address(('cd', 68)[0]), ('cd', 68)[2] % unknown01000000()), 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54))
  else:
      if withdrawToken(address token, uint256 amount, address sendTo) <= uint32(call.func_hash) >> 224:
          if withdrawToken(address token, uint256 amount, address sendTo) == uint32(call.func_hash) >> 224:
              require not call.value
              require calldata.size - 4 >=′ 96
              require cd[4] == address(cd[4])
              require cd[68] == address(cd[68])
              if not stor0[caller]:
                  revert with 0, 'owner'
              if not stor1[address(cd[68])]:
                  if address(cd[68]) != caller:
                      revert with 0, 'Invalid addr'
          else:
              if addOwner(address owner) == uint32(call.func_hash) >> 224:
                  require not call.value
                  require calldata.size - 4 >=′ 32
                  require cd[4] == address(cd[4])
                  if not stor0[caller]:
                      revert with 0, 'owner'
                  stor0[address(cd[4])] = 1
                  stop
              require 2560690428 == uint32(call.func_hash) >> 224
              require not call.value
              require calldata.size - 4 >=′ 160
              require cd[68] == address(cd[68])
              require cd[100] == address(cd[100])
              require cd[132] == bool(cd[132])
              if not stor0[caller]:
                  revert with 0, 'owner'
              static call address(cd[68]).getReserves() with:
                      gas gas_remaining wei
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 96
              require ext_call.return_data[0] == ext_call.return_data[18 len 14]
              require ext_call.return_data[32] == ext_call.return_data[50 len 14]
              require ext_call.return_data[64] == ext_call.return_data[92 len 4]
              if cd[4] and 997 > -1 / cd[4]:
                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
              if 997 * cd[4] / 997 != cd[4]:
                  revert with 0, 'ds-math-mul-overflow'
              if cd[132]:
                  if not ext_call.return_data[50 len 14]:
                      if ext_call.return_data[18 len 14] and 1000 > -1 / ext_call.return_data[18 len 14]:
                          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                      if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                          revert with 0, 'ds-math-mul-overflow'
                      if 1000 * ext_call.return_data[18 len 14] > !(997 * cd[4]):
                          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                      if (1000 * ext_call.return_data[18 len 14]) + (997 * cd[4]) < 1000 * ext_call.return_data[18 len 14]:
                          revert with 0, 'ds-math-add-overflow'
                  else:
                      if 997 * cd[4] and ext_call.return_data[50 len 14] > -1 / 997 * cd[4]:
                          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                      if not ext_call.return_data[50 len 14]:
                          revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                      if 997 * cd[4] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * cd[4]:
                          revert with 0, 'ds-math-mul-overflow'
                      if ext_call.return_data[18 len 14] and 1000 > -1 / ext_call.return_data[18 len 14]:
                          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                      if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                          revert with 0, 'ds-math-mul-overflow'
              else:
                  if not ext_call.return_data[18 len 14]:
                      if ext_call.return_data[50 len 14] and 1000 > -1 / ext_call.return_data[50 len 14]:
                          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                      if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                          revert with 0, 'ds-math-mul-overflow'
                      if 1000 * ext_call.return_data[50 len 14] > !(997 * cd[4]):
                          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                      if (1000 * ext_call.return_data[50 len 14]) + (997 * cd[4]) < 1000 * ext_call.return_data[50 len 14]:
                          revert with 0, 'ds-math-add-overflow'
                  else:
                      if 997 * cd[4] and ext_call.return_data[18 len 14] > -1 / 997 * cd[4]:
                          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                      if not ext_call.return_data[18 len 14]:
                          revert with Panic(18)  # If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
                      if 997 * cd[4] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * cd[4]:
                          revert with 0, 'ds-math-mul-overflow'
                      if ext_call.return_data[50 len 14] and 1000 > -1 / ext_call.return_data[50 len 14]:
                          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                      if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                          revert with 0, 'ds-math-mul-overflow'
      else:
          if 377944521 == uint32(call.func_hash) >> 224:
              require not call.value
              require calldata.size - 4 >=′ 32
              require cd[4] <= LOCK8605463013()
              require calldata.size >′ cd[4] + 35
              if ('cd', 4).length > LOCK8605463013():
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              if ceil32(32 * ('cd', 4).length) + 129 < 128 or ceil32(32 * ('cd', 4).length) + 129 > LOCK8605463013():
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
          else:
              if removeOwner(address owner) == uint32(call.func_hash) >> 224:
                  require not call.value
                  require calldata.size - 4 >=′ 32
                  require cd[4] == address(cd[4])
                  if not stor0[caller]:
                      revert with 0, 'owner'
                  stor0[address(cd[4])] = 0
                  stop
              require 710544173 == uint32(call.func_hash) >> 224
              require not call.value
              require calldata.size - 4 >=′ 96
              require cd[4] <= LOCK8605463013()
              require cd[4] + 35 <′ calldata.size
              require ('cd', 4).length <= LOCK8605463013()
              require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
              require cd[36] <= LOCK8605463013()
              require cd[36] + 35 <′ calldata.size
              require ('cd', 36).length <= LOCK8605463013()
              require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
              if cd[68] > LOCK8605463013():
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              if cd[68] > LOCK8605463013():
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              if not cd[68]:
              else:
                  if not cd[68]:
              if 0 < cd[68]:
                  if 0 >= ('cd', 4).length:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  require ('cd', 4)[0] == address(('cd', 4)[0])
                  if 0 >= ('cd', 36).length:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  require ('cd', 36)[0] == address(('cd', 36)[0])
                  if address(('cd', 4)[0]) < address(('cd', 36)[0]):
                      mem[(64 * cd[68]) + 224] = address(('cd', 4)[0])
                      mem[(64 * cd[68]) + 244] = address(('cd', 36)[0])
                  else:
                      mem[(64 * cd[68]) + 224] = address(('cd', 36)[0])
                      mem[(64 * cd[68]) + 244] = address(('cd', 4)[0])
                  static call address(sha3(0, 6659063423423185226, sha3(mem[(64 * cd[68]) + 224 len (127 * cd[68]) + 40]), 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f)).getReserves() with:
                          gas gas_remaining wei
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >=′ 96
                  require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                  require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                  require ext_call.return_data[64] == ext_call.return_data[92 len 4]
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def unknown2a5a0b2d(): # not payable
  require calldata.size - 4 >=′ 96
  require cd[4] <= LOCK8605463013()
  require cd[4] + 35 <′ calldata.size
  require ('cd', 4).length <= LOCK8605463013()
  require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
  require cd[36] <= LOCK8605463013()
  require cd[36] + 35 <′ calldata.size
  require ('cd', 36).length <= LOCK8605463013()
  require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
  if cd[68] > LOCK8605463013():
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  mem[96] = cd[68]
  if not cd[68]:
      if cd[68] > LOCK8605463013():
          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
      mem[(32 * cd[68]) + 128] = cd[68]
      mem[64] = (64 * cd[68]) + 160
      if not cd[68]:
          idx = 0
          while idx < cd[68]:
              if idx >= ('cd', 4).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])
              if idx >= ('cd', 36).length:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              require cd[((32 * idx) + cd[36] + 36)] == address(cd[((32 * idx) + cd[36] + 36)])
              if address(cd[((32 * idx) + cd[4] + 36)]) < address(cd[((32 * idx) + cd[36] + 36)]):
                  _196 = mem[64]
                  mem[mem[64] + 32] = address(cd[((32 * idx) + cd[4] + 36)])
                  mem[mem[64] + 52] = address(cd[((32 * idx) + cd[36] + 36)])
                  _197 = mem[64]
                  mem[mem[64]] = 40
                  mem[64] = mem[64] + 72
                  _199 = sha3(mem[_197 + 32 len mem[_197]])
                  mem[_196 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                  mem[_196 + 105] = 0x5c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f000000000000000000000000
                  mem[_196 + 125] = _199
                  mem[_196 + 157] = 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f
                  mem[_196 + 72] = 85
                  static call address(sha3(0, 6659063423423185226, _199, 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f)).getReserves() with:
                          gas gas_remaining wei
                  mem[_196 + 189 len 96] = ext_call.return_data[0 len 96]
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  mem[64] = _196 + ceil32(return_data.size) + 189
                  require return_data.size >=′ 96
                  require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                  require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                  require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                  if idx >= mem[96]:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  if idx >= mem[(32 * cd[68]) + 128]:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  if address(cd[((32 * idx) + cd[4] + 36)]) == address(cd[((32 * idx) + cd[4] + 36)]):
                      mem[(32 * idx) + (32 * cd[68]) + 160] = ext_call.return_data[50 len 14]
                      mem[(32 * idx) + 128] = Mask(112, 0, ext_call.return_data[0])
                  else:
                      mem[(32 * idx) + (32 * cd[68]) + 160] = ext_call.return_data[18 len 14]
                      mem[(32 * idx) + 128] = Mask(112, 0, ext_call.return_data[32])
              else:
                  _201 = mem[64]
                  mem[mem[64] + 32] = address(cd[((32 * idx) + cd[36] + 36)])
                  mem[mem[64] + 52] = address(cd[((32 * idx) + cd[4] + 36)])
                  _202 = mem[64]
                  mem[mem[64]] = 40
                  mem[64] = mem[64] + 72
                  _204 = sha3(mem[_202 + 32 len mem[_202]])
                  mem[_201 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                  mem[_201 + 105] = 0x5c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f000000000000000000000000
                  mem[_201 + 125] = _204
                  mem[_201 + 157] = 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f
                  mem[_201 + 72] = 85
                  static call address(sha3(0, 6659063423423185226, _204, 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f)).getReserves() with:
                          gas gas_remaining wei
                  mem[_201 + 189 len 96] = ext_call.return_data[0 len 96]
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  mem[64] = _201 + ceil32(return_data.size) + 189
                  require return_data.size >=′ 96
                  require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                  require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                  require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                  if idx >= mem[96]:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  if idx >= mem[(32 * cd[68]) + 128]:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  if address(cd[((32 * idx) + cd[4] + 36)]) == address(cd[((32 * idx) + cd[36] + 36)]):
                      mem[(32 * idx) + (32 * cd[68]) + 160] = ext_call.return_data[50 len 14]
                      mem[(32 * idx) + 128] = Mask(112, 0, ext_call.return_data[0])
                  else:
                      mem[(32 * idx) + (32 * cd[68]) + 160] = ext_call.return_data[18 len 14]
                      mem[(32 * idx) + 128] = Mask(112, 0, ext_call.return_data[32])
              if not idx - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
              idx = idx + 1
              continue 
          _172 = mem[64]
          mem[mem[64]] = 64
          _176 = mem[96]
          mem[mem[64] + 64] = mem[96]
          mem[mem[64] + 96 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
          mem[mem[64] + 32] = (32 * mem[96]) + 96
          _344 = mem[(32 * cd[68]) + 128]
          mem[_172 + (32 * mem[96]) + 96] = mem[(32 * cd[68]) + 128]
          mem[_172 + (32 * _176) + 128 len 32 * _344] = mem[(32 * cd[68]) + 160 len 32 * _344]
          return memory
            from mem[64]
             len _172 + (32 * _176) + (32 * _344) + -mem[64] + 128
      mem[(32 * cd[68]) + 160 len 32 * cd[68]] = call.data[calldata.size len 32 * cd[68]]
      idx = 0
      while idx < cd[68]:
          if idx >= ('cd', 4).length:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])
          if idx >= ('cd', 36).length:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          require cd[((32 * idx) + cd[36] + 36)] == address(cd[((32 * idx) + cd[36] + 36)])
          if address(cd[((32 * idx) + cd[4] + 36)]) < address(cd[((32 * idx) + cd[36] + 36)]):
              _206 = mem[64]
              mem[mem[64] + 32] = address(cd[((32 * idx) + cd[4] + 36)])
              mem[mem[64] + 52] = address(cd[((32 * idx) + cd[36] + 36)])
              _207 = mem[64]
              mem[mem[64]] = 40
              mem[64] = mem[64] + 72
              _209 = sha3(mem[_207 + 32 len mem[_207]])
              mem[_206 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
              mem[_206 + 105] = 0x5c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f000000000000000000000000
              mem[_206 + 125] = _209
              mem[_206 + 157] = 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f
              mem[_206 + 72] = 85
              static call address(sha3(0, 6659063423423185226, _209, 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f)).getReserves() with:
                      gas gas_remaining wei
              mem[_206 + 189 len 96] = ext_call.return_data[0 len 96]
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              mem[64] = _206 + ceil32(return_data.size) + 189
              require return_data.size >=′ 96
              require ext_call.return_data[0] == ext_call.return_data[18 len 14]
              require ext_call.return_data[32] == ext_call.return_data[50 len 14]
              require ext_call.return_data[64] == ext_call.return_data[92 len 4]
              if idx >= mem[96]:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              if idx >= mem[(32 * cd[68]) + 128]:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              if address(cd[((32 * idx) + cd[4] + 36)]) == address(cd[((32 * idx) + cd[4] + 36)]):
                  mem[(32 * idx) + (32 * cd[68]) + 160] = ext_call.return_data[50 len 14]
                  mem[(32 * idx) + 128] = Mask(112, 0, ext_call.return_data[0])
              else:
                  mem[(32 * idx) + (32 * cd[68]) + 160] = ext_call.return_data[18 len 14]
                  mem[(32 * idx) + 128] = Mask(112, 0, ext_call.return_data[32])
          else:
              _211 = mem[64]
              mem[mem[64] + 32] = address(cd[((32 * idx) + cd[36] + 36)])
              mem[mem[64] + 52] = address(cd[((32 * idx) + cd[4] + 36)])
              _212 = mem[64]
              mem[mem[64]] = 40
              mem[64] = mem[64] + 72
              _214 = sha3(mem[_212 + 32 len mem[_212]])
              mem[_211 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
              mem[_211 + 105] = 0x5c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f000000000000000000000000
              mem[_211 + 125] = _214
              mem[_211 + 157] = 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f
              mem[_211 + 72] = 85
              static call address(sha3(0, 6659063423423185226, _214, 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f)).getReserves() with:
                      gas gas_remaining wei
              mem[_211 + 189 len 96] = ext_call.return_data[0 len 96]
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              mem[64] = _211 + ceil32(return_data.size) + 189
              require return_data.size >=′ 96
              require ext_call.return_data[0] == ext_call.return_data[18 len 14]
              require ext_call.return_data[32] == ext_call.return_data[50 len 14]
              require ext_call.return_data[64] == ext_call.return_data[92 len 4]
              if idx >= mem[96]:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              if idx >= mem[(32 * cd[68]) + 128]:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              if address(cd[((32 * idx) + cd[4] + 36)]) == address(cd[((32 * idx) + cd[36] + 36)]):
                  mem[(32 * idx) + (32 * cd[68]) + 160] = ext_call.return_data[50 len 14]
                  mem[(32 * idx) + 128] = Mask(112, 0, ext_call.return_data[0])
              else:
                  mem[(32 * idx) + (32 * cd[68]) + 160] = ext_call.return_data[18 len 14]
                  mem[(32 * idx) + 128] = Mask(112, 0, ext_call.return_data[32])
          if not idx - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          idx = idx + 1
          continue 
      _173 = mem[64]
      mem[mem[64]] = 64
      _177 = mem[96]
      mem[mem[64] + 64] = mem[96]
      mem[mem[64] + 96 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
      mem[mem[64] + 32] = (32 * mem[96]) + 96
      _345 = mem[(32 * cd[68]) + 128]
      mem[_173 + (32 * mem[96]) + 96] = mem[(32 * cd[68]) + 128]
      mem[_173 + (32 * _177) + 128 len 32 * _345] = mem[(32 * cd[68]) + 160 len 32 * _345]
      return memory
        from mem[64]
         len _173 + (32 * _177) + (32 * _345) + -mem[64] + 128
  mem[128 len 32 * cd[68]] = call.data[calldata.size len 32 * cd[68]]
  if cd[68] > LOCK8605463013():
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  mem[(32 * cd[68]) + 128] = cd[68]
  mem[64] = (64 * cd[68]) + 160
  if not cd[68]:
      idx = 0
      while idx < cd[68]:
          if idx >= ('cd', 4).length:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])
          if idx >= ('cd', 36).length:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          require cd[((32 * idx) + cd[36] + 36)] == address(cd[((32 * idx) + cd[36] + 36)])
          if address(cd[((32 * idx) + cd[4] + 36)]) < address(cd[((32 * idx) + cd[36] + 36)]):
              _216 = mem[64]
              mem[mem[64] + 32] = address(cd[((32 * idx) + cd[4] + 36)])
              mem[mem[64] + 52] = address(cd[((32 * idx) + cd[36] + 36)])
              _217 = mem[64]
              mem[mem[64]] = 40
              mem[64] = mem[64] + 72
              _219 = sha3(mem[_217 + 32 len mem[_217]])
              mem[_216 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
              mem[_216 + 105] = 0x5c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f000000000000000000000000
              mem[_216 + 125] = _219
              mem[_216 + 157] = 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f
              mem[_216 + 72] = 85
              static call address(sha3(0, 6659063423423185226, _219, 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f)).getReserves() with:
                      gas gas_remaining wei
              mem[_216 + 189 len 96] = ext_call.return_data[0 len 96]
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              mem[64] = _216 + ceil32(return_data.size) + 189
              require return_data.size >=′ 96
              require ext_call.return_data[0] == ext_call.return_data[18 len 14]
              require ext_call.return_data[32] == ext_call.return_data[50 len 14]
              require ext_call.return_data[64] == ext_call.return_data[92 len 4]
              if idx >= mem[96]:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              if idx >= mem[(32 * cd[68]) + 128]:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              if address(cd[((32 * idx) + cd[4] + 36)]) == address(cd[((32 * idx) + cd[4] + 36)]):
                  mem[(32 * idx) + (32 * cd[68]) + 160] = ext_call.return_data[50 len 14]
                  mem[(32 * idx) + 128] = Mask(112, 0, ext_call.return_data[0])
              else:
                  mem[(32 * idx) + (32 * cd[68]) + 160] = ext_call.return_data[18 len 14]
                  mem[(32 * idx) + 128] = Mask(112, 0, ext_call.return_data[32])
          else:
              _221 = mem[64]
              mem[mem[64] + 32] = address(cd[((32 * idx) + cd[36] + 36)])
              mem[mem[64] + 52] = address(cd[((32 * idx) + cd[4] + 36)])
              _222 = mem[64]
              mem[mem[64]] = 40
              mem[64] = mem[64] + 72
              _224 = sha3(mem[_222 + 32 len mem[_222]])
              mem[_221 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
              mem[_221 + 105] = 0x5c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f000000000000000000000000
              mem[_221 + 125] = _224
              mem[_221 + 157] = 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f
              mem[_221 + 72] = 85
              static call address(sha3(0, 6659063423423185226, _224, 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f)).getReserves() with:
                      gas gas_remaining wei
              mem[_221 + 189 len 96] = ext_call.return_data[0 len 96]
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              mem[64] = _221 + ceil32(return_data.size) + 189
              require return_data.size >=′ 96
              require ext_call.return_data[0] == ext_call.return_data[18 len 14]
              require ext_call.return_data[32] == ext_call.return_data[50 len 14]
              require ext_call.return_data[64] == ext_call.return_data[92 len 4]
              if idx >= mem[96]:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              if idx >= mem[(32 * cd[68]) + 128]:
                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              if address(cd[((32 * idx) + cd[4] + 36)]) == address(cd[((32 * idx) + cd[36] + 36)]):
                  mem[(32 * idx) + (32 * cd[68]) + 160] = ext_call.return_data[50 len 14]
                  mem[(32 * idx) + 128] = Mask(112, 0, ext_call.return_data[0])
              else:
                  mem[(32 * idx) + (32 * cd[68]) + 160] = ext_call.return_data[18 len 14]
                  mem[(32 * idx) + 128] = Mask(112, 0, ext_call.return_data[32])
          if not idx - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          idx = idx + 1
          continue 
      _174 = mem[64]
      mem[mem[64]] = 64
      _178 = mem[96]
      mem[mem[64] + 64] = mem[96]
      mem[mem[64] + 96 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
      mem[mem[64] + 32] = (32 * mem[96]) + 96
      _346 = mem[(32 * cd[68]) + 128]
      mem[_174 + (32 * mem[96]) + 96] = mem[(32 * cd[68]) + 128]
      mem[_174 + (32 * _178) + 128 len 32 * _346] = mem[(32 * cd[68]) + 160 len 32 * _346]
      return memory
        from mem[64]
         len _174 + (32 * _178) + (32 * _346) + -mem[64] + 128
  mem[(32 * cd[68]) + 160 len 32 * cd[68]] = call.data[calldata.size len 32 * cd[68]]
  idx = 0
  while idx < cd[68]:
      if idx >= ('cd', 4).length:
          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
      require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])
      if idx >= ('cd', 36).length:
          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
      require cd[((32 * idx) + cd[36] + 36)] == address(cd[((32 * idx) + cd[36] + 36)])
      if address(cd[((32 * idx) + cd[4] + 36)]) < address(cd[((32 * idx) + cd[36] + 36)]):
          _226 = mem[64]
          mem[mem[64] + 32] = address(cd[((32 * idx) + cd[4] + 36)])
          mem[mem[64] + 52] = address(cd[((32 * idx) + cd[36] + 36)])
          _227 = mem[64]
          mem[mem[64]] = 40
          mem[64] = mem[64] + 72
          _229 = sha3(mem[_227 + 32 len mem[_227]])
          mem[_226 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
          mem[_226 + 105] = 0x5c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f000000000000000000000000
          mem[_226 + 125] = _229
          mem[_226 + 157] = 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f
          mem[_226 + 72] = 85
          static call address(sha3(0, 6659063423423185226, _229, 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f)).getReserves() with:
                  gas gas_remaining wei
          mem[_226 + 189 len 96] = ext_call.return_data[0 len 96]
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          mem[64] = _226 + ceil32(return_data.size) + 189
          require return_data.size >=′ 96
          require ext_call.return_data[0] == ext_call.return_data[18 len 14]
          require ext_call.return_data[32] == ext_call.return_data[50 len 14]
          require ext_call.return_data[64] == ext_call.return_data[92 len 4]
          if idx >= mem[96]:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          if idx >= mem[(32 * cd[68]) + 128]:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          if address(cd[((32 * idx) + cd[4] + 36)]) == address(cd[((32 * idx) + cd[4] + 36)]):
              mem[(32 * idx) + (32 * cd[68]) + 160] = ext_call.return_data[50 len 14]
              mem[(32 * idx) + 128] = Mask(112, 0, ext_call.return_data[0])
          else:
              mem[(32 * idx) + (32 * cd[68]) + 160] = ext_call.return_data[18 len 14]
              mem[(32 * idx) + 128] = Mask(112, 0, ext_call.return_data[32])
      else:
          _231 = mem[64]
          mem[mem[64] + 32] = address(cd[((32 * idx) + cd[36] + 36)])
          mem[mem[64] + 52] = address(cd[((32 * idx) + cd[4] + 36)])
          _232 = mem[64]
          mem[mem[64]] = 40
          mem[64] = mem[64] + 72
          _234 = sha3(mem[_232 + 32 len mem[_232]])
          mem[_231 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
          mem[_231 + 105] = 0x5c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f000000000000000000000000
          mem[_231 + 125] = _234
          mem[_231 + 157] = 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f
          mem[_231 + 72] = 85
          static call address(sha3(0, 6659063423423185226, _234, 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f)).getReserves() with:
                  gas gas_remaining wei
          mem[_231 + 189 len 96] = ext_call.return_data[0 len 96]
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          mem[64] = _231 + ceil32(return_data.size) + 189
          require return_data.size >=′ 96
          require ext_call.return_data[0] == ext_call.return_data[18 len 14]
          require ext_call.return_data[32] == ext_call.return_data[50 len 14]
          require ext_call.return_data[64] == ext_call.return_data[92 len 4]
          if idx >= mem[96]:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          if idx >= mem[(32 * cd[68]) + 128]:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          if address(cd[((32 * idx) + cd[4] + 36)]) == address(cd[((32 * idx) + cd[36] + 36)]):
              mem[(32 * idx) + (32 * cd[68]) + 160] = ext_call.return_data[50 len 14]
              mem[(32 * idx) + 128] = Mask(112, 0, ext_call.return_data[0])
          else:
              mem[(32 * idx) + (32 * cd[68]) + 160] = ext_call.return_data[18 len 14]
              mem[(32 * idx) + 128] = Mask(112, 0, ext_call.return_data[32])
      if not idx - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
      idx = idx + 1
      continue 
  _175 = mem[64]
  mem[mem[64]] = 64
  _179 = mem[96]
  mem[mem[64] + 64] = mem[96]
  mem[mem[64] + 96 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
  mem[mem[64] + 32] = (32 * mem[96]) + 96
  _347 = mem[(32 * cd[68]) + 128]
  mem[_175 + (32 * mem[96]) + 96] = mem[(32 * cd[68]) + 128]
  mem[_175 + (32 * _179) + 128 len 32 * _347] = mem[(32 * cd[68]) + 160 len 32 * _347]
  return memory
    from mem[64]
     len _175 + (32 * _179) + (32 * _347) + -mem[64] + 128


