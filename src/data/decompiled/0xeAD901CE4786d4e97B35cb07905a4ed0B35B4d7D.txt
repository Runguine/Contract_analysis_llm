# Palkeoramix decompiler. 

def storage:
  balanceOf is mapping of uint256 at storage 0
  allowance is mapping of uint256 at storage 1
  stor2 is uint8 at storage 2 offset 248
  totalSupply is uint256 at storage 2
  stor2 is uint256 at storage 2
  stor3 is bool at storage 3
  stor3 is uint8 at storage 3
  stor3 is uint8 at storage 3 offset 1
  stor3 is uint256 at storage 3
  stor4 is bool at storage 4
  stor4 is uint8 at storage 4
  stor4 is uint8 at storage 4 offset 1
  stor4 is uint256 at storage 4
  userReward is mapping of uint128 at storage 5
  unknownd68076c3 is mapping of uint128 at storage 6
  unknown4ba6dcd7 is uint256 at storage 7
  unknown60e0a9e1 is uint128 at storage 8
  stor8 is uint128 at storage 8 offset 128
  unknownd2a3584e is uint256 at storage 8
  stor9 is uint128 at storage 9
  stor9 is uint256 at storage 9
  stor10 is mapping of uint256 at storage 10
  stor11 is mapping of uint256 at storage 11

def totalSupply(): # not payable
  require calldata.size - 4 >=′ 0
  return totalSupply

def unknown4ba6dcd7(): # not payable
  require calldata.size - 4 >=′ 0
  return unknown4ba6dcd7

def userReward(address _account, address _token): # not payable
  require calldata.size - 4 >=′ 64
  require not Mask(96, 160, _account)
  require not Mask(96, 160, _token)
  return userReward[address(_account)][address(_token)], userReward[address(_account)][address(_token)]

def unknown60e0a9e1(): # not payable
  require calldata.size - 4 >=′ 0
  return unknown60e0a9e1

def balanceOf(address account): # not payable
  require calldata.size - 4 >=′ 32
  require not Mask(96, 160, account)
  return balanceOf[address(account)]

def unknownd2a3584e(): # not payable
  require calldata.size - 4 >=′ 0
  return (uint128(unknownd2a3584e) >> 128)

def unknownd68076c3(uint256 _param1): # not payable
  require calldata.size - 4 >=′ 32
  require not Mask(96, 160, _param1)
  return unknownd68076c3[address(_param1)], unknownd68076c3[address(_param1)]

def allowance(address owner, address spender): # not payable
  require calldata.size - 4 >=′ 64
  require not Mask(96, 160, owner)
  require not Mask(96, 160, spender)
  return allowance[address(owner)][address(spender)]

#
#  Regular functions
#

def decimals(): # not payable
  require calldata.size - 4 >=′ 0
  return 8

def unknown516399df(): # not payable
  require calldata.size - 4 >=′ 0
  return 1

def expiry(): # not payable
  require calldata.size - 4 >=′ 0
  return (484512 * 24 * 3600)

def SY(): # not payable
  require calldata.size - 4 >=′ 0
  return 0xac614884b52dbab8728476b5d50f0d672baed31f

def PT(): # not payable
  require calldata.size - 4 >=′ 0
  return 0xdfb913b117bc93fde164a4ff8b3176662d4198f3

def factory(): # not payable
  require calldata.size - 4 >=′ 0
  return 0x35a338522a435d46f77be32c70e215b813d0e3ac

def isExpired(): # not payable
  require calldata.size - 4 >=′ 0
  return 484512 * 24 * 3600 <= block.timestamp

def unknown0a2b83a7(): # not payable
  require calldata.size - 4 >=′ 0
  return uint128(stor9), uint128(stor9)

def approve(address spender, uint256 amount): # not payable
  require calldata.size - 4 >=′ 64
  require not Mask(96, 160, spender)
  if not caller:
      revert with Error(string reason), 'ERC20: approve from the zero address'
  if not spender:
      revert with Error(string reason), 'ERC20: approve to the zero address'
  allowance[caller][address(spender)] = amount
  log Approval(
        address owner=amount,
        address spender=caller,
        uint256 value=spender)
  return 1

def unknown53335819(array _param1, array _param2, array _param3): # not payable
  require calldata.size - 4 >=′ 96
  require _param1 <= LOCK8605463013()
  require _param1 + 35 <′ calldata.size
  require _param1.length <= LOCK8605463013()
  require (32 * _param1.length) + _param1 + 36 <= calldata.size
  require _param2 <= LOCK8605463013()
  require _param2 + 35 <′ calldata.size
  require _param2.length <= LOCK8605463013()
  require (32 * _param2.length) + _param2 + 36 <= calldata.size
  require _param3 <= LOCK8605463013()
  require _param3 + 35 <′ calldata.size
  require _param3.length <= LOCK8605463013()
  require (32 * _param3.length) + _param3 + 36 <= calldata.size
  if uint8(uint256(stor2.field_0)) >> 248 == 2:
      revert with Error(string reason), 'ReentrancyGuard: reentrant call'
  uint8(stor2.field_248) = 2
  if 484512 * 24 * 3600 <= block.timestamp:
      revert with 1528145626
  if not _param1.length:
      revert with ArrayEmpty()
  if _param2.length == _param1.length:
      if _param3.length != _param1.length:
          revert with ArrayLengthMismatch()
      if _param3.length > LOCK8605463013():
          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
      if ceil32(32 * _param3.length) + 97 > LOCK8605463013() or ceil32(32 * _param3.length) + 97 < 96:
          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
      require _param3 + (32 * _param3.length) + 36 <= calldata.size
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def unknown1d52edc4(): # not payable
  require calldata.size - 4 >=′ 0
  if uint8(uint256(stor2.field_0)) >> 248 == 2:
      revert with Error(string reason), 'ReentrancyGuard: reentrant call'
  uint8(stor2.field_248) = 2
  if block.number == unknown60e0a9e1:
      uint8(stor2.field_248) = 1
      return (uint128(unknownd2a3584e) >> 128)
  static call 0xac614884b52dbab8728476b5d50f0d672baed31f.exchangeRate() with:
          gas gas_remaining wei
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  if not ext_call.success:
      if 0 <= uint128(unknownd2a3584e) >> 128:
          require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
      unknown60e0a9e1 = uint128(block.number)
      stor8 = 0
      log 0x71475f2f 
      log 0x0 
      uint8(stor2.field_248) = 1
      return 0
  if 32 > return_data.size:
      if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
      require return_data.size >=′ 32
  if ext_call.return_data[0] <= uint128(unknownd2a3584e) >> 128:
      require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
      unknown60e0a9e1 = uint128(block.number)
      stor8 = 0
      log 0x71475f2f 
      log 0x0 
      uint8(stor2.field_248) = 1
      return 0
  require ext_call.return_data[0] <= LOCK8605463013()
  unknown60e0a9e1 = uint128(block.number)
  stor8 = uint128(ext_call.return_data[0])
  log 0x71475f2f: uint128(ext_call.return_data[0])
  uint8(stor2.field_248) = 1
  return uint128(ext_call.return_data[0])

def rewardIndexesCurrent() payable: 
  mem[64] = 96
  require not call.value
  require calldata.size - 4 >=′ 0
  if uint8(uint256(stor2.field_0)) >> 248 == 2:
      revert with Error(string reason), 'ReentrancyGuard: reentrant call'
  uint8(stor2.field_248) = 2
  mem[96] = 0xf8b2f99100000000000000000000000000000000000000000000000000000000
  call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
       gas gas_remaining wei
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  if not ext_call.success:
      uint8(stor2.field_248) = 1
      mem[96] = 32
      mem[128] = mem[0]
      mem[160 len 32 * mem[0]] = mem[32 len 32 * mem[0]]
      return 32, mem[128 len (32 * mem[0]) + 32]
  mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
  if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  mem[64] = ceil32(return_data.size) + 96
  require return_data.size >=′ 32
  _4 = mem[96]
  require mem[96] <= LOCK8605463013()
  require mem[96] + 127 <′ return_data.size + 96
  _5 = mem[mem[96] + 96]
  if mem[mem[96] + 96] > LOCK8605463013():
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  if ceil32(return_data.size) + ceil32(32 * mem[mem[96] + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[mem[96] + 96]) + 1 < 0:
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  mem[64] = ceil32(return_data.size) + ceil32(32 * mem[mem[96] + 96]) + 97
  mem[ceil32(return_data.size) + 96] = _5
  require _4 + (32 * _5) + 32 <= return_data.size
  mem[ceil32(return_data.size) + 128 len ceil32(32 * _5)] = mem[_4 + 128 len ceil32(32 * _5)]
  uint8(stor2.field_248) = 1
  mem[mem[64]] = 32
  mem[mem[64] + 32] = _5
  mem[mem[64] + 64 len 32 * _5] = mem[ceil32(return_data.size) + 128 len 32 * _5]
  return Array(len=_5, data=mem[mem[64] + 64 len 32 * _5])

def getRewardTokens() payable: 
  mem[64] = 96
  require not call.value
  require calldata.size - 4 >=′ 0
  mem[96] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
  static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
          gas gas_remaining wei
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  if not ext_call.success:
      mem[96] = 32
      mem[128] = mem[0]
      idx = 0
      s = 32
      t = 160
      while idx < mem[0]:
          mem[t] = mem[s + 12 len 20]
          idx = idx + 1
          s = s + 32
          t = t + 32
          continue 
      return 32, mem[128 len (32 * mem[0]) + 32]
  mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
  if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  mem[64] = ceil32(return_data.size) + 96
  require return_data.size >=′ 32
  _6 = mem[96]
  require mem[96] <= LOCK8605463013()
  require mem[96] + 127 <′ return_data.size + 96
  _7 = mem[mem[96] + 96]
  if mem[mem[96] + 96] > LOCK8605463013():
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  if ceil32(return_data.size) + ceil32(32 * mem[mem[96] + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[mem[96] + 96]) + 1 < 0:
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  mem[64] = ceil32(return_data.size) + ceil32(32 * mem[mem[96] + 96]) + 97
  mem[ceil32(return_data.size) + 96] = _7
  require _6 + (32 * _7) + 32 <= return_data.size
  s = ceil32(return_data.size) + 128
  idx = _6 + 128
  while idx < _6 + (32 * _7) + 128:
      require not Mask(96, 160, mem[idx])
      mem[s] = mem[idx]
      s = s + 32
      idx = idx + 32
      continue 
  _15 = mem[64]
  mem[mem[64]] = 32
  mem[mem[64] + 32] = _7
  idx = 0
  s = ceil32(return_data.size) + 128
  t = mem[64] + 64
  while idx < _7:
      mem[t] = mem[s + 12 len 20]
      idx = idx + 1
      s = s + 32
      t = t + 32
      continue 
  return mem[_15], _7, mem[_15 + 64 len 32 * _7]

def symbol(): # not payable
  require calldata.size - 4 >=′ 0
  if not bool(stor4.field_0):
      if bool(stor4.field_0) == stor4.field_1 % 128 < 32:
          revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.
      mem[96] = stor4.field_1 % 128
      if bool(stor4.field_0):
          if bool(stor4.field_0) != 1:
              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
          s = 0x8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b
          idx = 0
          while idx < stor4.field_1 % 128:
              mem[idx + 128] = stor[s]
              s = s + 1
              idx = idx + 32
              continue 
          if ceil32(ceil32(stor4.field_1 % 128)) + 97 > LOCK8605463013() or ceil32(ceil32(stor4.field_1 % 128)) + 97 < 96:
              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
          mem[ceil32(ceil32(stor4.field_1 % 128)) + 97] = 32
          return Array(len=stor4.field_0 % 128, data=mem[128 len ceil32(stor4.field_1 % 128)])
      mem[128] = Mask(248, 8, uint256(stor4.field_0))
      if ceil32(32 * bool(stor4.field_1 % 128)) + 97 > LOCK8605463013() or ceil32(32 * bool(stor4.field_1 % 128)) + 97 < 96:
          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
      mem[64] = ceil32(32 * bool(stor4.field_1 % 128)) + 97
      mem[ceil32(32 * bool(stor4.field_1 % 128)) + 97] = 32
      mem[ceil32(32 * bool(stor4.field_1 % 128)) + 129] = stor4.field_1 % 128
      mem[ceil32(32 * bool(stor4.field_1 % 128)) + 161 len ceil32(stor4.field_1 % 128)] = mem[128 len ceil32(stor4.field_1 % 128)]
      mem[ceil32(32 * bool(stor4.field_1 % 128)) + stor4.field_1 % 128 + 161] = 0
      return Array(len=stor4.field_0 % 128, data=mem[ceil32(32 * bool(stor4.field_1 % 128)) + 161 len ceil32(stor4.field_1 % 128)])
  if bool(stor4.field_0) == uint255(uint256(stor4.field_0)) * 0.5 < 32:
      revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.
  mem[96] = uint255(uint256(stor4.field_0)) * 0.5
  if bool(stor4.field_0):
      if bool(stor4.field_0) != 1:
          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
      s = 0x8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b
      idx = 0
      while idx < uint255(uint256(stor4.field_0)) * 0.5:
          mem[idx + 128] = stor[s]
          s = s + 1
          idx = idx + 32
          continue 
      if ceil32(ceil32(uint255(uint256(stor4.field_0)) * 0.5)) + 97 > LOCK8605463013() or ceil32(ceil32(uint255(uint256(stor4.field_0)) * 0.5)) + 97 < 96:
          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
      mem[ceil32(ceil32(uint255(uint256(stor4.field_0)) * 0.5)) + 97] = 32
      return Array(len=2 * Mask(256, -1, uint256(stor4.field_0)), data=mem[128 len ceil32(uint255(uint256(stor4.field_0)) * 0.5)])
  mem[128] = Mask(248, 8, uint256(stor4.field_0))
  if ceil32(32 * bool(uint255(uint256(stor4.field_0)) * 0.5)) + 97 > LOCK8605463013() or ceil32(32 * bool(uint255(uint256(stor4.field_0)) * 0.5)) + 97 < 96:
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  mem[64] = ceil32(32 * bool(uint255(uint256(stor4.field_0)) * 0.5)) + 97
  mem[ceil32(32 * bool(uint255(uint256(stor4.field_0)) * 0.5)) + 97] = 32
  mem[ceil32(32 * bool(uint255(uint256(stor4.field_0)) * 0.5)) + 129] = uint255(uint256(stor4.field_0)) * 0.5
  mem[ceil32(32 * bool(uint255(uint256(stor4.field_0)) * 0.5)) + 161 len ceil32(uint255(uint256(stor4.field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor4.field_0)) * 0.5)]
  mem[ceil32(32 * bool(uint255(uint256(stor4.field_0)) * 0.5)) + (uint255(uint256(stor4.field_0)) * 0.5) + 161] = 0
  return Array(len=2 * Mask(256, -1, uint256(stor4.field_0)), data=mem[ceil32(32 * bool(uint255(uint256(stor4.field_0)) * 0.5)) + 161 len ceil32(uint255(uint256(stor4.field_0)) * 0.5)]), 

def name(): # not payable
  require calldata.size - 4 >=′ 0
  if not bool(stor3.field_0):
      if bool(stor3.field_0) == stor3.field_1 % 128 < 32:
          revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.
      mem[128] = stor3.field_1 % 128
      if bool(stor3.field_0):
          if bool(stor3.field_0) != 1:
              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
          s = 0xc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b
          idx = 0
          while idx < stor3.field_1 % 128:
              mem[idx + 160] = stor[s]
              s = s + 1
              idx = idx + 32
              continue 
          if ceil32(ceil32(stor3.field_1 % 128)) + 129 > LOCK8605463013() or ceil32(ceil32(stor3.field_1 % 128)) + 129 < 128:
              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
          mem[ceil32(ceil32(stor3.field_1 % 128)) + 129] = 32
          return Array(len=stor3.field_0 % 128, data=mem[160 len ceil32(stor3.field_1 % 128)])
      mem[160] = Mask(248, 8, uint256(stor3.field_0))
      if ceil32(32 * bool(stor3.field_1 % 128)) + 129 > LOCK8605463013() or ceil32(32 * bool(stor3.field_1 % 128)) + 129 < 128:
          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
      mem[64] = ceil32(32 * bool(stor3.field_1 % 128)) + 129
      mem[ceil32(32 * bool(stor3.field_1 % 128)) + 129] = 32
      mem[ceil32(32 * bool(stor3.field_1 % 128)) + 161] = stor3.field_1 % 128
      mem[ceil32(32 * bool(stor3.field_1 % 128)) + 193 len ceil32(stor3.field_1 % 128)] = mem[160 len ceil32(stor3.field_1 % 128)]
      mem[ceil32(32 * bool(stor3.field_1 % 128)) + stor3.field_1 % 128 + 193] = 0
      return Array(len=stor3.field_0 % 128, data=mem[ceil32(32 * bool(stor3.field_1 % 128)) + 193 len ceil32(stor3.field_1 % 128)])
  if bool(stor3.field_0) == uint255(uint256(stor3.field_0)) * 0.5 < 32:
      revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.
  mem[128] = uint255(uint256(stor3.field_0)) * 0.5
  if bool(stor3.field_0):
      if bool(stor3.field_0) != 1:
          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
      s = 0xc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b
      idx = 0
      while idx < uint255(uint256(stor3.field_0)) * 0.5:
          mem[idx + 160] = stor[s]
          s = s + 1
          idx = idx + 32
          continue 
      if ceil32(ceil32(uint255(uint256(stor3.field_0)) * 0.5)) + 129 > LOCK8605463013() or ceil32(ceil32(uint255(uint256(stor3.field_0)) * 0.5)) + 129 < 128:
          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
      mem[ceil32(ceil32(uint255(uint256(stor3.field_0)) * 0.5)) + 129] = 32
      return Array(len=2 * Mask(256, -1, uint256(stor3.field_0)), data=mem[160 len ceil32(uint255(uint256(stor3.field_0)) * 0.5)])
  mem[160] = Mask(248, 8, uint256(stor3.field_0))
  if ceil32(32 * bool(uint255(uint256(stor3.field_0)) * 0.5)) + 129 > LOCK8605463013() or ceil32(32 * bool(uint255(uint256(stor3.field_0)) * 0.5)) + 129 < 128:
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  mem[64] = ceil32(32 * bool(uint255(uint256(stor3.field_0)) * 0.5)) + 129
  mem[ceil32(32 * bool(uint255(uint256(stor3.field_0)) * 0.5)) + 129] = 32
  mem[ceil32(32 * bool(uint255(uint256(stor3.field_0)) * 0.5)) + 161] = uint255(uint256(stor3.field_0)) * 0.5
  mem[ceil32(32 * bool(uint255(uint256(stor3.field_0)) * 0.5)) + 193 len ceil32(uint255(uint256(stor3.field_0)) * 0.5)] = mem[160 len ceil32(uint255(uint256(stor3.field_0)) * 0.5)]
  mem[ceil32(32 * bool(uint255(uint256(stor3.field_0)) * 0.5)) + (uint255(uint256(stor3.field_0)) * 0.5) + 193] = 0
  return Array(len=2 * Mask(256, -1, uint256(stor3.field_0)), data=mem[ceil32(32 * bool(uint255(uint256(stor3.field_0)) * 0.5)) + 193 len ceil32(uint255(uint256(stor3.field_0)) * 0.5)]), 

def unknownbcb7ea5d(uint256 _param1): # not payable
  require calldata.size - 4 >=′ 32
  require not Mask(96, 160, _param1)
  if uint8(uint256(stor2.field_0)) >> 248 == 2:
      revert with Error(string reason), 'ReentrancyGuard: reentrant call'
  uint8(stor2.field_248) = 2
  if 484512 * 24 * 3600 <= block.timestamp:
      if uint128(stor9):
          if 484512 * 24 * 3600 > block.timestamp:
          static call 0xdfb913b117bc93fde164a4ff8b3176662d4198f3.balanceOf(address account) with:
                  gas gas_remaining wei
                 args this.address
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          if ext_call.success:
              if 32 > return_data.size:
                  if ceil32(return_data.size) + 224 > LOCK8605463013() or ceil32(return_data.size) + 224 < 224:
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  require return_data.size >=′ 32
      else:
          mem[96] = 0xef5cfb8c00000000000000000000000000000000000000000000000000000000
          mem[100] = this.address
          call 0xac614884b52dbab8728476b5d50f0d672baed31f.claimRewards(address _receiver) with:
               gas gas_remaining wei
              args this.address
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          if ext_call.success:
              mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
              if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              mem[64] = ceil32(return_data.size) + 96
              require return_data.size >=′ 32
              require mem[96 len 4], Mask(224, 32, this.address) >> 32 <= LOCK8605463013()
              require mem[96 len 4], Mask(224, 32, this.address) >> 32 + 127 <′ return_data.size + 96
              if mem[mem[96 len 4], Mask(224, 32, this.address) >> 32 + 96] > LOCK8605463013():
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              if ceil32(return_data.size) + ceil32(32 * mem[mem[96 len 4], Mask(224, 32, this.address) >> 32 + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[mem[96 len 4], Mask(224, 32, this.address) >> 32 + 96]) + 1 < 0:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              require mem[96 len 4], Mask(224, 32, this.address) >> 32 + (32 * mem[mem[96 len 4], Mask(224, 32, this.address) >> 32 + 96]) + 32 <= return_data.size
          else:
              if block.number == unknown60e0a9e1:
                  require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                  uint128(stor9) = 0
                  mem[96] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                  static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                          gas gas_remaining wei
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if ext_call.success:
                      mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                      if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      mem[64] = ceil32(return_data.size) + 96
                      require return_data.size >=′ 32
                      require mem[96] <= LOCK8605463013()
                      require mem[96] + 127 <′ return_data.size + 96
                      if mem[mem[96] + 96] > LOCK8605463013():
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      if ceil32(return_data.size) + ceil32(32 * mem[mem[96] + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[mem[96] + 96]) + 1 < 0:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      require mem[96] + (32 * mem[mem[96] + 96]) + 32 <= return_data.size
              else:
                  static call 0xac614884b52dbab8728476b5d50f0d672baed31f.exchangeRate() with:
                          gas gas_remaining wei
                  mem[96] = ext_call.return_data[0]
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if ext_call.success:
                      if 32 > return_data.size:
                          if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                          require return_data.size >=′ 32
                          if ext_call.return_data[0] <= uint128(unknownd2a3584e) >> 128:
                              require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                              unknown60e0a9e1 = uint128(block.number)
                              stor8 = 0
                              log 0x71475f2f 
                              log 0x0 
                              uint128(stor9) = 0
                          else:
                              require ext_call.return_data[0] <= LOCK8605463013()
                              unknown60e0a9e1 = uint128(block.number)
                              stor8 = uint128(ext_call.return_data[0])
                              log 0x71475f2f: uint128(ext_call.return_data[0])
                              require uint128(ext_call.return_data[0]) <= LOCK8605463013()
                              uint128(stor9) = uint128(ext_call.return_data[0])
                          mem[ceil32(return_data.size) + 96] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                          static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                                  gas gas_remaining wei
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          if ext_call.success:
                              mem[ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                              if (2 * ceil32(return_data.size)) + 96 > LOCK8605463013() or 2 * ceil32(return_data.size) < ceil32(return_data.size):
                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                              require return_data.size >=′ 32
                              require mem[ceil32(return_data.size) + 96] <= LOCK8605463013()
                              require ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 127 <′ ceil32(return_data.size) + return_data.size + 96
                              if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96] > LOCK8605463013():
                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                              if (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96]) + 1 < 0:
                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                              require mem[ceil32(return_data.size) + 96] + (32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96]) + 32 <= return_data.size
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def unknownb0d88981(array _param1, array _param2): # not payable
  require calldata.size - 4 >=′ 64
  require _param1 <= LOCK8605463013()
  require _param1 + 35 <′ calldata.size
  require _param1.length <= LOCK8605463013()
  require (32 * _param1.length) + _param1 + 36 <= calldata.size
  require _param2 <= LOCK8605463013()
  require _param2 + 35 <′ calldata.size
  require _param2.length <= LOCK8605463013()
  require (32 * _param2.length) + _param2 + 36 <= calldata.size
  if uint8(uint256(stor2.field_0)) >> 248 == 2:
      revert with Error(string reason), 'ReentrancyGuard: reentrant call'
  uint8(stor2.field_248) = 2
  if 484512 * 24 * 3600 <= block.timestamp:
      if uint128(stor9):
          if _param1.length - _param2.length:
              revert with ArrayLengthMismatch()
          if not _param1.length:
              revert with ArrayEmpty()
          if _param1.length > LOCK8605463013():
              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
          if ceil32(32 * _param1.length) + 97 > LOCK8605463013() or ceil32(32 * _param1.length) + 97 < 96:
              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
          require _param1 + (32 * _param1.length) + 36 <= calldata.size
      else:
          mem[96] = 0xef5cfb8c00000000000000000000000000000000000000000000000000000000
          mem[100] = this.address
          call 0xac614884b52dbab8728476b5d50f0d672baed31f.claimRewards(address _receiver) with:
               gas gas_remaining wei
              args this.address
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          if ext_call.success:
              mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
              if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              mem[64] = ceil32(return_data.size) + 96
              require return_data.size >=′ 32
              require mem[96 len 4], Mask(224, 32, this.address) >> 32 <= LOCK8605463013()
              require mem[96 len 4], Mask(224, 32, this.address) >> 32 + 127 <′ return_data.size + 96
              if mem[mem[96 len 4], Mask(224, 32, this.address) >> 32 + 96] > LOCK8605463013():
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              if ceil32(return_data.size) + ceil32(32 * mem[mem[96 len 4], Mask(224, 32, this.address) >> 32 + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[mem[96 len 4], Mask(224, 32, this.address) >> 32 + 96]) + 1 < 0:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              require mem[96 len 4], Mask(224, 32, this.address) >> 32 + (32 * mem[mem[96 len 4], Mask(224, 32, this.address) >> 32 + 96]) + 32 <= return_data.size
          else:
              if block.number == unknown60e0a9e1:
                  require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                  uint128(stor9) = 0
                  mem[96] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                  static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                          gas gas_remaining wei
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if ext_call.success:
                      mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                      if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      mem[64] = ceil32(return_data.size) + 96
                      require return_data.size >=′ 32
                      require mem[96] <= LOCK8605463013()
                      require mem[96] + 127 <′ return_data.size + 96
                      if mem[mem[96] + 96] > LOCK8605463013():
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      if ceil32(return_data.size) + ceil32(32 * mem[mem[96] + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[mem[96] + 96]) + 1 < 0:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      require mem[96] + (32 * mem[mem[96] + 96]) + 32 <= return_data.size
              else:
                  static call 0xac614884b52dbab8728476b5d50f0d672baed31f.exchangeRate() with:
                          gas gas_remaining wei
                  mem[96] = ext_call.return_data[0]
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if ext_call.success:
                      if 32 > return_data.size:
                          if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                          require return_data.size >=′ 32
                          if ext_call.return_data[0] <= uint128(unknownd2a3584e) >> 128:
                              require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                              unknown60e0a9e1 = uint128(block.number)
                              stor8 = 0
                              log 0x71475f2f 
                              log 0x0 
                              uint128(stor9) = 0
                          else:
                              require ext_call.return_data[0] <= LOCK8605463013()
                              unknown60e0a9e1 = uint128(block.number)
                              stor8 = uint128(ext_call.return_data[0])
                              log 0x71475f2f: uint128(ext_call.return_data[0])
                              require uint128(ext_call.return_data[0]) <= LOCK8605463013()
                              uint128(stor9) = uint128(ext_call.return_data[0])
                          mem[ceil32(return_data.size) + 96] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                          static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                                  gas gas_remaining wei
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          if ext_call.success:
                              mem[ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                              if (2 * ceil32(return_data.size)) + 96 > LOCK8605463013() or 2 * ceil32(return_data.size) < ceil32(return_data.size):
                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                              require return_data.size >=′ 32
                              require mem[ceil32(return_data.size) + 96] <= LOCK8605463013()
                              require ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 127 <′ ceil32(return_data.size) + return_data.size + 96
                              if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96] > LOCK8605463013():
                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                              if (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96]) + 1 < 0:
                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                              require mem[ceil32(return_data.size) + 96] + (32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96]) + 32 <= return_data.size
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def unknown0b49fcef(): # not payable
  require calldata.size - 4 >=′ 0
  if not uint128(stor9):
      revert with 3528496691
  mem[96] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
  static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
          gas gas_remaining wei
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  if not ext_call.success:
      if mem[0] > LOCK8605463013():
          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
      if ceil32(32 * mem[0]) + 97 > LOCK8605463013() or ceil32(32 * mem[0]) + 97 < 96:
          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
      mem[96] = mem[0]
      if mem[0] > LOCK8605463013():
          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
      mem[128 len 32 * mem[0]] = call.data[calldata.size len 32 * mem[0]]
      if mem[0] > LOCK8605463013():
          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
      _10 = ceil32(32 * mem[0]) + 97
      if (2 * ceil32(32 * mem[0])) + 98 > LOCK8605463013() or (2 * ceil32(32 * mem[0])) + 98 < ceil32(32 * mem[0]) + 97:
          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
      mem[64] = (2 * ceil32(32 * mem[0])) + 98
      mem[ceil32(32 * mem[0]) + 97] = mem[0]
      if mem[0] > LOCK8605463013():
          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
      mem[ceil32(32 * mem[0]) + 129 len 32 * mem[0]] = call.data[calldata.size len 32 * mem[0]]
      _44 = mem[0]
      idx = 0
      while idx < _44:
          if idx >= mem[0]:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          mem[0] = mem[(32 * idx) + 44 len 20]
          mem[32] = 10
          if idx >= mem[96]:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          mem[(32 * idx) + 128] = stor10[mem[0]]
          if idx >= mem[0]:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          mem[0] = mem[(32 * idx) + 44 len 20]
          mem[32] = 11
          if idx >= mem[_10]:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
          mem[(32 * idx) + _10 + 32] = stor11[mem[0]]
          idx = idx + 1
          continue 
      mem[mem[64]] = uint128(stor9)
      mem[mem[64] + 32] = uint128(uint256(stor9)) >> 128
      mem[mem[64] + 64] = 128
      _47 = mem[96]
      mem[mem[64] + 128] = mem[96]
      mem[mem[64] + 160 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
      mem[mem[64] + 96] = (32 * mem[96]) + 160
      _82 = mem[_10]
      mem[mem[64] + (32 * _47) + 160] = mem[_10]
      mem[mem[64] + (32 * _47) + 192 len 32 * _82] = mem[_10 + 32 len 32 * _82]
      return uint128(stor9), uint128(stor9), 128, (32 * _47) + 160, mem[mem[64] + 128 len (32 * _47) + (32 * _82) + 64]
  mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
  if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  mem[64] = ceil32(return_data.size) + 96
  require return_data.size >=′ 32
  _5 = mem[96]
  require mem[96] <= LOCK8605463013()
  require mem[96] + 127 <′ return_data.size + 96
  _7 = mem[mem[96] + 96]
  if mem[mem[96] + 96] > LOCK8605463013():
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  if ceil32(return_data.size) + ceil32(32 * mem[mem[96] + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[mem[96] + 96]) + 1 < 0:
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  mem[64] = ceil32(return_data.size) + ceil32(32 * mem[mem[96] + 96]) + 97
  mem[ceil32(return_data.size) + 96] = _7
  require _5 + (32 * _7) + 32 <= return_data.size
  s = ceil32(return_data.size) + 128
  idx = _5 + 128
  while idx < _5 + (32 * _7) + 128:
      require not Mask(96, 160, mem[idx])
      mem[s] = mem[idx]
      s = s + 32
      idx = idx + 32
      continue 
  if _7 > LOCK8605463013():
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  _55 = mem[64]
  if mem[64] + ceil32(32 * _7) + 1 > LOCK8605463013() or mem[64] + ceil32(32 * _7) + 1 < mem[64]:
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  mem[64] = mem[64] + ceil32(32 * _7) + 1
  mem[_55] = _7
  if _7 > LOCK8605463013():
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  mem[_55 + 32 len 32 * _7] = call.data[calldata.size len 32 * _7]
  if _7 > LOCK8605463013():
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  _62 = mem[64]
  if mem[64] + ceil32(32 * _7) + 1 > LOCK8605463013() or mem[64] + ceil32(32 * _7) + 1 < mem[64]:
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  mem[64] = mem[64] + ceil32(32 * _7) + 1
  mem[_62] = _7
  if _7 > LOCK8605463013():
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  mem[_62 + 32 len 32 * _7] = call.data[calldata.size len 32 * _7]
  idx = 0
  while idx < _7:
      if idx >= mem[ceil32(return_data.size) + 96]:
          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
      mem[0] = mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]
      mem[32] = 10
      if idx >= mem[_55]:
          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
      mem[(32 * idx) + _55 + 32] = stor10[mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]]
      if idx >= mem[ceil32(return_data.size) + 96]:
          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
      mem[0] = mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]
      mem[32] = 11
      if idx >= mem[_62]:
          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
      mem[(32 * idx) + _62 + 32] = stor11[mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]]
      idx = idx + 1
      continue 
  mem[mem[64]] = uint128(stor9)
  mem[mem[64] + 32] = uint128(uint256(stor9)) >> 128
  mem[mem[64] + 64] = 128
  _80 = mem[_55]
  mem[mem[64] + 128] = mem[_55]
  mem[mem[64] + 160 len 32 * _80] = mem[_55 + 32 len 32 * _80]
  mem[mem[64] + 96] = (32 * _80) + 160
  _96 = mem[_62]
  mem[mem[64] + (32 * _80) + 160] = mem[_62]
  mem[mem[64] + (32 * _80) + 192 len 32 * _96] = mem[_62 + 32 len 32 * _96]
  return uint128(stor9), uint128(stor9), 128, (32 * _80) + 160, mem[mem[64] + 128 len (32 * _80) + (32 * _96) + 64]

def transfer(address recipient, uint256 amount): # not payable
  require calldata.size - 4 >=′ 64
  require not Mask(96, 160, recipient)
  if uint8(uint256(stor2.field_0)) >> 248 == 2:
      revert with Error(string reason), 'ReentrancyGuard: reentrant call'
  uint8(stor2.field_248) = 2
  if not caller:
      revert with Error(string reason), 'ERC20: transfer from the zero address'
  if not recipient:
      revert with Error(string reason), 'ERC20: transfer to the zero address'
  if caller == recipient:
      revert with Error(string reason), 'ERC20: transfer to self'
  if 484512 * 24 * 3600 <= block.timestamp:
      if uint128(stor9):
          mem[96] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
          static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                  gas gas_remaining wei
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          if ext_call.success:
              mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
              if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              mem[64] = ceil32(return_data.size) + 96
              require return_data.size >=′ 32
              require mem[96] <= LOCK8605463013()
              require mem[96] + 127 <′ return_data.size + 96
              if mem[mem[96] + 96] > LOCK8605463013():
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              if ceil32(return_data.size) + ceil32(32 * mem[mem[96] + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[mem[96] + 96]) + 1 < 0:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              require mem[96] + (32 * mem[mem[96] + 96]) + 32 <= return_data.size
          else:
              if 484512 * 24 * 3600 <= block.timestamp:
                  if mem[0] > LOCK8605463013():
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  if ceil32(32 * mem[0]) + 97 > LOCK8605463013() or ceil32(32 * mem[0]) + 97 < 96:
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  if mem[0] > LOCK8605463013():
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              else:
                  mem[96] = 0xf8b2f99100000000000000000000000000000000000000000000000000000000
                  call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                       gas gas_remaining wei
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if ext_call.success:
                      mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                      if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      mem[64] = ceil32(return_data.size) + 96
                      require return_data.size >=′ 32
                      require mem[96] <= LOCK8605463013()
                      require mem[96] + 127 <′ return_data.size + 96
                      if mem[mem[96] + 96] > LOCK8605463013():
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      if ceil32(return_data.size) + ceil32(32 * mem[mem[96] + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[mem[96] + 96]) + 1 < 0:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      require mem[96] + (32 * mem[mem[96] + 96]) + 32 <= return_data.size
      else:
          mem[96] = 0xef5cfb8c00000000000000000000000000000000000000000000000000000000
          mem[100] = this.address
          call 0xac614884b52dbab8728476b5d50f0d672baed31f.claimRewards(address _receiver) with:
               gas gas_remaining wei
              args this.address
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          if ext_call.success:
              mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
              if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              mem[64] = ceil32(return_data.size) + 96
              require return_data.size >=′ 32
              require mem[96 len 4], Mask(224, 32, this.address) >> 32 <= LOCK8605463013()
              require mem[96 len 4], Mask(224, 32, this.address) >> 32 + 127 <′ return_data.size + 96
              if mem[mem[96 len 4], Mask(224, 32, this.address) >> 32 + 96] > LOCK8605463013():
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              if ceil32(return_data.size) + ceil32(32 * mem[mem[96 len 4], Mask(224, 32, this.address) >> 32 + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[mem[96 len 4], Mask(224, 32, this.address) >> 32 + 96]) + 1 < 0:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              require mem[96 len 4], Mask(224, 32, this.address) >> 32 + (32 * mem[mem[96 len 4], Mask(224, 32, this.address) >> 32 + 96]) + 32 <= return_data.size
          else:
              if block.number == unknown60e0a9e1:
                  require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                  uint128(stor9) = 0
                  mem[96] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                  static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                          gas gas_remaining wei
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if ext_call.success:
                      mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                      if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      mem[64] = ceil32(return_data.size) + 96
                      require return_data.size >=′ 32
                      require mem[96] <= LOCK8605463013()
                      require mem[96] + 127 <′ return_data.size + 96
                      if mem[mem[96] + 96] > LOCK8605463013():
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      if ceil32(return_data.size) + ceil32(32 * mem[mem[96] + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[mem[96] + 96]) + 1 < 0:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      require mem[96] + (32 * mem[mem[96] + 96]) + 32 <= return_data.size
              else:
                  static call 0xac614884b52dbab8728476b5d50f0d672baed31f.exchangeRate() with:
                          gas gas_remaining wei
                  mem[96] = ext_call.return_data[0]
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if ext_call.success:
                      if 32 > return_data.size:
                          if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                          require return_data.size >=′ 32
                          if ext_call.return_data[0] <= uint128(unknownd2a3584e) >> 128:
                              require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                              unknown60e0a9e1 = uint128(block.number)
                              stor8 = 0
                              log 0x71475f2f 
                              log 0x0 
                              uint128(stor9) = 0
                          else:
                              require ext_call.return_data[0] <= LOCK8605463013()
                              unknown60e0a9e1 = uint128(block.number)
                              stor8 = uint128(ext_call.return_data[0])
                              log 0x71475f2f: uint128(ext_call.return_data[0])
                              require uint128(ext_call.return_data[0]) <= LOCK8605463013()
                              uint128(stor9) = uint128(ext_call.return_data[0])
                          mem[ceil32(return_data.size) + 96] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                          static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                                  gas gas_remaining wei
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          if ext_call.success:
                              mem[ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                              if (2 * ceil32(return_data.size)) + 96 > LOCK8605463013() or 2 * ceil32(return_data.size) < ceil32(return_data.size):
                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                              require return_data.size >=′ 32
                              require mem[ceil32(return_data.size) + 96] <= LOCK8605463013()
                              require ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 127 <′ ceil32(return_data.size) + return_data.size + 96
                              if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96] > LOCK8605463013():
                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                              if (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96]) + 1 < 0:
                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                              require mem[ceil32(return_data.size) + 96] + (32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96]) + 32 <= return_data.size
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def unknown7d24da4d(uint256 _param1, uint256 _param2, uint256 _param3): # not payable
  require calldata.size - 4 >=′ 96
  require not Mask(96, 160, _param1)
  require not _param2 - bool(_param2)
  require not _param3 - bool(_param3)
  if uint8(uint256(stor2.field_0)) >> 248 == 2:
      revert with Error(string reason), 'ReentrancyGuard: reentrant call'
  uint8(stor2.field_248) = 2
  if 484512 * 24 * 3600 <= block.timestamp:
      if uint128(stor9):
          if not _param2:
              if not _param3:
                  revert with 1746169629
              mem[96] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
              static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                      gas gas_remaining wei
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              if ext_call.success:
                  mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                  if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  mem[64] = ceil32(return_data.size) + 96
                  require return_data.size >=′ 32
                  require mem[96] <= LOCK8605463013()
                  require mem[96] + 127 <′ return_data.size + 96
                  if mem[mem[96] + 96] > LOCK8605463013():
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  if ceil32(return_data.size) + ceil32(32 * mem[mem[96] + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[mem[96] + 96]) + 1 < 0:
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  require mem[96] + (32 * mem[mem[96] + 96]) + 32 <= return_data.size
              else:
                  if 484512 * 24 * 3600 <= block.timestamp:
                      if mem[0] > LOCK8605463013():
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      if ceil32(32 * mem[0]) + 97 > LOCK8605463013() or ceil32(32 * mem[0]) + 97 < 96:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      if mem[0] > LOCK8605463013():
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  else:
                      mem[96] = 0xf8b2f99100000000000000000000000000000000000000000000000000000000
                      call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                           gas gas_remaining wei
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      if ext_call.success:
                          mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                          if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                          mem[64] = ceil32(return_data.size) + 96
                          require return_data.size >=′ 32
                          require mem[96] <= LOCK8605463013()
                          require mem[96] + 127 <′ return_data.size + 96
                          if mem[mem[96] + 96] > LOCK8605463013():
                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                          if ceil32(return_data.size) + ceil32(32 * mem[mem[96] + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[mem[96] + 96]) + 1 < 0:
                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                          require mem[96] + (32 * mem[mem[96] + 96]) + 32 <= return_data.size
      else:
          mem[96] = 0xef5cfb8c00000000000000000000000000000000000000000000000000000000
          mem[100] = this.address
          call 0xac614884b52dbab8728476b5d50f0d672baed31f.claimRewards(address _receiver) with:
               gas gas_remaining wei
              args this.address
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          if ext_call.success:
              mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
              if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              mem[64] = ceil32(return_data.size) + 96
              require return_data.size >=′ 32
              require mem[96 len 4], Mask(224, 32, this.address) >> 32 <= LOCK8605463013()
              require mem[96 len 4], Mask(224, 32, this.address) >> 32 + 127 <′ return_data.size + 96
              if mem[mem[96 len 4], Mask(224, 32, this.address) >> 32 + 96] > LOCK8605463013():
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              if ceil32(return_data.size) + ceil32(32 * mem[mem[96 len 4], Mask(224, 32, this.address) >> 32 + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[mem[96 len 4], Mask(224, 32, this.address) >> 32 + 96]) + 1 < 0:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              require mem[96 len 4], Mask(224, 32, this.address) >> 32 + (32 * mem[mem[96 len 4], Mask(224, 32, this.address) >> 32 + 96]) + 32 <= return_data.size
          else:
              if block.number == unknown60e0a9e1:
                  require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                  uint128(stor9) = 0
                  mem[96] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                  static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                          gas gas_remaining wei
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if ext_call.success:
                      mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                      if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      mem[64] = ceil32(return_data.size) + 96
                      require return_data.size >=′ 32
                      require mem[96] <= LOCK8605463013()
                      require mem[96] + 127 <′ return_data.size + 96
                      if mem[mem[96] + 96] > LOCK8605463013():
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      if ceil32(return_data.size) + ceil32(32 * mem[mem[96] + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[mem[96] + 96]) + 1 < 0:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      require mem[96] + (32 * mem[mem[96] + 96]) + 32 <= return_data.size
              else:
                  static call 0xac614884b52dbab8728476b5d50f0d672baed31f.exchangeRate() with:
                          gas gas_remaining wei
                  mem[96] = ext_call.return_data[0]
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if ext_call.success:
                      if 32 > return_data.size:
                          if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                          require return_data.size >=′ 32
                          if ext_call.return_data[0] <= uint128(unknownd2a3584e) >> 128:
                              require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                              unknown60e0a9e1 = uint128(block.number)
                              stor8 = 0
                              log 0x71475f2f 
                              log 0x0 
                              uint128(stor9) = 0
                          else:
                              require ext_call.return_data[0] <= LOCK8605463013()
                              unknown60e0a9e1 = uint128(block.number)
                              stor8 = uint128(ext_call.return_data[0])
                              log 0x71475f2f: uint128(ext_call.return_data[0])
                              require uint128(ext_call.return_data[0]) <= LOCK8605463013()
                              uint128(stor9) = uint128(ext_call.return_data[0])
                          mem[ceil32(return_data.size) + 96] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                          static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                                  gas gas_remaining wei
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          if ext_call.success:
                              mem[ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                              if (2 * ceil32(return_data.size)) + 96 > LOCK8605463013() or 2 * ceil32(return_data.size) < ceil32(return_data.size):
                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                              require return_data.size >=′ 32
                              require mem[ceil32(return_data.size) + 96] <= LOCK8605463013()
                              require ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 127 <′ ceil32(return_data.size) + return_data.size + 96
                              if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96] > LOCK8605463013():
                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                              if (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96]) + 1 < 0:
                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                              require mem[ceil32(return_data.size) + 96] + (32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96]) + 32 <= return_data.size
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def transferFrom(address sender, address recipient, uint256 amount): # not payable
  require calldata.size - 4 >=′ 96
  require not Mask(96, 160, sender)
  require not Mask(96, 160, recipient)
  if uint8(uint256(stor2.field_0)) >> 248 == 2:
      revert with Error(string reason), 'ReentrancyGuard: reentrant call'
  uint8(stor2.field_248) = 2
  if allowance[address(sender)][caller] - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
      if allowance[address(sender)][caller] < amount:
          revert with Error(string reason), 'ERC20: insufficient allowance'
      if not sender:
          revert with Error(string reason), 'ERC20: approve from the zero address'
      if not caller:
          revert with Error(string reason), 'ERC20: approve to the zero address'
      mem[0] = caller
      mem[32] = sha3(address(sender), 1)
      allowance[address(sender)][caller] = allowance[address(sender)][caller] - amount
      log Approval(
            address owner=(allowance[address(sender)][caller] - amount),
            address spender=sender,
            uint256 value=caller)
      if not sender:
          revert with Error(string reason), 'ERC20: transfer from the zero address'
      if not recipient:
          revert with Error(string reason), 'ERC20: transfer to the zero address'
      if sender == recipient:
          revert with Error(string reason), 'ERC20: transfer to self'
      if 484512 * 24 * 3600 <= block.timestamp:
          if uint128(stor9):
              mem[96] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
              static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                      gas gas_remaining wei
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              if ext_call.success:
                  mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                  if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  mem[64] = ceil32(return_data.size) + 96
                  require return_data.size >=′ 32
                  require mem[96] <= LOCK8605463013()
                  require mem[96] + 127 <′ return_data.size + 96
                  if mem[mem[96] + 96] > LOCK8605463013():
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  if ceil32(return_data.size) + ceil32(32 * mem[mem[96] + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[mem[96] + 96]) + 1 < 0:
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  require mem[96] + (32 * mem[mem[96] + 96]) + 32 <= return_data.size
              else:
                  if 484512 * 24 * 3600 <= block.timestamp:
                      if caller > LOCK8605463013():
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      if ceil32(32 * address(caller)) + 97 > LOCK8605463013() or ceil32(32 * address(caller)) + 97 < 96:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      if caller > LOCK8605463013():
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  else:
                      mem[96] = 0xf8b2f99100000000000000000000000000000000000000000000000000000000
                      call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                           gas gas_remaining wei
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      if ext_call.success:
                          mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                          if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                          mem[64] = ceil32(return_data.size) + 96
                          require return_data.size >=′ 32
                          require mem[96] <= LOCK8605463013()
                          require mem[96] + 127 <′ return_data.size + 96
                          if mem[mem[96] + 96] > LOCK8605463013():
                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                          if ceil32(return_data.size) + ceil32(32 * mem[mem[96] + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[mem[96] + 96]) + 1 < 0:
                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                          require mem[96] + (32 * mem[mem[96] + 96]) + 32 <= return_data.size
          else:
              mem[96] = 0xef5cfb8c00000000000000000000000000000000000000000000000000000000
              mem[100] = this.address
              call 0xac614884b52dbab8728476b5d50f0d672baed31f.claimRewards(address _receiver) with:
                   gas gas_remaining wei
                  args this.address
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              if ext_call.success:
                  mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                  if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  mem[64] = ceil32(return_data.size) + 96
                  require return_data.size >=′ 32
                  require mem[96 len 4], Mask(224, 32, this.address) >> 32 <= LOCK8605463013()
                  require mem[96 len 4], Mask(224, 32, this.address) >> 32 + 127 <′ return_data.size + 96
                  if mem[mem[96 len 4], Mask(224, 32, this.address) >> 32 + 96] > LOCK8605463013():
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  if ceil32(return_data.size) + ceil32(32 * mem[mem[96 len 4], Mask(224, 32, this.address) >> 32 + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[mem[96 len 4], Mask(224, 32, this.address) >> 32 + 96]) + 1 < 0:
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  require mem[96 len 4], Mask(224, 32, this.address) >> 32 + (32 * mem[mem[96 len 4], Mask(224, 32, this.address) >> 32 + 96]) + 32 <= return_data.size
              else:
                  if block.number == unknown60e0a9e1:
                      require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                      uint128(stor9) = 0
                      mem[96] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                      static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                              gas gas_remaining wei
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      if ext_call.success:
                          mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                          if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                          mem[64] = ceil32(return_data.size) + 96
                          require return_data.size >=′ 32
                          require mem[96] <= LOCK8605463013()
                          require mem[96] + 127 <′ return_data.size + 96
                          if mem[mem[96] + 96] > LOCK8605463013():
                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                          if ceil32(return_data.size) + ceil32(32 * mem[mem[96] + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[mem[96] + 96]) + 1 < 0:
                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                          require mem[96] + (32 * mem[mem[96] + 96]) + 32 <= return_data.size
                  else:
                      static call 0xac614884b52dbab8728476b5d50f0d672baed31f.exchangeRate() with:
                              gas gas_remaining wei
                      mem[96] = ext_call.return_data[0]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      if ext_call.success:
                          if 32 > return_data.size:
                              if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                              require return_data.size >=′ 32
                              if ext_call.return_data[0] <= uint128(unknownd2a3584e) >> 128:
                                  require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                                  unknown60e0a9e1 = uint128(block.number)
                                  stor8 = 0
                                  log 0x71475f2f 
                                  log 0x0 
                                  uint128(stor9) = 0
                              else:
                                  require ext_call.return_data[0] <= LOCK8605463013()
                                  unknown60e0a9e1 = uint128(block.number)
                                  stor8 = uint128(ext_call.return_data[0])
                                  log 0x71475f2f: uint128(ext_call.return_data[0])
                                  require uint128(ext_call.return_data[0]) <= LOCK8605463013()
                                  uint128(stor9) = uint128(ext_call.return_data[0])
                              mem[ceil32(return_data.size) + 96] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                              static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                                      gas gas_remaining wei
                              if not ext_call.success:
                                  revert with ext_call.return_data[0 len return_data.size]
                              if ext_call.success:
                                  mem[ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                  if (2 * ceil32(return_data.size)) + 96 > LOCK8605463013() or 2 * ceil32(return_data.size) < ceil32(return_data.size):
                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                  require return_data.size >=′ 32
                                  require mem[ceil32(return_data.size) + 96] <= LOCK8605463013()
                                  require ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 127 <′ ceil32(return_data.size) + return_data.size + 96
                                  if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96] > LOCK8605463013():
                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                  if (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96]) + 1 < 0:
                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                  require mem[ceil32(return_data.size) + 96] + (32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96]) + 32 <= return_data.size
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def unknownacc5da4c(): # not payable
  require calldata.size - 4 >=′ 0
  if uint8(uint256(stor2.field_0)) >> 248 == 2:
      revert with Error(string reason), 'ReentrancyGuard: reentrant call'
  uint8(stor2.field_248) = 2
  if 484512 * 24 * 3600 <= block.timestamp:
      if uint128(stor9):
          if 484512 * 24 * 3600 > block.timestamp:
              revert with 3447825974
          static call 0x35a338522a435d46f77be32c70e215b813d0e3ac.treasury() with:
                  gas gas_remaining wei
          mem[96] = ext_call.return_data[0]
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          if ext_call.success:
              if 32 > return_data.size:
                  if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  require return_data.size >=′ 32
                  require not Mask(96, 160, ext_call.return_data[0])
                  mem[ceil32(return_data.size) + 96] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                  static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                          gas gas_remaining wei
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if ext_call.success:
                      mem[ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                      if (2 * ceil32(return_data.size)) + 96 > LOCK8605463013() or 2 * ceil32(return_data.size) < ceil32(return_data.size):
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      require return_data.size >=′ 32
                      require mem[ceil32(return_data.size) + 96] <= LOCK8605463013()
                      require ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 127 <′ ceil32(return_data.size) + return_data.size + 96
                      if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96] > LOCK8605463013():
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      if (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96]) + 1 < 0:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      require mem[ceil32(return_data.size) + 96] + (32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96]) + 32 <= return_data.size
                  else:
                      if mem[0] > LOCK8605463013():
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      if ceil32(return_data.size) + ceil32(32 * mem[0]) + 97 > LOCK8605463013() or ceil32(32 * mem[0]) + 1 < 0:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      mem[ceil32(return_data.size) + 96] = mem[0]
                      if mem[0] > LOCK8605463013():
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      mem[ceil32(return_data.size) + 128 len 32 * mem[0]] = call.data[calldata.size len 32 * mem[0]]
                      mem[ceil32(return_data.size) + ceil32(32 * mem[0]) + 97] = 0xef5cfb8c00000000000000000000000000000000000000000000000000000000
                      mem[ceil32(return_data.size) + ceil32(32 * mem[0]) + 101] = this.address
                      call 0xac614884b52dbab8728476b5d50f0d672baed31f.claimRewards(address _receiver) with:
                           gas gas_remaining wei
                          args this.address
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      if ext_call.success:
                          mem[ceil32(return_data.size) + ceil32(32 * mem[0]) + 97 len return_data.size] = ext_call.return_data[0 len return_data.size]
                          if (2 * ceil32(return_data.size)) + ceil32(32 * mem[0]) + 97 > LOCK8605463013() or 2 * ceil32(return_data.size) < ceil32(return_data.size):
                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                          mem[64] = (2 * ceil32(return_data.size)) + ceil32(32 * mem[0]) + 97
                          require return_data.size >=′ 32
                          require mem[ceil32(return_data.size) + ceil32(32 * mem[0]) + 97 len 4], Mask(224, 32, this.address) >> 32 <= LOCK8605463013()
                          require ceil32(return_data.size) + ceil32(32 * mem[0]) + mem[ceil32(return_data.size) + ceil32(32 * mem[0]) + 97 len 4], Mask(224, 32, this.address) >> 32 + 128 <′ ceil32(return_data.size) + ceil32(32 * mem[0]) + return_data.size + 97
                          if mem[ceil32(return_data.size) + ceil32(32 * mem[0]) + mem[ceil32(return_data.size) + ceil32(32 * mem[0]) + 97 len 4], Mask(224, 32, this.address) >> 32 + 97] > LOCK8605463013():
                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                          if (2 * ceil32(return_data.size)) + ceil32(32 * mem[0]) + ceil32(32 * mem[ceil32(return_data.size) + ceil32(32 * mem[0]) + mem[ceil32(return_data.size) + ceil32(32 * mem[0]) + 97 len 4], Mask(224, 32, this.address) >> 32 + 97]) + 98 > LOCK8605463013() or ceil32(32 * mem[ceil32(return_data.size) + ceil32(32 * mem[0]) + mem[ceil32(return_data.size) + ceil32(32 * mem[0]) + 97 len 4], Mask(224, 32, this.address) >> 32 + 97]) + 1 < 0:
                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                          require mem[ceil32(return_data.size) + ceil32(32 * mem[0]) + 97 len 4], Mask(224, 32, this.address) >> 32 + (32 * mem[ceil32(return_data.size) + ceil32(32 * mem[0]) + mem[ceil32(return_data.size) + ceil32(32 * mem[0]) + 97 len 4], Mask(224, 32, this.address) >> 32 + 97]) + 32 <= return_data.size
      else:
          mem[96] = 0xef5cfb8c00000000000000000000000000000000000000000000000000000000
          mem[100] = this.address
          call 0xac614884b52dbab8728476b5d50f0d672baed31f.claimRewards(address _receiver) with:
               gas gas_remaining wei
              args this.address
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          if ext_call.success:
              mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
              if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              mem[64] = ceil32(return_data.size) + 96
              require return_data.size >=′ 32
              require mem[96 len 4], Mask(224, 32, this.address) >> 32 <= LOCK8605463013()
              require mem[96 len 4], Mask(224, 32, this.address) >> 32 + 127 <′ return_data.size + 96
              if mem[mem[96 len 4], Mask(224, 32, this.address) >> 32 + 96] > LOCK8605463013():
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              if ceil32(return_data.size) + ceil32(32 * mem[mem[96 len 4], Mask(224, 32, this.address) >> 32 + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[mem[96 len 4], Mask(224, 32, this.address) >> 32 + 96]) + 1 < 0:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              require mem[96 len 4], Mask(224, 32, this.address) >> 32 + (32 * mem[mem[96 len 4], Mask(224, 32, this.address) >> 32 + 96]) + 32 <= return_data.size
          else:
              if block.number == unknown60e0a9e1:
                  require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                  uint128(stor9) = 0
                  mem[96] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                  static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                          gas gas_remaining wei
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if ext_call.success:
                      mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                      if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      mem[64] = ceil32(return_data.size) + 96
                      require return_data.size >=′ 32
                      require mem[96] <= LOCK8605463013()
                      require mem[96] + 127 <′ return_data.size + 96
                      if mem[mem[96] + 96] > LOCK8605463013():
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      if ceil32(return_data.size) + ceil32(32 * mem[mem[96] + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[mem[96] + 96]) + 1 < 0:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      require mem[96] + (32 * mem[mem[96] + 96]) + 32 <= return_data.size
              else:
                  static call 0xac614884b52dbab8728476b5d50f0d672baed31f.exchangeRate() with:
                          gas gas_remaining wei
                  mem[96] = ext_call.return_data[0]
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if ext_call.success:
                      if 32 > return_data.size:
                          if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                          require return_data.size >=′ 32
                          if ext_call.return_data[0] <= uint128(unknownd2a3584e) >> 128:
                              require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                              unknown60e0a9e1 = uint128(block.number)
                              stor8 = 0
                              log 0x71475f2f 
                              log 0x0 
                              uint128(stor9) = 0
                          else:
                              require ext_call.return_data[0] <= LOCK8605463013()
                              unknown60e0a9e1 = uint128(block.number)
                              stor8 = uint128(ext_call.return_data[0])
                              log 0x71475f2f: uint128(ext_call.return_data[0])
                              require uint128(ext_call.return_data[0]) <= LOCK8605463013()
                              uint128(stor9) = uint128(ext_call.return_data[0])
                          mem[ceil32(return_data.size) + 96] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                          static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                                  gas gas_remaining wei
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          if ext_call.success:
                              mem[ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                              if (2 * ceil32(return_data.size)) + 96 > LOCK8605463013() or 2 * ceil32(return_data.size) < ceil32(return_data.size):
                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                              require return_data.size >=′ 32
                              require mem[ceil32(return_data.size) + 96] <= LOCK8605463013()
                              require ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 127 <′ ceil32(return_data.size) + return_data.size + 96
                              if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96] > LOCK8605463013():
                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                              if (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96]) + 1 < 0:
                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                              require mem[ceil32(return_data.size) + 96] + (32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96]) + 32 <= return_data.size
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def unknowndb74aa15(uint256 _param1, uint256 _param2): # not payable
  require calldata.size - 4 >=′ 64
  require not Mask(96, 160, _param1)
  require not Mask(96, 160, _param2)
  if uint8(uint256(stor2.field_0)) >> 248 == 2:
      revert with Error(string reason), 'ReentrancyGuard: reentrant call'
  uint8(stor2.field_248) = 2
  if 484512 * 24 * 3600 <= block.timestamp:
      revert with 1528145626
  mem[96] = 1
  mem[160] = 1
  mem[224] = 1
  mem[292] = this.address
  static call 0xac614884b52dbab8728476b5d50f0d672baed31f.balanceOf(address account) with:
          gas gas_remaining wei
         args this.address
  mem[288] = ext_call.return_data[0]
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  if ext_call.success:
      if 32 > return_data.size:
          if ceil32(return_data.size) + 288 > LOCK8605463013() or ceil32(return_data.size) + 288 < 288:
              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
          require return_data.size >=′ 32
          if ext_call.return_data[0] - unknown4ba6dcd7 > ext_call.return_data[0]:
              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
          if not ext_call.return_data[0] - unknown4ba6dcd7:
              revert with 578971161
          mem[256] = ext_call.return_data[0] - unknown4ba6dcd7
          mem[192] = address(_param2)
          mem[128] = address(_param1)
          if ceil32(return_data.size) + 321 > LOCK8605463013() or 33 < 0:
              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
          mem[ceil32(return_data.size) + 288] = 1
          if block.number == unknown60e0a9e1:
              if (ext_call.return_data[0] * uint128(unknownd2a3584e) >> 128) - (unknown4ba6dcd7 * uint128(unknownd2a3584e) >> 128) / ext_call.return_data[0] - unknown4ba6dcd7 != uint128(unknownd2a3584e) >> 128 and ext_call.return_data[0] - unknown4ba6dcd7:
                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
              mem[ceil32(return_data.size) + 320] = (ext_call.return_data[0] * uint128(unknownd2a3584e) >> 128) - (unknown4ba6dcd7 * uint128(unknownd2a3584e) >> 128) / 10^18
              if not address(_param2):
                  revert with Error(string reason), 'ERC20: mint to the zero address'
              if 484512 * 24 * 3600 <= block.timestamp:
                  if uint128(stor9):
                      mem[ceil32(return_data.size) + 321] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                      static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                              gas gas_remaining wei
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      if ext_call.success:
                          mem[ceil32(return_data.size) + 321 len return_data.size] = ext_call.return_data[0 len return_data.size]
                          if (2 * ceil32(return_data.size)) + 321 > LOCK8605463013() or 2 * ceil32(return_data.size) < ceil32(return_data.size):
                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                          mem[64] = (2 * ceil32(return_data.size)) + 321
                          require return_data.size >=′ 32
                          require mem[ceil32(return_data.size) + 321] <= LOCK8605463013()
                          require ceil32(return_data.size) + mem[ceil32(return_data.size) + 321] + 352 <′ ceil32(return_data.size) + return_data.size + 321
                          if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 321] + 321] > LOCK8605463013():
                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                          if (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 321] + 321]) + 322 > LOCK8605463013() or ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 321] + 321]) + 1 < 0:
                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                          require mem[ceil32(return_data.size) + 321] + (32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 321] + 321]) + 32 <= return_data.size
                      else:
                          if 484512 * 24 * 3600 <= block.timestamp:
                              if mem[0] > LOCK8605463013():
                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                              if ceil32(return_data.size) + ceil32(32 * mem[0]) + 322 > LOCK8605463013() or ceil32(32 * mem[0]) + 34 < 33:
                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                              if mem[0] > LOCK8605463013():
                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                          else:
                              mem[ceil32(return_data.size) + 321] = 0xf8b2f99100000000000000000000000000000000000000000000000000000000
                              call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                                   gas gas_remaining wei
                              if not ext_call.success:
                                  revert with ext_call.return_data[0 len return_data.size]
                              if ext_call.success:
                                  mem[ceil32(return_data.size) + 321 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                  if (2 * ceil32(return_data.size)) + 321 > LOCK8605463013() or 2 * ceil32(return_data.size) < ceil32(return_data.size):
                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                  mem[64] = (2 * ceil32(return_data.size)) + 321
                                  require return_data.size >=′ 32
                                  require mem[ceil32(return_data.size) + 321] <= LOCK8605463013()
                                  require ceil32(return_data.size) + mem[ceil32(return_data.size) + 321] + 352 <′ ceil32(return_data.size) + return_data.size + 321
                                  if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 321] + 321] > LOCK8605463013():
                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                  if (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 321] + 321]) + 322 > LOCK8605463013() or ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 321] + 321]) + 1 < 0:
                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                  require mem[ceil32(return_data.size) + 321] + (32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 321] + 321]) + 32 <= return_data.size
                  else:
                      mem[ceil32(return_data.size) + 321] = 0xef5cfb8c00000000000000000000000000000000000000000000000000000000
                      mem[ceil32(return_data.size) + 325] = this.address
                      call 0xac614884b52dbab8728476b5d50f0d672baed31f.claimRewards(address _receiver) with:
                           gas gas_remaining wei
                          args this.address
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      if ext_call.success:
                          mem[ceil32(return_data.size) + 321 len return_data.size] = ext_call.return_data[0 len return_data.size]
                          if (2 * ceil32(return_data.size)) + 321 > LOCK8605463013() or 2 * ceil32(return_data.size) < ceil32(return_data.size):
                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                          mem[64] = (2 * ceil32(return_data.size)) + 321
                          require return_data.size >=′ 32
                          require mem[ceil32(return_data.size) + 321 len 4], Mask(224, 32, this.address) >> 32 <= LOCK8605463013()
                          require ceil32(return_data.size) + mem[ceil32(return_data.size) + 321 len 4], Mask(224, 32, this.address) >> 32 + 352 <′ ceil32(return_data.size) + return_data.size + 321
                          if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 321 len 4], Mask(224, 32, this.address) >> 32 + 321] > LOCK8605463013():
                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                          if (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 321 len 4], Mask(224, 32, this.address) >> 32 + 321]) + 322 > LOCK8605463013() or ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 321 len 4], Mask(224, 32, this.address) >> 32 + 321]) + 1 < 0:
                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                          require mem[ceil32(return_data.size) + 321 len 4], Mask(224, 32, this.address) >> 32 + (32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 321 len 4], Mask(224, 32, this.address) >> 32 + 321]) + 32 <= return_data.size
                      else:
                          if block.number == unknown60e0a9e1:
                              require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                              uint128(stor9) = 0
                              mem[ceil32(return_data.size) + 321] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                              static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                                      gas gas_remaining wei
                              if not ext_call.success:
                                  revert with ext_call.return_data[0 len return_data.size]
                              if ext_call.success:
                                  mem[ceil32(return_data.size) + 321 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                  if (2 * ceil32(return_data.size)) + 321 > LOCK8605463013() or 2 * ceil32(return_data.size) < ceil32(return_data.size):
                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                  mem[64] = (2 * ceil32(return_data.size)) + 321
                                  require return_data.size >=′ 32
                                  require mem[ceil32(return_data.size) + 321] <= LOCK8605463013()
                                  require ceil32(return_data.size) + mem[ceil32(return_data.size) + 321] + 352 <′ ceil32(return_data.size) + return_data.size + 321
                                  if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 321] + 321] > LOCK8605463013():
                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                  if (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 321] + 321]) + 322 > LOCK8605463013() or ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 321] + 321]) + 1 < 0:
                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                  require mem[ceil32(return_data.size) + 321] + (32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 321] + 321]) + 32 <= return_data.size
                          else:
                              static call 0xac614884b52dbab8728476b5d50f0d672baed31f.exchangeRate() with:
                                      gas gas_remaining wei
                              mem[ceil32(return_data.size) + 321] = ext_call.return_data[0]
                              if not ext_call.success:
                                  revert with ext_call.return_data[0 len return_data.size]
                              if ext_call.success:
                                  if 32 > return_data.size:
                                      if (2 * ceil32(return_data.size)) + 321 > LOCK8605463013() or 2 * ceil32(return_data.size) < ceil32(return_data.size):
                                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                      require return_data.size >=′ 32
                                      if ext_call.return_data[0] <= uint128(unknownd2a3584e) >> 128:
                                          require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                                          unknown60e0a9e1 = uint128(block.number)
                                          stor8 = 0
                                          log 0x71475f2f 
                                          log 0x0 
                                          uint128(stor9) = 0
                                      else:
                                          require ext_call.return_data[0] <= LOCK8605463013()
                                          unknown60e0a9e1 = uint128(block.number)
                                          stor8 = uint128(ext_call.return_data[0])
                                          log 0x71475f2f: uint128(ext_call.return_data[0])
                                          require uint128(ext_call.return_data[0]) <= LOCK8605463013()
                                          uint128(stor9) = uint128(ext_call.return_data[0])
                                      mem[(2 * ceil32(return_data.size)) + 321] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                                      static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                                              gas gas_remaining wei
                                      if not ext_call.success:
                                          revert with ext_call.return_data[0 len return_data.size]
                                      if ext_call.success:
                                          mem[(2 * ceil32(return_data.size)) + 321 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                          if (4 * ceil32(return_data.size)) + 321 > LOCK8605463013() or 4 * ceil32(return_data.size) < 2 * ceil32(return_data.size):
                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                          require return_data.size >=′ 32
                                          require mem[(2 * ceil32(return_data.size)) + 321] <= LOCK8605463013()
                                          require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 321] + 352 <′ (2 * ceil32(return_data.size)) + return_data.size + 321
                                          if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 321] + 321] > LOCK8605463013():
                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                          if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 321] + 321]) + 322 > LOCK8605463013() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 321] + 321]) + 1 < 0:
                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                          require mem[(2 * ceil32(return_data.size)) + 321] + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 321] + 321]) + 32 <= return_data.size
          else:
              static call 0xac614884b52dbab8728476b5d50f0d672baed31f.exchangeRate() with:
                      gas gas_remaining wei
              mem[ceil32(return_data.size) + 321] = ext_call.return_data[0]
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              if ext_call.success:
                  if 32 > return_data.size:
                      if (2 * ceil32(return_data.size)) + 321 > LOCK8605463013() or 2 * ceil32(return_data.size) < ceil32(return_data.size):
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      require return_data.size >=′ 32
                      if ext_call.return_data[0] <= uint128(unknownd2a3584e) >> 128:
                          require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                          unknown60e0a9e1 = uint128(block.number)
                          stor8 = 0
                          log 0x71475f2f 
                          log 0x0 
                          if 0 / ext_call.return_data[0] - unknown4ba6dcd7 and ext_call.return_data[0] - unknown4ba6dcd7:
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[ceil32(return_data.size) + 320] = 0
                      else:
                          require ext_call.return_data[0] <= LOCK8605463013()
                          unknown60e0a9e1 = uint128(block.number)
                          stor8 = uint128(ext_call.return_data[0])
                          log 0x71475f2f: uint128(ext_call.return_data[0])
                          if (ext_call.return_data[0] * ext_call.return_data[16 len 16]) - (unknown4ba6dcd7 * ext_call.return_data[16 len 16]) / ext_call.return_data[0] - unknown4ba6dcd7 != ext_call.return_data[16 len 16] and ext_call.return_data[0] - unknown4ba6dcd7:
                              revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                          mem[ceil32(return_data.size) + 320] = (ext_call.return_data[0] * ext_call.return_data[16 len 16]) - (unknown4ba6dcd7 * ext_call.return_data[16 len 16]) / 10^18
                      if not address(_param2):
                          revert with Error(string reason), 'ERC20: mint to the zero address'
                      if 484512 * 24 * 3600 <= block.timestamp:
                          if uint128(stor9):
                              mem[(2 * ceil32(return_data.size)) + 321] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                              static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                                      gas gas_remaining wei
                              if not ext_call.success:
                                  revert with ext_call.return_data[0 len return_data.size]
                              if ext_call.success:
                                  mem[(2 * ceil32(return_data.size)) + 321 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                  if (4 * ceil32(return_data.size)) + 321 > LOCK8605463013() or 4 * ceil32(return_data.size) < 2 * ceil32(return_data.size):
                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                  require return_data.size >=′ 32
                                  require mem[(2 * ceil32(return_data.size)) + 321] <= LOCK8605463013()
                                  require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 321] + 352 <′ (2 * ceil32(return_data.size)) + return_data.size + 321
                                  if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 321] + 321] > LOCK8605463013():
                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                  if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 321] + 321]) + 322 > LOCK8605463013() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 321] + 321]) + 1 < 0:
                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                  require mem[(2 * ceil32(return_data.size)) + 321] + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 321] + 321]) + 32 <= return_data.size
                              else:
                                  if 484512 * 24 * 3600 <= block.timestamp:
                                      if mem[0] > LOCK8605463013():
                                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                      if (2 * ceil32(return_data.size)) + ceil32(32 * mem[0]) + 322 > LOCK8605463013() or ceil32(32 * mem[0]) + 1 < 0:
                                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                      if mem[0] > LOCK8605463013():
                                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                  else:
                                      mem[(2 * ceil32(return_data.size)) + 321] = 0xf8b2f99100000000000000000000000000000000000000000000000000000000
                                      call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                                           gas gas_remaining wei
                                      if not ext_call.success:
                                          revert with ext_call.return_data[0 len return_data.size]
                                      if ext_call.success:
                                          mem[(2 * ceil32(return_data.size)) + 321 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                          if (4 * ceil32(return_data.size)) + 321 > LOCK8605463013() or 4 * ceil32(return_data.size) < 2 * ceil32(return_data.size):
                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                          require return_data.size >=′ 32
                                          require mem[(2 * ceil32(return_data.size)) + 321] <= LOCK8605463013()
                                          require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 321] + 352 <′ (2 * ceil32(return_data.size)) + return_data.size + 321
                                          if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 321] + 321] > LOCK8605463013():
                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                          if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 321] + 321]) + 322 > LOCK8605463013() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 321] + 321]) + 1 < 0:
                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                          require mem[(2 * ceil32(return_data.size)) + 321] + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 321] + 321]) + 32 <= return_data.size
                          else:
                              mem[(2 * ceil32(return_data.size)) + 321] = 0xef5cfb8c00000000000000000000000000000000000000000000000000000000
                              mem[(2 * ceil32(return_data.size)) + 325] = this.address
                              call 0xac614884b52dbab8728476b5d50f0d672baed31f.claimRewards(address _receiver) with:
                                   gas gas_remaining wei
                                  args this.address
                              if not ext_call.success:
                                  revert with ext_call.return_data[0 len return_data.size]
                              if ext_call.success:
                                  mem[(2 * ceil32(return_data.size)) + 321 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                  if (4 * ceil32(return_data.size)) + 321 > LOCK8605463013() or 4 * ceil32(return_data.size) < 2 * ceil32(return_data.size):
                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                  mem[64] = (4 * ceil32(return_data.size)) + 321
                                  require return_data.size >=′ 32
                                  require mem[(2 * ceil32(return_data.size)) + 321 len 4], Mask(224, 32, this.address) >> 32 <= LOCK8605463013()
                                  require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 321 len 4], Mask(224, 32, this.address) >> 32 + 352 <′ (2 * ceil32(return_data.size)) + return_data.size + 321
                                  if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 321 len 4], Mask(224, 32, this.address) >> 32 + 321] > LOCK8605463013():
                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                  if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 321 len 4], Mask(224, 32, this.address) >> 32 + 321]) + 322 > LOCK8605463013() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 321 len 4], Mask(224, 32, this.address) >> 32 + 321]) + 1 < 0:
                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                  require mem[(2 * ceil32(return_data.size)) + 321 len 4], Mask(224, 32, this.address) >> 32 + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 321 len 4], Mask(224, 32, this.address) >> 32 + 321]) + 32 <= return_data.size
                              else:
                                  if block.number == unknown60e0a9e1:
                                      require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                                      uint128(stor9) = 0
                                      mem[(2 * ceil32(return_data.size)) + 321] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                                      static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                                              gas gas_remaining wei
                                      if not ext_call.success:
                                          revert with ext_call.return_data[0 len return_data.size]
                                      if ext_call.success:
                                          mem[(2 * ceil32(return_data.size)) + 321 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                          if (4 * ceil32(return_data.size)) + 321 > LOCK8605463013() or 4 * ceil32(return_data.size) < 2 * ceil32(return_data.size):
                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                          require return_data.size >=′ 32
                                          require mem[(2 * ceil32(return_data.size)) + 321] <= LOCK8605463013()
                                          require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 321] + 352 <′ (2 * ceil32(return_data.size)) + return_data.size + 321
                                          if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 321] + 321] > LOCK8605463013():
                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                          if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 321] + 321]) + 322 > LOCK8605463013() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 321] + 321]) + 1 < 0:
                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                          require mem[(2 * ceil32(return_data.size)) + 321] + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 321] + 321]) + 32 <= return_data.size
                                  else:
                                      static call 0xac614884b52dbab8728476b5d50f0d672baed31f.exchangeRate() with:
                                              gas gas_remaining wei
                                      mem[(2 * ceil32(return_data.size)) + 321] = ext_call.return_data[0]
                                      if not ext_call.success:
                                          revert with ext_call.return_data[0 len return_data.size]
                                      if ext_call.success:
                                          if 32 > return_data.size:
                                              if (4 * ceil32(return_data.size)) + 321 > LOCK8605463013() or 4 * ceil32(return_data.size) < 2 * ceil32(return_data.size):
                                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                              require return_data.size >=′ 32
                                              if ext_call.return_data[0] <= uint128(unknownd2a3584e) >> 128:
                                                  require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                                                  unknown60e0a9e1 = uint128(block.number)
                                                  stor8 = 0
                                                  log 0x71475f2f 
                                                  log 0x0 
                                                  uint128(stor9) = 0
                                              else:
                                                  require ext_call.return_data[0] <= LOCK8605463013()
                                                  unknown60e0a9e1 = uint128(block.number)
                                                  stor8 = uint128(ext_call.return_data[0])
                                                  log 0x71475f2f: uint128(ext_call.return_data[0])
                                                  require uint128(ext_call.return_data[0]) <= LOCK8605463013()
                                                  uint128(stor9) = uint128(ext_call.return_data[0])
                                              mem[(4 * ceil32(return_data.size)) + 321] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                                              static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                                                      gas gas_remaining wei
                                              if not ext_call.success:
                                                  revert with ext_call.return_data[0 len return_data.size]
                                              if ext_call.success:
                                                  mem[(4 * ceil32(return_data.size)) + 321 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                  if (6 * ceil32(return_data.size)) + 321 > LOCK8605463013() or 6 * ceil32(return_data.size) < 4 * ceil32(return_data.size):
                                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                  require return_data.size >=′ 32
                                                  require mem[(4 * ceil32(return_data.size)) + 321] <= LOCK8605463013()
                                                  require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 321] + 352 <′ (4 * ceil32(return_data.size)) + return_data.size + 321
                                                  if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 321] + 321] > LOCK8605463013():
                                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                  if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 321] + 321]) + 322 > LOCK8605463013() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 321] + 321]) + 1 < 0:
                                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                  require mem[(4 * ceil32(return_data.size)) + 321] + (32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 321] + 321]) + 32 <= return_data.size
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def unknowncdbb0361(): # not payable
  require calldata.size - 4 >=′ 0
  if uint8(uint256(stor2.field_0)) >> 248 == 2:
      revert with Error(string reason), 'ReentrancyGuard: reentrant call'
  uint8(stor2.field_248) = 2
  if 484512 * 24 * 3600 > block.timestamp:
      uint8(stor2.field_248) = 1
      return 0
  if uint128(stor9):
      uint8(stor2.field_248) = 1
      return 0
  mem[96] = 0xef5cfb8c00000000000000000000000000000000000000000000000000000000
  mem[100] = this.address
  call 0xac614884b52dbab8728476b5d50f0d672baed31f.claimRewards(address _receiver) with:
       gas gas_remaining wei
      args this.address
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  if not ext_call.success:
      if block.number == unknown60e0a9e1:
          require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
          uint128(stor9) = 0
          mem[96] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
          static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                  gas gas_remaining wei
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          if not ext_call.success:
              call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                   gas gas_remaining wei
              revert with ext_call.return_data[0 len return_data.size]
          mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
          if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
          mem[64] = ceil32(return_data.size) + 96
          require return_data.size >=′ 32
          _12 = mem[96]
          require mem[96] <= LOCK8605463013()
          require mem[96] + 127 <′ return_data.size + 96
          _14 = mem[mem[96] + 96]
          if mem[mem[96] + 96] > LOCK8605463013():
              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
          if ceil32(return_data.size) + ceil32(32 * mem[mem[96] + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[mem[96] + 96]) + 1 < 0:
              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
          mem[64] = ceil32(return_data.size) + ceil32(32 * mem[mem[96] + 96]) + 97
          mem[ceil32(return_data.size) + 96] = _14
          require _12 + (32 * _14) + 32 <= return_data.size
          s = ceil32(return_data.size) + 128
          idx = _12 + 128
          while idx < _12 + (32 * _14) + 128:
              require not Mask(96, 160, mem[idx])
              mem[s] = mem[idx]
              s = s + 32
              idx = idx + 32
              continue 
          _198 = mem[64]
          mem[mem[64]] = 0xf8b2f99100000000000000000000000000000000000000000000000000000000
          call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
               gas gas_remaining wei
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          if not ext_call.success:
              idx = 0
              while idx < _14:
                  if idx >= mem[0]:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  if idx >= mem[ceil32(return_data.size) + 96]:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  stor10[mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]] = mem[(32 * idx) + 32]
                  if idx >= mem[ceil32(return_data.size) + 96]:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  _1029 = mem[(32 * idx) + ceil32(return_data.size) + 128]
                  if not mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]:
                      if idx >= mem[ceil32(return_data.size) + 96]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      mem[0] = mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]
                      mem[32] = 11
                      stor11[mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]] = eth.balance(this.address)
                  else:
                      mem[mem[64] + 4] = this.address
                      static call address(_1029).balanceOf(address account) with:
                              gas gas_remaining wei
                             args this.address
                      mem[mem[64]] = ext_call.return_data[0]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      if not ext_call.success:
                          if idx >= mem[ceil32(return_data.size) + 96]:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          mem[0] = mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]
                          mem[32] = 11
                          stor11[mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]] = 0
                      else:
                          if 32 <= return_data.size:
                              if mem[64] + 32 > LOCK8605463013() or mem[64] + 32 < mem[64]:
                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                          if mem[64] + ceil32(return_data.size) > LOCK8605463013() or mem[64] + ceil32(return_data.size) < mem[64]:
                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          if idx >= mem[ceil32(return_data.size) + 96]:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          mem[0] = mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]
                          mem[32] = 11
                          stor11[mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]] = ext_call.return_data[0]
                  idx = idx + 1
                  continue 
          else:
              mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
              if mem[64] + ceil32(return_data.size) > LOCK8605463013() or mem[64] + ceil32(return_data.size) < mem[64]:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              mem[64] = mem[64] + ceil32(return_data.size)
              require return_data.size >=′ 32
              _213 = mem[_198]
              require mem[_198] <= LOCK8605463013()
              require _198 + mem[_198] + 31 <′ _198 + return_data.size
              _220 = mem[_198 + mem[_198]]
              if mem[_198 + mem[_198]] > LOCK8605463013():
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              if _198 + ceil32(return_data.size) + ceil32(32 * mem[_198 + mem[_198]]) + 1 > LOCK8605463013() or ceil32(32 * mem[_198 + mem[_198]]) + 1 < 0:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              mem[64] = _198 + ceil32(return_data.size) + ceil32(32 * mem[_198 + mem[_198]]) + 1
              mem[_198 + ceil32(return_data.size)] = _220
              require _213 + (32 * _220) + 32 <= return_data.size
              mem[_198 + ceil32(return_data.size) + 32 len ceil32(32 * _220)] = mem[_198 + _213 + 32 len ceil32(32 * _220)]
              idx = 0
              while idx < _14:
                  if idx >= mem[_198 + ceil32(return_data.size)]:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  if idx >= mem[ceil32(return_data.size) + 96]:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  stor10[mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]] = mem[(32 * idx) + _198 + ceil32(return_data.size) + 32]
                  if idx >= mem[ceil32(return_data.size) + 96]:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  _1028 = mem[(32 * idx) + ceil32(return_data.size) + 128]
                  if not mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]:
                      if idx >= mem[ceil32(return_data.size) + 96]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      mem[0] = mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]
                      mem[32] = 11
                      stor11[mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]] = eth.balance(this.address)
                  else:
                      mem[mem[64] + 4] = this.address
                      static call address(_1028).balanceOf(address account) with:
                              gas gas_remaining wei
                             args this.address
                      mem[mem[64]] = ext_call.return_data[0]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      if not ext_call.success:
                          if idx >= mem[ceil32(return_data.size) + 96]:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          mem[0] = mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]
                          mem[32] = 11
                          stor11[mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]] = 0
                      else:
                          if 32 <= return_data.size:
                              if mem[64] + 32 > LOCK8605463013() or mem[64] + 32 < mem[64]:
                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                          if mem[64] + ceil32(return_data.size) > LOCK8605463013() or mem[64] + ceil32(return_data.size) < mem[64]:
                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          if idx >= mem[ceil32(return_data.size) + 96]:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          mem[0] = mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]
                          mem[32] = 11
                          stor11[mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]] = ext_call.return_data[0]
                  idx = idx + 1
                  continue 
      else:
          static call 0xac614884b52dbab8728476b5d50f0d672baed31f.exchangeRate() with:
                  gas gas_remaining wei
          mem[96] = ext_call.return_data[0]
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          if not ext_call.success:
              if 0 > uint128(unknownd2a3584e) >> 128:
                  unknown60e0a9e1 = uint128(block.number)
                  stor8 = 0
                  log 0x71475f2f 
                  log 0x0 
                  uint128(stor9) = 0
                  mem[96] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                  static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                          gas gas_remaining wei
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if not ext_call.success:
                      call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                           gas gas_remaining wei
                      revert with ext_call.return_data[0 len return_data.size]
                  mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                  if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  mem[64] = ceil32(return_data.size) + 96
                  require return_data.size >=′ 32
                  _224 = mem[96]
                  require mem[96] <= LOCK8605463013()
                  require mem[96] + 127 <′ return_data.size + 96
                  _226 = mem[mem[96] + 96]
                  if mem[mem[96] + 96] > LOCK8605463013():
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  if ceil32(return_data.size) + ceil32(32 * mem[mem[96] + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[mem[96] + 96]) + 1 < 0:
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  mem[64] = ceil32(return_data.size) + ceil32(32 * mem[mem[96] + 96]) + 97
                  mem[ceil32(return_data.size) + 96] = _226
                  require _224 + (32 * _226) + 32 <= return_data.size
                  s = ceil32(return_data.size) + 128
                  idx = _224 + 128
                  while idx < _224 + (32 * _226) + 128:
                      require not Mask(96, 160, mem[idx])
                      mem[s] = mem[idx]
                      s = s + 32
                      idx = idx + 32
                      continue 
                  _510 = mem[64]
                  mem[mem[64]] = 0xf8b2f99100000000000000000000000000000000000000000000000000000000
                  call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                       gas gas_remaining wei
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if not ext_call.success:
                      if var67001 >= _226:
                          uint8(stor2.field_248) = 1
                          return 0
                      if var67001 >= mem[0]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  else:
                      mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                      if mem[64] + ceil32(return_data.size) > LOCK8605463013() or mem[64] + ceil32(return_data.size) < mem[64]:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      mem[64] = mem[64] + ceil32(return_data.size)
                      require return_data.size >=′ 32
                      require mem[_510] <= LOCK8605463013()
                      require _510 + mem[_510] + 31 <′ _510 + return_data.size
                      if mem[_510 + mem[_510]] > LOCK8605463013():
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      if _510 + ceil32(return_data.size) + ceil32(32 * mem[_510 + mem[_510]]) + 1 > LOCK8605463013() or ceil32(32 * mem[_510 + mem[_510]]) + 1 < 0:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      require mem[_510] + (32 * mem[_510 + mem[_510]]) + 32 <= return_data.size
                      if var85001 >= _226:
                          uint8(stor2.field_248) = 1
                          return 0
                      if var85001 >= mem[_510 + mem[_510]]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              else:
                  require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                  unknown60e0a9e1 = uint128(block.number)
                  stor8 = 0
                  log 0x71475f2f 
                  log 0x0 
                  uint128(stor9) = 0
                  mem[96] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                  static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                          gas gas_remaining wei
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if not ext_call.success:
                      call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                           gas gas_remaining wei
                      revert with ext_call.return_data[0 len return_data.size]
                  mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                  if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  mem[64] = ceil32(return_data.size) + 96
                  require return_data.size >=′ 32
                  _223 = mem[96]
                  require mem[96] <= LOCK8605463013()
                  require mem[96] + 127 <′ return_data.size + 96
                  _225 = mem[mem[96] + 96]
                  if mem[mem[96] + 96] > LOCK8605463013():
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  if ceil32(return_data.size) + ceil32(32 * mem[mem[96] + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[mem[96] + 96]) + 1 < 0:
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  mem[64] = ceil32(return_data.size) + ceil32(32 * mem[mem[96] + 96]) + 97
                  mem[ceil32(return_data.size) + 96] = _225
                  require _223 + (32 * _225) + 32 <= return_data.size
                  s = ceil32(return_data.size) + 128
                  idx = _223 + 128
                  while idx < _223 + (32 * _225) + 128:
                      require not Mask(96, 160, mem[idx])
                      mem[s] = mem[idx]
                      s = s + 32
                      idx = idx + 32
                      continue 
                  _509 = mem[64]
                  mem[mem[64]] = 0xf8b2f99100000000000000000000000000000000000000000000000000000000
                  call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                       gas gas_remaining wei
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if not ext_call.success:
                      if var67001 >= _225:
                          uint8(stor2.field_248) = 1
                          return 0
                      if var67001 >= mem[0]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  else:
                      mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                      if mem[64] + ceil32(return_data.size) > LOCK8605463013() or mem[64] + ceil32(return_data.size) < mem[64]:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      mem[64] = mem[64] + ceil32(return_data.size)
                      require return_data.size >=′ 32
                      require mem[_509] <= LOCK8605463013()
                      require _509 + mem[_509] + 31 <′ _509 + return_data.size
                      if mem[_509 + mem[_509]] > LOCK8605463013():
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      if _509 + ceil32(return_data.size) + ceil32(32 * mem[_509 + mem[_509]]) + 1 > LOCK8605463013() or ceil32(32 * mem[_509 + mem[_509]]) + 1 < 0:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      require mem[_509] + (32 * mem[_509 + mem[_509]]) + 32 <= return_data.size
                      if var85001 >= _225:
                          uint8(stor2.field_248) = 1
                          return 0
                      if var85001 >= mem[_509 + mem[_509]]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
          if 32 <= return_data.size:
              if ext_call.return_data[0] <= uint128(unknownd2a3584e) >> 128:
                  require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                  unknown60e0a9e1 = uint128(block.number)
                  stor8 = 0
                  log 0x71475f2f 
                  log 0x0 
                  uint128(stor9) = 0
                  mem[128] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                  static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                          gas gas_remaining wei
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if not ext_call.success:
                      call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                           gas gas_remaining wei
                      revert with ext_call.return_data[0 len return_data.size]
                  mem[128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                  if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  require return_data.size >=′ 32
                  _232 = mem[128]
                  require mem[128] <= LOCK8605463013()
                  require mem[128] + 159 <′ return_data.size + 128
                  _237 = mem[mem[128] + 128]
                  if mem[mem[128] + 128] > LOCK8605463013():
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  if ceil32(return_data.size) + ceil32(32 * mem[mem[128] + 128]) + 129 > LOCK8605463013() or ceil32(32 * mem[mem[128] + 128]) + 1 < 0:
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  mem[64] = ceil32(return_data.size) + ceil32(32 * mem[mem[128] + 128]) + 129
                  mem[ceil32(return_data.size) + 128] = mem[mem[128] + 128]
                  require _232 + (32 * _237) + 32 <= return_data.size
                  s = ceil32(return_data.size) + 160
                  idx = _232 + 160
                  while idx < _232 + (32 * _237) + 160:
                      require not Mask(96, 160, mem[idx])
                      mem[s] = mem[idx]
                      s = s + 32
                      idx = idx + 32
                      continue 
                  _507 = mem[64]
                  mem[mem[64]] = 0xf8b2f99100000000000000000000000000000000000000000000000000000000
                  call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                       gas gas_remaining wei
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if not ext_call.success:
                      if var73001 >= _237:
                          uint8(stor2.field_248) = 1
                          return 0
                      if var73001 >= mem[0]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  else:
                      mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                      if mem[64] + ceil32(return_data.size) > LOCK8605463013() or mem[64] + ceil32(return_data.size) < mem[64]:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      mem[64] = mem[64] + ceil32(return_data.size)
                      require return_data.size >=′ 32
                      _555 = mem[_507]
                      require mem[_507] <= LOCK8605463013()
                      require _507 + mem[_507] + 31 <′ _507 + return_data.size
                      _578 = mem[_507 + mem[_507]]
                      if mem[_507 + mem[_507]] > LOCK8605463013():
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      if _507 + ceil32(return_data.size) + ceil32(32 * mem[_507 + mem[_507]]) + 1 > LOCK8605463013() or ceil32(32 * mem[_507 + mem[_507]]) + 1 < 0:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      mem[64] = _507 + ceil32(return_data.size) + ceil32(32 * mem[_507 + mem[_507]]) + 1
                      mem[_507 + ceil32(return_data.size)] = _578
                      require _555 + (32 * _578) + 32 <= return_data.size
                      mem[_507 + ceil32(return_data.size) + 32 len ceil32(32 * _578)] = mem[_507 + _555 + 32 len ceil32(32 * _578)]
                      if var91001 >= mem[ceil32(return_data.size) + 128]:
                          uint8(stor2.field_248) = 1
                          return 0
                      if var91001 >= _578:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              else:
                  require ext_call.return_data[0] <= LOCK8605463013()
                  unknown60e0a9e1 = uint128(block.number)
                  stor8 = uint128(ext_call.return_data[0])
                  log 0x71475f2f: uint128(ext_call.return_data[0])
                  require uint128(ext_call.return_data[0]) <= LOCK8605463013()
                  uint128(stor9) = uint128(ext_call.return_data[0])
                  mem[128] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                  static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                          gas gas_remaining wei
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if not ext_call.success:
                      call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                           gas gas_remaining wei
                      revert with ext_call.return_data[0 len return_data.size]
                  mem[128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                  if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  require return_data.size >=′ 32
                  _233 = mem[128]
                  require mem[128] <= LOCK8605463013()
                  require mem[128] + 159 <′ return_data.size + 128
                  _238 = mem[mem[128] + 128]
                  if mem[mem[128] + 128] > LOCK8605463013():
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  if ceil32(return_data.size) + ceil32(32 * mem[mem[128] + 128]) + 129 > LOCK8605463013() or ceil32(32 * mem[mem[128] + 128]) + 1 < 0:
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  mem[64] = ceil32(return_data.size) + ceil32(32 * mem[mem[128] + 128]) + 129
                  mem[ceil32(return_data.size) + 128] = mem[mem[128] + 128]
                  require _233 + (32 * _238) + 32 <= return_data.size
                  s = ceil32(return_data.size) + 160
                  idx = _233 + 160
                  while idx < _233 + (32 * _238) + 160:
                      require not Mask(96, 160, mem[idx])
                      mem[s] = mem[idx]
                      s = s + 32
                      idx = idx + 32
                      continue 
                  _508 = mem[64]
                  mem[mem[64]] = 0xf8b2f99100000000000000000000000000000000000000000000000000000000
                  call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                       gas gas_remaining wei
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if not ext_call.success:
                      if var73001 >= _238:
                          uint8(stor2.field_248) = 1
                          return 0
                      if var73001 >= mem[0]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  else:
                      mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                      if mem[64] + ceil32(return_data.size) > LOCK8605463013() or mem[64] + ceil32(return_data.size) < mem[64]:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      mem[64] = mem[64] + ceil32(return_data.size)
                      require return_data.size >=′ 32
                      _556 = mem[_508]
                      require mem[_508] <= LOCK8605463013()
                      require _508 + mem[_508] + 31 <′ _508 + return_data.size
                      _579 = mem[_508 + mem[_508]]
                      if mem[_508 + mem[_508]] > LOCK8605463013():
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      if _508 + ceil32(return_data.size) + ceil32(32 * mem[_508 + mem[_508]]) + 1 > LOCK8605463013() or ceil32(32 * mem[_508 + mem[_508]]) + 1 < 0:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      mem[64] = _508 + ceil32(return_data.size) + ceil32(32 * mem[_508 + mem[_508]]) + 1
                      mem[_508 + ceil32(return_data.size)] = _579
                      require _556 + (32 * _579) + 32 <= return_data.size
                      mem[_508 + ceil32(return_data.size) + 32 len ceil32(32 * _579)] = mem[_508 + _556 + 32 len ceil32(32 * _579)]
                      if var91001 >= mem[ceil32(return_data.size) + 128]:
                          uint8(stor2.field_248) = 1
                          return 0
                      if var91001 >= _579:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
          if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
          require return_data.size >=′ 32
          if ext_call.return_data[0] <= uint128(unknownd2a3584e) >> 128:
              require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
              unknown60e0a9e1 = uint128(block.number)
              stor8 = 0
              log 0x71475f2f 
              log 0x0 
              uint128(stor9) = 0
              mem[ceil32(return_data.size) + 96] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
              static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                      gas gas_remaining wei
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              if not ext_call.success:
                  call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                       gas gas_remaining wei
                  revert with ext_call.return_data[0 len return_data.size]
              mem[ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
              if (2 * ceil32(return_data.size)) + 96 > LOCK8605463013() or 2 * ceil32(return_data.size) < ceil32(return_data.size):
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              require return_data.size >=′ 32
              _25 = mem[ceil32(return_data.size) + 96]
              require mem[ceil32(return_data.size) + 96] <= LOCK8605463013()
              require ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 127 <′ ceil32(return_data.size) + return_data.size + 96
              _29 = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96]
              if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96] > LOCK8605463013():
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              if (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96]) + 1 < 0:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              mem[64] = (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96]) + 97
              mem[(2 * ceil32(return_data.size)) + 96] = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96]
              require _25 + (32 * _29) + 32 <= return_data.size
              s = (2 * ceil32(return_data.size)) + 128
              idx = ceil32(return_data.size) + _25 + 128
              while idx < ceil32(return_data.size) + _25 + (32 * _29) + 128:
                  require not Mask(96, 160, mem[idx])
                  mem[s] = mem[idx]
                  s = s + 32
                  idx = idx + 32
                  continue 
              _199 = mem[64]
              mem[mem[64]] = 0xf8b2f99100000000000000000000000000000000000000000000000000000000
              call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                   gas gas_remaining wei
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              if not ext_call.success:
                  idx = 0
                  while idx < _29:
                      if idx >= mem[0]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      if idx >= mem[(2 * ceil32(return_data.size)) + 96]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      stor10[mem[(32 * idx) + (2 * ceil32(return_data.size)) + 140 len 20]] = mem[(32 * idx) + 32]
                      if idx >= mem[(2 * ceil32(return_data.size)) + 96]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      _1031 = mem[(32 * idx) + (2 * ceil32(return_data.size)) + 128]
                      if not mem[(32 * idx) + (2 * ceil32(return_data.size)) + 140 len 20]:
                          if idx >= mem[(2 * ceil32(return_data.size)) + 96]:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          mem[0] = mem[(32 * idx) + (2 * ceil32(return_data.size)) + 140 len 20]
                          mem[32] = 11
                          stor11[mem[(32 * idx) + (2 * ceil32(return_data.size)) + 140 len 20]] = eth.balance(this.address)
                      else:
                          mem[mem[64] + 4] = this.address
                          static call address(_1031).balanceOf(address account) with:
                                  gas gas_remaining wei
                                 args this.address
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          if not ext_call.success:
                              if idx >= mem[(2 * ceil32(return_data.size)) + 96]:
                                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                              mem[0] = mem[(32 * idx) + (2 * ceil32(return_data.size)) + 140 len 20]
                              mem[32] = 11
                              stor11[mem[(32 * idx) + (2 * ceil32(return_data.size)) + 140 len 20]] = 0
                          else:
                              if 32 <= return_data.size:
                                  if mem[64] + 32 > LOCK8605463013() or mem[64] + 32 < mem[64]:
                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                              if mem[64] + ceil32(return_data.size) > LOCK8605463013() or mem[64] + ceil32(return_data.size) < mem[64]:
                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              if idx >= mem[(2 * ceil32(return_data.size)) + 96]:
                                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                              mem[0] = mem[(32 * idx) + (2 * ceil32(return_data.size)) + 140 len 20]
                              mem[32] = 11
                              stor11[mem[(32 * idx) + (2 * ceil32(return_data.size)) + 140 len 20]] = ext_call.return_data[0]
                      idx = idx + 1
                      continue 
              else:
                  mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                  if mem[64] + ceil32(return_data.size) > LOCK8605463013() or mem[64] + ceil32(return_data.size) < mem[64]:
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  mem[64] = mem[64] + ceil32(return_data.size)
                  require return_data.size >=′ 32
                  _214 = mem[_199]
                  require mem[_199] <= LOCK8605463013()
                  require _199 + mem[_199] + 31 <′ _199 + return_data.size
                  _221 = mem[_199 + mem[_199]]
                  if mem[_199 + mem[_199]] > LOCK8605463013():
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  if _199 + ceil32(return_data.size) + ceil32(32 * mem[_199 + mem[_199]]) + 1 > LOCK8605463013() or ceil32(32 * mem[_199 + mem[_199]]) + 1 < 0:
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  mem[64] = _199 + ceil32(return_data.size) + ceil32(32 * mem[_199 + mem[_199]]) + 1
                  mem[_199 + ceil32(return_data.size)] = _221
                  require _214 + (32 * _221) + 32 <= return_data.size
                  mem[_199 + ceil32(return_data.size) + 32 len ceil32(32 * _221)] = mem[_199 + _214 + 32 len ceil32(32 * _221)]
                  _884 = mem[(2 * ceil32(return_data.size)) + 96]
                  idx = 0
                  while idx < _884:
                      if idx >= mem[_199 + ceil32(return_data.size)]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      if idx >= mem[(2 * ceil32(return_data.size)) + 96]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      stor10[mem[(32 * idx) + (2 * ceil32(return_data.size)) + 140 len 20]] = mem[(32 * idx) + _199 + ceil32(return_data.size) + 32]
                      if idx >= mem[(2 * ceil32(return_data.size)) + 96]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      _1030 = mem[(32 * idx) + (2 * ceil32(return_data.size)) + 128]
                      if not mem[(32 * idx) + (2 * ceil32(return_data.size)) + 140 len 20]:
                          if idx >= mem[(2 * ceil32(return_data.size)) + 96]:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          mem[0] = mem[(32 * idx) + (2 * ceil32(return_data.size)) + 140 len 20]
                          mem[32] = 11
                          stor11[mem[(32 * idx) + (2 * ceil32(return_data.size)) + 140 len 20]] = eth.balance(this.address)
                      else:
                          mem[mem[64] + 4] = this.address
                          static call address(_1030).balanceOf(address account) with:
                                  gas gas_remaining wei
                                 args this.address
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          if not ext_call.success:
                              if idx >= mem[(2 * ceil32(return_data.size)) + 96]:
                                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                              mem[0] = mem[(32 * idx) + (2 * ceil32(return_data.size)) + 140 len 20]
                              mem[32] = 11
                              stor11[mem[(32 * idx) + (2 * ceil32(return_data.size)) + 140 len 20]] = 0
                          else:
                              if 32 <= return_data.size:
                                  if mem[64] + 32 > LOCK8605463013() or mem[64] + 32 < mem[64]:
                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                              if mem[64] + ceil32(return_data.size) > LOCK8605463013() or mem[64] + ceil32(return_data.size) < mem[64]:
                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              if idx >= mem[(2 * ceil32(return_data.size)) + 96]:
                                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                              mem[0] = mem[(32 * idx) + (2 * ceil32(return_data.size)) + 140 len 20]
                              mem[32] = 11
                              stor11[mem[(32 * idx) + (2 * ceil32(return_data.size)) + 140 len 20]] = ext_call.return_data[0]
                      _884 = mem[(2 * ceil32(return_data.size)) + 96]
                      idx = idx + 1
                      continue 
          else:
              require ext_call.return_data[0] <= LOCK8605463013()
              unknown60e0a9e1 = uint128(block.number)
              stor8 = uint128(ext_call.return_data[0])
              log 0x71475f2f: uint128(ext_call.return_data[0])
              require uint128(ext_call.return_data[0]) <= LOCK8605463013()
              uint128(stor9) = uint128(ext_call.return_data[0])
              mem[ceil32(return_data.size) + 96] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
              static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                      gas gas_remaining wei
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              if not ext_call.success:
                  call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                       gas gas_remaining wei
                  revert with ext_call.return_data[0 len return_data.size]
              mem[ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
              if (2 * ceil32(return_data.size)) + 96 > LOCK8605463013() or 2 * ceil32(return_data.size) < ceil32(return_data.size):
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              require return_data.size >=′ 32
              _26 = mem[ceil32(return_data.size) + 96]
              require mem[ceil32(return_data.size) + 96] <= LOCK8605463013()
              require ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 127 <′ ceil32(return_data.size) + return_data.size + 96
              _30 = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96]
              if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96] > LOCK8605463013():
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              if (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96]) + 1 < 0:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              mem[64] = (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96]) + 97
              mem[(2 * ceil32(return_data.size)) + 96] = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 96] + 96]
              require _26 + (32 * _30) + 32 <= return_data.size
              s = (2 * ceil32(return_data.size)) + 128
              idx = ceil32(return_data.size) + _26 + 128
              while idx < ceil32(return_data.size) + _26 + (32 * _30) + 128:
                  require not Mask(96, 160, mem[idx])
                  mem[s] = mem[idx]
                  s = s + 32
                  idx = idx + 32
                  continue 
              _200 = mem[64]
              mem[mem[64]] = 0xf8b2f99100000000000000000000000000000000000000000000000000000000
              call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                   gas gas_remaining wei
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              if not ext_call.success:
                  idx = 0
                  while idx < _30:
                      if idx >= mem[0]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      if idx >= mem[(2 * ceil32(return_data.size)) + 96]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      stor10[mem[(32 * idx) + (2 * ceil32(return_data.size)) + 140 len 20]] = mem[(32 * idx) + 32]
                      if idx >= mem[(2 * ceil32(return_data.size)) + 96]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      _1033 = mem[(32 * idx) + (2 * ceil32(return_data.size)) + 128]
                      if not mem[(32 * idx) + (2 * ceil32(return_data.size)) + 140 len 20]:
                          if idx >= mem[(2 * ceil32(return_data.size)) + 96]:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          mem[0] = mem[(32 * idx) + (2 * ceil32(return_data.size)) + 140 len 20]
                          mem[32] = 11
                          stor11[mem[(32 * idx) + (2 * ceil32(return_data.size)) + 140 len 20]] = eth.balance(this.address)
                      else:
                          mem[mem[64] + 4] = this.address
                          static call address(_1033).balanceOf(address account) with:
                                  gas gas_remaining wei
                                 args this.address
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          if not ext_call.success:
                              if idx >= mem[(2 * ceil32(return_data.size)) + 96]:
                                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                              mem[0] = mem[(32 * idx) + (2 * ceil32(return_data.size)) + 140 len 20]
                              mem[32] = 11
                              stor11[mem[(32 * idx) + (2 * ceil32(return_data.size)) + 140 len 20]] = 0
                          else:
                              if 32 <= return_data.size:
                                  if mem[64] + 32 > LOCK8605463013() or mem[64] + 32 < mem[64]:
                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                              if mem[64] + ceil32(return_data.size) > LOCK8605463013() or mem[64] + ceil32(return_data.size) < mem[64]:
                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              if idx >= mem[(2 * ceil32(return_data.size)) + 96]:
                                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                              mem[0] = mem[(32 * idx) + (2 * ceil32(return_data.size)) + 140 len 20]
                              mem[32] = 11
                              stor11[mem[(32 * idx) + (2 * ceil32(return_data.size)) + 140 len 20]] = ext_call.return_data[0]
                      idx = idx + 1
                      continue 
              else:
                  mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                  if mem[64] + ceil32(return_data.size) > LOCK8605463013() or mem[64] + ceil32(return_data.size) < mem[64]:
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  mem[64] = mem[64] + ceil32(return_data.size)
                  require return_data.size >=′ 32
                  _215 = mem[_200]
                  require mem[_200] <= LOCK8605463013()
                  require _200 + mem[_200] + 31 <′ _200 + return_data.size
                  _222 = mem[_200 + mem[_200]]
                  if mem[_200 + mem[_200]] > LOCK8605463013():
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  if _200 + ceil32(return_data.size) + ceil32(32 * mem[_200 + mem[_200]]) + 1 > LOCK8605463013() or ceil32(32 * mem[_200 + mem[_200]]) + 1 < 0:
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  mem[64] = _200 + ceil32(return_data.size) + ceil32(32 * mem[_200 + mem[_200]]) + 1
                  mem[_200 + ceil32(return_data.size)] = _222
                  require _215 + (32 * _222) + 32 <= return_data.size
                  mem[_200 + ceil32(return_data.size) + 32 len ceil32(32 * _222)] = mem[_200 + _215 + 32 len ceil32(32 * _222)]
                  _886 = mem[(2 * ceil32(return_data.size)) + 96]
                  idx = 0
                  while idx < _886:
                      if idx >= mem[_200 + ceil32(return_data.size)]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      if idx >= mem[(2 * ceil32(return_data.size)) + 96]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      stor10[mem[(32 * idx) + (2 * ceil32(return_data.size)) + 140 len 20]] = mem[(32 * idx) + _200 + ceil32(return_data.size) + 32]
                      if idx >= mem[(2 * ceil32(return_data.size)) + 96]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                      _1032 = mem[(32 * idx) + (2 * ceil32(return_data.size)) + 128]
                      if not mem[(32 * idx) + (2 * ceil32(return_data.size)) + 140 len 20]:
                          if idx >= mem[(2 * ceil32(return_data.size)) + 96]:
                              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                          mem[0] = mem[(32 * idx) + (2 * ceil32(return_data.size)) + 140 len 20]
                          mem[32] = 11
                          stor11[mem[(32 * idx) + (2 * ceil32(return_data.size)) + 140 len 20]] = eth.balance(this.address)
                      else:
                          mem[mem[64] + 4] = this.address
                          static call address(_1032).balanceOf(address account) with:
                                  gas gas_remaining wei
                                 args this.address
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          if not ext_call.success:
                              if idx >= mem[(2 * ceil32(return_data.size)) + 96]:
                                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                              mem[0] = mem[(32 * idx) + (2 * ceil32(return_data.size)) + 140 len 20]
                              mem[32] = 11
                              stor11[mem[(32 * idx) + (2 * ceil32(return_data.size)) + 140 len 20]] = 0
                          else:
                              if 32 <= return_data.size:
                                  if mem[64] + 32 > LOCK8605463013() or mem[64] + 32 < mem[64]:
                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                              if mem[64] + ceil32(return_data.size) > LOCK8605463013() or mem[64] + ceil32(return_data.size) < mem[64]:
                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              if idx >= mem[(2 * ceil32(return_data.size)) + 96]:
                                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                              mem[0] = mem[(32 * idx) + (2 * ceil32(return_data.size)) + 140 len 20]
                              mem[32] = 11
                              stor11[mem[(32 * idx) + (2 * ceil32(return_data.size)) + 140 len 20]] = ext_call.return_data[0]
                      _886 = mem[(2 * ceil32(return_data.size)) + 96]
                      idx = idx + 1
                      continue 
      uint8(stor2.field_248) = 1
      return 0
  mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
  if ceil32(return_data.size) + 96 > LOCK8605463013() or ceil32(return_data.size) + 96 < 96:
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  mem[64] = ceil32(return_data.size) + 96
  require return_data.size >=′ 32
  _4 = mem[96 len 4], Mask(224, 32, this.address) >> 32
  require mem[96 len 4], Mask(224, 32, this.address) >> 32 <= LOCK8605463013()
  require mem[96 len 4], Mask(224, 32, this.address) >> 32 + 127 <′ return_data.size + 96
  _7 = mem[mem[96 len 4], Mask(224, 32, this.address) >> 32 + 96]
  if mem[mem[96 len 4], Mask(224, 32, this.address) >> 32 + 96] > LOCK8605463013():
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  if ceil32(return_data.size) + ceil32(32 * mem[mem[96 len 4], Mask(224, 32, this.address) >> 32 + 96]) + 97 > LOCK8605463013() or ceil32(32 * mem[mem[96 len 4], Mask(224, 32, this.address) >> 32 + 96]) + 1 < 0:
      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  mem[64] = ceil32(return_data.size) + ceil32(32 * mem[mem[96 len 4], Mask(224, 32, this.address) >> 32 + 96]) + 97
  mem[ceil32(return_data.size) + 96] = _7
  require _4 + (32 * _7) + 32 <= return_data.size
  mem[ceil32(return_data.size) + 128 len ceil32(32 * _7)] = mem[_4 + 128 len ceil32(32 * _7)]
  if block.number == unknown60e0a9e1:
      require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
      uint128(stor9) = 0
      _211 = mem[64]
      mem[mem[64]] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
      static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
              gas gas_remaining wei
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      if not ext_call.success:
          call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
               gas gas_remaining wei
          revert with ext_call.return_data[0 len return_data.size]
      mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
      if mem[64] + ceil32(return_data.size) > LOCK8605463013() or mem[64] + ceil32(return_data.size) < mem[64]:
          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
      mem[64] = mem[64] + ceil32(return_data.size)
      require return_data.size >=′ 32
      _231 = mem[_211]
      require mem[_211] <= LOCK8605463013()
      require _211 + mem[_211] + 31 <′ _211 + return_data.size
      _236 = mem[_211 + mem[_211]]
      if mem[_211 + mem[_211]] > LOCK8605463013():
          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
      if _211 + ceil32(return_data.size) + ceil32(32 * mem[_211 + mem[_211]]) + 1 > LOCK8605463013() or ceil32(32 * mem[_211 + mem[_211]]) + 1 < 0:
          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
      mem[64] = _211 + ceil32(return_data.size) + ceil32(32 * mem[_211 + mem[_211]]) + 1
      mem[_211 + ceil32(return_data.size)] = _236
      require _231 + (32 * _236) + 32 <= return_data.size
      s = _211 + ceil32(return_data.size) + 32
      idx = _211 + _231 + 32
      while idx < _211 + _231 + (32 * _236) + 32:
          require not Mask(96, 160, mem[idx])
          mem[s] = mem[idx]
          s = s + 32
          idx = idx + 32
          continue 
      _501 = mem[64]
      mem[mem[64]] = 0xf8b2f99100000000000000000000000000000000000000000000000000000000
      call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
           gas gas_remaining wei
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      if not ext_call.success:
          if var79001 >= _236:
              uint8(stor2.field_248) = 1
              return 0
          if var79001 >= mem[0]:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
      else:
          mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
          if mem[64] + ceil32(return_data.size) > LOCK8605463013() or mem[64] + ceil32(return_data.size) < mem[64]:
              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
          mem[64] = mem[64] + ceil32(return_data.size)
          require return_data.size >=′ 32
          require mem[_501] <= LOCK8605463013()
          require _501 + mem[_501] + 31 <′ _501 + return_data.size
          if mem[_501 + mem[_501]] > LOCK8605463013():
              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
          if _501 + ceil32(return_data.size) + ceil32(32 * mem[_501 + mem[_501]]) + 1 > LOCK8605463013() or ceil32(32 * mem[_501 + mem[_501]]) + 1 < 0:
              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
          require mem[_501] + (32 * mem[_501 + mem[_501]]) + 32 <= return_data.size
          if var97001 >= _236:
              uint8(stor2.field_248) = 1
              return 0
          if var97001 >= mem[_501 + mem[_501]]:
              revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
  else:
      _209 = mem[64]
      static call 0xac614884b52dbab8728476b5d50f0d672baed31f.exchangeRate() with:
              gas gas_remaining wei
      mem[mem[64]] = ext_call.return_data[0]
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      if not ext_call.success:
          if 0 > uint128(unknownd2a3584e) >> 128:
              unknown60e0a9e1 = uint128(block.number)
              stor8 = 0
              log 0x71475f2f 
              log 0x0 
              uint128(stor9) = 0
              _523 = mem[64]
              mem[mem[64]] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
              static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                      gas gas_remaining wei
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              if not ext_call.success:
                  call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                       gas gas_remaining wei
                  revert with ext_call.return_data[0 len return_data.size]
              mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
              if mem[64] + ceil32(return_data.size) > LOCK8605463013() or mem[64] + ceil32(return_data.size) < mem[64]:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              mem[64] = mem[64] + ceil32(return_data.size)
              require return_data.size >=′ 32
              _574 = mem[_523]
              require mem[_523] <= LOCK8605463013()
              require _523 + mem[_523] + 31 <′ _523 + return_data.size
              _586 = mem[_523 + mem[_523]]
              if mem[_523 + mem[_523]] > LOCK8605463013():
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              if _523 + ceil32(return_data.size) + ceil32(32 * mem[_523 + mem[_523]]) + 1 > LOCK8605463013() or ceil32(32 * mem[_523 + mem[_523]]) + 1 < 0:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              mem[64] = _523 + ceil32(return_data.size) + ceil32(32 * mem[_523 + mem[_523]]) + 1
              mem[_523 + ceil32(return_data.size)] = _586
              require _574 + (32 * _586) + 32 <= return_data.size
              s = _523 + ceil32(return_data.size) + 32
              idx = _523 + _574 + 32
              while idx < _523 + _574 + (32 * _586) + 32:
                  require not Mask(96, 160, mem[idx])
                  mem[s] = mem[idx]
                  s = s + 32
                  idx = idx + 32
                  continue 
              _922 = mem[64]
              mem[mem[64]] = 0xf8b2f99100000000000000000000000000000000000000000000000000000000
              call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                   gas gas_remaining wei
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              if not ext_call.success:
                  if 0 >= _586:
                      uint8(stor2.field_248) = 1
                      return 0
                  if 0 >= mem[0]:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              else:
                  mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                  if mem[64] + ceil32(return_data.size) > LOCK8605463013() or mem[64] + ceil32(return_data.size) < mem[64]:
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  mem[64] = mem[64] + ceil32(return_data.size)
                  require return_data.size >=′ 32
                  require mem[_922] <= LOCK8605463013()
                  require _922 + mem[_922] + 31 <′ _922 + return_data.size
                  if mem[_922 + mem[_922]] > LOCK8605463013():
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  if _922 + ceil32(return_data.size) + ceil32(32 * mem[_922 + mem[_922]]) + 1 > LOCK8605463013() or ceil32(32 * mem[_922 + mem[_922]]) + 1 < 0:
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  require mem[_922] + (32 * mem[_922 + mem[_922]]) + 32 <= return_data.size
          else:
              require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
              unknown60e0a9e1 = uint128(block.number)
              stor8 = 0
              log 0x71475f2f 
              log 0x0 
              uint128(stor9) = 0
              _522 = mem[64]
              mem[mem[64]] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
              static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                      gas gas_remaining wei
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              if not ext_call.success:
                  call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                       gas gas_remaining wei
                  revert with ext_call.return_data[0 len return_data.size]
              mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
              if mem[64] + ceil32(return_data.size) > LOCK8605463013() or mem[64] + ceil32(return_data.size) < mem[64]:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              mem[64] = mem[64] + ceil32(return_data.size)
              require return_data.size >=′ 32
              _573 = mem[_522]
              require mem[_522] <= LOCK8605463013()
              require _522 + mem[_522] + 31 <′ _522 + return_data.size
              _585 = mem[_522 + mem[_522]]
              if mem[_522 + mem[_522]] > LOCK8605463013():
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              if _522 + ceil32(return_data.size) + ceil32(32 * mem[_522 + mem[_522]]) + 1 > LOCK8605463013() or ceil32(32 * mem[_522 + mem[_522]]) + 1 < 0:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              mem[64] = _522 + ceil32(return_data.size) + ceil32(32 * mem[_522 + mem[_522]]) + 1
              mem[_522 + ceil32(return_data.size)] = _585
              require _573 + (32 * _585) + 32 <= return_data.size
              s = _522 + ceil32(return_data.size) + 32
              idx = _522 + _573 + 32
              while idx < _522 + _573 + (32 * _585) + 32:
                  require not Mask(96, 160, mem[idx])
                  mem[s] = mem[idx]
                  s = s + 32
                  idx = idx + 32
                  continue 
              _921 = mem[64]
              mem[mem[64]] = 0xf8b2f99100000000000000000000000000000000000000000000000000000000
              call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                   gas gas_remaining wei
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              if not ext_call.success:
                  if 0 >= _585:
                      uint8(stor2.field_248) = 1
                      return 0
                  if 0 >= mem[0]:
                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              else:
                  mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                  if mem[64] + ceil32(return_data.size) > LOCK8605463013() or mem[64] + ceil32(return_data.size) < mem[64]:
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  mem[64] = mem[64] + ceil32(return_data.size)
                  require return_data.size >=′ 32
                  require mem[_921] <= LOCK8605463013()
                  require _921 + mem[_921] + 31 <′ _921 + return_data.size
                  if mem[_921 + mem[_921]] > LOCK8605463013():
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  if _921 + ceil32(return_data.size) + ceil32(32 * mem[_921 + mem[_921]]) + 1 > LOCK8605463013() or ceil32(32 * mem[_921 + mem[_921]]) + 1 < 0:
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  require mem[_921] + (32 * mem[_921 + mem[_921]]) + 32 <= return_data.size
      else:
          if 32 <= return_data.size:
              if mem[64] + 32 > LOCK8605463013() or mem[64] + 32 < mem[64]:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              if ext_call.return_data[0] <= uint128(unknownd2a3584e) >> 128:
                  require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                  unknown60e0a9e1 = uint128(block.number)
                  stor8 = 0
                  log 0x71475f2f 
                  log 0x0 
                  uint128(stor9) = 0
                  mem[mem[64] + 32] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                  static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                          gas gas_remaining wei
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if not ext_call.success:
                      call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                           gas gas_remaining wei
                      revert with ext_call.return_data[0 len return_data.size]
                  mem[mem[64] + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                  if mem[64] + ceil32(return_data.size) + 32 > LOCK8605463013() or ceil32(return_data.size) < 0:
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  mem[64] = mem[64] + ceil32(return_data.size) + 32
                  require return_data.size >=′ 32
                  _606 = mem[_209 + 32]
                  require mem[_209 + 32] <= LOCK8605463013()
                  require _209 + mem[_209 + 32] + 63 <′ _209 + return_data.size + 32
                  _622 = mem[_209 + mem[_209 + 32] + 32]
                  if mem[_209 + mem[_209 + 32] + 32] > LOCK8605463013():
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  if _209 + ceil32(return_data.size) + ceil32(32 * mem[_209 + mem[_209 + 32] + 32]) + 33 > LOCK8605463013() or ceil32(32 * mem[_209 + mem[_209 + 32] + 32]) + 1 < 0:
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  mem[64] = _209 + ceil32(return_data.size) + ceil32(32 * mem[_209 + mem[_209 + 32] + 32]) + 33
                  mem[_209 + ceil32(return_data.size) + 32] = _622
                  require _606 + (32 * _622) + 32 <= return_data.size
                  s = _209 + ceil32(return_data.size) + 64
                  idx = _209 + _606 + 64
                  while idx < _209 + _606 + (32 * _622) + 64:
                      require not Mask(96, 160, mem[idx])
                      mem[s] = mem[idx]
                      s = s + 32
                      idx = idx + 32
                      continue 
                  _919 = mem[64]
                  mem[mem[64]] = 0xf8b2f99100000000000000000000000000000000000000000000000000000000
                  call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                       gas gas_remaining wei
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if not ext_call.success:
                      if 0 >= _622:
                          uint8(stor2.field_248) = 1
                          return 0
                      if 0 >= mem[0]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  else:
                      mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                      if mem[64] + ceil32(return_data.size) > LOCK8605463013() or mem[64] + ceil32(return_data.size) < mem[64]:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      mem[64] = mem[64] + ceil32(return_data.size)
                      require return_data.size >=′ 32
                      require mem[_919] <= LOCK8605463013()
                      require _919 + mem[_919] + 31 <′ _919 + return_data.size
                      if mem[_919 + mem[_919]] > LOCK8605463013():
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      if _919 + ceil32(return_data.size) + ceil32(32 * mem[_919 + mem[_919]]) + 1 > LOCK8605463013() or ceil32(32 * mem[_919 + mem[_919]]) + 1 < 0:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      require mem[_919] + (32 * mem[_919 + mem[_919]]) + 32 <= return_data.size
              else:
                  require ext_call.return_data[0] <= LOCK8605463013()
                  unknown60e0a9e1 = uint128(block.number)
                  stor8 = uint128(ext_call.return_data[0])
                  log 0x71475f2f: uint128(ext_call.return_data[0])
                  require uint128(ext_call.return_data[0]) <= LOCK8605463013()
                  uint128(stor9) = uint128(ext_call.return_data[0])
                  mem[mem[64] + 32] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                  static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                          gas gas_remaining wei
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if not ext_call.success:
                      call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                           gas gas_remaining wei
                      revert with ext_call.return_data[0 len return_data.size]
                  mem[mem[64] + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                  if mem[64] + ceil32(return_data.size) + 32 > LOCK8605463013() or ceil32(return_data.size) < 0:
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  mem[64] = mem[64] + ceil32(return_data.size) + 32
                  require return_data.size >=′ 32
                  _607 = mem[_209 + 32]
                  require mem[_209 + 32] <= LOCK8605463013()
                  require _209 + mem[_209 + 32] + 63 <′ _209 + return_data.size + 32
                  _623 = mem[_209 + mem[_209 + 32] + 32]
                  if mem[_209 + mem[_209 + 32] + 32] > LOCK8605463013():
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  if _209 + ceil32(return_data.size) + ceil32(32 * mem[_209 + mem[_209 + 32] + 32]) + 33 > LOCK8605463013() or ceil32(32 * mem[_209 + mem[_209 + 32] + 32]) + 1 < 0:
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  mem[64] = _209 + ceil32(return_data.size) + ceil32(32 * mem[_209 + mem[_209 + 32] + 32]) + 33
                  mem[_209 + ceil32(return_data.size) + 32] = _623
                  require _607 + (32 * _623) + 32 <= return_data.size
                  s = _209 + ceil32(return_data.size) + 64
                  idx = _209 + _607 + 64
                  while idx < _209 + _607 + (32 * _623) + 64:
                      require not Mask(96, 160, mem[idx])
                      mem[s] = mem[idx]
                      s = s + 32
                      idx = idx + 32
                      continue 
                  _920 = mem[64]
                  mem[mem[64]] = 0xf8b2f99100000000000000000000000000000000000000000000000000000000
                  call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                       gas gas_remaining wei
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if not ext_call.success:
                      if 0 >= _623:
                          uint8(stor2.field_248) = 1
                          return 0
                      if 0 >= mem[0]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  else:
                      mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                      if mem[64] + ceil32(return_data.size) > LOCK8605463013() or mem[64] + ceil32(return_data.size) < mem[64]:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      mem[64] = mem[64] + ceil32(return_data.size)
                      require return_data.size >=′ 32
                      require mem[_920] <= LOCK8605463013()
                      require _920 + mem[_920] + 31 <′ _920 + return_data.size
                      if mem[_920 + mem[_920]] > LOCK8605463013():
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      if _920 + ceil32(return_data.size) + ceil32(32 * mem[_920 + mem[_920]]) + 1 > LOCK8605463013() or ceil32(32 * mem[_920 + mem[_920]]) + 1 < 0:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      require mem[_920] + (32 * mem[_920 + mem[_920]]) + 32 <= return_data.size
          else:
              if mem[64] + ceil32(return_data.size) > LOCK8605463013() or mem[64] + ceil32(return_data.size) < mem[64]:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              require return_data.size >=′ 32
              if ext_call.return_data[0] <= uint128(unknownd2a3584e) >> 128:
                  require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                  unknown60e0a9e1 = uint128(block.number)
                  stor8 = 0
                  log 0x71475f2f 
                  log 0x0 
                  uint128(stor9) = 0
                  mem[mem[64] + ceil32(return_data.size)] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                  static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                          gas gas_remaining wei
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if not ext_call.success:
                      call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                           gas gas_remaining wei
                      revert with ext_call.return_data[0 len return_data.size]
                  mem[mem[64] + ceil32(return_data.size) len return_data.size] = ext_call.return_data[0 len return_data.size]
                  if mem[64] + (2 * ceil32(return_data.size)) > LOCK8605463013() or 2 * ceil32(return_data.size) < ceil32(return_data.size):
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  mem[64] = mem[64] + (2 * ceil32(return_data.size))
                  require return_data.size >=′ 32
                  _262 = mem[_209 + ceil32(return_data.size)]
                  require mem[_209 + ceil32(return_data.size)] <= LOCK8605463013()
                  require _209 + ceil32(return_data.size) + mem[_209 + ceil32(return_data.size)] + 31 <′ _209 + ceil32(return_data.size) + return_data.size
                  _274 = mem[_209 + ceil32(return_data.size) + mem[_209 + ceil32(return_data.size)]]
                  if mem[_209 + ceil32(return_data.size) + mem[_209 + ceil32(return_data.size)]] > LOCK8605463013():
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  if _209 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_209 + ceil32(return_data.size) + mem[_209 + ceil32(return_data.size)]]) + 1 > LOCK8605463013() or ceil32(32 * mem[_209 + ceil32(return_data.size) + mem[_209 + ceil32(return_data.size)]]) + 1 < 0:
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  mem[64] = _209 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_209 + ceil32(return_data.size) + mem[_209 + ceil32(return_data.size)]]) + 1
                  mem[_209 + (2 * ceil32(return_data.size))] = _274
                  require _262 + (32 * _274) + 32 <= return_data.size
                  s = _209 + (2 * ceil32(return_data.size)) + 32
                  idx = _209 + ceil32(return_data.size) + _262 + 32
                  while idx < _209 + ceil32(return_data.size) + _262 + (32 * _274) + 32:
                      require not Mask(96, 160, mem[idx])
                      mem[s] = mem[idx]
                      s = s + 32
                      idx = idx + 32
                      continue 
                  _502 = mem[64]
                  mem[mem[64]] = 0xf8b2f99100000000000000000000000000000000000000000000000000000000
                  call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                       gas gas_remaining wei
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if not ext_call.success:
                      if var91001 >= _274:
                          uint8(stor2.field_248) = 1
                          return 0
                      if var91001 >= mem[0]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  else:
                      mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                      if mem[64] + ceil32(return_data.size) > LOCK8605463013() or mem[64] + ceil32(return_data.size) < mem[64]:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      mem[64] = mem[64] + ceil32(return_data.size)
                      require return_data.size >=′ 32
                      require mem[_502] <= LOCK8605463013()
                      require _502 + mem[_502] + 31 <′ _502 + return_data.size
                      if mem[_502 + mem[_502]] > LOCK8605463013():
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      if _502 + ceil32(return_data.size) + ceil32(32 * mem[_502 + mem[_502]]) + 1 > LOCK8605463013() or ceil32(32 * mem[_502 + mem[_502]]) + 1 < 0:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      require mem[_502] + (32 * mem[_502 + mem[_502]]) + 32 <= return_data.size
                      if var109001 >= _274:
                          uint8(stor2.field_248) = 1
                          return 0
                      if var109001 >= mem[_502 + mem[_502]]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
              else:
                  require ext_call.return_data[0] <= LOCK8605463013()
                  unknown60e0a9e1 = uint128(block.number)
                  stor8 = uint128(ext_call.return_data[0])
                  log 0x71475f2f: uint128(ext_call.return_data[0])
                  require uint128(ext_call.return_data[0]) <= LOCK8605463013()
                  uint128(stor9) = uint128(ext_call.return_data[0])
                  mem[mem[64] + ceil32(return_data.size)] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                  static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                          gas gas_remaining wei
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if not ext_call.success:
                      call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                           gas gas_remaining wei
                      revert with ext_call.return_data[0 len return_data.size]
                  mem[mem[64] + ceil32(return_data.size) len return_data.size] = ext_call.return_data[0 len return_data.size]
                  if mem[64] + (2 * ceil32(return_data.size)) > LOCK8605463013() or 2 * ceil32(return_data.size) < ceil32(return_data.size):
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  mem[64] = mem[64] + (2 * ceil32(return_data.size))
                  require return_data.size >=′ 32
                  _263 = mem[_209 + ceil32(return_data.size)]
                  require mem[_209 + ceil32(return_data.size)] <= LOCK8605463013()
                  require _209 + ceil32(return_data.size) + mem[_209 + ceil32(return_data.size)] + 31 <′ _209 + ceil32(return_data.size) + return_data.size
                  _275 = mem[_209 + ceil32(return_data.size) + mem[_209 + ceil32(return_data.size)]]
                  if mem[_209 + ceil32(return_data.size) + mem[_209 + ceil32(return_data.size)]] > LOCK8605463013():
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  if _209 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_209 + ceil32(return_data.size) + mem[_209 + ceil32(return_data.size)]]) + 1 > LOCK8605463013() or ceil32(32 * mem[_209 + ceil32(return_data.size) + mem[_209 + ceil32(return_data.size)]]) + 1 < 0:
                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                  mem[64] = _209 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_209 + ceil32(return_data.size) + mem[_209 + ceil32(return_data.size)]]) + 1
                  mem[_209 + (2 * ceil32(return_data.size))] = _275
                  require _263 + (32 * _275) + 32 <= return_data.size
                  s = _209 + (2 * ceil32(return_data.size)) + 32
                  idx = _209 + ceil32(return_data.size) + _263 + 32
                  while idx < _209 + ceil32(return_data.size) + _263 + (32 * _275) + 32:
                      require not Mask(96, 160, mem[idx])
                      mem[s] = mem[idx]
                      s = s + 32
                      idx = idx + 32
                      continue 
                  _503 = mem[64]
                  mem[mem[64]] = 0xf8b2f99100000000000000000000000000000000000000000000000000000000
                  call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                       gas gas_remaining wei
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if not ext_call.success:
                      if var91001 >= _275:
                          uint8(stor2.field_248) = 1
                          return 0
                      if var91001 >= mem[0]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                  else:
                      mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                      if mem[64] + ceil32(return_data.size) > LOCK8605463013() or mem[64] + ceil32(return_data.size) < mem[64]:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      mem[64] = mem[64] + ceil32(return_data.size)
                      require return_data.size >=′ 32
                      require mem[_503] <= LOCK8605463013()
                      require _503 + mem[_503] + 31 <′ _503 + return_data.size
                      if mem[_503 + mem[_503]] > LOCK8605463013():
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      if _503 + ceil32(return_data.size) + ceil32(32 * mem[_503 + mem[_503]]) + 1 > LOCK8605463013() or ceil32(32 * mem[_503 + mem[_503]]) + 1 < 0:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      require mem[_503] + (32 * mem[_503 + mem[_503]]) + 32 <= return_data.size
                      if var109001 >= _275:
                          uint8(stor2.field_248) = 1
                          return 0
                      if var109001 >= mem[_503 + mem[_503]]:
                          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def _fallback(?) payable: # default function
  require calldata.size >= 4
  if name() == uint32(call.func_hash) >> 224:
      require not call.value
      require calldata.size - 4 >=′ 0
      if not bool(stor3.field_0):
          if bool(stor3.field_0) == stor3.field_1 % 128 < 32:
              revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.
          if not bool(stor3.field_0):
              if ceil32(32 * bool(stor3.field_1 % 128)) + 129 > LOCK8605463013() or ceil32(32 * bool(stor3.field_1 % 128)) + 129 < 128:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
          else:
              if bool(stor3.field_0) != 1:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  else:
      if approve(address spender, uint256 amount) == uint32(call.func_hash) >> 224:
          require not call.value
          require calldata.size - 4 >=′ 64
          require not Mask(96, 160, _param1)
          if not caller:
              revert with Error(string reason), 'ERC20: approve from the zero address'
          if not address(_param1):
              revert with Error(string reason), 'ERC20: approve to the zero address'
          allowance[caller][address(_param1)] = _param2
          log Approval(
                address owner=_param2,
                address spender=caller,
                uint256 value=address(_param1))
          return 1
      if unknown0a2b83a7() == uint32(call.func_hash) >> 224:
          require not call.value
          require calldata.size - 4 >=′ 0
          return uint128(stor9), uint128(stor9)
      if unknown0b49fcef() == uint32(call.func_hash) >> 224:
          require not call.value
          require calldata.size - 4 >=′ 0
          if not uint128(stor9):
              revert with 3528496691
          mem[128] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
          static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                  gas gas_remaining wei
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          if not ext_call.success:
              if mem[0] > LOCK8605463013():
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              if ceil32(32 * mem[0]) + 129 > LOCK8605463013() or ceil32(32 * mem[0]) + 129 < 128:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              if mem[0] > LOCK8605463013():
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              if mem[0] > LOCK8605463013():
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              if (2 * ceil32(32 * mem[0])) + 130 > LOCK8605463013() or (2 * ceil32(32 * mem[0])) + 130 < ceil32(32 * mem[0]) + 129:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              if mem[0] > LOCK8605463013():
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
          else:
              mem[128 len return_data.size] = ext_call.return_data[0 len return_data.size]
              if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              require return_data.size >=′ 32
              require mem[128] <= LOCK8605463013()
              require mem[128] + 159 <′ return_data.size + 128
              if mem[mem[128] + 128] > LOCK8605463013():
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              if ceil32(return_data.size) + ceil32(32 * mem[mem[128] + 128]) + 129 > LOCK8605463013() or ceil32(32 * mem[mem[128] + 128]) + 1 < 0:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              require mem[128] + (32 * mem[mem[128] + 128]) + 32 <= return_data.size
      else:
          if totalSupply() == uint32(call.func_hash) >> 224:
              require not call.value
              require calldata.size - 4 >=′ 0
              return totalSupply
          if unknown1d52edc4() == uint32(call.func_hash) >> 224:
              require not call.value
              require calldata.size - 4 >=′ 0
              if uint8(uint256(stor2.field_0)) >> 248 == 2:
                  revert with Error(string reason), 'ReentrancyGuard: reentrant call'
              uint8(stor2.field_248) = 2
              if block.number == unknown60e0a9e1:
                  uint8(stor2.field_248) = 1
                  return (uint128(unknownd2a3584e) >> 128)
              static call 0xac614884b52dbab8728476b5d50f0d672baed31f.exchangeRate() with:
                      gas gas_remaining wei
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              if not ext_call.success:
                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              if 32 <= return_data.size:
                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
              require return_data.size >=′ 32
              if ext_call.return_data[0] <= uint128(unknownd2a3584e) >> 128:
                  require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                  unknown60e0a9e1 = uint128(block.number)
                  stor8 = 0
                  log 0x71475f2f 
                  log 0x0 
                  uint8(stor2.field_248) = 1
                  return 0
              require ext_call.return_data[0] <= LOCK8605463013()
              unknown60e0a9e1 = uint128(block.number)
              stor8 = uint128(ext_call.return_data[0])
              log 0x71475f2f: uint128(ext_call.return_data[0])
              uint8(stor2.field_248) = 1
              return uint128(ext_call.return_data[0])
          if transferFrom(address sender, address recipient, uint256 amount) == uint32(call.func_hash) >> 224:
              require not call.value
              require calldata.size - 4 >=′ 96
              require not Mask(96, 160, _param1)
              require not Mask(96, 160, _param2)
              if uint8(uint256(stor2.field_0)) >> 248 == 2:
                  revert with Error(string reason), 'ReentrancyGuard: reentrant call'
              uint8(stor2.field_248) = 2
              if allowance[address(_param1)][caller] - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
                  if allowance[address(_param1)][caller] < _param3:
                      revert with Error(string reason), 'ERC20: insufficient allowance'
                  if not address(_param1):
                      revert with Error(string reason), 'ERC20: approve from the zero address'
                  if not caller:
                      revert with Error(string reason), 'ERC20: approve to the zero address'
                  mem[0] = caller
                  mem[32] = sha3(address(_param1), 1)
                  allowance[address(_param1)][caller] = allowance[address(_param1)][caller] - _param3
                  log Approval(
                        address owner=(allowance[address(_param1)][caller] - _param3),
                        address spender=address(_param1),
                        uint256 value=caller)
                  if not address(_param1):
                      revert with Error(string reason), 'ERC20: transfer from the zero address'
                  if not address(_param2):
                      revert with Error(string reason), 'ERC20: transfer to the zero address'
                  if address(_param1) == address(_param2):
                      revert with Error(string reason), 'ERC20: transfer to self'
                  if 484512 * 24 * 3600 <= block.timestamp:
                      if uint128(stor9):
                          mem[128] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                          static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                                  gas gas_remaining wei
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          if ext_call.success:
                              mem[128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                              if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                              require return_data.size >=′ 32
                              require mem[128] <= LOCK8605463013()
                              require mem[128] + 159 <′ return_data.size + 128
                              if mem[mem[128] + 128] > LOCK8605463013():
                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                              if ceil32(return_data.size) + ceil32(32 * mem[mem[128] + 128]) + 129 > LOCK8605463013() or ceil32(32 * mem[mem[128] + 128]) + 1 < 0:
                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                              require mem[128] + (32 * mem[mem[128] + 128]) + 32 <= return_data.size
                          else:
                              if 484512 * 24 * 3600 <= block.timestamp:
                                  if caller > LOCK8605463013():
                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                  if ceil32(32 * address(caller)) + 129 > LOCK8605463013() or ceil32(32 * address(caller)) + 129 < 128:
                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                  if caller > LOCK8605463013():
                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                              else:
                                  mem[128] = 0xf8b2f99100000000000000000000000000000000000000000000000000000000
                                  call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                                       gas gas_remaining wei
                                  if not ext_call.success:
                                      revert with ext_call.return_data[0 len return_data.size]
                                  if ext_call.success:
                                      mem[128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                      if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                      require return_data.size >=′ 32
                                      require mem[128] <= LOCK8605463013()
                                      require mem[128] + 159 <′ return_data.size + 128
                                      if mem[mem[128] + 128] > LOCK8605463013():
                                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                      if ceil32(return_data.size) + ceil32(32 * mem[mem[128] + 128]) + 129 > LOCK8605463013() or ceil32(32 * mem[mem[128] + 128]) + 1 < 0:
                                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                      require mem[128] + (32 * mem[mem[128] + 128]) + 32 <= return_data.size
                      else:
                          mem[128] = 0xef5cfb8c00000000000000000000000000000000000000000000000000000000
                          mem[132] = this.address
                          call 0xac614884b52dbab8728476b5d50f0d672baed31f.claimRewards(address _receiver) with:
                               gas gas_remaining wei
                              args this.address
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          if ext_call.success:
                              mem[128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                              if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                              mem[64] = ceil32(return_data.size) + 128
                              require return_data.size >=′ 32
                              require mem[128 len 4], Mask(224, 32, this.address) >> 32 <= LOCK8605463013()
                              require mem[128 len 4], Mask(224, 32, this.address) >> 32 + 159 <′ return_data.size + 128
                              if mem[mem[128 len 4], Mask(224, 32, this.address) >> 32 + 128] > LOCK8605463013():
                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                              if ceil32(return_data.size) + ceil32(32 * mem[mem[128 len 4], Mask(224, 32, this.address) >> 32 + 128]) + 129 > LOCK8605463013() or ceil32(32 * mem[mem[128 len 4], Mask(224, 32, this.address) >> 32 + 128]) + 1 < 0:
                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                              require mem[128 len 4], Mask(224, 32, this.address) >> 32 + (32 * mem[mem[128 len 4], Mask(224, 32, this.address) >> 32 + 128]) + 32 <= return_data.size
                          else:
                              if block.number == unknown60e0a9e1:
                                  require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                                  uint128(stor9) = 0
                                  mem[128] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                                  static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                                          gas gas_remaining wei
                                  if not ext_call.success:
                                      revert with ext_call.return_data[0 len return_data.size]
                                  if ext_call.success:
                                      mem[128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                      if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                      require return_data.size >=′ 32
                                      require mem[128] <= LOCK8605463013()
                                      require mem[128] + 159 <′ return_data.size + 128
                                      if mem[mem[128] + 128] > LOCK8605463013():
                                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                      if ceil32(return_data.size) + ceil32(32 * mem[mem[128] + 128]) + 129 > LOCK8605463013() or ceil32(32 * mem[mem[128] + 128]) + 1 < 0:
                                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                      require mem[128] + (32 * mem[mem[128] + 128]) + 32 <= return_data.size
                              else:
                                  static call 0xac614884b52dbab8728476b5d50f0d672baed31f.exchangeRate() with:
                                          gas gas_remaining wei
                                  mem[128] = ext_call.return_data[0]
                                  if not ext_call.success:
                                      revert with ext_call.return_data[0 len return_data.size]
                                  if ext_call.success:
                                      if 32 > return_data.size:
                                          if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                          require return_data.size >=′ 32
                                          if ext_call.return_data[0] <= uint128(unknownd2a3584e) >> 128:
                                              require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                                              unknown60e0a9e1 = uint128(block.number)
                                              stor8 = 0
                                              log 0x71475f2f 
                                              log 0x0 
                                              uint128(stor9) = 0
                                          else:
                                              require ext_call.return_data[0] <= LOCK8605463013()
                                              unknown60e0a9e1 = uint128(block.number)
                                              stor8 = uint128(ext_call.return_data[0])
                                              log 0x71475f2f: uint128(ext_call.return_data[0])
                                              require uint128(ext_call.return_data[0]) <= LOCK8605463013()
                                              uint128(stor9) = uint128(ext_call.return_data[0])
                                          mem[ceil32(return_data.size) + 128] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                                          static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                                                  gas gas_remaining wei
                                          if not ext_call.success:
                                              revert with ext_call.return_data[0 len return_data.size]
                                          if ext_call.success:
                                              mem[ceil32(return_data.size) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                              if (2 * ceil32(return_data.size)) + 128 > LOCK8605463013() or 2 * ceil32(return_data.size) < ceil32(return_data.size):
                                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                              require return_data.size >=′ 32
                                              require mem[ceil32(return_data.size) + 128] <= LOCK8605463013()
                                              require ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 159 <′ ceil32(return_data.size) + return_data.size + 128
                                              if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 128] > LOCK8605463013():
                                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                              if (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 128]) + 129 > LOCK8605463013() or ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 128]) + 1 < 0:
                                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                              require mem[ceil32(return_data.size) + 128] + (32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 128]) + 32 <= return_data.size
          else:
              if isExpired() == uint32(call.func_hash) >> 224:
                  require not call.value
                  require calldata.size - 4 >=′ 0
                  return 484512 * 24 * 3600 <= block.timestamp
              if decimals() == uint32(call.func_hash) >> 224:
                  require not call.value
                  require calldata.size - 4 >=′ 0
                  return 8
              if unknown4ba6dcd7() == uint32(call.func_hash) >> 224:
                  require not call.value
                  require calldata.size - 4 >=′ 0
                  return unknown4ba6dcd7
              if unknown516399df() == uint32(call.func_hash) >> 224:
                  require not call.value
                  require calldata.size - 4 >=′ 0
                  return 1
              if unknown53335819(array _param1, array _param2, array _param3) == uint32(call.func_hash) >> 224:
                  require not call.value
                  require calldata.size - 4 >=′ 96
                  require _param1 <= LOCK8605463013()
                  require _param1 + 35 <′ calldata.size
                  require _param1.length <= LOCK8605463013()
                  require (32 * _param1.length) + _param1 + 36 <= calldata.size
                  require _param2 <= LOCK8605463013()
                  require _param2 + 35 <′ calldata.size
                  require _param2.length <= LOCK8605463013()
                  require (32 * _param2.length) + _param2 + 36 <= calldata.size
                  require _param3 <= LOCK8605463013()
                  require _param3 + 35 <′ calldata.size
                  require _param3.length <= LOCK8605463013()
                  require (32 * _param3.length) + _param3 + 36 <= calldata.size
                  if uint8(uint256(stor2.field_0)) >> 248 == 2:
                      revert with Error(string reason), 'ReentrancyGuard: reentrant call'
                  uint8(stor2.field_248) = 2
                  if 484512 * 24 * 3600 <= block.timestamp:
                      revert with 1528145626
                  if not _param1.length:
                      revert with ArrayEmpty()
                  if _param2.length == _param1.length:
                      if _param3.length != _param1.length:
                          revert with ArrayLengthMismatch()
                      if _param3.length > LOCK8605463013():
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      if ceil32(32 * _param3.length) + 129 > LOCK8605463013() or ceil32(32 * _param3.length) + 129 < 128:
                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                      require _param3 + (32 * _param3.length) + 36 <= calldata.size
              else:
                  if userReward(address _account, address _token) == uint32(call.func_hash) >> 224:
                      require not call.value
                      require calldata.size - 4 >=′ 64
                      require not Mask(96, 160, _param1)
                      require not Mask(96, 160, _param2)
                      return userReward[address(_param1)][address(_param2)], userReward[address(_param1)][address(_param2)]
                  if unknown60e0a9e1() == uint32(call.func_hash) >> 224:
                      require not call.value
                      require calldata.size - 4 >=′ 0
                      return unknown60e0a9e1
                  if balanceOf(address account) == uint32(call.func_hash) >> 224:
                      require not call.value
                      require calldata.size - 4 >=′ 32
                      require not Mask(96, 160, _param1)
                      return balanceOf[address(_param1)]
                  if unknown7d24da4d(uint256 _param1, uint256 _param2, uint256 _param3) == uint32(call.func_hash) >> 224:
                      require not call.value
                      require calldata.size - 4 >=′ 96
                      require not Mask(96, 160, _param1)
                      require not _param2 - bool(_param2)
                      require not _param3 - bool(_param3)
                      if uint8(uint256(stor2.field_0)) >> 248 == 2:
                          revert with Error(string reason), 'ReentrancyGuard: reentrant call'
                      uint8(stor2.field_248) = 2
                      if 484512 * 24 * 3600 <= block.timestamp:
                          if uint128(stor9):
                              if not _param2:
                                  if not _param3:
                                      revert with 1746169629
                                  mem[128] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                                  static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                                          gas gas_remaining wei
                                  if not ext_call.success:
                                      revert with ext_call.return_data[0 len return_data.size]
                                  if ext_call.success:
                                      mem[128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                      if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                      require return_data.size >=′ 32
                                      require mem[128] <= LOCK8605463013()
                                      require mem[128] + 159 <′ return_data.size + 128
                                      if mem[mem[128] + 128] > LOCK8605463013():
                                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                      if ceil32(return_data.size) + ceil32(32 * mem[mem[128] + 128]) + 129 > LOCK8605463013() or ceil32(32 * mem[mem[128] + 128]) + 1 < 0:
                                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                      require mem[128] + (32 * mem[mem[128] + 128]) + 32 <= return_data.size
                                  else:
                                      if 484512 * 24 * 3600 <= block.timestamp:
                                          if mem[0] > LOCK8605463013():
                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                          if ceil32(32 * mem[0]) + 129 > LOCK8605463013() or ceil32(32 * mem[0]) + 129 < 128:
                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                          if mem[0] > LOCK8605463013():
                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                      else:
                                          mem[128] = 0xf8b2f99100000000000000000000000000000000000000000000000000000000
                                          call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                                               gas gas_remaining wei
                                          if not ext_call.success:
                                              revert with ext_call.return_data[0 len return_data.size]
                                          if ext_call.success:
                                              mem[128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                              if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                              require return_data.size >=′ 32
                                              require mem[128] <= LOCK8605463013()
                                              require mem[128] + 159 <′ return_data.size + 128
                                              if mem[mem[128] + 128] > LOCK8605463013():
                                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                              if ceil32(return_data.size) + ceil32(32 * mem[mem[128] + 128]) + 129 > LOCK8605463013() or ceil32(32 * mem[mem[128] + 128]) + 1 < 0:
                                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                              require mem[128] + (32 * mem[mem[128] + 128]) + 32 <= return_data.size
                          else:
                              mem[128] = 0xef5cfb8c00000000000000000000000000000000000000000000000000000000
                              mem[132] = this.address
                              call 0xac614884b52dbab8728476b5d50f0d672baed31f.claimRewards(address _receiver) with:
                                   gas gas_remaining wei
                                  args this.address
                              if not ext_call.success:
                                  revert with ext_call.return_data[0 len return_data.size]
                              if ext_call.success:
                                  mem[128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                  if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                  mem[64] = ceil32(return_data.size) + 128
                                  require return_data.size >=′ 32
                                  require mem[128 len 4], Mask(224, 32, this.address) >> 32 <= LOCK8605463013()
                                  require mem[128 len 4], Mask(224, 32, this.address) >> 32 + 159 <′ return_data.size + 128
                                  if mem[mem[128 len 4], Mask(224, 32, this.address) >> 32 + 128] > LOCK8605463013():
                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                  if ceil32(return_data.size) + ceil32(32 * mem[mem[128 len 4], Mask(224, 32, this.address) >> 32 + 128]) + 129 > LOCK8605463013() or ceil32(32 * mem[mem[128 len 4], Mask(224, 32, this.address) >> 32 + 128]) + 1 < 0:
                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                  require mem[128 len 4], Mask(224, 32, this.address) >> 32 + (32 * mem[mem[128 len 4], Mask(224, 32, this.address) >> 32 + 128]) + 32 <= return_data.size
                              else:
                                  if block.number == unknown60e0a9e1:
                                      require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                                      uint128(stor9) = 0
                                      mem[128] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                                      static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                                              gas gas_remaining wei
                                      if not ext_call.success:
                                          revert with ext_call.return_data[0 len return_data.size]
                                      if ext_call.success:
                                          mem[128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                          if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                          require return_data.size >=′ 32
                                          require mem[128] <= LOCK8605463013()
                                          require mem[128] + 159 <′ return_data.size + 128
                                          if mem[mem[128] + 128] > LOCK8605463013():
                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                          if ceil32(return_data.size) + ceil32(32 * mem[mem[128] + 128]) + 129 > LOCK8605463013() or ceil32(32 * mem[mem[128] + 128]) + 1 < 0:
                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                          require mem[128] + (32 * mem[mem[128] + 128]) + 32 <= return_data.size
                                  else:
                                      static call 0xac614884b52dbab8728476b5d50f0d672baed31f.exchangeRate() with:
                                              gas gas_remaining wei
                                      mem[128] = ext_call.return_data[0]
                                      if not ext_call.success:
                                          revert with ext_call.return_data[0 len return_data.size]
                                      if ext_call.success:
                                          if 32 > return_data.size:
                                              if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                              require return_data.size >=′ 32
                                              if ext_call.return_data[0] <= uint128(unknownd2a3584e) >> 128:
                                                  require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                                                  unknown60e0a9e1 = uint128(block.number)
                                                  stor8 = 0
                                                  log 0x71475f2f 
                                                  log 0x0 
                                                  uint128(stor9) = 0
                                              else:
                                                  require ext_call.return_data[0] <= LOCK8605463013()
                                                  unknown60e0a9e1 = uint128(block.number)
                                                  stor8 = uint128(ext_call.return_data[0])
                                                  log 0x71475f2f: uint128(ext_call.return_data[0])
                                                  require uint128(ext_call.return_data[0]) <= LOCK8605463013()
                                                  uint128(stor9) = uint128(ext_call.return_data[0])
                                              mem[ceil32(return_data.size) + 128] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                                              static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                                                      gas gas_remaining wei
                                              if not ext_call.success:
                                                  revert with ext_call.return_data[0 len return_data.size]
                                              if ext_call.success:
                                                  mem[ceil32(return_data.size) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                  if (2 * ceil32(return_data.size)) + 128 > LOCK8605463013() or 2 * ceil32(return_data.size) < ceil32(return_data.size):
                                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                  require return_data.size >=′ 32
                                                  require mem[ceil32(return_data.size) + 128] <= LOCK8605463013()
                                                  require ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 159 <′ ceil32(return_data.size) + return_data.size + 128
                                                  if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 128] > LOCK8605463013():
                                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                  if (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 128]) + 129 > LOCK8605463013() or ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 128]) + 1 < 0:
                                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                  require mem[ceil32(return_data.size) + 128] + (32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 128]) + 32 <= return_data.size
                  else:
                      if symbol() == uint32(call.func_hash) >> 224:
                          require not call.value
                          require calldata.size - 4 >=′ 0
                          if not bool(stor4.field_0):
                              if bool(stor4.field_0) == stor4.field_1 % 128 < 32:
                                  revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.
                              if not bool(stor4.field_0):
                                  if ceil32(32 * bool(stor4.field_1 % 128)) + 129 > LOCK8605463013() or ceil32(32 * bool(stor4.field_1 % 128)) + 129 < 128:
                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                              else:
                      else:
                          if transfer(address recipient, uint256 amount) == uint32(call.func_hash) >> 224:
                              require not call.value
                              require calldata.size - 4 >=′ 64
                              require not Mask(96, 160, _param1)
                              if uint8(uint256(stor2.field_0)) >> 248 == 2:
                                  revert with Error(string reason), 'ReentrancyGuard: reentrant call'
                              uint8(stor2.field_248) = 2
                              if not caller:
                                  revert with Error(string reason), 'ERC20: transfer from the zero address'
                              if not address(_param1):
                                  revert with Error(string reason), 'ERC20: transfer to the zero address'
                              if caller == address(_param1):
                                  revert with Error(string reason), 'ERC20: transfer to self'
                              if 484512 * 24 * 3600 <= block.timestamp:
                                  if uint128(stor9):
                                      mem[128] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                                      static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                                              gas gas_remaining wei
                                      if not ext_call.success:
                                          revert with ext_call.return_data[0 len return_data.size]
                                      if ext_call.success:
                                          mem[128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                          if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                          require return_data.size >=′ 32
                                          require mem[128] <= LOCK8605463013()
                                          require mem[128] + 159 <′ return_data.size + 128
                                          if mem[mem[128] + 128] > LOCK8605463013():
                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                          if ceil32(return_data.size) + ceil32(32 * mem[mem[128] + 128]) + 129 > LOCK8605463013() or ceil32(32 * mem[mem[128] + 128]) + 1 < 0:
                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                          require mem[128] + (32 * mem[mem[128] + 128]) + 32 <= return_data.size
                                      else:
                                          if 484512 * 24 * 3600 <= block.timestamp:
                                              if mem[0] > LOCK8605463013():
                                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                              if ceil32(32 * mem[0]) + 129 > LOCK8605463013() or ceil32(32 * mem[0]) + 129 < 128:
                                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                              if mem[0] > LOCK8605463013():
                                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                          else:
                                              mem[128] = 0xf8b2f99100000000000000000000000000000000000000000000000000000000
                                              call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                                                   gas gas_remaining wei
                                              if not ext_call.success:
                                                  revert with ext_call.return_data[0 len return_data.size]
                                              if ext_call.success:
                                                  mem[128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                  if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                  require return_data.size >=′ 32
                                                  require mem[128] <= LOCK8605463013()
                                                  require mem[128] + 159 <′ return_data.size + 128
                                                  if mem[mem[128] + 128] > LOCK8605463013():
                                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                  if ceil32(return_data.size) + ceil32(32 * mem[mem[128] + 128]) + 129 > LOCK8605463013() or ceil32(32 * mem[mem[128] + 128]) + 1 < 0:
                                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                  require mem[128] + (32 * mem[mem[128] + 128]) + 32 <= return_data.size
                                  else:
                                      mem[128] = 0xef5cfb8c00000000000000000000000000000000000000000000000000000000
                                      mem[132] = this.address
                                      call 0xac614884b52dbab8728476b5d50f0d672baed31f.claimRewards(address _receiver) with:
                                           gas gas_remaining wei
                                          args this.address
                                      if not ext_call.success:
                                          revert with ext_call.return_data[0 len return_data.size]
                                      if ext_call.success:
                                          mem[128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                          if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                          mem[64] = ceil32(return_data.size) + 128
                                          require return_data.size >=′ 32
                                          require mem[128 len 4], Mask(224, 32, this.address) >> 32 <= LOCK8605463013()
                                          require mem[128 len 4], Mask(224, 32, this.address) >> 32 + 159 <′ return_data.size + 128
                                          if mem[mem[128 len 4], Mask(224, 32, this.address) >> 32 + 128] > LOCK8605463013():
                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                          if ceil32(return_data.size) + ceil32(32 * mem[mem[128 len 4], Mask(224, 32, this.address) >> 32 + 128]) + 129 > LOCK8605463013() or ceil32(32 * mem[mem[128 len 4], Mask(224, 32, this.address) >> 32 + 128]) + 1 < 0:
                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                          require mem[128 len 4], Mask(224, 32, this.address) >> 32 + (32 * mem[mem[128 len 4], Mask(224, 32, this.address) >> 32 + 128]) + 32 <= return_data.size
                                      else:
                                          if block.number == unknown60e0a9e1:
                                              require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                                              uint128(stor9) = 0
                                              mem[128] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                                              static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                                                      gas gas_remaining wei
                                              if not ext_call.success:
                                                  revert with ext_call.return_data[0 len return_data.size]
                                              if ext_call.success:
                                                  mem[128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                  if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                  require return_data.size >=′ 32
                                                  require mem[128] <= LOCK8605463013()
                                                  require mem[128] + 159 <′ return_data.size + 128
                                                  if mem[mem[128] + 128] > LOCK8605463013():
                                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                  if ceil32(return_data.size) + ceil32(32 * mem[mem[128] + 128]) + 129 > LOCK8605463013() or ceil32(32 * mem[mem[128] + 128]) + 1 < 0:
                                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                  require mem[128] + (32 * mem[mem[128] + 128]) + 32 <= return_data.size
                                          else:
                                              static call 0xac614884b52dbab8728476b5d50f0d672baed31f.exchangeRate() with:
                                                      gas gas_remaining wei
                                              mem[128] = ext_call.return_data[0]
                                              if not ext_call.success:
                                                  revert with ext_call.return_data[0 len return_data.size]
                                              if ext_call.success:
                                                  if 32 > return_data.size:
                                                      if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                                                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                      require return_data.size >=′ 32
                                                      if ext_call.return_data[0] <= uint128(unknownd2a3584e) >> 128:
                                                          require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                                                          unknown60e0a9e1 = uint128(block.number)
                                                          stor8 = 0
                                                          log 0x71475f2f 
                                                          log 0x0 
                                                          uint128(stor9) = 0
                                                      else:
                                                          require ext_call.return_data[0] <= LOCK8605463013()
                                                          unknown60e0a9e1 = uint128(block.number)
                                                          stor8 = uint128(ext_call.return_data[0])
                                                          log 0x71475f2f: uint128(ext_call.return_data[0])
                                                          require uint128(ext_call.return_data[0]) <= LOCK8605463013()
                                                          uint128(stor9) = uint128(ext_call.return_data[0])
                                                      mem[ceil32(return_data.size) + 128] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                                                      static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                                                              gas gas_remaining wei
                                                      if not ext_call.success:
                                                          revert with ext_call.return_data[0 len return_data.size]
                                                      if ext_call.success:
                                                          mem[ceil32(return_data.size) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                          if (2 * ceil32(return_data.size)) + 128 > LOCK8605463013() or 2 * ceil32(return_data.size) < ceil32(return_data.size):
                                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                          require return_data.size >=′ 32
                                                          require mem[ceil32(return_data.size) + 128] <= LOCK8605463013()
                                                          require ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 159 <′ ceil32(return_data.size) + return_data.size + 128
                                                          if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 128] > LOCK8605463013():
                                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                          if (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 128]) + 129 > LOCK8605463013() or ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 128]) + 1 < 0:
                                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                          require mem[ceil32(return_data.size) + 128] + (32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 128]) + 32 <= return_data.size
                          else:
                              if unknownacc5da4c() == uint32(call.func_hash) >> 224:
                                  require not call.value
                                  require calldata.size - 4 >=′ 0
                                  if uint8(uint256(stor2.field_0)) >> 248 == 2:
                                      revert with Error(string reason), 'ReentrancyGuard: reentrant call'
                                  uint8(stor2.field_248) = 2
                                  if 484512 * 24 * 3600 <= block.timestamp:
                                      if uint128(stor9):
                                          if 484512 * 24 * 3600 > block.timestamp:
                                              revert with 3447825974
                                          static call 0x35a338522a435d46f77be32c70e215b813d0e3ac.treasury() with:
                                                  gas gas_remaining wei
                                          mem[128] = ext_call.return_data[0]
                                          if not ext_call.success:
                                              revert with ext_call.return_data[0 len return_data.size]
                                          if ext_call.success:
                                              if 32 > return_data.size:
                                                  if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                  require return_data.size >=′ 32
                                                  require not Mask(96, 160, ext_call.return_data[0])
                                                  mem[ceil32(return_data.size) + 128] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                                                  static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                                                          gas gas_remaining wei
                                                  if not ext_call.success:
                                                      revert with ext_call.return_data[0 len return_data.size]
                                                  if ext_call.success:
                                                      mem[ceil32(return_data.size) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                      if (2 * ceil32(return_data.size)) + 128 > LOCK8605463013() or 2 * ceil32(return_data.size) < ceil32(return_data.size):
                                                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                      require return_data.size >=′ 32
                                                      require mem[ceil32(return_data.size) + 128] <= LOCK8605463013()
                                                      require ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 159 <′ ceil32(return_data.size) + return_data.size + 128
                                                      if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 128] > LOCK8605463013():
                                                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                      if (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 128]) + 129 > LOCK8605463013() or ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 128]) + 1 < 0:
                                                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                      require mem[ceil32(return_data.size) + 128] + (32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 128]) + 32 <= return_data.size
                                                  else:
                                                      if mem[0] > LOCK8605463013():
                                                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                      if ceil32(return_data.size) + ceil32(32 * mem[0]) + 129 > LOCK8605463013() or ceil32(32 * mem[0]) + 1 < 0:
                                                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                      mem[ceil32(return_data.size) + 128] = mem[0]
                                                      if mem[0] > LOCK8605463013():
                                                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                      mem[ceil32(return_data.size) + 160 len 32 * mem[0]] = call.data[calldata.size len 32 * mem[0]]
                                                      mem[ceil32(return_data.size) + ceil32(32 * mem[0]) + 129] = 0xef5cfb8c00000000000000000000000000000000000000000000000000000000
                                                      mem[ceil32(return_data.size) + ceil32(32 * mem[0]) + 133] = this.address
                                                      call 0xac614884b52dbab8728476b5d50f0d672baed31f.claimRewards(address _receiver) with:
                                                           gas gas_remaining wei
                                                          args this.address
                                                      if not ext_call.success:
                                                          revert with ext_call.return_data[0 len return_data.size]
                                                      if ext_call.success:
                                                          mem[ceil32(return_data.size) + ceil32(32 * mem[0]) + 129 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                          if (2 * ceil32(return_data.size)) + ceil32(32 * mem[0]) + 129 > LOCK8605463013() or 2 * ceil32(return_data.size) < ceil32(return_data.size):
                                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                          mem[64] = (2 * ceil32(return_data.size)) + ceil32(32 * mem[0]) + 129
                                                          require return_data.size >=′ 32
                                                          require mem[ceil32(return_data.size) + ceil32(32 * mem[0]) + 129 len 4], Mask(224, 32, this.address) >> 32 <= LOCK8605463013()
                                                          require ceil32(return_data.size) + ceil32(32 * mem[0]) + mem[ceil32(return_data.size) + ceil32(32 * mem[0]) + 129 len 4], Mask(224, 32, this.address) >> 32 + 160 <′ ceil32(return_data.size) + ceil32(32 * mem[0]) + return_data.size + 129
                                                          if mem[ceil32(return_data.size) + ceil32(32 * mem[0]) + mem[ceil32(return_data.size) + ceil32(32 * mem[0]) + 129 len 4], Mask(224, 32, this.address) >> 32 + 129] > LOCK8605463013():
                                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                          if (2 * ceil32(return_data.size)) + ceil32(32 * mem[0]) + ceil32(32 * mem[ceil32(return_data.size) + ceil32(32 * mem[0]) + mem[ceil32(return_data.size) + ceil32(32 * mem[0]) + 129 len 4], Mask(224, 32, this.address) >> 32 + 129]) + 130 > LOCK8605463013() or ceil32(32 * mem[ceil32(return_data.size) + ceil32(32 * mem[0]) + mem[ceil32(return_data.size) + ceil32(32 * mem[0]) + 129 len 4], Mask(224, 32, this.address) >> 32 + 129]) + 1 < 0:
                                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                          require mem[ceil32(return_data.size) + ceil32(32 * mem[0]) + 129 len 4], Mask(224, 32, this.address) >> 32 + (32 * mem[ceil32(return_data.size) + ceil32(32 * mem[0]) + mem[ceil32(return_data.size) + ceil32(32 * mem[0]) + 129 len 4], Mask(224, 32, this.address) >> 32 + 129]) + 32 <= return_data.size
                                                      else:
                                                          if 0 < mem[0]:
                                                              if 0 >= mem[0]:
                                                                  revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                                                              if not mem[44 len 20]:
                                                                  if 0 >= mem[0]:
                                                                      revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
                                                                  if eth.balance(this.address) - stor11[mem[44 len 20]] > eth.balance(this.address):
                                                                      revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                                                              else:
                                                                  static call mem[44 len 20].balanceOf(address account) with:
                                                                          gas gas_remaining wei
                                                                         args this.address
                                                                  if not ext_call.success:
                                                                      revert with ext_call.return_data[0 len return_data.size]
                                                                  if ext_call.success:
                                                                      if 32 > return_data.size:
                                                                          if (2 * ceil32(return_data.size)) + ceil32(32 * mem[0]) + 129 > LOCK8605463013() or 2 * ceil32(return_data.size) < ceil32(return_data.size):
                                                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                                          require return_data.size >=′ 32
                                      else:
                                          mem[128] = 0xef5cfb8c00000000000000000000000000000000000000000000000000000000
                                          mem[132] = this.address
                                          call 0xac614884b52dbab8728476b5d50f0d672baed31f.claimRewards(address _receiver) with:
                                               gas gas_remaining wei
                                              args this.address
                                          if not ext_call.success:
                                              revert with ext_call.return_data[0 len return_data.size]
                                          if ext_call.success:
                                              mem[128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                              if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                              mem[64] = ceil32(return_data.size) + 128
                                              require return_data.size >=′ 32
                                              require mem[128 len 4], Mask(224, 32, this.address) >> 32 <= LOCK8605463013()
                                              require mem[128 len 4], Mask(224, 32, this.address) >> 32 + 159 <′ return_data.size + 128
                                              if mem[mem[128 len 4], Mask(224, 32, this.address) >> 32 + 128] > LOCK8605463013():
                                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                              if ceil32(return_data.size) + ceil32(32 * mem[mem[128 len 4], Mask(224, 32, this.address) >> 32 + 128]) + 129 > LOCK8605463013() or ceil32(32 * mem[mem[128 len 4], Mask(224, 32, this.address) >> 32 + 128]) + 1 < 0:
                                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                              require mem[128 len 4], Mask(224, 32, this.address) >> 32 + (32 * mem[mem[128 len 4], Mask(224, 32, this.address) >> 32 + 128]) + 32 <= return_data.size
                                          else:
                                              if block.number == unknown60e0a9e1:
                                                  require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                                                  uint128(stor9) = 0
                                                  mem[128] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                                                  static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                                                          gas gas_remaining wei
                                                  if not ext_call.success:
                                                      revert with ext_call.return_data[0 len return_data.size]
                                                  if ext_call.success:
                                                      mem[128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                      if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                                                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                      require return_data.size >=′ 32
                                                      require mem[128] <= LOCK8605463013()
                                                      require mem[128] + 159 <′ return_data.size + 128
                                                      if mem[mem[128] + 128] > LOCK8605463013():
                                                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                      if ceil32(return_data.size) + ceil32(32 * mem[mem[128] + 128]) + 129 > LOCK8605463013() or ceil32(32 * mem[mem[128] + 128]) + 1 < 0:
                                                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                      require mem[128] + (32 * mem[mem[128] + 128]) + 32 <= return_data.size
                                              else:
                                                  static call 0xac614884b52dbab8728476b5d50f0d672baed31f.exchangeRate() with:
                                                          gas gas_remaining wei
                                                  mem[128] = ext_call.return_data[0]
                                                  if not ext_call.success:
                                                      revert with ext_call.return_data[0 len return_data.size]
                                                  if ext_call.success:
                                                      if 32 > return_data.size:
                                                          if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                          require return_data.size >=′ 32
                                                          if ext_call.return_data[0] <= uint128(unknownd2a3584e) >> 128:
                                                              require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                                                              unknown60e0a9e1 = uint128(block.number)
                                                              stor8 = 0
                                                              log 0x71475f2f 
                                                              log 0x0 
                                                              uint128(stor9) = 0
                                                          else:
                                                              require ext_call.return_data[0] <= LOCK8605463013()
                                                              unknown60e0a9e1 = uint128(block.number)
                                                              stor8 = uint128(ext_call.return_data[0])
                                                              log 0x71475f2f: uint128(ext_call.return_data[0])
                                                              require uint128(ext_call.return_data[0]) <= LOCK8605463013()
                                                              uint128(stor9) = uint128(ext_call.return_data[0])
                                                          mem[ceil32(return_data.size) + 128] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                                                          static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                                                                  gas gas_remaining wei
                                                          if not ext_call.success:
                                                              revert with ext_call.return_data[0 len return_data.size]
                                                          if ext_call.success:
                                                              mem[ceil32(return_data.size) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                              if (2 * ceil32(return_data.size)) + 128 > LOCK8605463013() or 2 * ceil32(return_data.size) < ceil32(return_data.size):
                                                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                              require return_data.size >=′ 32
                                                              require mem[ceil32(return_data.size) + 128] <= LOCK8605463013()
                                                              require ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 159 <′ ceil32(return_data.size) + return_data.size + 128
                                                              if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 128] > LOCK8605463013():
                                                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                              if (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 128]) + 129 > LOCK8605463013() or ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 128]) + 1 < 0:
                                                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                              require mem[ceil32(return_data.size) + 128] + (32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 128]) + 32 <= return_data.size
                              else:
                                  if SY() == uint32(call.func_hash) >> 224:
                                      require not call.value
                                      require calldata.size - 4 >=′ 0
                                      return 0xac614884b52dbab8728476b5d50f0d672baed31f
                                  if uint32(call.func_hash) >> 224 != unknownb0d88981(array _param1, array _param2):
                                      if unknownbcb7ea5d(uint256 _param1) == uint32(call.func_hash) >> 224:
                                          require not call.value
                                          require calldata.size - 4 >=′ 32
                                          require not Mask(96, 160, _param1)
                                          if uint8(uint256(stor2.field_0)) >> 248 == 2:
                                              revert with Error(string reason), 'ReentrancyGuard: reentrant call'
                                          uint8(stor2.field_248) = 2
                                          if 484512 * 24 * 3600 <= block.timestamp:
                                              if uint128(stor9):
                                                  if 484512 * 24 * 3600 > block.timestamp:
                                                  static call 0xdfb913b117bc93fde164a4ff8b3176662d4198f3.balanceOf(address account) with:
                                                          gas gas_remaining wei
                                                         args this.address
                                                  if not ext_call.success:
                                                      revert with ext_call.return_data[0 len return_data.size]
                                                  if ext_call.success:
                                                      if 32 > return_data.size:
                                                          if ceil32(return_data.size) + 256 > LOCK8605463013() or ceil32(return_data.size) + 256 < 256:
                                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                          require return_data.size >=′ 32
                                              else:
                                                  mem[128] = 0xef5cfb8c00000000000000000000000000000000000000000000000000000000
                                                  mem[132] = this.address
                                                  call 0xac614884b52dbab8728476b5d50f0d672baed31f.claimRewards(address _receiver) with:
                                                       gas gas_remaining wei
                                                      args this.address
                                                  if not ext_call.success:
                                                      revert with ext_call.return_data[0 len return_data.size]
                                                  if ext_call.success:
                                                      mem[128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                      if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                                                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                      mem[64] = ceil32(return_data.size) + 128
                                                      require return_data.size >=′ 32
                                                      require mem[128 len 4], Mask(224, 32, this.address) >> 32 <= LOCK8605463013()
                                                      require mem[128 len 4], Mask(224, 32, this.address) >> 32 + 159 <′ return_data.size + 128
                                                      if mem[mem[128 len 4], Mask(224, 32, this.address) >> 32 + 128] > LOCK8605463013():
                                                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                      if ceil32(return_data.size) + ceil32(32 * mem[mem[128 len 4], Mask(224, 32, this.address) >> 32 + 128]) + 129 > LOCK8605463013() or ceil32(32 * mem[mem[128 len 4], Mask(224, 32, this.address) >> 32 + 128]) + 1 < 0:
                                                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                      require mem[128 len 4], Mask(224, 32, this.address) >> 32 + (32 * mem[mem[128 len 4], Mask(224, 32, this.address) >> 32 + 128]) + 32 <= return_data.size
                                                  else:
                                                      if block.number == unknown60e0a9e1:
                                                          require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                                                          uint128(stor9) = 0
                                                          mem[128] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                                                          static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                                                                  gas gas_remaining wei
                                                          if not ext_call.success:
                                                              revert with ext_call.return_data[0 len return_data.size]
                                                          if ext_call.success:
                                                              mem[128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                              if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                                                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                              require return_data.size >=′ 32
                                                              require mem[128] <= LOCK8605463013()
                                                              require mem[128] + 159 <′ return_data.size + 128
                                                              if mem[mem[128] + 128] > LOCK8605463013():
                                                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                              if ceil32(return_data.size) + ceil32(32 * mem[mem[128] + 128]) + 129 > LOCK8605463013() or ceil32(32 * mem[mem[128] + 128]) + 1 < 0:
                                                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                              require mem[128] + (32 * mem[mem[128] + 128]) + 32 <= return_data.size
                                                      else:
                                                          static call 0xac614884b52dbab8728476b5d50f0d672baed31f.exchangeRate() with:
                                                                  gas gas_remaining wei
                                                          mem[128] = ext_call.return_data[0]
                                                          if not ext_call.success:
                                                              revert with ext_call.return_data[0 len return_data.size]
                                                          if ext_call.success:
                                                              if 32 > return_data.size:
                                                                  if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                                                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                                  require return_data.size >=′ 32
                                                                  if ext_call.return_data[0] <= uint128(unknownd2a3584e) >> 128:
                                                                      require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                                                                      unknown60e0a9e1 = uint128(block.number)
                                                                      stor8 = 0
                                                                      log 0x71475f2f 
                                                                      log 0x0 
                                                                      uint128(stor9) = 0
                                                                  else:
                                                                      require ext_call.return_data[0] <= LOCK8605463013()
                                                                      unknown60e0a9e1 = uint128(block.number)
                                                                      stor8 = uint128(ext_call.return_data[0])
                                                                      log 0x71475f2f: uint128(ext_call.return_data[0])
                                                                      require uint128(ext_call.return_data[0]) <= LOCK8605463013()
                                                                      uint128(stor9) = uint128(ext_call.return_data[0])
                                                                  mem[ceil32(return_data.size) + 128] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                                                                  static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                                                                          gas gas_remaining wei
                                                                  if not ext_call.success:
                                                                      revert with ext_call.return_data[0 len return_data.size]
                                                                  if ext_call.success:
                                                                      mem[ceil32(return_data.size) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                      if (2 * ceil32(return_data.size)) + 128 > LOCK8605463013() or 2 * ceil32(return_data.size) < ceil32(return_data.size):
                                                                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                                      require return_data.size >=′ 32
                                                                      require mem[ceil32(return_data.size) + 128] <= LOCK8605463013()
                                                                      require ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 159 <′ ceil32(return_data.size) + return_data.size + 128
                                                                      if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 128] > LOCK8605463013():
                                                                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                                      if (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 128]) + 129 > LOCK8605463013() or ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 128]) + 1 < 0:
                                                                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                                      require mem[ceil32(return_data.size) + 128] + (32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 128]) + 32 <= return_data.size
                                      else:
                                          if factory() == uint32(call.func_hash) >> 224:
                                              require not call.value
                                              require calldata.size - 4 >=′ 0
                                              return 0x35a338522a435d46f77be32c70e215b813d0e3ac
                                          if getRewardTokens() == uint32(call.func_hash) >> 224:
                                              require not call.value
                                              require calldata.size - 4 >=′ 0
                                              mem[128] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                                              static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                                                      gas gas_remaining wei
                                              if not ext_call.success:
                                                  revert with ext_call.return_data[0 len return_data.size]
                                              if ext_call.success:
                                                  mem[128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                  if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                  require return_data.size >=′ 32
                                                  require mem[128] <= LOCK8605463013()
                                                  require mem[128] + 159 <′ return_data.size + 128
                                                  if mem[mem[128] + 128] > LOCK8605463013():
                                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                  if ceil32(return_data.size) + ceil32(32 * mem[mem[128] + 128]) + 129 > LOCK8605463013() or ceil32(32 * mem[mem[128] + 128]) + 1 < 0:
                                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                  require mem[128] + (32 * mem[mem[128] + 128]) + 32 <= return_data.size
                                          else:
                                              if uint32(call.func_hash) >> 224 != unknowncdbb0361():
                                                  if unknownd2a3584e() == uint32(call.func_hash) >> 224:
                                                      require not call.value
                                                      require calldata.size - 4 >=′ 0
                                                      return (uint128(unknownd2a3584e) >> 128)
                                                  if unknownd68076c3(uint256 _param1) == uint32(call.func_hash) >> 224:
                                                      require not call.value
                                                      require calldata.size - 4 >=′ 32
                                                      require not Mask(96, 160, _param1)
                                                      return unknownd68076c3[address(_param1)], unknownd68076c3[address(_param1)]
                                                  if PT() == uint32(call.func_hash) >> 224:
                                                      require not call.value
                                                      require calldata.size - 4 >=′ 0
                                                      return 0xdfb913b117bc93fde164a4ff8b3176662d4198f3
                                                  if unknowndb74aa15(uint256 _param1, uint256 _param2) == uint32(call.func_hash) >> 224:
                                                      require not call.value
                                                      require calldata.size - 4 >=′ 64
                                                      require not Mask(96, 160, _param1)
                                                      require not Mask(96, 160, _param2)
                                                      if uint8(uint256(stor2.field_0)) >> 248 == 2:
                                                          revert with Error(string reason), 'ReentrancyGuard: reentrant call'
                                                      uint8(stor2.field_248) = 2
                                                      if 484512 * 24 * 3600 <= block.timestamp:
                                                          revert with 1528145626
                                                      static call 0xac614884b52dbab8728476b5d50f0d672baed31f.balanceOf(address account) with:
                                                              gas gas_remaining wei
                                                             args this.address
                                                      if not ext_call.success:
                                                          revert with ext_call.return_data[0 len return_data.size]
                                                      if ext_call.success:
                                                          if 32 > return_data.size:
                                                              if ceil32(return_data.size) + 320 > LOCK8605463013() or ceil32(return_data.size) + 320 < 320:
                                                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                              require return_data.size >=′ 32
                                                              if ext_call.return_data[0] - unknown4ba6dcd7 > ext_call.return_data[0]:
                                                                  revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
                                                              if not ext_call.return_data[0] - unknown4ba6dcd7:
                                                                  revert with 578971161
                                                  else:
                                                      if allowance(address owner, address spender) == uint32(call.func_hash) >> 224:
                                                          require not call.value
                                                          require calldata.size - 4 >=′ 64
                                                          require not Mask(96, 160, _param1)
                                                          require not Mask(96, 160, _param2)
                                                          return allowance[address(_param1)][address(_param2)]
                                                      if expiry() == uint32(call.func_hash) >> 224:
                                                          require not call.value
                                                          require calldata.size - 4 >=′ 0
                                                          return (484512 * 24 * 3600)
                                                      require rewardIndexesCurrent() == uint32(call.func_hash) >> 224
                                                      require not call.value
                                                      require calldata.size - 4 >=′ 0
                                                      if uint8(uint256(stor2.field_0)) >> 248 == 2:
                                                          revert with Error(string reason), 'ReentrancyGuard: reentrant call'
                                                      uint8(stor2.field_248) = 2
                                                      mem[128] = 0xf8b2f99100000000000000000000000000000000000000000000000000000000
                                                      call 0xac614884b52dbab8728476b5d50f0d672baed31f.rewardIndexesCurrent() with:
                                                           gas gas_remaining wei
                                                      if not ext_call.success:
                                                          revert with ext_call.return_data[0 len return_data.size]
                                                      if ext_call.success:
                                                          mem[128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                          if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                          require return_data.size >=′ 32
                                                          require mem[128] <= LOCK8605463013()
                                                          require mem[128] + 159 <′ return_data.size + 128
                                                          if mem[mem[128] + 128] > LOCK8605463013():
                                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                          if ceil32(return_data.size) + ceil32(32 * mem[mem[128] + 128]) + 129 > LOCK8605463013() or ceil32(32 * mem[mem[128] + 128]) + 1 < 0:
                                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                          require mem[128] + (32 * mem[mem[128] + 128]) + 32 <= return_data.size
                                              else:
                                                  require not call.value
                                                  require calldata.size - 4 >=′ 0
                                                  if uint8(uint256(stor2.field_0)) >> 248 == 2:
                                                      revert with Error(string reason), 'ReentrancyGuard: reentrant call'
                                                  uint8(stor2.field_248) = 2
                                                  if 484512 * 24 * 3600 <= block.timestamp:
                                                      if uint128(stor9):
                                                          uint8(stor2.field_248) = 1
                                                          return 0
                                                      mem[128] = 0xef5cfb8c00000000000000000000000000000000000000000000000000000000
                                                      mem[132] = this.address
                                                      call 0xac614884b52dbab8728476b5d50f0d672baed31f.claimRewards(address _receiver) with:
                                                           gas gas_remaining wei
                                                          args this.address
                                                      if not ext_call.success:
                                                          revert with ext_call.return_data[0 len return_data.size]
                                                      if ext_call.success:
                                                          mem[128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                          if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                          mem[64] = ceil32(return_data.size) + 128
                                                          require return_data.size >=′ 32
                                                          require mem[128 len 4], Mask(224, 32, this.address) >> 32 <= LOCK8605463013()
                                                          require mem[128 len 4], Mask(224, 32, this.address) >> 32 + 159 <′ return_data.size + 128
                                                          if mem[mem[128 len 4], Mask(224, 32, this.address) >> 32 + 128] > LOCK8605463013():
                                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                          if ceil32(return_data.size) + ceil32(32 * mem[mem[128 len 4], Mask(224, 32, this.address) >> 32 + 128]) + 129 > LOCK8605463013() or ceil32(32 * mem[mem[128 len 4], Mask(224, 32, this.address) >> 32 + 128]) + 1 < 0:
                                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                          require mem[128 len 4], Mask(224, 32, this.address) >> 32 + (32 * mem[mem[128 len 4], Mask(224, 32, this.address) >> 32 + 128]) + 32 <= return_data.size
                                                      else:
                                                          if block.number == unknown60e0a9e1:
                                                              require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                                                              uint128(stor9) = 0
                                                              mem[128] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                                                              static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                                                                      gas gas_remaining wei
                                                              if not ext_call.success:
                                                                  revert with ext_call.return_data[0 len return_data.size]
                                                              if ext_call.success:
                                                                  mem[128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                  if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                                                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                                  require return_data.size >=′ 32
                                                                  require mem[128] <= LOCK8605463013()
                                                                  require mem[128] + 159 <′ return_data.size + 128
                                                                  if mem[mem[128] + 128] > LOCK8605463013():
                                                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                                  if ceil32(return_data.size) + ceil32(32 * mem[mem[128] + 128]) + 129 > LOCK8605463013() or ceil32(32 * mem[mem[128] + 128]) + 1 < 0:
                                                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                                  require mem[128] + (32 * mem[mem[128] + 128]) + 32 <= return_data.size
                                                          else:
                                                              static call 0xac614884b52dbab8728476b5d50f0d672baed31f.exchangeRate() with:
                                                                      gas gas_remaining wei
                                                              mem[128] = ext_call.return_data[0]
                                                              if not ext_call.success:
                                                                  revert with ext_call.return_data[0 len return_data.size]
                                                              if ext_call.success:
                                                                  if 32 > return_data.size:
                                                                      if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                                                                          revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                                      require return_data.size >=′ 32
                                                                      if ext_call.return_data[0] <= uint128(unknownd2a3584e) >> 128:
                                                                          require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                                                                          unknown60e0a9e1 = uint128(block.number)
                                                                          stor8 = 0
                                                                          log 0x71475f2f 
                                                                          log 0x0 
                                                                          uint128(stor9) = 0
                                                                      else:
                                                                          require ext_call.return_data[0] <= LOCK8605463013()
                                                                          unknown60e0a9e1 = uint128(block.number)
                                                                          stor8 = uint128(ext_call.return_data[0])
                                                                          log 0x71475f2f: uint128(ext_call.return_data[0])
                                                                          require uint128(ext_call.return_data[0]) <= LOCK8605463013()
                                                                          uint128(stor9) = uint128(ext_call.return_data[0])
                                                                      mem[ceil32(return_data.size) + 128] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                                                                      static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                                                                              gas gas_remaining wei
                                                                      if not ext_call.success:
                                                                          revert with ext_call.return_data[0 len return_data.size]
                                                                      if ext_call.success:
                                                                          mem[ceil32(return_data.size) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                          if (2 * ceil32(return_data.size)) + 128 > LOCK8605463013() or 2 * ceil32(return_data.size) < ceil32(return_data.size):
                                                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                                          require return_data.size >=′ 32
                                                                          require mem[ceil32(return_data.size) + 128] <= LOCK8605463013()
                                                                          require ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 159 <′ ceil32(return_data.size) + return_data.size + 128
                                                                          if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 128] > LOCK8605463013():
                                                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                                          if (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 128]) + 129 > LOCK8605463013() or ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 128]) + 1 < 0:
                                                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                                          require mem[ceil32(return_data.size) + 128] + (32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 128]) + 32 <= return_data.size
                                  else:
                                      require not call.value
                                      require calldata.size - 4 >=′ 64
                                      require _param1 <= LOCK8605463013()
                                      require _param1 + 35 <′ calldata.size
                                      require _param1.length <= LOCK8605463013()
                                      require (32 * _param1.length) + _param1 + 36 <= calldata.size
                                      require _param2 <= LOCK8605463013()
                                      require _param2 + 35 <′ calldata.size
                                      require _param2.length <= LOCK8605463013()
                                      require (32 * _param2.length) + _param2 + 36 <= calldata.size
                                      if uint8(uint256(stor2.field_0)) >> 248 == 2:
                                          revert with Error(string reason), 'ReentrancyGuard: reentrant call'
                                      uint8(stor2.field_248) = 2
                                      if 484512 * 24 * 3600 <= block.timestamp:
                                          if uint128(stor9):
                                              if _param1.length - _param2.length:
                                                  revert with ArrayLengthMismatch()
                                              if not _param1.length:
                                                  revert with ArrayEmpty()
                                              if _param1.length > LOCK8605463013():
                                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                              if ceil32(32 * _param1.length) + 129 > LOCK8605463013() or ceil32(32 * _param1.length) + 129 < 128:
                                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                              require _param1 + (32 * _param1.length) + 36 <= calldata.size
                                          else:
                                              mem[128] = 0xef5cfb8c00000000000000000000000000000000000000000000000000000000
                                              mem[132] = this.address
                                              call 0xac614884b52dbab8728476b5d50f0d672baed31f.claimRewards(address _receiver) with:
                                                   gas gas_remaining wei
                                                  args this.address
                                              if not ext_call.success:
                                                  revert with ext_call.return_data[0 len return_data.size]
                                              if ext_call.success:
                                                  mem[128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                  if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                  mem[64] = ceil32(return_data.size) + 128
                                                  require return_data.size >=′ 32
                                                  require mem[128 len 4], Mask(224, 32, this.address) >> 32 <= LOCK8605463013()
                                                  require mem[128 len 4], Mask(224, 32, this.address) >> 32 + 159 <′ return_data.size + 128
                                                  if mem[mem[128 len 4], Mask(224, 32, this.address) >> 32 + 128] > LOCK8605463013():
                                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                  if ceil32(return_data.size) + ceil32(32 * mem[mem[128 len 4], Mask(224, 32, this.address) >> 32 + 128]) + 129 > LOCK8605463013() or ceil32(32 * mem[mem[128 len 4], Mask(224, 32, this.address) >> 32 + 128]) + 1 < 0:
                                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                  require mem[128 len 4], Mask(224, 32, this.address) >> 32 + (32 * mem[mem[128 len 4], Mask(224, 32, this.address) >> 32 + 128]) + 32 <= return_data.size
                                              else:
                                                  if block.number == unknown60e0a9e1:
                                                      require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                                                      uint128(stor9) = 0
                                                      mem[128] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                                                      static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                                                              gas gas_remaining wei
                                                      if not ext_call.success:
                                                          revert with ext_call.return_data[0 len return_data.size]
                                                      if ext_call.success:
                                                          mem[128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                          if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                          require return_data.size >=′ 32
                                                          require mem[128] <= LOCK8605463013()
                                                          require mem[128] + 159 <′ return_data.size + 128
                                                          if mem[mem[128] + 128] > LOCK8605463013():
                                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                          if ceil32(return_data.size) + ceil32(32 * mem[mem[128] + 128]) + 129 > LOCK8605463013() or ceil32(32 * mem[mem[128] + 128]) + 1 < 0:
                                                              revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                          require mem[128] + (32 * mem[mem[128] + 128]) + 32 <= return_data.size
                                                  else:
                                                      static call 0xac614884b52dbab8728476b5d50f0d672baed31f.exchangeRate() with:
                                                              gas gas_remaining wei
                                                      mem[128] = ext_call.return_data[0]
                                                      if not ext_call.success:
                                                          revert with ext_call.return_data[0 len return_data.size]
                                                      if ext_call.success:
                                                          if 32 > return_data.size:
                                                              if ceil32(return_data.size) + 128 > LOCK8605463013() or ceil32(return_data.size) + 128 < 128:
                                                                  revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                              require return_data.size >=′ 32
                                                              if ext_call.return_data[0] <= uint128(unknownd2a3584e) >> 128:
                                                                  require uint128(unknownd2a3584e) >> 128 <= LOCK8605463013()
                                                                  unknown60e0a9e1 = uint128(block.number)
                                                                  stor8 = 0
                                                                  log 0x71475f2f 
                                                                  log 0x0 
                                                                  uint128(stor9) = 0
                                                              else:
                                                                  require ext_call.return_data[0] <= LOCK8605463013()
                                                                  unknown60e0a9e1 = uint128(block.number)
                                                                  stor8 = uint128(ext_call.return_data[0])
                                                                  log 0x71475f2f: uint128(ext_call.return_data[0])
                                                                  require uint128(ext_call.return_data[0]) <= LOCK8605463013()
                                                                  uint128(stor9) = uint128(ext_call.return_data[0])
                                                              mem[ceil32(return_data.size) + 128] = 0xc4f59f9b00000000000000000000000000000000000000000000000000000000
                                                              static call 0xac614884b52dbab8728476b5d50f0d672baed31f.getRewardTokens() with:
                                                                      gas gas_remaining wei
                                                              if not ext_call.success:
                                                                  revert with ext_call.return_data[0 len return_data.size]
                                                              if ext_call.success:
                                                                  mem[ceil32(return_data.size) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                  if (2 * ceil32(return_data.size)) + 128 > LOCK8605463013() or 2 * ceil32(return_data.size) < ceil32(return_data.size):
                                                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
                                                                  require return_data.size >=′ 32
                                                                  require mem[ceil32(return_data.size) + 128] <= LOCK8605463013()
                                                                  require ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 159 <′ ceil32(return_data.size) + return_data.size + 128
                                                                  if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 128] + 128] > LOCK8605463013():
                                                                      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)


