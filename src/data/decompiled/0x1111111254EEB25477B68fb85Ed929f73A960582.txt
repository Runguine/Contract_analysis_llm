# Palkeoramix decompiler. 

def storage:
  owner is address at storage 0
  nonce is mapping of uint256 at storage 1
  remainingRaw is mapping of uint256 at storage 2
  invalidatorForOrderRFQ is mapping of uint256 at storage 3

def invalidatorForOrderRFQ(address maker, uint256 slot): # not payable
  require calldata.size - 4 >=′ 64
  require maker == maker
  return invalidatorForOrderRFQ[address(maker)][slot]

def nonce(address _param1): # not payable
  require calldata.size - 4 >=′ 32
  require _param1 == _param1
  return nonce[_param1]

def remainingRaw(bytes32 orderHash): # not payable
  require calldata.size - 4 >=′ 32
  return remainingRaw[orderHash]

def owner(): # not payable
  return owner

#
#  Regular functions
#

def destroy(): # not payable
  if owner != caller:
      revert with 0, 'Ownable: caller is not the owner'
  selfdestruct(caller)

def _fallback(?) payable: # default function
  if calldata.size < 4:
      require not calldata.size
      if not caller - tx.origin:
          revert with EthDepositRejected()
      stop
  if remainingRaw(bytes32 orderHash) > uint32(call.func_hash) >> 224:
      if fillOrderRFQTo(tuple order, bytes signature, uint256 flagsAndAmount, address target) <= uint32(call.func_hash) >> 224:
          if nonce(address _param1) > uint32(call.func_hash) >> 224:
              if timestampBelow(uint256 time) > uint32(call.func_hash) >> 224:
                  if fillOrderRFQTo(tuple order, bytes signature, uint256 flagsAndAmount, address target) == uint32(call.func_hash) >> 224:
                      require calldata.size - 4 >=′ 320
                      require calldata.size - 4 >=′ 224
                      require cd[36] == address(cd[36])
                      require cd[68] == address(cd[68])
                      require cd[100] == address(cd[100])
                      require cd[132] == address(cd[132])
                      require cd[228] <= LOCK8605463013()
                      require cd[228] + 35 <′ calldata.size
                      require ('cd', 228).length <= LOCK8605463013()
                      require cd[228] + ('cd', 228).length + 36 <= calldata.size
                      require cd[292] == address(cd[292])
                      if this.address != 0x1111111254eeb25477b68fb85ed929f73a960582:
                          if Mask(1, 254, cd[260]):
                      else:
                  else:
                      require fillOrder(tuple order, bytes signature, bytes interaction, uint256 makingAmount, uint256 takingAmount, uint256 skipPermitAndThresholdAmount) == uint32(call.func_hash) >> 224
                      require calldata.size - 4 >=′ 192
                      require cd[4] <= LOCK8605463013()
                      require calldata.size + -cd[4] - 4 >=′ 320
                      require cd[36] <= LOCK8605463013()
                      require cd[36] + 35 <′ calldata.size
                      require ('cd', 36).length <= LOCK8605463013()
                      require cd[36] + ('cd', 36).length + 36 <= calldata.size
                      require cd[68] <= LOCK8605463013()
                      require cd[68] + 35 <′ calldata.size
                      require ('cd', 68).length <= LOCK8605463013()
                      require cd[68] + ('cd', 68).length + 36 <= calldata.size
                      if not caller:
                          revert with ZeroTargetIsForbidden()
                      if 0x1111111254eeb25477b68fb85ed929f73a960582 == this.address:
                      require ('cd', 4)[8] <′ calldata.size + -cd[4] - 35
                      require cd[(cd[4] + ('cd', 4)[8] + 4)] <= LOCK8605463013()
                      require cd[4] + ('cd', 4)[8] + 36 <=′ calldata.size - cd[(cd[4] + ('cd', 4)[8] + 4)]
              else:
                  if timestampBelow(uint256 time) == uint32(call.func_hash) >> 224:
                      require not call.value
                      require calldata.size - 4 >=′ 32
                      return (block.timestamp < cd[4])
                  if checkPredicate(tuple order) == uint32(call.func_hash) >> 224:
                      require not call.value
                      require calldata.size - 4 >=′ 32
                      require cd[4] <= LOCK8605463013()
                      require calldata.size + -cd[4] - 4 >=′ 320
                      require ('cd', 4)[8] <′ calldata.size + -cd[4] - 35
                      require cd[(cd[4] + ('cd', 4)[8] + 4)] <= LOCK8605463013()
                      require cd[4] + ('cd', 4)[8] + 36 <=′ calldata.size - cd[(cd[4] + ('cd', 4)[8] + 4)]
                      require 0 <= cd[(cd[4] + ('cd', 4)[8] + 4)]
                      revert with IncorrectDataLength()
                  require eq(uint256 value, bytes data) == uint32(call.func_hash) >> 224
                  require not call.value
                  require calldata.size - 4 >=′ 64
                  require cd[36] <= LOCK8605463013()
                  require cd[36] + 35 <′ calldata.size
                  require ('cd', 36).length <= LOCK8605463013()
                  require cd[36] + ('cd', 36).length + 36 <= calldata.size
                  if ('cd', 36).length < 4:
                      revert with IncorrectDataLength()
                  if ('cd', 36).length < 36:
                      revert with IncorrectDataLength()
                  if not (uint32(('cd', 36)[0]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                      if block.timestamp < ('cd', 36)[0] % unknown10000000() >> 208:
                          if not nonce[address(('cd', 36)[0])]:
                              return (cd[4] == 1)
                      return not cd[4]
                  if uint32(('cd', 36)[0]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                      if uint32(('cd', 36)[0]) >> 224 >= lt(uint256 value, bytes data):
                          if (uint32(('cd', 36)[0]) >> 224) - lt(uint256 value, bytes data):
                              if not (uint32(('cd', 36)[0]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                                  if ('cd', 36).length < 68:
                                      revert with IncorrectDataLength()
                                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                              mem[128 len ('cd', 36).length] = call.data[cd[36] + 36 len ('cd', 36).length]
                              static call this.address.mem[128 len 4] with:
                                      gas gas_remaining wei
                                     args mem[132 len ('cd', 36).length - 4]
                              if return_data.size != 32 or not ext_call.success:
                                  return bool(32 == return_data.size and ext_call.success)
                              return (cd[4] == ext_call.return_data[0])
                          if ('cd', 36).length < 100:
                              revert with IncorrectDataLength()
                          if ('cd', 36).length - 100 < 4:
                              revert with IncorrectDataLength()
                          if ('cd', 36).length - 100 < 36:
                              revert with IncorrectDataLength()
                      else:
                          if (uint32(('cd', 36)[0]) >> 224) - arbitraryStaticCall(address target, bytes data):
                              if (uint32(('cd', 36)[0]) >> 224) - and(uint256 offsets, bytes data):
                                  mem[128 len ('cd', 36).length] = call.data[cd[36] + 36 len ('cd', 36).length]
                                  static call this.address.mem[128 len 4] with:
                                          gas gas_remaining wei
                                         args mem[132 len ('cd', 36).length - 4]
                                  if return_data.size != 32 or not ext_call.success:
                                      return bool(32 == return_data.size and ext_call.success)
                                  return (cd[4] == ext_call.return_data[0])
                              if ('cd', 36).length < 100:
                                  revert with IncorrectDataLength()
                              if uint32(('cd', 36)[0]):
                                  require 0 <= uint32(('cd', 36)[0])
                                  require uint32(('cd', 36)[0]) <= ('cd', 36).length - 100
                          else:
                              if ('cd', 36).length < 100:
                                  revert with IncorrectDataLength()
                              mem[128 len ('cd', 36).length - 100] = call.data[cd[36] + 136 len ('cd', 36).length - 100]
                              static call ('cd', 36)[0].mem[128 len 4] with:
                                      gas gas_remaining wei
                                     args mem[132 len ('cd', 36).length - 104]
                              if return_data.size != 32 or not ext_call.success:
                                  revert with ArbitraryStaticCallFailed()
                              if return_data.size != 32 or not ext_call.success:
                                  revert with ArbitraryStaticCallFailed()
                  else:
                      if uint32(('cd', 36)[0]) >> 224 < eq(uint256 value, bytes data):
                          if (uint32(('cd', 36)[0]) >> 224) - gt(uint256 value, bytes data):
                              if not (uint32(('cd', 36)[0]) >> 224) - timestampBelow(uint256 time):
                                  if block.timestamp < ('cd', 36)[0]:
                                      return (cd[4] == 1)
                                  return not cd[4]
                              mem[128 len ('cd', 36).length] = call.data[cd[36] + 36 len ('cd', 36).length]
                              static call this.address.mem[128 len 4] with:
                                      gas gas_remaining wei
                                     args mem[132 len ('cd', 36).length - 4]
                              if return_data.size != 32 or not ext_call.success:
                                  return bool(32 == return_data.size and ext_call.success)
                              return (cd[4] == ext_call.return_data[0])
                          if ('cd', 36).length < 100:
                              revert with IncorrectDataLength()
                          if ('cd', 36).length - 100 < 4:
                              revert with IncorrectDataLength()
                          if ('cd', 36).length - 100 < 36:
                              revert with IncorrectDataLength()
                      else:
                          if not (uint32(('cd', 36)[0]) >> 224) - eq(uint256 value, bytes data):
                              if ('cd', 36).length < 100:
                                  revert with IncorrectDataLength()
                              if ('cd', 36).length - 100 < 4:
                                  revert with IncorrectDataLength()
                              if ('cd', 36).length - 100 < 36:
                                  revert with IncorrectDataLength()
                          else:
                              if (uint32(('cd', 36)[0]) >> 224) - or(uint256 offsets, bytes data):
                                  mem[128 len ('cd', 36).length] = call.data[cd[36] + 36 len ('cd', 36).length]
                                  static call this.address.mem[128 len 4] with:
                                          gas gas_remaining wei
                                         args mem[132 len ('cd', 36).length - 4]
                                  if return_data.size != 32 or not ext_call.success:
                                      return bool(32 == return_data.size and ext_call.success)
                                  return (cd[4] == ext_call.return_data[0])
                              if ('cd', 36).length < 100:
                                  revert with IncorrectDataLength()
                              if uint32(('cd', 36)[0]):
                                  require 0 <= uint32(('cd', 36)[0])
                                  require uint32(('cd', 36)[0]) <= ('cd', 36).length - 100
          else:
              if advanceNonce(uint8 amount) > uint32(call.func_hash) >> 224:
                  if nonce(address _param1) == uint32(call.func_hash) >> 224:
                      require not call.value
                      require calldata.size - 4 >=′ 32
                      require cd[4] == address(cd[4])
                      return nonce[cd[4]]
                  if uint32(call.func_hash) >> 224 != fillOrderRFQToWithPermit(tuple order, bytes signature, uint256 flagsAndAmount, address target, bytes permit):
                      require renounceOwnership() == uint32(call.func_hash) >> 224
                      require not call.value
                      if owner != caller:
                          revert with 0, 'Ownable: caller is not the owner'
                      owner = 0
                      log OwnershipTransferred(
                            address previousOwner=owner,
                            address newOwner=0)
                      stop
                  require not call.value
                  require calldata.size - 4 >=′ 352
                  require calldata.size - 4 >=′ 224
                  require cd[36] == address(cd[36])
                  require cd[68] == address(cd[68])
                  require cd[100] == address(cd[100])
                  require cd[132] == address(cd[132])
                  require cd[228] <= LOCK8605463013()
                  require cd[228] + 35 <′ calldata.size
                  require ('cd', 228).length <= LOCK8605463013()
                  require cd[228] + ('cd', 228).length + 36 <= calldata.size
                  require cd[292] == address(cd[292])
                  require cd[324] <= LOCK8605463013()
                  require cd[324] + 35 <′ calldata.size
                  require ('cd', 324).length <= LOCK8605463013()
                  require cd[324] + ('cd', 324).length + 36 <= calldata.size
              else:
                  if advanceNonce(uint8 amount) == uint32(call.func_hash) >> 224:
                      require not call.value
                      require calldata.size - 4 >=′ 32
                      require cd[4] == uint8(cd[4])
                      if not -uint8(cd[4]):
                          revert with AdvanceNonceFailed()
                      if nonce[caller] > uint8(cd[4]) + nonce[caller]:
                          revert with 0, 17
                      nonce[caller] += uint8(cd[4])
                      log NonceIncreased(
                            address maker=(uint8(cd[4]) + nonce[caller]),
                            uint256 newNonce=caller)
                      stop
                  if uint32(call.func_hash) >> 224 != or(uint256 offsets, bytes data):
                      require rescueFunds(address token, uint256 amount) == uint32(call.func_hash) >> 224
                      require not call.value
                      require calldata.size - 4 >=′ 64
                      require cd[4] == address(cd[4])
                      if owner != caller:
                          revert with 0, 'Ownable: caller is not the owner'
                      if cd[36]:
                          if not address(cd[4]):
                              if eth.balance(this.address) < cd[36]:
                                  revert with InsufficientBalance()
                              call caller with:
                                 value cd[36] wei
                                   gas 5000 wei
                              if not ext_call.success:
                                  revert with ETHTransferFailed()
                          else:
                              if address(cd[4]) != 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee:
                                  call address(cd[4]).transfer(address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args caller, cd[36]
                                  if not ext_call.success:
                                      revert with SafeTransferFailed()
                                  if not return_data.size:
                                      if ext_code.size(address(cd[4])) <= 0:
                                          revert with SafeTransferFailed()
                                  else:
                                      if return_data.size <= 31 or ext_call.return_data[0] != 1:
                                          revert with SafeTransferFailed()
                              else:
                                  if eth.balance(this.address) < cd[36]:
                                      revert with InsufficientBalance()
                                  call caller with:
                                     value cd[36] wei
                                       gas 5000 wei
                                  if not ext_call.success:
                                      revert with ETHTransferFailed()
                      stop
                  require not call.value
                  require calldata.size - 4 >=′ 64
                  require cd[36] <= LOCK8605463013()
                  require cd[36] + 35 <′ calldata.size
                  require ('cd', 36).length <= LOCK8605463013()
                  require cd[36] + ('cd', 36).length + 36 <= calldata.size
                  if not uint32(cd[4]):
                      return 0
                  require 0 <= uint32(cd[4])
                  require uint32(cd[4]) <= ('cd', 36).length
                  if uint32(cd[4]) < 4:
                      revert with IncorrectDataLength()
                  if uint32(cd[4]) < 36:
                      revert with IncorrectDataLength()
                  if not (uint32(('cd', 36)[0]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                      if block.timestamp < ('cd', 36)[0] % unknown10000000() >> 208:
                  else:
                      if uint32(('cd', 36)[0]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                          if uint32(('cd', 36)[0]) >> 224 >= lt(uint256 value, bytes data):
                              if not (uint32(('cd', 36)[0]) >> 224) - lt(uint256 value, bytes data):
                                  if uint32(cd[4]) < 100:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(('cd', 36)[0]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                                      if uint32(cd[4]) < 68:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[128 len uint32(cd[4])] = call.data[cd[36] + 36 len uint32(cd[4])]
                                      static call this.address.mem[128 len 4] with:
                                              gas gas_remaining wei
                                             args mem[132 len uint32(cd[4]) - 4]
                          else:
                              if (uint32(('cd', 36)[0]) >> 224) - arbitraryStaticCall(address target, bytes data):
                                  if not (uint32(('cd', 36)[0]) >> 224) - and(uint256 offsets, bytes data):
                                      if uint32(cd[4]) < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[128 len uint32(cd[4])] = call.data[cd[36] + 36 len uint32(cd[4])]
                                      static call this.address.mem[128 len 4] with:
                                              gas gas_remaining wei
                                             args mem[132 len uint32(cd[4]) - 4]
                              else:
                                  if uint32(cd[4]) < 100:
                                      revert with IncorrectDataLength()
                                  mem[128 len uint32(cd[4]) - 100] = call.data[cd[36] + 136 len uint32(cd[4]) - 100]
                                  static call ('cd', 36)[0].mem[128 len 4] with:
                                          gas gas_remaining wei
                                         args mem[132 len uint32(cd[4]) - 104]
                      else:
                          if uint32(('cd', 36)[0]) >> 224 >= eq(uint256 value, bytes data):
                              if not (uint32(('cd', 36)[0]) >> 224) - eq(uint256 value, bytes data):
                                  if uint32(cd[4]) < 100:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(('cd', 36)[0]) >> 224) - or(uint256 offsets, bytes data):
                                      if uint32(cd[4]) < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[128 len uint32(cd[4])] = call.data[cd[36] + 36 len uint32(cd[4])]
                                      static call this.address.mem[128 len 4] with:
                                              gas gas_remaining wei
                                             args mem[132 len uint32(cd[4]) - 4]
                          else:
                              if not (uint32(('cd', 36)[0]) >> 224) - gt(uint256 value, bytes data):
                                  if uint32(cd[4]) < 100:
                                      revert with IncorrectDataLength()
                              else:
                                  if (uint32(('cd', 36)[0]) >> 224) - timestampBelow(uint256 time):
                                      mem[128 len uint32(cd[4])] = call.data[cd[36] + 36 len uint32(cd[4])]
                                      static call this.address.mem[128 len 4] with:
                                              gas gas_remaining wei
                                             args mem[132 len uint32(cd[4]) - 4]
      else:
          if cancelOrder(tuple order) <= uint32(call.func_hash) >> 224:
              if fillOrderRFQ(tuple order, bytes signature, uint256 flagsAndAmount) <= uint32(call.func_hash) >> 224:
                  if fillOrderRFQ(tuple order, bytes signature, uint256 flagsAndAmount) == uint32(call.func_hash) >> 224:
                      require calldata.size - 4 >=′ 288
                      require calldata.size - 4 >=′ 224
                      require cd[36] == address(cd[36])
                      require cd[68] == address(cd[68])
                      require cd[100] == address(cd[100])
                      require cd[132] == address(cd[132])
                      require cd[228] <= LOCK8605463013()
                      require cd[228] + 35 <′ calldata.size
                      require ('cd', 228).length <= LOCK8605463013()
                      require cd[228] + ('cd', 228).length + 36 <= calldata.size
                      if this.address != 0x1111111254eeb25477b68fb85ed929f73a960582:
                          if not Mask(1, 254, cd[260]):
                              if address(cd[100]):
                          else:
                              if Mask(1, 253, cd[260]):
                      else:
                          if Mask(1, 254, cd[260]):
                  else:
                      if uint32(call.func_hash) >> 224 != gt(uint256 value, bytes data):
                          require invalidatorForOrderRFQ(address maker, uint256 slot) == uint32(call.func_hash) >> 224
                          require not call.value
                          require calldata.size - 4 >=′ 64
                          require cd[4] == address(cd[4])
                          return invalidatorForOrderRFQ[address(cd[4])][cd[36]]
                      require not call.value
                      require calldata.size - 4 >=′ 64
                      require cd[36] <= LOCK8605463013()
                      require cd[36] + 35 <′ calldata.size
                      require ('cd', 36).length <= LOCK8605463013()
                      require cd[36] + ('cd', 36).length + 36 <= calldata.size
                      if ('cd', 36).length < 4:
                          revert with IncorrectDataLength()
                      if ('cd', 36).length < 36:
                          revert with IncorrectDataLength()
                      if not (uint32(('cd', 36)[0]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                          if block.timestamp < ('cd', 36)[0] % unknown10000000() >> 208:
                              if not nonce[address(('cd', 36)[0])]:
                                  return (1 > cd[4])
                          return (0 > cd[4])
                      if uint32(('cd', 36)[0]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                          if uint32(('cd', 36)[0]) >> 224 >= lt(uint256 value, bytes data):
                              if (uint32(('cd', 36)[0]) >> 224) - lt(uint256 value, bytes data):
                                  if not (uint32(('cd', 36)[0]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                                      if ('cd', 36).length < 68:
                                          revert with IncorrectDataLength()
                                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                  mem[128 len ('cd', 36).length] = call.data[cd[36] + 36 len ('cd', 36).length]
                                  static call this.address.mem[128 len 4] with:
                                          gas gas_remaining wei
                                         args mem[132 len ('cd', 36).length - 4]
                                  if return_data.size != 32 or not ext_call.success:
                                      return bool(32 == return_data.size and ext_call.success)
                                  return (ext_call.return_data[0] > cd[4])
                              if ('cd', 36).length < 100:
                                  revert with IncorrectDataLength()
                              if ('cd', 36).length - 100 < 4:
                                  revert with IncorrectDataLength()
                              if ('cd', 36).length - 100 < 36:
                                  revert with IncorrectDataLength()
                              if (uint32(('cd', 36)[3]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                          else:
                              if (uint32(('cd', 36)[0]) >> 224) - arbitraryStaticCall(address target, bytes data):
                                  if (uint32(('cd', 36)[0]) >> 224) - and(uint256 offsets, bytes data):
                                      mem[128 len ('cd', 36).length] = call.data[cd[36] + 36 len ('cd', 36).length]
                                      static call this.address.mem[128 len 4] with:
                                              gas gas_remaining wei
                                             args mem[132 len ('cd', 36).length - 4]
                                      if return_data.size != 32 or not ext_call.success:
                                          return bool(32 == return_data.size and ext_call.success)
                                  else:
                                      if ('cd', 36).length < 100:
                                          revert with IncorrectDataLength()
                                      if uint32(('cd', 36)[0]):
                                          require 0 <= uint32(('cd', 36)[0])
                                          require uint32(('cd', 36)[0]) <= ('cd', 36).length - 100
                              else:
                                  if ('cd', 36).length < 100:
                                      revert with IncorrectDataLength()
                                  mem[128 len ('cd', 36).length - 100] = call.data[cd[36] + 136 len ('cd', 36).length - 100]
                                  static call ('cd', 36)[0].mem[128 len 4] with:
                                          gas gas_remaining wei
                                         args mem[132 len ('cd', 36).length - 104]
                                  if return_data.size != 32 or not ext_call.success:
                                      revert with ArbitraryStaticCallFailed()
                                  if return_data.size != 32 or not ext_call.success:
                                      revert with ArbitraryStaticCallFailed()
                      else:
                          if uint32(('cd', 36)[0]) >> 224 >= eq(uint256 value, bytes data):
                              if (uint32(('cd', 36)[0]) >> 224) - eq(uint256 value, bytes data):
                                  if (uint32(('cd', 36)[0]) >> 224) - or(uint256 offsets, bytes data):
                                      mem[128 len ('cd', 36).length] = call.data[cd[36] + 36 len ('cd', 36).length]
                                      static call this.address.mem[128 len 4] with:
                                              gas gas_remaining wei
                                             args mem[132 len ('cd', 36).length - 4]
                                      if return_data.size != 32 or not ext_call.success:
                                          return bool(32 == return_data.size and ext_call.success)
                                  else:
                                      if ('cd', 36).length < 100:
                                          revert with IncorrectDataLength()
                                      if uint32(('cd', 36)[0]):
                                          require 0 <= uint32(('cd', 36)[0])
                                          require uint32(('cd', 36)[0]) <= ('cd', 36).length - 100
                              else:
                                  if ('cd', 36).length < 100:
                                      revert with IncorrectDataLength()
                                  if ('cd', 36).length - 100 < 4:
                                      revert with IncorrectDataLength()
                                  if ('cd', 36).length - 100 < 36:
                                      revert with IncorrectDataLength()
                                  if (uint32(('cd', 36)[3]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                          else:
                              if (uint32(('cd', 36)[0]) >> 224) - gt(uint256 value, bytes data):
                                  if not (uint32(('cd', 36)[0]) >> 224) - timestampBelow(uint256 time):
                                      if block.timestamp < ('cd', 36)[0]:
                                          return (1 > cd[4])
                                      return (0 > cd[4])
                                  mem[128 len ('cd', 36).length] = call.data[cd[36] + 36 len ('cd', 36).length]
                                  static call this.address.mem[128 len 4] with:
                                          gas gas_remaining wei
                                         args mem[132 len ('cd', 36).length - 4]
                                  if return_data.size != 32 or not ext_call.success:
                                      return bool(32 == return_data.size and ext_call.success)
                              else:
                                  if ('cd', 36).length < 100:
                                      revert with IncorrectDataLength()
                                  if ('cd', 36).length - 100 < 4:
                                      revert with IncorrectDataLength()
                                  if ('cd', 36).length - 100 < 36:
                                      revert with IncorrectDataLength()
                                  if (uint32(('cd', 36)[3]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
              else:
                  if cancelOrder(tuple order) == uint32(call.func_hash) >> 224:
                      require not call.value
                      require calldata.size - 4 >=′ 32
                      require cd[4] <= LOCK8605463013()
                      require calldata.size + -cd[4] - 4 >=′ 320
                      require ('cd', 4)[2] == address(('cd', 4)[2])
                      if address(('cd', 4)[2]) != caller:
                          revert with AccessDenied()
                      require ('cd', 4)[8] <′ calldata.size + -cd[4] - 35
                      require cd[(cd[4] + ('cd', 4)[8] + 4)] <= LOCK8605463013()
                      require cd[4] + ('cd', 4)[8] + 36 <=′ calldata.size - cd[(cd[4] + ('cd', 4)[8] + 4)]
                      if this.address != 0x1111111254eeb25477b68fb85ed929f73a960582:
                          if not remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[cd[4] + 4 len 288], sha3(call.data[cd[4] + ('cd', 4)[8] + 36 len cd[(cd[4] + ('cd', 4)[8] + 4)]]))] - 1:
                              revert with AlreadyFilled()
                          log OrderCanceled(
                                address maker=sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[cd[4] + 4 len 288], sha3(call.data[cd[4] + ('cd', 4)[8] + 36 len cd[(cd[4] + ('cd', 4)[8] + 4)]]))),
                                bytes32 orderHash=remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[cd[4] + 4 len 288], sha3(call.data[cd[4] + ('cd', 4)[8] + 36 len cd[(cd[4] + ('cd', 4)[8] + 4)]]))],
                                uint256 remainingRaw=caller)
                          remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[cd[4] + 4 len 288], sha3(call.data[cd[4] + ('cd', 4)[8] + 36 len cd[(cd[4] + ('cd', 4)[8] + 4)]]))] = 1
                          return remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[cd[4] + 4 len 288], sha3(call.data[cd[4] + ('cd', 4)[8] + 36 len cd[(cd[4] + ('cd', 4)[8] + 4)]]))], 
                                 sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[cd[4] + 4 len 288], sha3(call.data[cd[4] + ('cd', 4)[8] + 36 len cd[(cd[4] + ('cd', 4)[8] + 4)]])))
                      if 1 != chainid:
                          if not remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[cd[4] + 4 len 288], sha3(call.data[cd[4] + ('cd', 4)[8] + 36 len cd[(cd[4] + ('cd', 4)[8] + 4)]]))] - 1:
                              revert with AlreadyFilled()
                          log OrderCanceled(
                                address maker=sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[cd[4] + 4 len 288], sha3(call.data[cd[4] + ('cd', 4)[8] + 36 len cd[(cd[4] + ('cd', 4)[8] + 4)]]))),
                                bytes32 orderHash=remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[cd[4] + 4 len 288], sha3(call.data[cd[4] + ('cd', 4)[8] + 36 len cd[(cd[4] + ('cd', 4)[8] + 4)]]))],
                                uint256 remainingRaw=caller)
                          remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[cd[4] + 4 len 288], sha3(call.data[cd[4] + ('cd', 4)[8] + 36 len cd[(cd[4] + ('cd', 4)[8] + 4)]]))] = 1
                          return remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[cd[4] + 4 len 288], sha3(call.data[cd[4] + ('cd', 4)[8] + 36 len cd[(cd[4] + ('cd', 4)[8] + 4)]]))], 
                                 sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[cd[4] + 4 len 288], sha3(call.data[cd[4] + ('cd', 4)[8] + 36 len cd[(cd[4] + ('cd', 4)[8] + 4)]])))
                      if not remainingRaw[6401][0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[cd[4] + 4 len 288], sha3(call.data[cd[4] + ('cd', 4)[8] + 36 len cd[(cd[4] + ('cd', 4)[8] + 4)]]))] - 1:
                          revert with AlreadyFilled()
                      log OrderCanceled(
                            address maker=sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[cd[4] + 4 len 288], sha3(call.data[cd[4] + ('cd', 4)[8] + 36 len cd[(cd[4] + ('cd', 4)[8] + 4)]]))),
                            bytes32 orderHash=remainingRaw[6401][0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[cd[4] + 4 len 288], sha3(call.data[cd[4] + ('cd', 4)[8] + 36 len cd[(cd[4] + ('cd', 4)[8] + 4)]]))],
                            uint256 remainingRaw=caller)
                      remainingRaw[6401][0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[cd[4] + 4 len 288], sha3(call.data[cd[4] + ('cd', 4)[8] + 36 len cd[(cd[4] + ('cd', 4)[8] + 4)]]))] = 1
                      return remainingRaw[6401][0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[cd[4] + 4 len 288], sha3(call.data[cd[4] + ('cd', 4)[8] + 36 len cd[(cd[4] + ('cd', 4)[8] + 4)]]))], 
                             sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[cd[4] + 4 len 288], sha3(call.data[cd[4] + ('cd', 4)[8] + 36 len cd[(cd[4] + ('cd', 4)[8] + 4)]])))
                  if hashOrder(tuple order) == uint32(call.func_hash) >> 224:
                      require not call.value
                      require calldata.size - 4 >=′ 32
                      require cd[4] <= LOCK8605463013()
                      require calldata.size + -cd[4] - 4 >=′ 320
                      require ('cd', 4)[8] <′ calldata.size + -cd[4] - 35
                      require cd[(cd[4] + ('cd', 4)[8] + 4)] <= LOCK8605463013()
                      require cd[4] + ('cd', 4)[8] + 36 <=′ calldata.size - cd[(cd[4] + ('cd', 4)[8] + 4)]
                      if this.address != 0x1111111254eeb25477b68fb85ed929f73a960582:
                          return sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[cd[4] + 4 len 288], sha3(call.data[cd[4] + ('cd', 4)[8] + 36 len cd[(cd[4] + ('cd', 4)[8] + 4)]])))
                      if 1 != chainid:
                          return sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[cd[4] + 4 len 288], sha3(call.data[cd[4] + ('cd', 4)[8] + 36 len cd[(cd[4] + ('cd', 4)[8] + 4)]])))
                      return sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[cd[4] + 4 len 288], sha3(call.data[cd[4] + ('cd', 4)[8] + 36 len cd[(cd[4] + ('cd', 4)[8] + 4)]])))
                  require unoswapToWithPermit(address recipient, address srcToken, uint256 amount, uint256 minReturn, uint256[] pools, bytes permit) == uint32(call.func_hash) >> 224
                  require not call.value
                  require calldata.size - 4 >=′ 192
                  require cd[4] == address(cd[4])
                  require cd[36] == address(cd[36])
                  require cd[132] <= LOCK8605463013()
                  require cd[132] + 35 <′ calldata.size
                  require ('cd', 132).length <= LOCK8605463013()
                  require cd[132] + (32 * ('cd', 132).length) + 36 <= calldata.size
                  require cd[164] <= LOCK8605463013()
                  require cd[164] + 35 <′ calldata.size
                  require ('cd', 164).length <= LOCK8605463013()
                  require cd[164] + ('cd', 164).length + 36 <= calldata.size
                  if not -('cd', 164).length + 224:
                      call address(cd[36]).permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
                           gas gas_remaining wei
                          args call.data[cd[164] + 36 len ('cd', 164).length]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      if not return_data.size:
                          if ext_code.size(address(cd[36])) <= 0:
                              revert with ext_call.return_data[0 len return_data.size]
                      else:
                          if return_data.size <= 31 or ext_call.return_data[0] != 1:
                              revert with ext_call.return_data[0 len return_data.size]
                  else:
                      if -('cd', 164).length + 256:
                          revert with 'h'XW'
                      call address(cd[36]).permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) with:
                           gas gas_remaining wei
                          args call.data[cd[164] + 36 len ('cd', 164).length]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      if return_data.size:
          else:
              if swap(address executor, tuple desc, bytes permit, bytes data) <= uint32(call.func_hash) >> 224:
                  if swap(address executor, tuple desc, bytes permit, bytes data) == uint32(call.func_hash) >> 224:
                      require calldata.size - 4 >=′ 320
                      require cd[4] == address(cd[4])
                      require calldata.size - 36 >=′ 224
                      require cd[260] <= LOCK8605463013()
                      require cd[260] + 35 <′ calldata.size
                      require ('cd', 260).length <= LOCK8605463013()
                      require cd[260] + ('cd', 260).length + 36 <= calldata.size
                      require cd[292] <= LOCK8605463013()
                      require cd[292] + 35 <′ calldata.size
                      require ('cd', 292).length <= LOCK8605463013()
                      require cd[292] + ('cd', 292).length + 36 <= calldata.size
                      if not -cd[196]:
                          revert with ZeroMinReturn()
                      require cd[36] == address(cd[36])
                      require cd[68] == address(cd[68])
                  else:
                      if uint32(call.func_hash) >> 224 != uniswapV3SwapToWithPermit(address recipient, address srcToken, uint256 amount, uint256 minReturn, uint256[] pools, bytes permit):
                          require timestampBelowAndNonceEquals(uint256 timeNonceAccount) == uint32(call.func_hash) >> 224
                          require not call.value
                          require calldata.size - 4 >=′ 32
                          if block.timestamp >= cd[4] % unknown10000000() >> 208:
                              return (block.timestamp < cd[4] % unknown10000000() >> 208)
                          return not nonce[address(cd[4])]
                      require not call.value
                      require calldata.size - 4 >=′ 192
                      require cd[4] == address(cd[4])
                      require cd[36] == address(cd[36])
                      require cd[132] <= LOCK8605463013()
                      require cd[132] + 35 <′ calldata.size
                      require ('cd', 132).length <= LOCK8605463013()
                      require cd[132] + (32 * ('cd', 132).length) + 36 <= calldata.size
                      require cd[164] <= LOCK8605463013()
                      require cd[164] + 35 <′ calldata.size
                      require ('cd', 164).length <= LOCK8605463013()
                      require cd[164] + ('cd', 164).length + 36 <= calldata.size
                      if -('cd', 164).length + 224:
                          if -('cd', 164).length + 256:
                              revert with 'h'XW'
                          call address(cd[36]).permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) with:
                               gas gas_remaining wei
                              args call.data[cd[164] + 36 len ('cd', 164).length]
                      else:
                          call address(cd[36]).permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
                               gas gas_remaining wei
                              args call.data[cd[164] + 36 len ('cd', 164).length]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      if not return_data.size:
                          if ext_code.size(address(cd[36])) <= 0:
                              revert with ext_call.return_data[0 len return_data.size]
                      else:
                          if return_data.size <= 31 or ext_call.return_data[0] != 1:
                              revert with ext_call.return_data[0 len return_data.size]
              else:
                  if unoswap(address srcToken, uint256 amount, uint256 minReturn, uint256[] pools) == uint32(call.func_hash) >> 224:
                      require calldata.size - 4 >=′ 128
                      require cd[4] == address(cd[4])
                      require cd[100] <= LOCK8605463013()
                      require cd[100] + 35 <′ calldata.size
                      require ('cd', 100).length <= LOCK8605463013()
                      require cd[100] + (32 * ('cd', 100).length) + 36 <= calldata.size
                      if cd[36] > LOCK8605463013():
                          revert with SwapAmountTooLarge()
                      if not cd[4]:
                          if cd[36] != call.value:
                              revert with InvalidMsgValue()
                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
                             value cd[36] wei
                               gas gas_remaining wei
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transfer(address recipient, uint256 amount) with:
                               gas gas_remaining wei
                              args address(('cd', 100)[0]), cd[36]
                      else:
                          if call.value:
                              revert with InvalidMsgValue()
                          call cd[4].transferFrom(address sender, address recipient, uint256 amount) with:
                               gas gas_remaining wei
                              args caller, address(('cd', 100)[0]), cd[36]
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          if return_data.size and return_data.size <= 31 or ext_call.return_data[0] != 1:
                              revert with ERC20TransferFailed()
                  else:
                      require clipperSwapTo(address clipperExchange, address recipient, address srcToken, address dstToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, bytes32 r, bytes32 vs) == uint32(call.func_hash) >> 224
                      require calldata.size - 4 >=′ 288
                      require cd[4] == address(cd[4])
                      require cd[36] == address(cd[36])
                      require cd[68] == address(cd[68])
                      require cd[100] == address(cd[100])
                      if not address(cd[68]):
                          if cd[132] != call.value:
                              revert with InvalidMsgValue()
                          if not address(cd[68]):
                              call cd[4].sellEthForToken(address outputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                                 value cd[132] wei
                                   gas gas_remaining wei
                                  args cd[100], cd[132], cd[164], cd[196], cd[36], (bool(cd[260]) >> 255) + 27, cd[228], 2 * cd[260], Array(len=mem[420 len 31], data=5709241402184)
                              if not ext_call.success:
                                  revert with ext_call.return_data[0 len return_data.size]
                          else:
                              if not address(cd[100]):
                                  if not cd[100] == 1:
                                      call cd[4].sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                                           gas gas_remaining wei
                                          args cd[68], cd[132], cd[164], cd[196], cd[36], (bool(cd[260]) >> 255) + 27, cd[228], 2 * cd[260], Array(len=mem[420 len 31], data=5709241402184)
                                  else:
                                      call cd[4].sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                                           gas gas_remaining wei
                                          args cd[68], cd[132], cd[164], cd[196], this.address, (bool(cd[260]) >> 255) + 27, cd[228], 2 * cd[260], Array(len=mem[420 len 31], data=5709241402184)
                                  if not ext_call.success:
                                      revert with ext_call.return_data[0 len return_data.size]
                                  if not address(cd[100]) - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
                                         value cd[164] wei
                                           gas gas_remaining wei
                                      if not ext_call.success:
                                          revert with ext_call.return_data[0 len return_data.size]
                                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transfer(address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args cd[36], cd[164]
                              else:
                                  if address(cd[100]) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                      call cd[4].swap(address inputToken, address outputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                                           gas gas_remaining wei
                                          args cd[68], cd[100], cd[132], cd[164], cd[196], cd[36], (bool(cd[260]) >> 255) + 27, cd[228], 2 * cd[260], Array(len=mem[452 len 31], data=5709241402184)
                                      if not ext_call.success:
                                          revert with ext_call.return_data[0 len return_data.size]
                                  else:
                                      if not cd[100] == 1:
                                          call cd[4].sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                                               gas gas_remaining wei
                                              args cd[68], cd[132], cd[164], cd[196], cd[36], (bool(cd[260]) >> 255) + 27, cd[228], 2 * cd[260], Array(len=mem[420 len 31], data=5709241402184)
                                      else:
                                          call cd[4].sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                                               gas gas_remaining wei
                                              args cd[68], cd[132], cd[164], cd[196], this.address, (bool(cd[260]) >> 255) + 27, cd[228], 2 * cd[260], Array(len=mem[420 len 31], data=5709241402184)
                                      if not ext_call.success:
                                          revert with ext_call.return_data[0 len return_data.size]
                                      if not address(cd[100]) - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
                                             value cd[164] wei
                                               gas gas_remaining wei
                                          if not ext_call.success:
                                              revert with ext_call.return_data[0 len return_data.size]
                                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transfer(address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args cd[36], cd[164]
                          return cd[164]
                      if call.value:
                          revert with InvalidMsgValue()
                      if not address(cd[68]) - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                               gas gas_remaining wei
                              args caller, this.address, cd[132]
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.withdraw(uint256 amount) with:
                               gas gas_remaining wei
                              args cd[132]
                          call cd[4].sellEthForToken(address outputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                             value cd[132] wei
                               gas gas_remaining wei
                              args cd[100], cd[132], cd[164], cd[196], cd[36], (bool(cd[260]) >> 255) + 27, cd[228], 2 * cd[260], Array(len=mem[420 len 31], data=5709241402184)
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          return cd[164]
                      call address(cd[68]).transferFrom(address sender, address recipient, uint256 amount) with:
                           gas gas_remaining wei
                          args caller, cd[4], cd[132]
                      if not ext_call.success:
                          revert with SafeTransferFromFailed()
                      if not return_data.size:
                          if ext_code.size(address(cd[68])) <= 0:
                              revert with SafeTransferFromFailed()
                      else:
                          if return_data.size <= 31 or ext_call.return_data[0] != 1:
                              revert with SafeTransferFromFailed()
                      if not address(cd[68]):
                          call cd[4].sellEthForToken(address outputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                             value cd[132] wei
                               gas gas_remaining wei
                              args cd[100], cd[132], cd[164], cd[196], cd[36], (bool(cd[260]) >> 255) + 27, cd[228], 2 * cd[260], Array(len=mem[420 len 31], data=5709241402184)
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          return cd[164]
                      if not address(cd[100]):
                          if not cd[100] == 1:
                              call cd[4].sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                                   gas gas_remaining wei
                                  args cd[68], cd[132], cd[164], cd[196], cd[36], (bool(cd[260]) >> 255) + 27, cd[228], 2 * cd[260], Array(len=mem[420 len 31], data=5709241402184)
                          else:
                              call cd[4].sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                                   gas gas_remaining wei
                                  args cd[68], cd[132], cd[164], cd[196], this.address, (bool(cd[260]) >> 255) + 27, cd[228], 2 * cd[260], Array(len=mem[420 len 31], data=5709241402184)
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          if not address(cd[100]) - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                              call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
                                 value cd[164] wei
                                   gas gas_remaining wei
                              if not ext_call.success:
                                  revert with ext_call.return_data[0 len return_data.size]
                              call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transfer(address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args cd[36], cd[164]
                      else:
                          if address(cd[100]) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                              call cd[4].swap(address inputToken, address outputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                                   gas gas_remaining wei
                                  args cd[68], cd[100], cd[132], cd[164], cd[196], cd[36], (bool(cd[260]) >> 255) + 27, cd[228], 2 * cd[260], Array(len=mem[452 len 31], data=5709241402184)
                              if not ext_call.success:
                                  revert with ext_call.return_data[0 len return_data.size]
                              return cd[164]
                          if not cd[100] == 1:
                              call cd[4].sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                                   gas gas_remaining wei
                                  args cd[68], cd[132], cd[164], cd[196], cd[36], (bool(cd[260]) >> 255) + 27, cd[228], 2 * cd[260], Array(len=mem[420 len 31], data=5709241402184)
                          else:
                              call cd[4].sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                                   gas gas_remaining wei
                                  args cd[68], cd[132], cd[164], cd[196], this.address, (bool(cd[260]) >> 255) + 27, cd[228], 2 * cd[260], Array(len=mem[420 len 31], data=5709241402184)
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          if not address(cd[100]) - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                              call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
                                 value cd[164] wei
                                   gas gas_remaining wei
  else:
      if arbitraryStaticCall(address target, bytes data) <= uint32(call.func_hash) >> 224:
          if fillOrderToWithPermit(tuple order, bytes signature, bytes interaction, uint256 makingAmount, uint256 takingAmount, uint256 skipPermitAndThresholdAmount, address target, bytes permit) <= uint32(call.func_hash) >> 224:
              if transferOwnership(address newOwner) <= uint32(call.func_hash) >> 224:
                  if transferOwnership(address newOwner) == uint32(call.func_hash) >> 224:
                      require not call.value
                      require calldata.size - 4 >=′ 32
                      require cd[4] == address(cd[4])
                      if owner != caller:
                          revert with 0, 'Ownable: caller is not the owner'
                      if not address(cd[4]):
                          revert with 0, 'Ownable: new owner is the zero address'
                      owner = address(cd[4])
                      log OwnershipTransferred(
                            address previousOwner=owner,
                            address newOwner=address(cd[4]))
                  else:
                      if unoswapTo(address recipient, address srcToken, uint256 amount, uint256 minReturn, uint256[] pools) == uint32(call.func_hash) >> 224:
                          require calldata.size - 4 >=′ 160
                          require cd[4] == address(cd[4])
                          require cd[36] == address(cd[36])
                          require cd[132] <= LOCK8605463013()
                          require cd[132] + 35 <′ calldata.size
                          require ('cd', 132).length <= LOCK8605463013()
                          require cd[132] + (32 * ('cd', 132).length) + 36 <= calldata.size
                          if cd[68] > LOCK8605463013():
                              revert with SwapAmountTooLarge()
                          if not cd[36]:
                              if cd[68] != call.value:
                                  revert with InvalidMsgValue()
                              call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
                                 value cd[68] wei
                                   gas gas_remaining wei
                              if not ext_call.success:
                                  revert with ext_call.return_data[0 len return_data.size]
                              call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transfer(address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args address(('cd', 132)[0]), cd[68]
                          else:
                              if call.value:
                                  revert with InvalidMsgValue()
                              call cd[36].transferFrom(address sender, address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args caller, address(('cd', 132)[0]), cd[68]
                              if not ext_call.success:
                                  revert with ext_call.return_data[0 len return_data.size]
                              if return_data.size and return_data.size <= 31 or ext_call.return_data[0] != 1:
                                  revert with ERC20TransferFailed()
                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                      require uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes data) == uint32(call.func_hash) >> 224
                      require not call.value
                      require calldata.size - 4 >=′ 96
                      require cd[68] <= LOCK8605463013()
                      require cd[68] + 35 <′ calldata.size
                      require ('cd', 68).length <= LOCK8605463013()
                      require cd[68] + ('cd', 68).length + 36 <= calldata.size
                      static call caller.token0() with:
                              gas gas_remaining wei
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      static call caller with:
                              gas gas_remaining wei
                      static call caller.0xd with:
                              gas gas_remaining wei
                      if address(sha3(1204786273842544410698595, sha3(0, ext_call.return_data[11 len 21], ext_call.return_data[0], ext_call.return_data[0]), 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54)) xor caller:
                          revert with BadPool()
                      if cd[4] >′ 0 == 1:
                          if cd[132] == this.address == 1:
                              call ext_call.return_data[0] with:
                                   gas gas_remaining wei
                                  args caller, cd[4]
                          else:
                              call ext_call.return_data[0].token1() with:
                                   gas gas_remaining wei
                                  args cd[132], caller, cd[4]
                      else:
                          if cd[132] == this.address == 1:
                              call ext_call.return_data[0] with:
                                   gas gas_remaining wei
                                  args caller, cd[36]
                          else:
                              call ext_call.return_data[0].token1() with:
                                   gas gas_remaining wei
                                  args cd[132], caller, cd[36]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      if return_data.size and return_data.size <= 31 or ext_call.return_data[0] != 1:
                          revert with ERC20TransferFailed()
                  stop
              if fillOrderToWithPermit(tuple order, bytes signature, bytes interaction, uint256 makingAmount, uint256 takingAmount, uint256 skipPermitAndThresholdAmount, address target, bytes permit) == uint32(call.func_hash) >> 224:
                  require not call.value
                  require calldata.size - 4 >=′ 256
                  require cd[4] <= LOCK8605463013()
                  require calldata.size + -cd[4] - 4 >=′ 320
                  require cd[36] <= LOCK8605463013()
                  require cd[36] + 35 <′ calldata.size
                  require ('cd', 36).length <= LOCK8605463013()
                  require cd[36] + ('cd', 36).length + 36 <= calldata.size
                  require LOCK8605463013() >= cd[68]
                  require cd[68] + 35 <′ calldata.size
                  require ('cd', 68).length <= LOCK8605463013()
                  require cd[68] + ('cd', 68).length + 36 <= calldata.size
                  require cd[196] == address(cd[196])
                  require cd[228] <= LOCK8605463013()
                  require cd[228] + 35 <′ calldata.size
                  require ('cd', 228).length <= LOCK8605463013()
                  require cd[228] + ('cd', 228).length + 36 <= calldata.size
                  if ('cd', 228).length < 20:
                      revert with PermitLengthTooLow()
              else:
                  if uniswapV3Swap(uint256 amount, uint256 minReturn, uint256[] pools) == uint32(call.func_hash) >> 224:
                      require calldata.size - 4 >=′ 96
                      require cd[68] <= LOCK8605463013()
                      require cd[68] + 35 <′ calldata.size
                      require ('cd', 68).length <= LOCK8605463013()
                      require cd[68] + (32 * ('cd', 68).length) + 36 <= calldata.size
                      if not -('cd', 68).length:
                          revert with EmptyPools()
                      if ('cd', 68).length - 1 >= ('cd', 68).length:
                          revert with 0, 50
                      if call.value:
                          if cd[4] != call.value:
                              revert with InvalidMsgValue()
                          require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
                             value cd[4] wei
                               gas gas_remaining wei
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                      if ('cd', 68).length <= 1:
                      if 0 >= ('cd', 68).length:
                          revert with 0, 50
                      if cd[4] > 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
                          revert with 0, 'SafeCast: value doesn't fit in an int256'
                  else:
                      require fillOrderTo(tuple order_, bytes signature, bytes interaction, uint256 makingAmount, uint256 takingAmount, uint256 skipPermitAndThresholdAmount, address target) == uint32(call.func_hash) >> 224
                      require calldata.size - 4 >=′ 224
                      require cd[4] <= LOCK8605463013()
                      require calldata.size + -cd[4] - 4 >=′ 320
                      require cd[36] <= LOCK8605463013()
                      require cd[36] + 35 <′ calldata.size
                      require ('cd', 36).length <= LOCK8605463013()
                      require cd[36] + ('cd', 36).length + 36 <= calldata.size
                      require cd[68] <= LOCK8605463013()
                      require cd[68] + 35 <′ calldata.size
                      require ('cd', 68).length <= LOCK8605463013()
                      require cd[68] + ('cd', 68).length + 36 <= calldata.size
                      require cd[196] == address(cd[196])
                      if not address(cd[196]):
                          revert with ZeroTargetIsForbidden()
                      require ('cd', 4)[8] <′ calldata.size + -cd[4] - 35
                      if this.address != 0x1111111254eeb25477b68fb85ed929f73a960582:
                          require cd[(cd[4] + ('cd', 4)[8] + 4)] <= LOCK8605463013()
                      else:
          else:
              if clipperSwapToWithPermit(address clipperExchange, address recipient, address srcToken, address dstToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, bytes32 r, bytes32 vs, bytes permit) <= uint32(call.func_hash) >> 224:
                  if clipperSwapToWithPermit(address clipperExchange, address recipient, address srcToken, address dstToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, bytes32 r, bytes32 vs, bytes permit) == uint32(call.func_hash) >> 224:
                      require not call.value
                      require calldata.size - 4 >=′ 320
                      require cd[4] == address(cd[4])
                      require cd[36] == address(cd[36])
                      require cd[68] == address(cd[68])
                      require cd[100] == address(cd[100])
                      require cd[292] <= LOCK8605463013()
                      require cd[292] + 35 <′ calldata.size
                      require ('cd', 292).length <= LOCK8605463013()
                      require cd[292] + ('cd', 292).length + 36 <= calldata.size
                      if -('cd', 292).length + 224:
                          if -('cd', 292).length + 256:
                              revert with 'h'XW'
                          call address(cd[68]).permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) with:
                               gas gas_remaining wei
                              args call.data[cd[292] + 36 len ('cd', 292).length]
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          if not return_data.size:
                              if ext_code.size(address(cd[68])) <= 0:
                                  revert with ext_call.return_data[0 len return_data.size]
                          else:
                              if return_data.size <= 31 or ext_call.return_data[0] != 1:
                                  revert with ext_call.return_data[0 len return_data.size]
                      else:
                          call address(cd[68]).permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
                               gas gas_remaining wei
                              args call.data[cd[292] + 36 len ('cd', 292).length]
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          if not return_data.size:
                              if ext_code.size(address(cd[68])) <= 0:
                                  revert with ext_call.return_data[0 len return_data.size]
                          else:
                              if return_data.size <= 31 or ext_call.return_data[0] != 1:
                                  revert with ext_call.return_data[0 len return_data.size]
                          if not address(cd[68]):
                  else:
                      if uint32(call.func_hash) >> 224 != lt(uint256 value, bytes data):
                          require nonceEquals(address makerAddress, uint256 makerNonce) == uint32(call.func_hash) >> 224
                          require not call.value
                          require calldata.size - 4 >=′ 64
                          require cd[4] == address(cd[4])
                          return (nonce[address(cd[4])] == cd[36])
                      require not call.value
                      require calldata.size - 4 >=′ 64
                      require cd[36] <= LOCK8605463013()
                      require cd[36] + 35 <′ calldata.size
                      require ('cd', 36).length <= LOCK8605463013()
                      require cd[36] + ('cd', 36).length + 36 <= calldata.size
                      if ('cd', 36).length < 4:
                          revert with IncorrectDataLength()
                      if ('cd', 36).length < 36:
                          revert with IncorrectDataLength()
                      if not (uint32(('cd', 36)[0]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                          if block.timestamp < ('cd', 36)[0] % unknown10000000() >> 208:
                              if not nonce[address(('cd', 36)[0])]:
                                  return (1 < cd[4])
                          return (0 < cd[4])
                      if uint32(('cd', 36)[0]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                          if uint32(('cd', 36)[0]) >> 224 >= lt(uint256 value, bytes data):
                              if (uint32(('cd', 36)[0]) >> 224) - lt(uint256 value, bytes data):
                                  if not (uint32(('cd', 36)[0]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                                      if ('cd', 36).length < 68:
                                          revert with IncorrectDataLength()
                                      if nonce[address(('cd', 36)[0])] == ('cd', 36)[1]:
                                          return (1 < cd[4])
                                      return (0 < cd[4])
                                  mem[128 len ('cd', 36).length] = call.data[cd[36] + 36 len ('cd', 36).length]
                                  static call this.address.mem[128 len 4] with:
                                          gas gas_remaining wei
                                         args mem[132 len ('cd', 36).length - 4]
                                  if return_data.size != 32 or not ext_call.success:
                                      return bool(32 == return_data.size and ext_call.success)
                                  return (ext_call.return_data[0] < cd[4])
                              if ('cd', 36).length < 100:
                                  revert with IncorrectDataLength()
                              if ('cd', 36).length - 100 < 4:
                                  revert with IncorrectDataLength()
                              if ('cd', 36).length - 100 < 36:
                                  revert with IncorrectDataLength()
                              if (uint32(('cd', 36)[3]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                          else:
                              if (uint32(('cd', 36)[0]) >> 224) - arbitraryStaticCall(address target, bytes data):
                                  if (uint32(('cd', 36)[0]) >> 224) - and(uint256 offsets, bytes data):
                                      mem[128 len ('cd', 36).length] = call.data[cd[36] + 36 len ('cd', 36).length]
                                      static call this.address.mem[128 len 4] with:
                                              gas gas_remaining wei
                                             args mem[132 len ('cd', 36).length - 4]
                                      if return_data.size != 32 or not ext_call.success:
                                          return bool(32 == return_data.size and ext_call.success)
                                      return (ext_call.return_data[0] < cd[4])
                                  if ('cd', 36).length < 100:
                                      revert with IncorrectDataLength()
                                  if uint32(('cd', 36)[0]):
                                      require 0 <= uint32(('cd', 36)[0])
                                      require uint32(('cd', 36)[0]) <= ('cd', 36).length - 100
                              else:
                                  if ('cd', 36).length < 100:
                                      revert with IncorrectDataLength()
                                  mem[128 len ('cd', 36).length - 100] = call.data[cd[36] + 136 len ('cd', 36).length - 100]
                                  static call ('cd', 36)[0].mem[128 len 4] with:
                                          gas gas_remaining wei
                                         args mem[132 len ('cd', 36).length - 104]
                                  if return_data.size != 32 or not ext_call.success:
                                      revert with ArbitraryStaticCallFailed()
                                  if return_data.size != 32 or not ext_call.success:
                                      revert with ArbitraryStaticCallFailed()
                      else:
                          if uint32(('cd', 36)[0]) >> 224 >= eq(uint256 value, bytes data):
                              if (uint32(('cd', 36)[0]) >> 224) - eq(uint256 value, bytes data):
                                  if (uint32(('cd', 36)[0]) >> 224) - or(uint256 offsets, bytes data):
                                      mem[128 len ('cd', 36).length] = call.data[cd[36] + 36 len ('cd', 36).length]
                                      static call this.address.mem[128 len 4] with:
                                              gas gas_remaining wei
                                             args mem[132 len ('cd', 36).length - 4]
                                      if return_data.size != 32 or not ext_call.success:
                                          return bool(32 == return_data.size and ext_call.success)
                                      return (ext_call.return_data[0] < cd[4])
                                  if ('cd', 36).length < 100:
                                      revert with IncorrectDataLength()
                                  if uint32(('cd', 36)[0]):
                                      require 0 <= uint32(('cd', 36)[0])
                                      require uint32(('cd', 36)[0]) <= ('cd', 36).length - 100
                              else:
                                  if ('cd', 36).length < 100:
                                      revert with IncorrectDataLength()
                                  if ('cd', 36).length - 100 < 4:
                                      revert with IncorrectDataLength()
                                  if ('cd', 36).length - 100 < 36:
                                      revert with IncorrectDataLength()
                                  if (uint32(('cd', 36)[3]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                          else:
                              if (uint32(('cd', 36)[0]) >> 224) - gt(uint256 value, bytes data):
                                  if not (uint32(('cd', 36)[0]) >> 224) - timestampBelow(uint256 time):
                                      if block.timestamp < ('cd', 36)[0]:
                                          return (1 < cd[4])
                                      return (0 < cd[4])
                                  mem[128 len ('cd', 36).length] = call.data[cd[36] + 36 len ('cd', 36).length]
                                  static call this.address.mem[128 len 4] with:
                                          gas gas_remaining wei
                                         args mem[132 len ('cd', 36).length - 4]
                                  if return_data.size != 32 or not ext_call.success:
                                      return bool(32 == return_data.size and ext_call.success)
                                  return (ext_call.return_data[0] < cd[4])
                              if ('cd', 36).length < 100:
                                  revert with IncorrectDataLength()
                              if ('cd', 36).length - 100 < 4:
                                  revert with IncorrectDataLength()
                              if ('cd', 36).length - 100 < 36:
                                  revert with IncorrectDataLength()
                              if (uint32(('cd', 36)[3]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
              else:
                  if arbitraryStaticCall(address target, bytes data) == uint32(call.func_hash) >> 224:
                      require not call.value
                      require calldata.size - 4 >=′ 64
                      require cd[4] == address(cd[4])
                      require cd[36] <= LOCK8605463013()
                      require cd[36] + 35 <′ calldata.size
                      require ('cd', 36).length <= LOCK8605463013()
                      require cd[36] + ('cd', 36).length + 36 <= calldata.size
                      mem[128 len ('cd', 36).length] = call.data[cd[36] + 36 len ('cd', 36).length]
                      static call cd[4].mem[128 len 4] with:
                              gas gas_remaining wei
                             args mem[132 len ('cd', 36).length - 4]
                      if return_data.size != 32 or not ext_call.success:
                          revert with ArbitraryStaticCallFailed()
                      if return_data.size != 32 or not ext_call.success:
                          revert with ArbitraryStaticCallFailed()
                      return ext_call.return_data[0]
                  if uint32(call.func_hash) >> 224 != and(uint256 offsets, bytes data):
                      require increaseNonce() == uint32(call.func_hash) >> 224
                      require not call.value
                      if nonce[caller] > nonce[caller] + 1:
                          revert with 0, 17
                      nonce[caller]++
                      log NonceIncreased(
                            address maker=(nonce[caller] + 1),
                            uint256 newNonce=caller)
                      stop
                  require not call.value
                  require calldata.size - 4 >=′ 64
                  require cd[36] <= LOCK8605463013()
                  require cd[36] + 35 <′ calldata.size
                  require ('cd', 36).length <= LOCK8605463013()
                  require cd[36] + ('cd', 36).length + 36 <= calldata.size
                  if not uint32(cd[4]):
                      return 1
                  require 0 <= uint32(cd[4])
                  require uint32(cd[4]) <= ('cd', 36).length
                  if uint32(cd[4]) < 4:
                      revert with IncorrectDataLength()
                  if uint32(cd[4]) < 36:
                      revert with IncorrectDataLength()
                  if not (uint32(('cd', 36)[0]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                      if block.timestamp < ('cd', 36)[0] % unknown10000000() >> 208:
                  else:
                      if uint32(('cd', 36)[0]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                          if uint32(('cd', 36)[0]) >> 224 >= lt(uint256 value, bytes data):
                              if not (uint32(('cd', 36)[0]) >> 224) - lt(uint256 value, bytes data):
                                  if uint32(cd[4]) < 100:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(('cd', 36)[0]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                                      if uint32(cd[4]) < 68:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[128 len uint32(cd[4])] = call.data[cd[36] + 36 len uint32(cd[4])]
                                      static call this.address.mem[128 len 4] with:
                                              gas gas_remaining wei
                                             args mem[132 len uint32(cd[4]) - 4]
                          else:
                              if (uint32(('cd', 36)[0]) >> 224) - arbitraryStaticCall(address target, bytes data):
                                  if not (uint32(('cd', 36)[0]) >> 224) - and(uint256 offsets, bytes data):
                                      if uint32(cd[4]) < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[128 len uint32(cd[4])] = call.data[cd[36] + 36 len uint32(cd[4])]
                                      static call this.address.mem[128 len 4] with:
                                              gas gas_remaining wei
                                             args mem[132 len uint32(cd[4]) - 4]
                              else:
                                  if uint32(cd[4]) < 100:
                                      revert with IncorrectDataLength()
                                  mem[128 len uint32(cd[4]) - 100] = call.data[cd[36] + 136 len uint32(cd[4]) - 100]
                                  static call ('cd', 36)[0].mem[128 len 4] with:
                                          gas gas_remaining wei
                                         args mem[132 len uint32(cd[4]) - 104]
                      else:
                          if uint32(('cd', 36)[0]) >> 224 >= eq(uint256 value, bytes data):
                              if not (uint32(('cd', 36)[0]) >> 224) - eq(uint256 value, bytes data):
                                  if uint32(cd[4]) < 100:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(('cd', 36)[0]) >> 224) - or(uint256 offsets, bytes data):
                                      if uint32(cd[4]) < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[128 len uint32(cd[4])] = call.data[cd[36] + 36 len uint32(cd[4])]
                                      static call this.address.mem[128 len 4] with:
                                              gas gas_remaining wei
                                             args mem[132 len uint32(cd[4]) - 4]
                          else:
                              if not (uint32(('cd', 36)[0]) >> 224) - gt(uint256 value, bytes data):
                                  if uint32(cd[4]) < 100:
                                      revert with IncorrectDataLength()
                              else:
                                  if (uint32(('cd', 36)[0]) >> 224) - timestampBelow(uint256 time):
                                      mem[128 len uint32(cd[4])] = call.data[cd[36] + 36 len uint32(cd[4])]
                                      static call this.address.mem[128 len 4] with:
                                              gas gas_remaining wei
                                             args mem[132 len uint32(cd[4]) - 4]
      else:
          if remainingsRaw(bytes32[] orderHashes) <= uint32(call.func_hash) >> 224:
              if uniswapV3SwapTo(address recipient, uint256 amount, uint256 minReturn, uint256[] pools) > uint32(call.func_hash) >> 224:
                  if remainingsRaw(bytes32[] orderHashes) == uint32(call.func_hash) >> 224:
                      require not call.value
                      require calldata.size - 4 >=′ 32
                      require cd[4] <= LOCK8605463013()
                      require cd[4] + 35 <′ calldata.size
                      if ('cd', 4).length > LOCK8605463013():
                          revert with 0, 65
                      if ceil32(32 * ('cd', 4).length) + 129 < 128 or ceil32(32 * ('cd', 4).length) + 129 > LOCK8605463013():
                          revert with 0, 65
                      require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
                  else:
                      if uint32(call.func_hash) >> 224 != fillOrderRFQCompact(tuple order, bytes32 r, bytes32 vs, uint256 flagsAndAmount):
                          require remaining(bytes32 orderHash) == uint32(call.func_hash) >> 224
                          require not call.value
                          require calldata.size - 4 >=′ 32
                          if not remainingRaw[cd[4]]:
                              revert with UnknownOrder()
                          return (remainingRaw[cd[4]] - 1)
                      require calldata.size - 4 >=′ 320
                      require calldata.size - 4 >=′ 224
                      require cd[36] == address(cd[36])
                      require cd[68] == address(cd[68])
                      require cd[100] == address(cd[100])
                      require cd[132] == address(cd[132])
                      if this.address != 0x1111111254eeb25477b68fb85ed929f73a960582:
                          if not Mask(1, 254, cd[292]):
                              if not address(cd[100]):
                                  revert with RFQBadSignature()
                              if uint255(cd[260]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                                  if -address(cd[100]):
                                      static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, cd[4], cd[36], cd[68], cd[100], cd[132], cd[164], cd[196])), 64, 64, cd[228], cd[260]
                              else:
                                  signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, cd[4], cd[36], cd[68], cd[100], cd[132], cd[164], cd[196])), (bool(cd[260]) >> 255) + 27, cd[228], uint255(cd[260])) # precompiled
                                  if address(signer) - address(cd[100]):
                                      static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, cd[4], cd[36], cd[68], cd[100], cd[132], cd[164], cd[196])), 64, 64, cd[228], cd[260]
                          else:
                              if not Mask(1, 253, cd[292]):
                                  static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, cd[4], cd[36], cd[68], cd[100], cd[132], cd[164], cd[196])), 64, 64, cd[228], cd[260]
                              else:
                                  static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, cd[4], cd[36], cd[68], cd[100], cd[132], cd[164], cd[196])), Array(len=65, data=cd[228], 2 * cd[260], Mask(8, 248, (bool(cd[260]) >> 255) + 27) >> 248)
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                              if return_data.size != 32 or ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000:
                                  revert with RFQBadSignature()
                              if not caller:
                                  revert with RFQZeroTargetIsForbidden()
                      else:
                          if 1 != chainid:
                              if Mask(1, 254, cd[292]):
                                  if not Mask(1, 253, cd[292]):
                                      static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, cd[4], cd[36], cd[68], cd[100], cd[132], cd[164], cd[196])), 64, 64, cd[228], cd[260]
                                  else:
                                      static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, cd[4], cd[36], cd[68], cd[100], cd[132], cd[164], cd[196])), Array(len=65, data=cd[228], 2 * cd[260], Mask(8, 248, (bool(cd[260]) >> 255) + 27) >> 248)
                                  if not ext_call.success:
                                      revert with RFQBadSignature()
                                  if return_data.size != 32 or ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000:
                                      revert with RFQBadSignature()
                              else:
                                  if not address(cd[100]):
                                      revert with RFQBadSignature()
                                  if uint255(cd[260]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                                      if -address(cd[100]):
                                          static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                                  gas gas_remaining wei
                                                 args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, cd[4], cd[36], cd[68], cd[100], cd[132], cd[164], cd[196])), 64, 64, cd[228], cd[260]
                                  else:
                                      signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, cd[4], cd[36], cd[68], cd[100], cd[132], cd[164], cd[196])), (bool(cd[260]) >> 255) + 27, cd[228], uint255(cd[260])) # precompiled
                                      if address(signer) - address(cd[100]):
                                          static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                                  gas gas_remaining wei
                                                 args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, cd[4], cd[36], cd[68], cd[100], cd[132], cd[164], cd[196])), 64, 64, cd[228], cd[260]
                          else:
                              if Mask(1, 254, cd[292]):
                                  if not Mask(1, 253, cd[292]):
                                      static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, cd[4], cd[36], cd[68], cd[100], cd[132], cd[164], cd[196])), 64, 64, cd[228], cd[260]
                                  else:
                                      static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, cd[4], cd[36], cd[68], cd[100], cd[132], cd[164], cd[196])), Array(len=65, data=cd[228], 2 * cd[260], Mask(8, 248, (bool(cd[260]) >> 255) + 27) >> 248)
                                  if not ext_call.success:
                                      revert with RFQBadSignature()
                                  if return_data.size != 32 or ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000:
                                      revert with RFQBadSignature()
                              else:
                                  if not address(cd[100]):
                                      revert with RFQBadSignature()
                                  if uint255(cd[260]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                                      if -address(cd[100]):
                                          static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                                  gas gas_remaining wei
                                                 args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, cd[4], cd[36], cd[68], cd[100], cd[132], cd[164], cd[196])), 64, 64, cd[228], cd[260]
                                  else:
                                      signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, cd[4], cd[36], cd[68], cd[100], cd[132], cd[164], cd[196])), (bool(cd[260]) >> 255) + 27, cd[228], uint255(cd[260])) # precompiled
                                      if address(signer) - address(cd[100]):
                                          static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                                  gas gas_remaining wei
                                                 args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, cd[4], cd[36], cd[68], cd[100], cd[132], cd[164], cd[196])), 64, 64, cd[228], cd[260]
              else:
                  if uint32(call.func_hash) >> 224 != uniswapV3SwapTo(address recipient, uint256 amount, uint256 minReturn, uint256[] pools):
                      if uint32(call.func_hash) >> 224 != simulate(address targetContract, bytes calldataPayload):
                          require cancelOrderRFQ(uint256 orderInfo, uint256 additionalMask) == uint32(call.func_hash) >> 224
                          require not call.value
                          require calldata.size - 4 >=′ 64
                          if not (cd[36] or 1 << uint8(cd[4]) and invalidatorForOrderRFQ[caller][Mask(56, 8, cd[4]) << 192]) - (cd[36] or 1 << uint8(cd[4])):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[caller][Mask(56, 8, cd[4]) << 192] = invalidatorForOrderRFQ[caller][Mask(56, 8, cd[4]) << 192] or cd[36] or 1 << uint8(cd[4])
                          stop
                      require not call.value
                      require calldata.size - 4 >=′ 64
                      require cd[4] == address(cd[4])
                      require cd[36] <= LOCK8605463013()
                      require cd[36] + 35 <′ calldata.size
                      require ('cd', 36).length <= LOCK8605463013()
                      require cd[36] + ('cd', 36).length + 36 <= calldata.size
                      delegate address(cd[4]) with:
                           gas gas_remaining wei
                          args call.data[cd[36] + 36 len ('cd', 36).length]
                  else:
                      require calldata.size - 4 >=′ 128
                      require cd[4] == address(cd[4])
                      require cd[100] <= LOCK8605463013()
                      require cd[100] + 35 <′ calldata.size
                      require ('cd', 100).length <= LOCK8605463013()
                      require cd[100] + (32 * ('cd', 100).length) + 36 <= calldata.size
                      if not -('cd', 100).length:
                          revert with EmptyPools()
                      if ('cd', 100).length - 1 >= ('cd', 100).length:
                          revert with 0, 50
                      if call.value:
                          if cd[36] != call.value:
                              revert with InvalidMsgValue()
                          require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
                             value cd[36] wei
                               gas gas_remaining wei
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                      if ('cd', 100).length <= 1:
                      if 0 >= ('cd', 100).length:
                          revert with 0, 50
                      if cd[36] > 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
                          revert with 0, 'SafeCast: value doesn't fit in an int256'
          else:
              if destroy() > uint32(call.func_hash) >> 224:
                  if remainingRaw(bytes32 orderHash) == uint32(call.func_hash) >> 224:
                      require not call.value
                      require calldata.size - 4 >=′ 32
                      return remainingRaw[cd[4]]
                  require cancelOrderRFQ(uint256 orderInfo) == uint32(call.func_hash) >> 224
                  require not call.value
                  require calldata.size - 4 >=′ 32
                  if not (1 << uint8(cd[4]) and invalidatorForOrderRFQ[caller][Mask(56, 8, cd[4]) << 192]) - (1 << uint8(cd[4])):
                      revert with InvalidatedOrder()
                  invalidatorForOrderRFQ[caller][Mask(56, 8, cd[4]) << 192] = 1
                  stop
              if destroy() == uint32(call.func_hash) >> 224:
                  require not call.value
                  if owner != caller:
                      revert with 0, 'Ownable: caller is not the owner'
                  selfdestruct(caller)
              if uint32(call.func_hash) >> 224 != clipperSwap(address clipperExchange, address srcToken, address dstToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, bytes32 r, bytes32 vs):
                  require owner() == uint32(call.func_hash) >> 224
                  require not call.value
                  return owner
              require calldata.size - 4 >=′ 256
              require cd[4] == address(cd[4])
              require cd[36] == address(cd[36])
              require cd[68] == address(cd[68])
              if not address(cd[36]):
                  if cd[100] != call.value:
                      revert with InvalidMsgValue()
                  if not address(cd[36]):
                      call cd[4].sellEthForToken(address outputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                         value cd[100] wei
                           gas gas_remaining wei
                          args cd[68], cd[100], cd[132], cd[164], caller, (bool(cd[228]) >> 255) + 27, cd[196], 2 * cd[228], Array(len=mem[420 len 31], data=5709241402184)
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                  else:
                      if not address(cd[68]):
                          if not cd[68] == 1:
                              call cd[4].sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                                   gas gas_remaining wei
                                  args cd[36], cd[100], cd[132], cd[164], caller, (bool(cd[228]) >> 255) + 27, cd[196], 2 * cd[228], Array(len=mem[420 len 31], data=5709241402184)
                          else:
                              call cd[4].sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                                   gas gas_remaining wei
                                  args cd[36], cd[100], cd[132], cd[164], this.address, (bool(cd[228]) >> 255) + 27, cd[196], 2 * cd[228], Array(len=mem[420 len 31], data=5709241402184)
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          if not address(cd[68]) - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                              call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
                                 value cd[132] wei
                                   gas gas_remaining wei
                              if not ext_call.success:
                                  revert with ext_call.return_data[0 len return_data.size]
                              call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transfer(address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args caller, cd[132]
                      else:
                          if address(cd[68]) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                              call cd[4].swap(address inputToken, address outputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                                   gas gas_remaining wei
                                  args cd[36], cd[68], cd[100], cd[132], cd[164], caller, (bool(cd[228]) >> 255) + 27, cd[196], 2 * cd[228], Array(len=mem[452 len 31], data=5709241402184)
                              if not ext_call.success:
                                  revert with ext_call.return_data[0 len return_data.size]
                          else:
                              if not cd[68] == 1:
                                  call cd[4].sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                                       gas gas_remaining wei
                                      args cd[36], cd[100], cd[132], cd[164], caller, (bool(cd[228]) >> 255) + 27, cd[196], 2 * cd[228], Array(len=mem[420 len 31], data=5709241402184)
                              else:
                                  call cd[4].sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                                       gas gas_remaining wei
                                      args cd[36], cd[100], cd[132], cd[164], this.address, (bool(cd[228]) >> 255) + 27, cd[196], 2 * cd[228], Array(len=mem[420 len 31], data=5709241402184)
                              if not ext_call.success:
                                  revert with ext_call.return_data[0 len return_data.size]
                              if not address(cd[68]) - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
                                     value cd[132] wei
                                       gas gas_remaining wei
                                  if not ext_call.success:
                                      revert with ext_call.return_data[0 len return_data.size]
                                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transfer(address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args caller, cd[132]
                  return cd[132]
              if call.value:
                  revert with InvalidMsgValue()
              if not address(cd[36]) - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                       gas gas_remaining wei
                      args caller, this.address, cd[100]
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.withdraw(uint256 amount) with:
                       gas gas_remaining wei
                      args cd[100]
                  call cd[4].sellEthForToken(address outputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                     value cd[100] wei
                       gas gas_remaining wei
                      args cd[68], cd[100], cd[132], cd[164], caller, (bool(cd[228]) >> 255) + 27, cd[196], 2 * cd[228], Array(len=mem[420 len 31], data=5709241402184)
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  return cd[132]
              call address(cd[36]).transferFrom(address sender, address recipient, uint256 amount) with:
                   gas gas_remaining wei
                  args caller, cd[4], cd[100]
              if not ext_call.success:
                  revert with SafeTransferFromFailed()
              if not return_data.size:
                  if ext_code.size(address(cd[36])) <= 0:
                      revert with SafeTransferFromFailed()
              else:
                  if return_data.size <= 31 or ext_call.return_data[0] != 1:
                      revert with SafeTransferFromFailed()
              if not address(cd[36]):
                  call cd[4].sellEthForToken(address outputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                     value cd[100] wei
                       gas gas_remaining wei
                      args cd[68], cd[100], cd[132], cd[164], caller, (bool(cd[228]) >> 255) + 27, cd[196], 2 * cd[228], Array(len=mem[420 len 31], data=5709241402184)
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  return cd[132]
              if address(cd[68]):
                  if address(cd[68]) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      call cd[4].swap(address inputToken, address outputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                           gas gas_remaining wei
                          args cd[36], cd[68], cd[100], cd[132], cd[164], caller, (bool(cd[228]) >> 255) + 27, cd[196], 2 * cd[228], Array(len=mem[452 len 31], data=5709241402184)
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      return cd[132]
              if not cd[68] == 1:
                  call cd[4].sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                       gas gas_remaining wei
                      args cd[36], cd[100], cd[132], cd[164], caller, (bool(cd[228]) >> 255) + 27, cd[196], 2 * cd[228], Array(len=mem[420 len 31], data=5709241402184)
              else:
                  call cd[4].sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                       gas gas_remaining wei
                      args cd[36], cd[100], cd[132], cd[164], this.address, (bool(cd[228]) >> 255) + 27, cd[196], 2 * cd[228], Array(len=mem[420 len 31], data=5709241402184)
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              if not address(cd[68]) - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
                     value cd[132] wei
                       gas gas_remaining wei
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transfer(address recipient, uint256 amount) with:
                       gas gas_remaining wei
                      args caller, cd[132]
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def timestampBelow(uint256 time): # not payable
  require calldata.size - 4 >=′ 32
  return (block.timestamp < time)

def remaining(bytes32 orderHash): # not payable
  require calldata.size - 4 >=′ 32
  if not remainingRaw[orderHash]:
      revert with UnknownOrder()
  return (remainingRaw[orderHash] - 1)

def renounceOwnership(): # not payable
  if owner != caller:
      revert with 0, 'Ownable: caller is not the owner'
  owner = 0
  log OwnershipTransferred(
        address previousOwner=owner,
        address newOwner=0)

def nonceEquals(address makerAddress, uint256 makerNonce): # not payable
  require calldata.size - 4 >=′ 64
  require makerAddress == makerAddress
  return (nonce[address(makerAddress)] == makerNonce)

def increaseNonce(): # not payable
  if nonce[caller] > nonce[caller] + 1:
      revert with 0, 17
  nonce[caller]++
  log NonceIncreased(
        address maker=(nonce[caller] + 1),
        uint256 newNonce=caller)

def timestampBelowAndNonceEquals(uint256 timeNonceAccount): # not payable
  require calldata.size - 4 >=′ 32
  if block.timestamp >= timeNonceAccount % unknown10000000() >> 208:
      return (block.timestamp < timeNonceAccount % unknown10000000() >> 208)
  return not nonce[address(timeNonceAccount)]

def or(uint256 offsets, bytes data): # not payable
  require calldata.size - 4 >=′ 64
  require data <= LOCK8605463013()
  require data + 35 <′ calldata.size
  require data.length <= LOCK8605463013()
  require data + data.length + 36 <= calldata.size
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def and(uint256 offsets, bytes data): # not payable
  require calldata.size - 4 >=′ 64
  require data <= LOCK8605463013()
  require data + 35 <′ calldata.size
  require data.length <= LOCK8605463013()
  require data + data.length + 36 <= calldata.size
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def cancelOrderRFQ(uint256 orderInfo): # not payable
  require calldata.size - 4 >=′ 32
  if not (1 << uint8(orderInfo) and invalidatorForOrderRFQ[caller][Mask(56, 8, orderInfo) << 192]) - (1 << uint8(orderInfo)):
      revert with InvalidatedOrder()
  invalidatorForOrderRFQ[caller][Mask(56, 8, orderInfo) << 192] = 1

def advanceNonce(uint8 amount): # not payable
  require calldata.size - 4 >=′ 32
  require amount == amount
  if not -amount:
      revert with AdvanceNonceFailed()
  if nonce[caller] > amount + nonce[caller]:
      revert with 0, 17
  nonce[caller] += amount
  log NonceIncreased(
        address maker=(amount + nonce[caller]),
        uint256 newNonce=caller)

def transferOwnership(address newOwner): # not payable
  require calldata.size - 4 >=′ 32
  require newOwner == newOwner
  if owner != caller:
      revert with 0, 'Ownable: caller is not the owner'
  if not newOwner:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
  owner = newOwner
  log OwnershipTransferred(
        address previousOwner=owner,
        address newOwner=newOwner)

def checkPredicate(tuple order): # not payable
  require calldata.size - 4 >=′ 32
  require order <= LOCK8605463013()
  require calldata.size + -order - 4 >=′ 320
  require cd[(order + 292)] <′ calldata.size + -order - 35
  require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
  require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
  require 0 <= cd[(order + cd[(order + 292)] + 4)]
  revert with IncorrectDataLength()

def cancelOrderRFQ(uint256 orderInfo, uint256 additionalMask): # not payable
  require calldata.size - 4 >=′ 64
  if not (additionalMask or 1 << uint8(orderInfo) and invalidatorForOrderRFQ[caller][Mask(56, 8, orderInfo) << 192]) - (additionalMask or 1 << uint8(orderInfo)):
      revert with InvalidatedOrder()
  invalidatorForOrderRFQ[caller][Mask(56, 8, orderInfo) << 192] = invalidatorForOrderRFQ[caller][Mask(56, 8, orderInfo) << 192] or additionalMask or 1 << uint8(orderInfo)

def arbitraryStaticCall(address target, bytes data): # not payable
  require calldata.size - 4 >=′ 64
  require target == target
  require data <= LOCK8605463013()
  require data + 35 <′ calldata.size
  require data.length <= LOCK8605463013()
  require data + data.length + 36 <= calldata.size
  mem[96 len data.length] = data[all]
  static call target.mem[96 len 4] with:
          gas gas_remaining wei
         args mem[100 len data.length - 4]
  if return_data.size != 32 or not ext_call.success:
      revert with ArbitraryStaticCallFailed()
  if return_data.size != 32 or not ext_call.success:
      revert with ArbitraryStaticCallFailed()
  return ext_call.return_data[0]

def rescueFunds(address token, uint256 amount): # not payable
  require calldata.size - 4 >=′ 64
  require token == token
  if owner != caller:
      revert with 0, 'Ownable: caller is not the owner'
  if amount:
      if not token:
          if eth.balance(this.address) < amount:
              revert with InsufficientBalance()
          call caller with:
             value amount wei
               gas 5000 wei
          if not ext_call.success:
              revert with ETHTransferFailed()
      else:
          if token != 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee:
              call token.transfer(address recipient, uint256 amount) with:
                   gas gas_remaining wei
                  args caller, amount
              if not ext_call.success:
                  revert with SafeTransferFailed()
              if not return_data.size:
                  if ext_code.size(token) <= 0:
                      revert with SafeTransferFailed()
              else:
                  if return_data.size <= 31 or ext_call.return_data[0] != 1:
                      revert with SafeTransferFailed()
          else:
              if eth.balance(this.address) < amount:
                  revert with InsufficientBalance()
              call caller with:
                 value amount wei
                   gas 5000 wei
              if not ext_call.success:
                  revert with ETHTransferFailed()

def hashOrder(tuple order): # not payable
  require calldata.size - 4 >=′ 32
  require order <= LOCK8605463013()
  require calldata.size + -order - 4 >=′ 320
  require cd[(order + 292)] <′ calldata.size + -order - 35
  require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
  require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
  if this.address != 0x1111111254eeb25477b68fb85ed929f73a960582:
      return sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]])))
  if 1 != chainid:
      return sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]])))
  return sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]])))

def simulate(address targetContract, bytes calldataPayload): # not payable
  require calldata.size - 4 >=′ 64
  require targetContract == targetContract
  require calldataPayload <= LOCK8605463013()
  require calldataPayload + 35 <′ calldata.size
  require calldataPayload.length <= LOCK8605463013()
  require calldataPayload + calldataPayload.length + 36 <= calldata.size
  mem[96 len calldataPayload.length] = calldataPayload[all]
  mem[calldataPayload.length + 96] = 0
  delegate targetContract with:
       gas gas_remaining wei
      args calldataPayload[all]
  if return_data.size:
      revert with 0, 
                  bool(delegate.return_code),
                  64,
                  return_data.size,
                  ext_call.return_data[0 len return_data.size],
                  Mask(8 * ceil32(return_data.size) - return_data.size, -(8 * ceil32(return_data.size) + -ceil32(return_data.size) + 27) + 256, bool(delegate.return_code)) >> -(8 * ceil32(return_data.size) + -ceil32(return_data.size) + 27) + 256
  mem[196 len 0x1934afc800000000000000000000000000000000000000000000000000000000] = uint32(bool(delegate.return_code)), 64, 0x1934afc800000000000000000000000000000000000000000000000000000000, mem[196 len 0x1934afc7ffffffffffffffffffffffffffffffffffffffffffffffffffffffbc]
  revert with 0, 
              bool(delegate.return_code),
              64,
              0x1934afc800000000000000000000000000000000000000000000000000000000,
              mem[196 len 0x1934afc800000000000000000000000000000000000000000000000000000000]

def uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes data): # not payable
  require calldata.size - 4 >=′ 96
  require data <= LOCK8605463013()
  require data + 35 <′ calldata.size
  require data.length <= LOCK8605463013()
  require data + data.length + 36 <= calldata.size
  static call caller.token0() with:
          gas gas_remaining wei
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  static call caller with:
          gas gas_remaining wei
  static call caller.0xd with:
          gas gas_remaining wei
  if address(sha3(1204786273842544410698595, sha3(0, ext_call.return_data[11 len 21], ext_call.return_data[0], ext_call.return_data[0]), 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54)) xor caller:
      revert with BadPool()
  if amount0Delta >′ 0 == 1:
      if cd[132] == this.address == 1:
          call ext_call.return_data[0] with:
               gas gas_remaining wei
              args caller, amount0Delta
      else:
          call ext_call.return_data[0].token1() with:
               gas gas_remaining wei
              args cd[132], caller, amount0Delta
  else:
      if cd[132] == this.address == 1:
          call ext_call.return_data[0] with:
               gas gas_remaining wei
              args caller, amount1Delta
      else:
          call ext_call.return_data[0].token1() with:
               gas gas_remaining wei
              args cd[132], caller, amount1Delta
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  if return_data.size and return_data.size <= 31 or ext_call.return_data[0] != 1:
      revert with ERC20TransferFailed()

def uniswapV3SwapToWithPermit(address recipient, address srcToken, uint256 amount, uint256 minReturn, uint256[] pools, bytes permit): # not payable
  require calldata.size - 4 >=′ 192
  require recipient == recipient
  require srcToken == srcToken
  require pools <= LOCK8605463013()
  require pools + 35 <′ calldata.size
  require pools.length <= LOCK8605463013()
  require pools + (32 * pools.length) + 36 <= calldata.size
  require permit <= LOCK8605463013()
  require permit + 35 <′ calldata.size
  require permit.length <= LOCK8605463013()
  require permit + permit.length + 36 <= calldata.size
  if not -permit.length + 224:
      call srcToken.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
           gas gas_remaining wei
          args permit[all]
  else:
      if -permit.length + 256:
          revert with 'h'XW'
      call srcToken.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) with:
           gas gas_remaining wei
          args permit[all]
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  if not return_data.size:
      if ext_code.size(srcToken) <= 0:
          revert with ext_call.return_data[0 len return_data.size]
  else:
      if return_data.size <= 31 or ext_call.return_data[0] != 1:
          revert with ext_call.return_data[0 len return_data.size]
  if not -pools.length:
      revert with EmptyPools()
  if pools.length - 1 >= pools.length:
      revert with 0, 50
  if call.value:
      if amount != call.value:
          revert with InvalidMsgValue()
      require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
         value amount wei
           gas gas_remaining wei
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
  if pools.length <= 1:
  if 0 >= pools.length:
      revert with 0, 50
  if amount > 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeCast: value doesn't fit in an int256'
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def remainingsRaw(bytes32[] orderHashes): # not payable
  require calldata.size - 4 >=′ 32
  require orderHashes <= LOCK8605463013()
  require orderHashes + 35 <′ calldata.size
  if orderHashes.length > LOCK8605463013():
      revert with 0, 65
  if ceil32(32 * orderHashes.length) + 97 < 96 or ceil32(32 * orderHashes.length) + 97 > LOCK8605463013():
      revert with 0, 65
  mem[96] = orderHashes.length
  require orderHashes + (32 * orderHashes.length) + 36 <= calldata.size
  s = 128
  idx = orderHashes + 36
  while idx < orderHashes + (32 * orderHashes.length) + 36:
      mem[s] = cd[idx]
      s = s + 32
      idx = idx + 32
      continue 
  if orderHashes.length > LOCK8605463013():
      revert with 0, 65
  mem[ceil32(32 * orderHashes.length) + 97] = orderHashes.length
  mem[64] = ceil32(32 * orderHashes.length) + (32 * orderHashes.length) + 129
  if orderHashes.length:
      mem[ceil32(32 * orderHashes.length) + 129 len 32 * orderHashes.length] = call.data[calldata.size len 32 * orderHashes.length]
  idx = 0
  while idx < orderHashes.length:
      if idx >= orderHashes.length:
          revert with 0, 50
      mem[0] = mem[(32 * idx) + 128]
      mem[32] = 2
      if idx >= orderHashes.length:
          revert with 0, 50
      mem[(32 * idx) + ceil32(32 * orderHashes.length) + 129] = remainingRaw[mem[(32 * idx) + 128]]
      if not idx + 1:
          revert with 0, 17
      idx = idx + 1
      continue 
  mem[ceil32(32 * orderHashes.length) + (32 * orderHashes.length) + 129] = 32
  mem[ceil32(32 * orderHashes.length) + (32 * orderHashes.length) + 161] = orderHashes.length
  s = 0
  s = mem[64] + 64
  t = ceil32(32 * orderHashes.length) + 129
  while orderHashes.length < orderHashes.length:
      mem[s] = mem[t]
      s = orderHashes.length + 1
      s = s + 32
      t = t + 32
      continue 
  return memory
    from mem[64]
     len s - mem[64]

def unoswap(address srcToken, uint256 amount, uint256 minReturn, uint256[] pools) payable: 
  require calldata.size - 4 >=′ 128
  require srcToken == srcToken
  require pools <= LOCK8605463013()
  require pools + 35 <′ calldata.size
  require pools.length <= LOCK8605463013()
  require pools + (32 * pools.length) + 36 <= calldata.size
  if amount > LOCK8605463013():
      revert with SwapAmountTooLarge()
  if not srcToken:
      if amount != call.value:
          revert with InvalidMsgValue()
      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
         value amount wei
           gas gas_remaining wei
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transfer(address recipient, uint256 amount) with:
           gas gas_remaining wei
          args address(cd[(pools + 36)]), amount
  else:
      if call.value:
          revert with InvalidMsgValue()
      call srcToken.transferFrom(address sender, address recipient, uint256 amount) with:
           gas gas_remaining wei
          args caller, address(cd[(pools + 36)]), amount
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      if return_data.size and return_data.size <= 31 or ext_call.return_data[0] != 1:
          revert with ERC20TransferFailed()
  idx = pools + 68
  s = cd[(pools + 36)]
  t = amount
  while idx < pools + (32 * pools.length) + 36:
      static call address(s).getReserves() with:
              gas gas_remaining wei
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      if 96 != return_data.size:
          revert with ReservesCallFailed()
      mem[96] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
      if not Mask(1, 255, s):
          mem[100] = 0 / 10^9 * ext_call.return_data[0] * bool(Mask(1, 255, s))
          mem[132] = 0 / 10^9 * ext_call.return_data[0] * not Mask(1, 255, s)
          mem[164] = address(cd[idx])
          mem[196] = 128
          mem[228] = 0
          call address(s).swap(uint256 amount0Out, uint256 amount1Out, address to, bytes data) with:
               gas gas_remaining wei
              args 0 / 10^9 * ext_call.return_data[0] * bool(Mask(1, 255, s)), 0 / 10^9 * ext_call.return_data[0] * not Mask(1, 255, s), address(cd[idx]), 128, 0
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          idx = idx + 32
          s = cd[idx]
          t = 0 / 10^9 * ext_call.return_data[0]
          continue 
      mem[100] = 0 / 10^9 * ext_call.return_data[32] * bool(Mask(1, 255, s))
      mem[132] = 0 / 10^9 * ext_call.return_data[32] * not Mask(1, 255, s)
      mem[164] = address(cd[idx])
      mem[196] = 128
      mem[228] = 0
      call address(s).swap(uint256 amount0Out, uint256 amount1Out, address to, bytes data) with:
           gas gas_remaining wei
          args 0 / 10^9 * ext_call.return_data[32] * bool(Mask(1, 255, s)), 0 / 10^9 * ext_call.return_data[32] * not Mask(1, 255, s), address(cd[idx]), 128, 0
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      idx = idx + 32
      s = cd[idx]
      t = 0 / 10^9 * ext_call.return_data[32]
      continue 
  static call address(s).getReserves() with:
          gas gas_remaining wei
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  if 96 != return_data.size:
      revert with ReservesCallFailed()
  if not Mask(1, 254, s):
      if not Mask(1, 255, s):
          call address(s).swap(uint256 amount0Out, uint256 amount1Out, address to, bytes data) with:
               gas gas_remaining wei
              args 0 / 10^9 * ext_call.return_data[0] * bool(Mask(1, 255, s)), 0 / 10^9 * ext_call.return_data[0] * not Mask(1, 255, s), caller, 128, 0
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          if 0 / 10^9 * ext_call.return_data[0] < minReturn:
              revert with ReturnAmountIsNotEnough()
          return (0 / 10^9 * ext_call.return_data[0])
      call address(s).swap(uint256 amount0Out, uint256 amount1Out, address to, bytes data) with:
           gas gas_remaining wei
          args 0 / 10^9 * ext_call.return_data[32] * bool(Mask(1, 255, s)), 0 / 10^9 * ext_call.return_data[32] * not Mask(1, 255, s), caller, 128, 0
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
  else:
      if not Mask(1, 255, s):
          call address(s).swap(uint256 amount0Out, uint256 amount1Out, address to, bytes data) with:
               gas gas_remaining wei
              args 0 / 10^9 * ext_call.return_data[0] * bool(Mask(1, 255, s)), 0 / 10^9 * ext_call.return_data[0] * not Mask(1, 255, s), this.address, 128, 0
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.withdraw(uint256 amount) with:
               gas gas_remaining wei
              args (0 / 10^9 * ext_call.return_data[0])
          call caller with:
             value 0 / 10^9 * ext_call.return_data[0] wei
               gas gas_remaining wei
          if 0 / 10^9 * ext_call.return_data[0] < minReturn:
              revert with ReturnAmountIsNotEnough()
          return (0 / 10^9 * ext_call.return_data[0])
      call address(s).swap(uint256 amount0Out, uint256 amount1Out, address to, bytes data) with:
           gas gas_remaining wei
          args 0 / 10^9 * ext_call.return_data[32] * bool(Mask(1, 255, s)), 0 / 10^9 * ext_call.return_data[32] * not Mask(1, 255, s), this.address, 128, 0
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.withdraw(uint256 amount) with:
           gas gas_remaining wei
          args (0 / 10^9 * ext_call.return_data[32])
      call caller with:
         value 0 / 10^9 * ext_call.return_data[32] wei
           gas gas_remaining wei
  if 0 / 10^9 * ext_call.return_data[32] < minReturn:
      revert with ReturnAmountIsNotEnough()
  return (0 / 10^9 * ext_call.return_data[32])

def unoswapTo(address recipient, address srcToken, uint256 amount, uint256 minReturn, uint256[] pools) payable: 
  require calldata.size - 4 >=′ 160
  require recipient == recipient
  require srcToken == srcToken
  require pools <= LOCK8605463013()
  require pools + 35 <′ calldata.size
  require pools.length <= LOCK8605463013()
  require pools + (32 * pools.length) + 36 <= calldata.size
  if amount > LOCK8605463013():
      revert with SwapAmountTooLarge()
  if not srcToken:
      if amount != call.value:
          revert with InvalidMsgValue()
      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
         value amount wei
           gas gas_remaining wei
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transfer(address recipient, uint256 amount) with:
           gas gas_remaining wei
          args address(cd[(pools + 36)]), amount
  else:
      if call.value:
          revert with InvalidMsgValue()
      call srcToken.transferFrom(address sender, address recipient, uint256 amount) with:
           gas gas_remaining wei
          args caller, address(cd[(pools + 36)]), amount
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      if return_data.size and return_data.size <= 31 or ext_call.return_data[0] != 1:
          revert with ERC20TransferFailed()
  idx = pools + 68
  s = cd[(pools + 36)]
  t = amount
  while idx < pools + (32 * pools.length) + 36:
      static call address(s).getReserves() with:
              gas gas_remaining wei
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      if 96 != return_data.size:
          revert with ReservesCallFailed()
      mem[96] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
      if not Mask(1, 255, s):
          mem[100] = 0 / 10^9 * ext_call.return_data[0] * bool(Mask(1, 255, s))
          mem[132] = 0 / 10^9 * ext_call.return_data[0] * not Mask(1, 255, s)
          mem[164] = address(cd[idx])
          mem[196] = 128
          mem[228] = 0
          call address(s).swap(uint256 amount0Out, uint256 amount1Out, address to, bytes data) with:
               gas gas_remaining wei
              args 0 / 10^9 * ext_call.return_data[0] * bool(Mask(1, 255, s)), 0 / 10^9 * ext_call.return_data[0] * not Mask(1, 255, s), address(cd[idx]), 128, 0
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          idx = idx + 32
          s = cd[idx]
          t = 0 / 10^9 * ext_call.return_data[0]
          continue 
      mem[100] = 0 / 10^9 * ext_call.return_data[32] * bool(Mask(1, 255, s))
      mem[132] = 0 / 10^9 * ext_call.return_data[32] * not Mask(1, 255, s)
      mem[164] = address(cd[idx])
      mem[196] = 128
      mem[228] = 0
      call address(s).swap(uint256 amount0Out, uint256 amount1Out, address to, bytes data) with:
           gas gas_remaining wei
          args 0 / 10^9 * ext_call.return_data[32] * bool(Mask(1, 255, s)), 0 / 10^9 * ext_call.return_data[32] * not Mask(1, 255, s), address(cd[idx]), 128, 0
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      idx = idx + 32
      s = cd[idx]
      t = 0 / 10^9 * ext_call.return_data[32]
      continue 
  static call address(s).getReserves() with:
          gas gas_remaining wei
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  if 96 != return_data.size:
      revert with ReservesCallFailed()
  if not Mask(1, 254, s):
      if not Mask(1, 255, s):
          call address(s).swap(uint256 amount0Out, uint256 amount1Out, address to, bytes data) with:
               gas gas_remaining wei
              args 0 / 10^9 * ext_call.return_data[0] * bool(Mask(1, 255, s)), 0 / 10^9 * ext_call.return_data[0] * not Mask(1, 255, s), recipient, 128, 0
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          if 0 / 10^9 * ext_call.return_data[0] < minReturn:
              revert with ReturnAmountIsNotEnough()
          return (0 / 10^9 * ext_call.return_data[0])
      call address(s).swap(uint256 amount0Out, uint256 amount1Out, address to, bytes data) with:
           gas gas_remaining wei
          args 0 / 10^9 * ext_call.return_data[32] * bool(Mask(1, 255, s)), 0 / 10^9 * ext_call.return_data[32] * not Mask(1, 255, s), recipient, 128, 0
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
  else:
      if not Mask(1, 255, s):
          call address(s).swap(uint256 amount0Out, uint256 amount1Out, address to, bytes data) with:
               gas gas_remaining wei
              args 0 / 10^9 * ext_call.return_data[0] * bool(Mask(1, 255, s)), 0 / 10^9 * ext_call.return_data[0] * not Mask(1, 255, s), this.address, 128, 0
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.withdraw(uint256 amount) with:
               gas gas_remaining wei
              args (0 / 10^9 * ext_call.return_data[0])
          call recipient with:
             value 0 / 10^9 * ext_call.return_data[0] wei
               gas gas_remaining wei
          if 0 / 10^9 * ext_call.return_data[0] < minReturn:
              revert with ReturnAmountIsNotEnough()
          return (0 / 10^9 * ext_call.return_data[0])
      call address(s).swap(uint256 amount0Out, uint256 amount1Out, address to, bytes data) with:
           gas gas_remaining wei
          args 0 / 10^9 * ext_call.return_data[32] * bool(Mask(1, 255, s)), 0 / 10^9 * ext_call.return_data[32] * not Mask(1, 255, s), this.address, 128, 0
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.withdraw(uint256 amount) with:
           gas gas_remaining wei
          args (0 / 10^9 * ext_call.return_data[32])
      call recipient with:
         value 0 / 10^9 * ext_call.return_data[32] wei
           gas gas_remaining wei
  if 0 / 10^9 * ext_call.return_data[32] < minReturn:
      revert with ReturnAmountIsNotEnough()
  return (0 / 10^9 * ext_call.return_data[32])

def cancelOrder(tuple order): # not payable
  require calldata.size - 4 >=′ 32
  require order <= LOCK8605463013()
  require calldata.size + -order - 4 >=′ 320
  require cd[(order + 100)] == address(cd[(order + 100)])
  if address(cd[(order + 100)]) != caller:
      revert with AccessDenied()
  require cd[(order + 292)] <′ calldata.size + -order - 35
  require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
  require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
  if this.address != 0x1111111254eeb25477b68fb85ed929f73a960582:
      if not remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))] - 1:
          revert with AlreadyFilled()
      log OrderCanceled(
            address maker=sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))),
            bytes32 orderHash=remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))],
            uint256 remainingRaw=caller)
      remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))] = 1
      return remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))], 
             sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]])))
  if 1 != chainid:
      if not remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))] - 1:
          revert with AlreadyFilled()
      log OrderCanceled(
            address maker=sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))),
            bytes32 orderHash=remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))],
            uint256 remainingRaw=caller)
      remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))] = 1
      return remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))], 
             sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]])))
  if not remainingRaw[6401][0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))] - 1:
      revert with AlreadyFilled()
  log OrderCanceled(
        address maker=sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))),
        bytes32 orderHash=remainingRaw[6401][0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))],
        uint256 remainingRaw=caller)
  remainingRaw[6401][0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))] = 1
  return remainingRaw[6401][0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))], 
         sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]])))

def unoswapToWithPermit(address recipient, address srcToken, uint256 amount, uint256 minReturn, uint256[] pools, bytes permit): # not payable
  require calldata.size - 4 >=′ 192
  require recipient == recipient
  require srcToken == srcToken
  require pools <= LOCK8605463013()
  require pools + 35 <′ calldata.size
  require pools.length <= LOCK8605463013()
  require pools + (32 * pools.length) + 36 <= calldata.size
  require permit <= LOCK8605463013()
  require permit + 35 <′ calldata.size
  require permit.length <= LOCK8605463013()
  require permit + permit.length + 36 <= calldata.size
  if not -permit.length + 224:
      call srcToken.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
           gas gas_remaining wei
          args permit[all]
  else:
      if -permit.length + 256:
          revert with 'h'XW'
      call srcToken.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) with:
           gas gas_remaining wei
          args permit[all]
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  if not return_data.size:
      if ext_code.size(srcToken) <= 0:
          revert with ext_call.return_data[0 len return_data.size]
  else:
      if return_data.size <= 31 or ext_call.return_data[0] != 1:
          revert with ext_call.return_data[0 len return_data.size]
  if amount > LOCK8605463013():
      revert with SwapAmountTooLarge()
  if not srcToken:
      if amount != call.value:
          revert with InvalidMsgValue()
      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
         value amount wei
           gas gas_remaining wei
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transfer(address recipient, uint256 amount) with:
           gas gas_remaining wei
          args address(cd[(pools + 36)]), amount
  else:
      if call.value:
          revert with InvalidMsgValue()
      call srcToken.transferFrom(address sender, address recipient, uint256 amount) with:
           gas gas_remaining wei
          args caller, address(cd[(pools + 36)]), amount
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      if return_data.size and return_data.size <= 31 or ext_call.return_data[0] != 1:
          revert with ERC20TransferFailed()
  idx = pools + 68
  s = cd[(pools + 36)]
  t = amount
  while idx < pools + (32 * pools.length) + 36:
      static call address(s).getReserves() with:
              gas gas_remaining wei
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      if 96 != return_data.size:
          revert with ReservesCallFailed()
      mem[96] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
      if not Mask(1, 255, s):
          mem[100] = 0 / 10^9 * ext_call.return_data[0] * bool(Mask(1, 255, s))
          mem[132] = 0 / 10^9 * ext_call.return_data[0] * not Mask(1, 255, s)
          mem[164] = address(cd[idx])
          mem[196] = 128
          mem[228] = 0
          call address(s).swap(uint256 amount0Out, uint256 amount1Out, address to, bytes data) with:
               gas gas_remaining wei
              args 0 / 10^9 * ext_call.return_data[0] * bool(Mask(1, 255, s)), 0 / 10^9 * ext_call.return_data[0] * not Mask(1, 255, s), address(cd[idx]), 128, 0
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          idx = idx + 32
          s = cd[idx]
          t = 0 / 10^9 * ext_call.return_data[0]
          continue 
      mem[100] = 0 / 10^9 * ext_call.return_data[32] * bool(Mask(1, 255, s))
      mem[132] = 0 / 10^9 * ext_call.return_data[32] * not Mask(1, 255, s)
      mem[164] = address(cd[idx])
      mem[196] = 128
      mem[228] = 0
      call address(s).swap(uint256 amount0Out, uint256 amount1Out, address to, bytes data) with:
           gas gas_remaining wei
          args 0 / 10^9 * ext_call.return_data[32] * bool(Mask(1, 255, s)), 0 / 10^9 * ext_call.return_data[32] * not Mask(1, 255, s), address(cd[idx]), 128, 0
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      idx = idx + 32
      s = cd[idx]
      t = 0 / 10^9 * ext_call.return_data[32]
      continue 
  static call address(s).getReserves() with:
          gas gas_remaining wei
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  if 96 != return_data.size:
      revert with ReservesCallFailed()
  if not Mask(1, 254, s):
      if not Mask(1, 255, s):
          call address(s).swap(uint256 amount0Out, uint256 amount1Out, address to, bytes data) with:
               gas gas_remaining wei
              args 0 / 10^9 * ext_call.return_data[0] * bool(Mask(1, 255, s)), 0 / 10^9 * ext_call.return_data[0] * not Mask(1, 255, s), recipient, 128, 0
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          if 0 / 10^9 * ext_call.return_data[0] < minReturn:
              revert with ReturnAmountIsNotEnough()
          return (0 / 10^9 * ext_call.return_data[0])
      call address(s).swap(uint256 amount0Out, uint256 amount1Out, address to, bytes data) with:
           gas gas_remaining wei
          args 0 / 10^9 * ext_call.return_data[32] * bool(Mask(1, 255, s)), 0 / 10^9 * ext_call.return_data[32] * not Mask(1, 255, s), recipient, 128, 0
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
  else:
      if not Mask(1, 255, s):
          call address(s).swap(uint256 amount0Out, uint256 amount1Out, address to, bytes data) with:
               gas gas_remaining wei
              args 0 / 10^9 * ext_call.return_data[0] * bool(Mask(1, 255, s)), 0 / 10^9 * ext_call.return_data[0] * not Mask(1, 255, s), this.address, 128, 0
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.withdraw(uint256 amount) with:
               gas gas_remaining wei
              args (0 / 10^9 * ext_call.return_data[0])
          call recipient with:
             value 0 / 10^9 * ext_call.return_data[0] wei
               gas gas_remaining wei
          if 0 / 10^9 * ext_call.return_data[0] < minReturn:
              revert with ReturnAmountIsNotEnough()
          return (0 / 10^9 * ext_call.return_data[0])
      call address(s).swap(uint256 amount0Out, uint256 amount1Out, address to, bytes data) with:
           gas gas_remaining wei
          args 0 / 10^9 * ext_call.return_data[32] * bool(Mask(1, 255, s)), 0 / 10^9 * ext_call.return_data[32] * not Mask(1, 255, s), this.address, 128, 0
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.withdraw(uint256 amount) with:
           gas gas_remaining wei
          args (0 / 10^9 * ext_call.return_data[32])
      call recipient with:
         value 0 / 10^9 * ext_call.return_data[32] wei
           gas gas_remaining wei
  if 0 / 10^9 * ext_call.return_data[32] < minReturn:
      revert with ReturnAmountIsNotEnough()
  return (0 / 10^9 * ext_call.return_data[32])

def uniswapV3Swap(uint256 amount, uint256 minReturn, uint256[] pools) payable: 
  require calldata.size - 4 >=′ 96
  require pools <= LOCK8605463013()
  require pools + 35 <′ calldata.size
  require pools.length <= LOCK8605463013()
  require pools + (32 * pools.length) + 36 <= calldata.size
  if not -pools.length:
      revert with EmptyPools()
  if pools.length - 1 >= pools.length:
      revert with 0, 50
  if call.value:
      if amount != call.value:
          revert with InvalidMsgValue()
      require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
         value amount wei
           gas gas_remaining wei
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
  if 0 >= pools.length:
      revert with 0, 50
  if amount > 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeCast: value doesn't fit in an int256'
  if pools.length > 1:
      if call.value:
          if Mask(1, 255, cd[(pools + 36)]):
              call address(cd[(pools + 36)]).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                   gas gas_remaining wei
                  args address(this.address), not bool(Mask(1, 255, cd[(pools + 36)])), amount, 0xfffd8963efd1fc6a506488495d951d5263988d25, 160, 32, this.address
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 64
              if not ext_call.return_data[0] - 0x8000000000000000000000000000000000000000000000000000000000000000:
                  revert with 0, 17
              if -ext_call.return_data[0] <′ 0:
                  revert with 0, 'SafeCast: value must be positive'
          else:
              call address(cd[(pools + 36)]).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                   gas gas_remaining wei
                  args address(this.address), not bool(Mask(1, 255, cd[(pools + 36)])), amount, 4295128740, 160, 32, this.address
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 64
              if not ext_call.return_data[32] - 0x8000000000000000000000000000000000000000000000000000000000000000:
                  revert with 0, 17
              if -ext_call.return_data[32] <′ 0:
                  revert with 0, 'SafeCast: value must be positive'
      else:
          if Mask(1, 255, cd[(pools + 36)]):
              call address(cd[(pools + 36)]).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                   gas gas_remaining wei
                  args address(this.address), not bool(Mask(1, 255, cd[(pools + 36)])), amount, 0xfffd8963efd1fc6a506488495d951d5263988d25, 160, 32, caller
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 64
              if not ext_call.return_data[0] - 0x8000000000000000000000000000000000000000000000000000000000000000:
                  revert with 0, 17
              if -ext_call.return_data[0] <′ 0:
                  revert with 0, 'SafeCast: value must be positive'
          else:
              call address(cd[(pools + 36)]).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                   gas gas_remaining wei
                  args address(this.address), not bool(Mask(1, 255, cd[(pools + 36)])), amount, 4295128740, 160, 32, caller
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 64
              if not ext_call.return_data[32] - 0x8000000000000000000000000000000000000000000000000000000000000000:
                  revert with 0, 17
              if -ext_call.return_data[32] <′ 0:
                  revert with 0, 'SafeCast: value must be positive'
  else:
      if Mask(1, 253, cd[((32 * pools.length - 1) + pools + 36)]) > 0:
          if call.value:
              if Mask(1, 255, cd[(pools + 36)]):
                  call address(cd[(pools + 36)]).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                       gas gas_remaining wei
                      args address(this.address), not bool(Mask(1, 255, cd[(pools + 36)])), amount, 0xfffd8963efd1fc6a506488495d951d5263988d25, 160, 32, this.address
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >=′ 64
                  if not ext_call.return_data[0] - 0x8000000000000000000000000000000000000000000000000000000000000000:
                      revert with 0, 17
                  if -ext_call.return_data[0] <′ 0:
                      revert with 0, 'SafeCast: value must be positive'
              else:
                  call address(cd[(pools + 36)]).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                       gas gas_remaining wei
                      args address(this.address), not bool(Mask(1, 255, cd[(pools + 36)])), amount, 4295128740, 160, 32, this.address
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >=′ 64
                  if not ext_call.return_data[32] - 0x8000000000000000000000000000000000000000000000000000000000000000:
                      revert with 0, 17
                  if -ext_call.return_data[32] <′ 0:
                      revert with 0, 'SafeCast: value must be positive'
          else:
              if Mask(1, 255, cd[(pools + 36)]):
                  call address(cd[(pools + 36)]).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                       gas gas_remaining wei
                      args address(this.address), not bool(Mask(1, 255, cd[(pools + 36)])), amount, 0xfffd8963efd1fc6a506488495d951d5263988d25, 160, 32, caller
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >=′ 64
                  if not ext_call.return_data[0] - 0x8000000000000000000000000000000000000000000000000000000000000000:
                      revert with 0, 17
                  if -ext_call.return_data[0] <′ 0:
                      revert with 0, 'SafeCast: value must be positive'
              else:
                  call address(cd[(pools + 36)]).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                       gas gas_remaining wei
                      args address(this.address), not bool(Mask(1, 255, cd[(pools + 36)])), amount, 4295128740, 160, 32, caller
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >=′ 64
                  if not ext_call.return_data[32] - 0x8000000000000000000000000000000000000000000000000000000000000000:
                      revert with 0, 17
                  if -ext_call.return_data[32] <′ 0:
                      revert with 0, 'SafeCast: value must be positive'
      else:
          if call.value:
              if Mask(1, 255, cd[(pools + 36)]):
                  call address(cd[(pools + 36)]).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                       gas gas_remaining wei
                      args caller, not bool(Mask(1, 255, cd[(pools + 36)])), amount, 0xfffd8963efd1fc6a506488495d951d5263988d25, 160, 32, this.address
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >=′ 64
                  if not ext_call.return_data[0] - 0x8000000000000000000000000000000000000000000000000000000000000000:
                      revert with 0, 17
                  if -ext_call.return_data[0] <′ 0:
                      revert with 0, 'SafeCast: value must be positive'
              else:
                  call address(cd[(pools + 36)]).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                       gas gas_remaining wei
                      args caller, not bool(Mask(1, 255, cd[(pools + 36)])), amount, 4295128740, 160, 32, this.address
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >=′ 64
                  if not ext_call.return_data[32] - 0x8000000000000000000000000000000000000000000000000000000000000000:
                      revert with 0, 17
                  if -ext_call.return_data[32] <′ 0:
                      revert with 0, 'SafeCast: value must be positive'
          else:
              if Mask(1, 255, cd[(pools + 36)]):
                  call address(cd[(pools + 36)]).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                       gas gas_remaining wei
                      args caller, not bool(Mask(1, 255, cd[(pools + 36)])), amount, 0xfffd8963efd1fc6a506488495d951d5263988d25, 160, 32, caller
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >=′ 64
                  if not ext_call.return_data[0] - 0x8000000000000000000000000000000000000000000000000000000000000000:
                      revert with 0, 17
                  if -ext_call.return_data[0] <′ 0:
                      revert with 0, 'SafeCast: value must be positive'
              else:
                  call address(cd[(pools + 36)]).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                       gas gas_remaining wei
                      args caller, not bool(Mask(1, 255, cd[(pools + 36)])), amount, 4295128740, 160, 32, caller
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >=′ 64
                  if not ext_call.return_data[32] - 0x8000000000000000000000000000000000000000000000000000000000000000:
                      revert with 0, 17
                  if -ext_call.return_data[32] <′ 0:
                      revert with 0, 'SafeCast: value must be positive'
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def uniswapV3SwapTo(address recipient, uint256 amount, uint256 minReturn, uint256[] pools) payable: 
  require calldata.size - 4 >=′ 128
  require recipient == recipient
  require pools <= LOCK8605463013()
  require pools + 35 <′ calldata.size
  require pools.length <= LOCK8605463013()
  require pools + (32 * pools.length) + 36 <= calldata.size
  if not -pools.length:
      revert with EmptyPools()
  if pools.length - 1 >= pools.length:
      revert with 0, 50
  if call.value:
      if amount != call.value:
          revert with InvalidMsgValue()
      require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
         value amount wei
           gas gas_remaining wei
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
  if 0 >= pools.length:
      revert with 0, 50
  if amount > 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeCast: value doesn't fit in an int256'
  if pools.length > 1:
      if call.value:
          if Mask(1, 255, cd[(pools + 36)]):
              call address(cd[(pools + 36)]).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                   gas gas_remaining wei
                  args address(this.address), not bool(Mask(1, 255, cd[(pools + 36)])), amount, 0xfffd8963efd1fc6a506488495d951d5263988d25, 160, 32, this.address
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 64
              if not ext_call.return_data[0] - 0x8000000000000000000000000000000000000000000000000000000000000000:
                  revert with 0, 17
              if -ext_call.return_data[0] <′ 0:
                  revert with 0, 'SafeCast: value must be positive'
          else:
              call address(cd[(pools + 36)]).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                   gas gas_remaining wei
                  args address(this.address), not bool(Mask(1, 255, cd[(pools + 36)])), amount, 4295128740, 160, 32, this.address
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 64
              if not ext_call.return_data[32] - 0x8000000000000000000000000000000000000000000000000000000000000000:
                  revert with 0, 17
              if -ext_call.return_data[32] <′ 0:
                  revert with 0, 'SafeCast: value must be positive'
      else:
          if Mask(1, 255, cd[(pools + 36)]):
              call address(cd[(pools + 36)]).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                   gas gas_remaining wei
                  args address(this.address), not bool(Mask(1, 255, cd[(pools + 36)])), amount, 0xfffd8963efd1fc6a506488495d951d5263988d25, 160, 32, caller
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 64
              if not ext_call.return_data[0] - 0x8000000000000000000000000000000000000000000000000000000000000000:
                  revert with 0, 17
              if -ext_call.return_data[0] <′ 0:
                  revert with 0, 'SafeCast: value must be positive'
          else:
              call address(cd[(pools + 36)]).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                   gas gas_remaining wei
                  args address(this.address), not bool(Mask(1, 255, cd[(pools + 36)])), amount, 4295128740, 160, 32, caller
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              require return_data.size >=′ 64
              if not ext_call.return_data[32] - 0x8000000000000000000000000000000000000000000000000000000000000000:
                  revert with 0, 17
              if -ext_call.return_data[32] <′ 0:
                  revert with 0, 'SafeCast: value must be positive'
  else:
      if Mask(1, 253, cd[((32 * pools.length - 1) + pools + 36)]) > 0:
          if call.value:
              if Mask(1, 255, cd[(pools + 36)]):
                  call address(cd[(pools + 36)]).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                       gas gas_remaining wei
                      args address(this.address), not bool(Mask(1, 255, cd[(pools + 36)])), amount, 0xfffd8963efd1fc6a506488495d951d5263988d25, 160, 32, this.address
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >=′ 64
                  if not ext_call.return_data[0] - 0x8000000000000000000000000000000000000000000000000000000000000000:
                      revert with 0, 17
                  if -ext_call.return_data[0] <′ 0:
                      revert with 0, 'SafeCast: value must be positive'
              else:
                  call address(cd[(pools + 36)]).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                       gas gas_remaining wei
                      args address(this.address), not bool(Mask(1, 255, cd[(pools + 36)])), amount, 4295128740, 160, 32, this.address
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >=′ 64
                  if not ext_call.return_data[32] - 0x8000000000000000000000000000000000000000000000000000000000000000:
                      revert with 0, 17
                  if -ext_call.return_data[32] <′ 0:
                      revert with 0, 'SafeCast: value must be positive'
          else:
              if Mask(1, 255, cd[(pools + 36)]):
                  call address(cd[(pools + 36)]).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                       gas gas_remaining wei
                      args address(this.address), not bool(Mask(1, 255, cd[(pools + 36)])), amount, 0xfffd8963efd1fc6a506488495d951d5263988d25, 160, 32, caller
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >=′ 64
                  if not ext_call.return_data[0] - 0x8000000000000000000000000000000000000000000000000000000000000000:
                      revert with 0, 17
                  if -ext_call.return_data[0] <′ 0:
                      revert with 0, 'SafeCast: value must be positive'
              else:
                  call address(cd[(pools + 36)]).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                       gas gas_remaining wei
                      args address(this.address), not bool(Mask(1, 255, cd[(pools + 36)])), amount, 4295128740, 160, 32, caller
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >=′ 64
                  if not ext_call.return_data[32] - 0x8000000000000000000000000000000000000000000000000000000000000000:
                      revert with 0, 17
                  if -ext_call.return_data[32] <′ 0:
                      revert with 0, 'SafeCast: value must be positive'
      else:
          if call.value:
              if Mask(1, 255, cd[(pools + 36)]):
                  call address(cd[(pools + 36)]).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                       gas gas_remaining wei
                      args address(recipient), not bool(Mask(1, 255, cd[(pools + 36)])), amount, 0xfffd8963efd1fc6a506488495d951d5263988d25, 160, 32, this.address
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >=′ 64
                  if not ext_call.return_data[0] - 0x8000000000000000000000000000000000000000000000000000000000000000:
                      revert with 0, 17
                  if -ext_call.return_data[0] <′ 0:
                      revert with 0, 'SafeCast: value must be positive'
              else:
                  call address(cd[(pools + 36)]).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                       gas gas_remaining wei
                      args address(recipient), not bool(Mask(1, 255, cd[(pools + 36)])), amount, 4295128740, 160, 32, this.address
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >=′ 64
                  if not ext_call.return_data[32] - 0x8000000000000000000000000000000000000000000000000000000000000000:
                      revert with 0, 17
                  if -ext_call.return_data[32] <′ 0:
                      revert with 0, 'SafeCast: value must be positive'
          else:
              if Mask(1, 255, cd[(pools + 36)]):
                  call address(cd[(pools + 36)]).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                       gas gas_remaining wei
                      args address(recipient), not bool(Mask(1, 255, cd[(pools + 36)])), amount, 0xfffd8963efd1fc6a506488495d951d5263988d25, 160, 32, caller
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >=′ 64
                  if not ext_call.return_data[0] - 0x8000000000000000000000000000000000000000000000000000000000000000:
                      revert with 0, 17
                  if -ext_call.return_data[0] <′ 0:
                      revert with 0, 'SafeCast: value must be positive'
              else:
                  call address(cd[(pools + 36)]).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                       gas gas_remaining wei
                      args address(recipient), not bool(Mask(1, 255, cd[(pools + 36)])), amount, 4295128740, 160, 32, caller
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >=′ 64
                  if not ext_call.return_data[32] - 0x8000000000000000000000000000000000000000000000000000000000000000:
                      revert with 0, 17
                  if -ext_call.return_data[32] <′ 0:
                      revert with 0, 'SafeCast: value must be positive'
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def clipperSwap(address clipperExchange, address srcToken, address dstToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, bytes32 r, bytes32 vs) payable: 
  require calldata.size - 4 >=′ 256
  require clipperExchange == clipperExchange
  require srcToken == srcToken
  require dstToken == dstToken
  if not srcToken:
      if inputAmount != call.value:
          revert with InvalidMsgValue()
      if not srcToken:
          call clipperExchange.sellEthForToken(address outputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
             value inputAmount wei
               gas gas_remaining wei
              args dstToken, inputAmount, outputAmount, goodUntil, caller, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
      else:
          if not dstToken:
              if not dstToken == 1:
                  call clipperExchange.sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                       gas gas_remaining wei
                      args srcToken, inputAmount, outputAmount, goodUntil, caller, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
              else:
                  call clipperExchange.sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                       gas gas_remaining wei
                      args srcToken, inputAmount, outputAmount, goodUntil, this.address, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              if not dstToken - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
                     value outputAmount wei
                       gas gas_remaining wei
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transfer(address recipient, uint256 amount) with:
                       gas gas_remaining wei
                      args caller, outputAmount
          else:
              if dstToken != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                  call clipperExchange.swap(address inputToken, address outputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                       gas gas_remaining wei
                      args srcToken, dstToken, inputAmount, outputAmount, goodUntil, caller, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[420 len 31], data=5709241402184)
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
              else:
                  if not dstToken == 1:
                      call clipperExchange.sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                           gas gas_remaining wei
                          args srcToken, inputAmount, outputAmount, goodUntil, caller, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
                  else:
                      call clipperExchange.sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                           gas gas_remaining wei
                          args srcToken, inputAmount, outputAmount, goodUntil, this.address, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if not dstToken - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
                         value outputAmount wei
                           gas gas_remaining wei
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transfer(address recipient, uint256 amount) with:
                           gas gas_remaining wei
                          args caller, outputAmount
  else:
      if call.value:
          revert with InvalidMsgValue()
      if not srcToken - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
               gas gas_remaining wei
              args caller, this.address, inputAmount
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.withdraw(uint256 amount) with:
               gas gas_remaining wei
              args inputAmount
          call clipperExchange.sellEthForToken(address outputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
             value inputAmount wei
               gas gas_remaining wei
              args dstToken, inputAmount, outputAmount, goodUntil, caller, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
      else:
          call srcToken.transferFrom(address sender, address recipient, uint256 amount) with:
               gas gas_remaining wei
              args caller, clipperExchange, inputAmount
          if not ext_call.success:
              revert with SafeTransferFromFailed()
          if not return_data.size:
              if ext_code.size(srcToken) <= 0:
                  revert with SafeTransferFromFailed()
          else:
              if return_data.size <= 31 or ext_call.return_data[0] != 1:
                  revert with SafeTransferFromFailed()
          if not srcToken:
              call clipperExchange.sellEthForToken(address outputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                 value inputAmount wei
                   gas gas_remaining wei
                  args dstToken, inputAmount, outputAmount, goodUntil, caller, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
          else:
              if not dstToken:
                  if not dstToken == 1:
                      call clipperExchange.sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                           gas gas_remaining wei
                          args srcToken, inputAmount, outputAmount, goodUntil, caller, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
                  else:
                      call clipperExchange.sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                           gas gas_remaining wei
                          args srcToken, inputAmount, outputAmount, goodUntil, this.address, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if not dstToken - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
                         value outputAmount wei
                           gas gas_remaining wei
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transfer(address recipient, uint256 amount) with:
                           gas gas_remaining wei
                          args caller, outputAmount
              else:
                  if dstToken != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      call clipperExchange.swap(address inputToken, address outputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                           gas gas_remaining wei
                          args srcToken, dstToken, inputAmount, outputAmount, goodUntil, caller, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[420 len 31], data=5709241402184)
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                  else:
                      if not dstToken == 1:
                          call clipperExchange.sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                               gas gas_remaining wei
                              args srcToken, inputAmount, outputAmount, goodUntil, caller, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
                      else:
                          call clipperExchange.sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                               gas gas_remaining wei
                              args srcToken, inputAmount, outputAmount, goodUntil, this.address, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      if not dstToken - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
                             value outputAmount wei
                               gas gas_remaining wei
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transfer(address recipient, uint256 amount) with:
                               gas gas_remaining wei
                              args caller, outputAmount
  return outputAmount

def clipperSwapTo(address clipperExchange, address recipient, address srcToken, address dstToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, bytes32 r, bytes32 vs) payable: 
  require calldata.size - 4 >=′ 288
  require clipperExchange == clipperExchange
  require recipient == recipient
  require srcToken == srcToken
  require dstToken == dstToken
  if not srcToken:
      if inputAmount != call.value:
          revert with InvalidMsgValue()
      if not srcToken:
          call clipperExchange.sellEthForToken(address outputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
             value inputAmount wei
               gas gas_remaining wei
              args dstToken, inputAmount, outputAmount, goodUntil, recipient, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
      else:
          if not dstToken:
              if not dstToken == 1:
                  call clipperExchange.sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                       gas gas_remaining wei
                      args srcToken, inputAmount, outputAmount, goodUntil, recipient, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
              else:
                  call clipperExchange.sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                       gas gas_remaining wei
                      args srcToken, inputAmount, outputAmount, goodUntil, this.address, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              if not dstToken - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
                     value outputAmount wei
                       gas gas_remaining wei
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transfer(address recipient, uint256 amount) with:
                       gas gas_remaining wei
                      args recipient, outputAmount
          else:
              if dstToken != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                  call clipperExchange.swap(address inputToken, address outputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                       gas gas_remaining wei
                      args srcToken, dstToken, inputAmount, outputAmount, goodUntil, recipient, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[420 len 31], data=5709241402184)
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
              else:
                  if not dstToken == 1:
                      call clipperExchange.sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                           gas gas_remaining wei
                          args srcToken, inputAmount, outputAmount, goodUntil, recipient, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
                  else:
                      call clipperExchange.sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                           gas gas_remaining wei
                          args srcToken, inputAmount, outputAmount, goodUntil, this.address, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if not dstToken - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
                         value outputAmount wei
                           gas gas_remaining wei
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transfer(address recipient, uint256 amount) with:
                           gas gas_remaining wei
                          args recipient, outputAmount
  else:
      if call.value:
          revert with InvalidMsgValue()
      if not srcToken - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
               gas gas_remaining wei
              args caller, this.address, inputAmount
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.withdraw(uint256 amount) with:
               gas gas_remaining wei
              args inputAmount
          call clipperExchange.sellEthForToken(address outputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
             value inputAmount wei
               gas gas_remaining wei
              args dstToken, inputAmount, outputAmount, goodUntil, recipient, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
      else:
          call srcToken.transferFrom(address sender, address recipient, uint256 amount) with:
               gas gas_remaining wei
              args caller, clipperExchange, inputAmount
          if not ext_call.success:
              revert with SafeTransferFromFailed()
          if not return_data.size:
              if ext_code.size(srcToken) <= 0:
                  revert with SafeTransferFromFailed()
          else:
              if return_data.size <= 31 or ext_call.return_data[0] != 1:
                  revert with SafeTransferFromFailed()
          if not srcToken:
              call clipperExchange.sellEthForToken(address outputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                 value inputAmount wei
                   gas gas_remaining wei
                  args dstToken, inputAmount, outputAmount, goodUntil, recipient, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
          else:
              if not dstToken:
                  if not dstToken == 1:
                      call clipperExchange.sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                           gas gas_remaining wei
                          args srcToken, inputAmount, outputAmount, goodUntil, recipient, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
                  else:
                      call clipperExchange.sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                           gas gas_remaining wei
                          args srcToken, inputAmount, outputAmount, goodUntil, this.address, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if not dstToken - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
                         value outputAmount wei
                           gas gas_remaining wei
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transfer(address recipient, uint256 amount) with:
                           gas gas_remaining wei
                          args recipient, outputAmount
              else:
                  if dstToken != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      call clipperExchange.swap(address inputToken, address outputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                           gas gas_remaining wei
                          args srcToken, dstToken, inputAmount, outputAmount, goodUntil, recipient, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[420 len 31], data=5709241402184)
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                  else:
                      if not dstToken == 1:
                          call clipperExchange.sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                               gas gas_remaining wei
                              args srcToken, inputAmount, outputAmount, goodUntil, recipient, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
                      else:
                          call clipperExchange.sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                               gas gas_remaining wei
                              args srcToken, inputAmount, outputAmount, goodUntil, this.address, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      if not dstToken - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
                             value outputAmount wei
                               gas gas_remaining wei
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transfer(address recipient, uint256 amount) with:
                               gas gas_remaining wei
                              args recipient, outputAmount
  return outputAmount

def clipperSwapToWithPermit(address clipperExchange, address recipient, address srcToken, address dstToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, bytes32 r, bytes32 vs, bytes permit): # not payable
  require calldata.size - 4 >=′ 320
  require clipperExchange == clipperExchange
  require recipient == recipient
  require srcToken == srcToken
  require dstToken == dstToken
  require permit <= LOCK8605463013()
  require permit + 35 <′ calldata.size
  require permit.length <= LOCK8605463013()
  require permit + permit.length + 36 <= calldata.size
  if not -permit.length + 224:
      mem[100 len permit.length] = permit[all]
      call srcToken.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
           gas gas_remaining wei
          args permit[all]
  else:
      if -permit.length + 256:
          revert with 'h'XW'
      mem[100 len permit.length] = permit[all]
      call srcToken.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) with:
           gas gas_remaining wei
          args permit[all]
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  if not return_data.size:
      if ext_code.size(srcToken) <= 0:
          revert with ext_call.return_data[0 len return_data.size]
  else:
      if return_data.size <= 31 or ext_call.return_data[0] != 1:
          revert with ext_call.return_data[0 len return_data.size]
  if not srcToken:
      if inputAmount != call.value:
          revert with InvalidMsgValue()
      if not srcToken:
          call clipperExchange.sellEthForToken(address outputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
             value inputAmount wei
               gas gas_remaining wei
              args dstToken, inputAmount, outputAmount, goodUntil, recipient, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
      else:
          if not dstToken:
              if not dstToken == 1:
                  call clipperExchange.sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                       gas gas_remaining wei
                      args srcToken, inputAmount, outputAmount, goodUntil, recipient, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
              else:
                  call clipperExchange.sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                       gas gas_remaining wei
                      args srcToken, inputAmount, outputAmount, goodUntil, this.address, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              if not dstToken - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
                     value outputAmount wei
                       gas gas_remaining wei
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transfer(address recipient, uint256 amount) with:
                       gas gas_remaining wei
                      args recipient, outputAmount
          else:
              if dstToken != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                  call clipperExchange.swap(address inputToken, address outputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                       gas gas_remaining wei
                      args srcToken, dstToken, inputAmount, outputAmount, goodUntil, recipient, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[420 len 31], data=5709241402184)
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
              else:
                  if not dstToken == 1:
                      call clipperExchange.sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                           gas gas_remaining wei
                          args srcToken, inputAmount, outputAmount, goodUntil, recipient, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
                  else:
                      call clipperExchange.sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                           gas gas_remaining wei
                          args srcToken, inputAmount, outputAmount, goodUntil, this.address, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if not dstToken - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
                         value outputAmount wei
                           gas gas_remaining wei
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transfer(address recipient, uint256 amount) with:
                           gas gas_remaining wei
                          args recipient, outputAmount
  else:
      if call.value:
          revert with InvalidMsgValue()
      if not srcToken - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
               gas gas_remaining wei
              args caller, this.address, inputAmount
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.withdraw(uint256 amount) with:
               gas gas_remaining wei
              args inputAmount
          call clipperExchange.sellEthForToken(address outputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
             value inputAmount wei
               gas gas_remaining wei
              args dstToken, inputAmount, outputAmount, goodUntil, recipient, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
      else:
          call srcToken.transferFrom(address sender, address recipient, uint256 amount) with:
               gas gas_remaining wei
              args caller, clipperExchange, inputAmount
          if not ext_call.success:
              revert with SafeTransferFromFailed()
          if not return_data.size:
              if ext_code.size(srcToken) <= 0:
                  revert with SafeTransferFromFailed()
          else:
              if return_data.size <= 31 or ext_call.return_data[0] != 1:
                  revert with SafeTransferFromFailed()
          if not srcToken:
              call clipperExchange.sellEthForToken(address outputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                 value inputAmount wei
                   gas gas_remaining wei
                  args dstToken, inputAmount, outputAmount, goodUntil, recipient, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
          else:
              if not dstToken:
                  if not dstToken == 1:
                      call clipperExchange.sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                           gas gas_remaining wei
                          args srcToken, inputAmount, outputAmount, goodUntil, recipient, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
                  else:
                      call clipperExchange.sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                           gas gas_remaining wei
                          args srcToken, inputAmount, outputAmount, goodUntil, this.address, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if not dstToken - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
                         value outputAmount wei
                           gas gas_remaining wei
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transfer(address recipient, uint256 amount) with:
                           gas gas_remaining wei
                          args recipient, outputAmount
              else:
                  if dstToken != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      call clipperExchange.swap(address inputToken, address outputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                           gas gas_remaining wei
                          args srcToken, dstToken, inputAmount, outputAmount, goodUntil, recipient, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[420 len 31], data=5709241402184)
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                  else:
                      if not dstToken == 1:
                          call clipperExchange.sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                               gas gas_remaining wei
                              args srcToken, inputAmount, outputAmount, goodUntil, recipient, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
                      else:
                          call clipperExchange.sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, tuple theSignature, bytes auxiliaryData) with:
                               gas gas_remaining wei
                              args srcToken, inputAmount, outputAmount, goodUntil, this.address, (bool(vs) >> 255) + 27, r, 2 * vs, Array(len=mem[388 len 31], data=5709241402184)
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      if not dstToken - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
                             value outputAmount wei
                               gas gas_remaining wei
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transfer(address recipient, uint256 amount) with:
                               gas gas_remaining wei
                              args recipient, outputAmount
  return outputAmount

def swap(address executor, tuple desc, bytes permit, bytes data) payable: 
  require calldata.size - 4 >=′ 320
  require executor == executor
  require calldata.size - 36 >=′ 224
  require cd[260] <= LOCK8605463013()
  require cd[260] + 35 <′ calldata.size
  require ('cd', 260).length <= LOCK8605463013()
  require cd[260] + ('cd', 260).length + 36 <= calldata.size
  require cd[292] <= LOCK8605463013()
  require cd[292] + 35 <′ calldata.size
  require ('cd', 292).length <= LOCK8605463013()
  require cd[292] + ('cd', 292).length + 36 <= calldata.size
  if not -cd[196]:
      revert with ZeroMinReturn()
  require desc == address(desc)
  require permit == address(permit)
  if not address(desc):
      if Mask(1, 1, cd[228]):
          if not address(desc):
              if call.value <= cd[164]:
                  revert with InvalidMsgValue()
          else:
              if call.value <= 0:
                  revert with InvalidMsgValue()
          if not address(desc):
              call executor.execute(address ) with:
                 value call.value wei
                   gas gas_remaining wei
                  args caller, call.data[cd[292] + 36 len ('cd', 292).length], cd[164]
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              if not address(permit):
                  if not -eth.balance(this.address):
                      revert with ZeroReturnAmount()
                  if not bool(cd[228]):
                      if eth.balance(this.address) - 1 < cd[196]:
                          revert with ReturnAmountIsNotEnough()
                      require cd[132] == address(cd[132])
                      if address(cd[132]):
                          require cd[132] == address(cd[132])
                      else:
                          if not eth.balance(this.address) - 1:
                              return eth.balance(this.address) - 1, cd[164]
                          if address(permit):
                  else:
                      if not address(desc):
                          if eth.balance(this.address) <= 1:
                              if cd[164] != cd[164] * cd[196] / cd[196] and cd[196]:
                                  revert with 0, 17
                              if cd[164] != eth.balance(this.address) * cd[164] / eth.balance(this.address) - 1 and eth.balance(this.address) - 1:
                                  revert with 0, 17
                          else:
                              if cd[164] + -eth.balance(this.address) - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff > cd[164]:
                                  revert with 0, 17
                              if eth.balance(this.address) - 1:
                      else:
                          if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(desc):
                              if eth.balance(this.address) <= 1:
                                  if cd[164] != cd[164] * cd[196] / cd[196] and cd[196]:
                                      revert with 0, 17
                                  if cd[164] != eth.balance(this.address) * cd[164] / eth.balance(this.address) - 1 and eth.balance(this.address) - 1:
                                      revert with 0, 17
                              else:
                                  if cd[164] + -eth.balance(this.address) - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff > cd[164]:
                                      revert with 0, 17
                                  if eth.balance(this.address) - 1:
                          else:
                              static call address(desc).balanceOf(address account) with:
                                      gas gas_remaining wei
                                     args this.address
                              if not ext_call.success:
                                  revert with ext_call.return_data[0 len return_data.size]
                              require return_data.size >=′ 32
                              if ext_call.return_data[0] > 1:
              else:
                  if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(permit):
                      if not -eth.balance(this.address):
                          revert with ZeroReturnAmount()
                      if not bool(cd[228]):
                          if eth.balance(this.address) - 1 < cd[196]:
                              revert with ReturnAmountIsNotEnough()
                          require cd[132] == address(cd[132])
                          if address(cd[132]):
                              require cd[132] == address(cd[132])
                          else:
                              if not eth.balance(this.address) - 1:
                                  return eth.balance(this.address) - 1, cd[164]
                              if address(permit):
                      else:
                          if not address(desc):
                              if eth.balance(this.address) <= 1:
                                  if cd[164] != cd[164] * cd[196] / cd[196] and cd[196]:
                                      revert with 0, 17
                                  if cd[164] != eth.balance(this.address) * cd[164] / eth.balance(this.address) - 1 and eth.balance(this.address) - 1:
                                      revert with 0, 17
                              else:
                                  if cd[164] + -eth.balance(this.address) - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff > cd[164]:
                                      revert with 0, 17
                                  if eth.balance(this.address) - 1:
                          else:
                              if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(desc):
                                  if eth.balance(this.address) <= 1:
                                      if cd[164] != cd[164] * cd[196] / cd[196] and cd[196]:
                                          revert with 0, 17
                                      if cd[164] != eth.balance(this.address) * cd[164] / eth.balance(this.address) - 1 and eth.balance(this.address) - 1:
                                          revert with 0, 17
                                  else:
                                      if cd[164] + -eth.balance(this.address) - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff > cd[164]:
                                          revert with 0, 17
                                      if eth.balance(this.address) - 1:
                              else:
                                  static call address(desc).balanceOf(address account) with:
                                          gas gas_remaining wei
                                         args this.address
                                  if not ext_call.success:
                                      revert with ext_call.return_data[0 len return_data.size]
                                  require return_data.size >=′ 32
                                  if ext_call.return_data[0] > 1:
                  else:
                      static call address(permit).balanceOf(address account) with:
                              gas gas_remaining wei
                             args this.address
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if not -ext_call.return_data[0]:
                          revert with ZeroReturnAmount()
                      if not bool(cd[228]):
                          if ext_call.return_data[0] - 1 < cd[196]:
                              revert with ReturnAmountIsNotEnough()
                          require cd[132] == address(cd[132])
                          if not address(cd[132]):
                      else:
                          if not address(desc):
                              if eth.balance(this.address) > 1:
                          else:
                              if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(desc):
                                  if eth.balance(this.address) > 1:
                              else:
                                  static call address(desc).balanceOf(address account) with:
                                          gas gas_remaining wei
                                         args this.address
                                  if not ext_call.success:
                                      revert with ext_call.return_data[0 len return_data.size]
                                  require return_data.size >=′ 32
          else:
              if not ('cd', 260).length:
                  require data == address(data)
                  call address(desc).transferFrom(address sender, address recipient, uint256 amount) with:
                       gas gas_remaining wei
                      args caller, data, cd[164]
                  if not ext_call.success:
                      revert with SafeTransferFromFailed()
                  if not return_data.size:
                      if ext_code.size(address(desc)) <= 0:
                          revert with SafeTransferFromFailed()
                  else:
                      if return_data.size <= 31 or ext_call.return_data[0] != 1:
                          revert with SafeTransferFromFailed()
                  call executor.execute(address ) with:
                     value call.value wei
                       gas gas_remaining wei
                      args caller, call.data[cd[292] + 36 len ('cd', 292).length], cd[164]
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if not address(permit):
                      if not -eth.balance(this.address):
                          revert with ZeroReturnAmount()
                      if not bool(cd[228]):
                  else:
                      if address(permit) != 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee:
                          static call address(permit).balanceOf(address account) with:
                                  gas gas_remaining wei
                                 args this.address
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          require return_data.size >=′ 32
                      else:
                          if not -eth.balance(this.address):
                              revert with ZeroReturnAmount()
                          if not bool(cd[228]):
              else:
                  if not -('cd', 260).length + 224:
                      call address(desc).permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
                           gas gas_remaining wei
                          args call.data[cd[260] + 36 len ('cd', 260).length]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      if not return_data.size:
                          if ext_code.size(address(desc)) <= 0:
                              revert with ext_call.return_data[0 len return_data.size]
                      else:
                          if return_data.size <= 31 or ext_call.return_data[0] != 1:
                              revert with ext_call.return_data[0 len return_data.size]
                      require data == address(data)
                      call address(desc).transferFrom(address sender, address recipient, uint256 amount) with:
                           gas gas_remaining wei
                          args caller, data, cd[164]
                      if not ext_call.success:
                          revert with SafeTransferFromFailed()
                      if not return_data.size:
                          if ext_code.size(address(desc)) <= 0:
                              revert with SafeTransferFromFailed()
                      else:
                          if return_data.size <= 31 or ext_call.return_data[0] != 1:
                              revert with SafeTransferFromFailed()
                      call executor.execute(address ) with:
                         value call.value wei
                           gas gas_remaining wei
                          args caller, call.data[cd[292] + 36 len ('cd', 292).length], cd[164]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                  else:
                      if -('cd', 260).length + 256:
                          revert with 'h'XW'
                      call address(desc).permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) with:
                           gas gas_remaining wei
                          args call.data[cd[260] + 36 len ('cd', 260).length]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      if not return_data.size:
                          if ext_code.size(address(desc)) <= 0:
                              revert with ext_call.return_data[0 len return_data.size]
                      else:
                          if return_data.size <= 31 or ext_call.return_data[0] != 1:
                              revert with ext_call.return_data[0 len return_data.size]
                      require data == address(data)
                      call address(desc).transferFrom(address sender, address recipient, uint256 amount) with:
                           gas gas_remaining wei
                          args caller, data, cd[164]
                      if not ext_call.success:
                          revert with SafeTransferFromFailed()
                      if not return_data.size:
                          if ext_code.size(address(desc)) <= 0:
                              revert with SafeTransferFromFailed()
                      else:
                          if return_data.size <= 31 or ext_call.return_data[0] != 1:
                              revert with SafeTransferFromFailed()
                      call executor.execute(address ) with:
                         value call.value wei
                           gas gas_remaining wei
                          args caller, call.data[cd[292] + 36 len ('cd', 292).length], cd[164]
      else:
          if not address(desc):
              if cd[164] != call.value:
                  revert with InvalidMsgValue()
          else:
              if call.value:
                  revert with InvalidMsgValue()
          if address(desc):
              if not ('cd', 260).length:
                  require data == address(data)
                  call address(desc).transferFrom(address sender, address recipient, uint256 amount) with:
                       gas gas_remaining wei
                      args caller, data, cd[164]
                  if not ext_call.success:
                      revert with SafeTransferFromFailed()
                  if not return_data.size:
                      if ext_code.size(address(desc)) <= 0:
                          revert with SafeTransferFromFailed()
                  else:
                      if return_data.size <= 31 or ext_call.return_data[0] != 1:
                          revert with SafeTransferFromFailed()
                  call executor.execute(address ) with:
                     value call.value wei
                       gas gas_remaining wei
                      args caller, call.data[cd[292] + 36 len ('cd', 292).length], cd[164]
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if not address(permit):
                      if not -eth.balance(this.address):
                          revert with ZeroReturnAmount()
                      if not bool(cd[228]):
                          if eth.balance(this.address) - 1 < cd[196]:
                              revert with ReturnAmountIsNotEnough()
                  else:
                      if address(permit) != 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee:
                          static call address(permit).balanceOf(address account) with:
                                  gas gas_remaining wei
                                 args this.address
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          require return_data.size >=′ 32
                      else:
                          if not -eth.balance(this.address):
                              revert with ZeroReturnAmount()
                          if not bool(cd[228]):
                              if eth.balance(this.address) - 1 < cd[196]:
                                  revert with ReturnAmountIsNotEnough()
              else:
                  if not -('cd', 260).length + 224:
                      call address(desc).permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
                           gas gas_remaining wei
                          args call.data[cd[260] + 36 len ('cd', 260).length]
                  else:
                      if -('cd', 260).length + 256:
                          revert with 'h'XW'
                      call address(desc).permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) with:
                           gas gas_remaining wei
                          args call.data[cd[260] + 36 len ('cd', 260).length]
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if not return_data.size:
                      if ext_code.size(address(desc)) <= 0:
                          revert with ext_call.return_data[0 len return_data.size]
                  else:
                      if return_data.size <= 31 or ext_call.return_data[0] != 1:
                          revert with ext_call.return_data[0 len return_data.size]
                  require data == address(data)
                  call address(desc).transferFrom(address sender, address recipient, uint256 amount) with:
                       gas gas_remaining wei
                      args caller, data, cd[164]
                  if not ext_call.success:
                      revert with SafeTransferFromFailed()
                  if not return_data.size:
                      if ext_code.size(address(desc)) <= 0:
                          revert with SafeTransferFromFailed()
                  else:
                      if return_data.size <= 31 or ext_call.return_data[0] != 1:
                          revert with SafeTransferFromFailed()
                  call executor.execute(address ) with:
                     value call.value wei
                       gas gas_remaining wei
                      args caller, call.data[cd[292] + 36 len ('cd', 292).length], cd[164]
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
          else:
              call executor.execute(address ) with:
                 value call.value wei
                   gas gas_remaining wei
                  args caller, call.data[cd[292] + 36 len ('cd', 292).length], cd[164]
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              if not address(permit):
                  if not -eth.balance(this.address):
                      revert with ZeroReturnAmount()
                  if not bool(cd[228]):
                      if eth.balance(this.address) - 1 < cd[196]:
                          revert with ReturnAmountIsNotEnough()
                      require cd[132] == address(cd[132])
                      if address(cd[132]):
                          require cd[132] == address(cd[132])
                      else:
                          if not eth.balance(this.address) - 1:
                              return eth.balance(this.address) - 1, cd[164]
                          if address(permit):
                              if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(permit):
                  else:
                      if not address(desc):
                          if eth.balance(this.address) <= 1:
                              if cd[164] != cd[164] * cd[196] / cd[196] and cd[196]:
                                  revert with 0, 17
                              if cd[164] != eth.balance(this.address) * cd[164] / eth.balance(this.address) - 1 and eth.balance(this.address) - 1:
                                  revert with 0, 17
                              if eth.balance(this.address) * cd[164] < cd[164] * cd[196]:
                                  revert with ReturnAmountIsNotEnough()
                          else:
                              if cd[164] + -eth.balance(this.address) - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff > cd[164]:
                                  revert with 0, 17
                              if eth.balance(this.address) - 1:
                      else:
                          if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(desc):
                              if eth.balance(this.address) <= 1:
                                  if cd[164] != cd[164] * cd[196] / cd[196] and cd[196]:
                                      revert with 0, 17
                                  if cd[164] != eth.balance(this.address) * cd[164] / eth.balance(this.address) - 1 and eth.balance(this.address) - 1:
                                      revert with 0, 17
                                  if eth.balance(this.address) * cd[164] < cd[164] * cd[196]:
                                      revert with ReturnAmountIsNotEnough()
                              else:
                                  if cd[164] + -eth.balance(this.address) - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff > cd[164]:
                                      revert with 0, 17
                                  if eth.balance(this.address) - 1:
                          else:
                              static call address(desc).balanceOf(address account) with:
                                      gas gas_remaining wei
                                     args this.address
                              if not ext_call.success:
                                  revert with ext_call.return_data[0 len return_data.size]
                              require return_data.size >=′ 32
                              if ext_call.return_data[0] <= 1:
                                  if cd[164] != cd[164] * cd[196] / cd[196] and cd[196]:
                                      revert with 0, 17
                              else:
                                  if cd[164] + -ext_call.return_data[0] - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff > cd[164]:
                                      revert with 0, 17
              else:
                  if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(permit):
                      if not -eth.balance(this.address):
                          revert with ZeroReturnAmount()
                      if not bool(cd[228]):
                          if eth.balance(this.address) - 1 < cd[196]:
                              revert with ReturnAmountIsNotEnough()
                          require cd[132] == address(cd[132])
                          if address(cd[132]):
                              require cd[132] == address(cd[132])
                          else:
                              if not eth.balance(this.address) - 1:
                                  return eth.balance(this.address) - 1, cd[164]
                              if address(permit):
                                  if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(permit):
                      else:
                          if not address(desc):
                              if eth.balance(this.address) <= 1:
                                  if cd[164] != cd[164] * cd[196] / cd[196] and cd[196]:
                                      revert with 0, 17
                                  if cd[164] != eth.balance(this.address) * cd[164] / eth.balance(this.address) - 1 and eth.balance(this.address) - 1:
                                      revert with 0, 17
                                  if eth.balance(this.address) * cd[164] < cd[164] * cd[196]:
                                      revert with ReturnAmountIsNotEnough()
                              else:
                                  if cd[164] + -eth.balance(this.address) - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff > cd[164]:
                                      revert with 0, 17
                                  if eth.balance(this.address) - 1:
                          else:
                              if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(desc):
                                  if eth.balance(this.address) <= 1:
                                      if cd[164] != cd[164] * cd[196] / cd[196] and cd[196]:
                                          revert with 0, 17
                                      if cd[164] != eth.balance(this.address) * cd[164] / eth.balance(this.address) - 1 and eth.balance(this.address) - 1:
                                          revert with 0, 17
                                      if eth.balance(this.address) * cd[164] < cd[164] * cd[196]:
                                          revert with ReturnAmountIsNotEnough()
                                  else:
                                      if cd[164] + -eth.balance(this.address) - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff > cd[164]:
                                          revert with 0, 17
                                      if eth.balance(this.address) - 1:
                              else:
                                  static call address(desc).balanceOf(address account) with:
                                          gas gas_remaining wei
                                         args this.address
                                  if not ext_call.success:
                                      revert with ext_call.return_data[0 len return_data.size]
                                  require return_data.size >=′ 32
                                  if ext_call.return_data[0] <= 1:
                                      if cd[164] != cd[164] * cd[196] / cd[196] and cd[196]:
                                          revert with 0, 17
                                  else:
                                      if cd[164] + -ext_call.return_data[0] - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff > cd[164]:
                                          revert with 0, 17
                  else:
                      static call address(permit).balanceOf(address account) with:
                              gas gas_remaining wei
                             args this.address
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if not -ext_call.return_data[0]:
                          revert with ZeroReturnAmount()
                      if not bool(cd[228]):
                          if ext_call.return_data[0] - 1 < cd[196]:
                              revert with ReturnAmountIsNotEnough()
                          require cd[132] == address(cd[132])
                          if address(cd[132]):
                      else:
                          if not address(desc):
                              if eth.balance(this.address) <= 1:
                                  if cd[164] != cd[164] * cd[196] / cd[196] and cd[196]:
                                      revert with 0, 17
                              else:
                                  if cd[164] + -eth.balance(this.address) - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff > cd[164]:
                                      revert with 0, 17
                          else:
                              if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(desc):
                                  if eth.balance(this.address) <= 1:
                                      if cd[164] != cd[164] * cd[196] / cd[196] and cd[196]:
                                          revert with 0, 17
                                  else:
                                      if cd[164] + -eth.balance(this.address) - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff > cd[164]:
                                          revert with 0, 17
                              else:
                                  static call address(desc).balanceOf(address account) with:
                                          gas gas_remaining wei
                                         args this.address
                                  if not ext_call.success:
                                      revert with ext_call.return_data[0 len return_data.size]
                                  require return_data.size >=′ 32
  else:
      if Mask(1, 1, cd[228]):
          if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(desc):
              if call.value <= cd[164]:
                  revert with InvalidMsgValue()
          else:
              if call.value <= 0:
                  revert with InvalidMsgValue()
          if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(desc):
              call executor.execute(address ) with:
                 value call.value wei
                   gas gas_remaining wei
                  args caller, call.data[cd[292] + 36 len ('cd', 292).length], cd[164]
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              if not address(permit):
                  if not -eth.balance(this.address):
                      revert with ZeroReturnAmount()
                  if not bool(cd[228]):
                      if eth.balance(this.address) - 1 < cd[196]:
                          revert with ReturnAmountIsNotEnough()
                      require cd[132] == address(cd[132])
                      if address(cd[132]):
                          require cd[132] == address(cd[132])
                      else:
                          if not eth.balance(this.address) - 1:
                              return eth.balance(this.address) - 1, cd[164]
                          if address(permit):
                  else:
                      if not address(desc):
                          if eth.balance(this.address) <= 1:
                              if cd[164] != cd[164] * cd[196] / cd[196] and cd[196]:
                                  revert with 0, 17
                              if cd[164] != eth.balance(this.address) * cd[164] / eth.balance(this.address) - 1 and eth.balance(this.address) - 1:
                                  revert with 0, 17
                          else:
                              if cd[164] + -eth.balance(this.address) - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff > cd[164]:
                                  revert with 0, 17
                              if eth.balance(this.address) - 1:
                      else:
                          if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(desc):
                              if eth.balance(this.address) <= 1:
                                  if cd[164] != cd[164] * cd[196] / cd[196] and cd[196]:
                                      revert with 0, 17
                                  if cd[164] != eth.balance(this.address) * cd[164] / eth.balance(this.address) - 1 and eth.balance(this.address) - 1:
                                      revert with 0, 17
                              else:
                                  if cd[164] + -eth.balance(this.address) - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff > cd[164]:
                                      revert with 0, 17
                                  if eth.balance(this.address) - 1:
                          else:
                              static call address(desc).balanceOf(address account) with:
                                      gas gas_remaining wei
                                     args this.address
                              if not ext_call.success:
                                  revert with ext_call.return_data[0 len return_data.size]
                              require return_data.size >=′ 32
                              if ext_call.return_data[0] > 1:
              else:
                  if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(permit):
                      if not -eth.balance(this.address):
                          revert with ZeroReturnAmount()
                      if not bool(cd[228]):
                          if eth.balance(this.address) - 1 < cd[196]:
                              revert with ReturnAmountIsNotEnough()
                          require cd[132] == address(cd[132])
                          if address(cd[132]):
                              require cd[132] == address(cd[132])
                          else:
                              if not eth.balance(this.address) - 1:
                                  return eth.balance(this.address) - 1, cd[164]
                              if address(permit):
                      else:
                          if not address(desc):
                              if eth.balance(this.address) <= 1:
                                  if cd[164] != cd[164] * cd[196] / cd[196] and cd[196]:
                                      revert with 0, 17
                                  if cd[164] != eth.balance(this.address) * cd[164] / eth.balance(this.address) - 1 and eth.balance(this.address) - 1:
                                      revert with 0, 17
                              else:
                                  if cd[164] + -eth.balance(this.address) - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff > cd[164]:
                                      revert with 0, 17
                                  if eth.balance(this.address) - 1:
                          else:
                              if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(desc):
                                  if eth.balance(this.address) <= 1:
                                      if cd[164] != cd[164] * cd[196] / cd[196] and cd[196]:
                                          revert with 0, 17
                                      if cd[164] != eth.balance(this.address) * cd[164] / eth.balance(this.address) - 1 and eth.balance(this.address) - 1:
                                          revert with 0, 17
                                  else:
                                      if cd[164] + -eth.balance(this.address) - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff > cd[164]:
                                          revert with 0, 17
                                      if eth.balance(this.address) - 1:
                              else:
                                  static call address(desc).balanceOf(address account) with:
                                          gas gas_remaining wei
                                         args this.address
                                  if not ext_call.success:
                                      revert with ext_call.return_data[0 len return_data.size]
                                  require return_data.size >=′ 32
                                  if ext_call.return_data[0] > 1:
                  else:
                      static call address(permit).balanceOf(address account) with:
                              gas gas_remaining wei
                             args this.address
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if not -ext_call.return_data[0]:
                          revert with ZeroReturnAmount()
                      if not bool(cd[228]):
                          if ext_call.return_data[0] - 1 < cd[196]:
                              revert with ReturnAmountIsNotEnough()
                          require cd[132] == address(cd[132])
                          if not address(cd[132]):
                      else:
                          if not address(desc):
                              if eth.balance(this.address) > 1:
                          else:
                              if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(desc):
                                  if eth.balance(this.address) > 1:
                              else:
                                  static call address(desc).balanceOf(address account) with:
                                          gas gas_remaining wei
                                         args this.address
                                  if not ext_call.success:
                                      revert with ext_call.return_data[0 len return_data.size]
                                  require return_data.size >=′ 32
          else:
              if not ('cd', 260).length:
                  require data == address(data)
                  call address(desc).transferFrom(address sender, address recipient, uint256 amount) with:
                       gas gas_remaining wei
                      args caller, data, cd[164]
                  if not ext_call.success:
                      revert with SafeTransferFromFailed()
                  if not return_data.size:
                      if ext_code.size(address(desc)) <= 0:
                          revert with SafeTransferFromFailed()
                  else:
                      if return_data.size <= 31 or ext_call.return_data[0] != 1:
                          revert with SafeTransferFromFailed()
                  call executor.execute(address ) with:
                     value call.value wei
                       gas gas_remaining wei
                      args caller, call.data[cd[292] + 36 len ('cd', 292).length], cd[164]
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if not address(permit):
                      if not -eth.balance(this.address):
                          revert with ZeroReturnAmount()
                      if not bool(cd[228]):
                  else:
                      if address(permit) != 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee:
                          static call address(permit).balanceOf(address account) with:
                                  gas gas_remaining wei
                                 args this.address
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          require return_data.size >=′ 32
                      else:
                          if not -eth.balance(this.address):
                              revert with ZeroReturnAmount()
                          if not bool(cd[228]):
              else:
                  if not -('cd', 260).length + 224:
                      call address(desc).permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
                           gas gas_remaining wei
                          args call.data[cd[260] + 36 len ('cd', 260).length]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      if not return_data.size:
                          if ext_code.size(address(desc)) <= 0:
                              revert with ext_call.return_data[0 len return_data.size]
                      else:
                          if return_data.size <= 31 or ext_call.return_data[0] != 1:
                              revert with ext_call.return_data[0 len return_data.size]
                      require data == address(data)
                      call address(desc).transferFrom(address sender, address recipient, uint256 amount) with:
                           gas gas_remaining wei
                          args caller, data, cd[164]
                      if not ext_call.success:
                          revert with SafeTransferFromFailed()
                      if not return_data.size:
                          if ext_code.size(address(desc)) <= 0:
                              revert with SafeTransferFromFailed()
                      else:
                          if return_data.size <= 31 or ext_call.return_data[0] != 1:
                              revert with SafeTransferFromFailed()
                      call executor.execute(address ) with:
                         value call.value wei
                           gas gas_remaining wei
                          args caller, call.data[cd[292] + 36 len ('cd', 292).length], cd[164]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                  else:
                      if -('cd', 260).length + 256:
                          revert with 'h'XW'
                      call address(desc).permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) with:
                           gas gas_remaining wei
                          args call.data[cd[260] + 36 len ('cd', 260).length]
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      if not return_data.size:
                          if ext_code.size(address(desc)) <= 0:
                              revert with ext_call.return_data[0 len return_data.size]
                      else:
                          if return_data.size <= 31 or ext_call.return_data[0] != 1:
                              revert with ext_call.return_data[0 len return_data.size]
                      require data == address(data)
                      call address(desc).transferFrom(address sender, address recipient, uint256 amount) with:
                           gas gas_remaining wei
                          args caller, data, cd[164]
                      if not ext_call.success:
                          revert with SafeTransferFromFailed()
                      if not return_data.size:
                          if ext_code.size(address(desc)) <= 0:
                              revert with SafeTransferFromFailed()
                      else:
                          if return_data.size <= 31 or ext_call.return_data[0] != 1:
                              revert with SafeTransferFromFailed()
                      call executor.execute(address ) with:
                         value call.value wei
                           gas gas_remaining wei
                          args caller, call.data[cd[292] + 36 len ('cd', 292).length], cd[164]
      else:
          if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(desc):
              if cd[164] != call.value:
                  revert with InvalidMsgValue()
          else:
              if call.value:
                  revert with InvalidMsgValue()
          if address(desc) != 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee:
              if not ('cd', 260).length:
                  require data == address(data)
                  call address(desc).transferFrom(address sender, address recipient, uint256 amount) with:
                       gas gas_remaining wei
                      args caller, data, cd[164]
                  if not ext_call.success:
                      revert with SafeTransferFromFailed()
                  if not return_data.size:
                      if ext_code.size(address(desc)) <= 0:
                          revert with SafeTransferFromFailed()
                  else:
                      if return_data.size <= 31 or ext_call.return_data[0] != 1:
                          revert with SafeTransferFromFailed()
                  call executor.execute(address ) with:
                     value call.value wei
                       gas gas_remaining wei
                      args caller, call.data[cd[292] + 36 len ('cd', 292).length], cd[164]
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if not address(permit):
                      if not -eth.balance(this.address):
                          revert with ZeroReturnAmount()
                      if not bool(cd[228]):
                          if eth.balance(this.address) - 1 < cd[196]:
                              revert with ReturnAmountIsNotEnough()
                  else:
                      if address(permit) != 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee:
                          static call address(permit).balanceOf(address account) with:
                                  gas gas_remaining wei
                                 args this.address
                          if not ext_call.success:
                              revert with ext_call.return_data[0 len return_data.size]
                          require return_data.size >=′ 32
                      else:
                          if not -eth.balance(this.address):
                              revert with ZeroReturnAmount()
                          if not bool(cd[228]):
                              if eth.balance(this.address) - 1 < cd[196]:
                                  revert with ReturnAmountIsNotEnough()
              else:
                  if not -('cd', 260).length + 224:
                      call address(desc).permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
                           gas gas_remaining wei
                          args call.data[cd[260] + 36 len ('cd', 260).length]
                  else:
                      if -('cd', 260).length + 256:
                          revert with 'h'XW'
                      call address(desc).permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) with:
                           gas gas_remaining wei
                          args call.data[cd[260] + 36 len ('cd', 260).length]
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  if not return_data.size:
                      if ext_code.size(address(desc)) <= 0:
                          revert with ext_call.return_data[0 len return_data.size]
                  else:
                      if return_data.size <= 31 or ext_call.return_data[0] != 1:
                          revert with ext_call.return_data[0 len return_data.size]
                  require data == address(data)
                  call address(desc).transferFrom(address sender, address recipient, uint256 amount) with:
                       gas gas_remaining wei
                      args caller, data, cd[164]
                  if not ext_call.success:
                      revert with SafeTransferFromFailed()
                  if not return_data.size:
                      if ext_code.size(address(desc)) <= 0:
                          revert with SafeTransferFromFailed()
                  else:
                      if return_data.size <= 31 or ext_call.return_data[0] != 1:
                          revert with SafeTransferFromFailed()
                  call executor.execute(address ) with:
                     value call.value wei
                       gas gas_remaining wei
                      args caller, call.data[cd[292] + 36 len ('cd', 292).length], cd[164]
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
          else:
              call executor.execute(address ) with:
                 value call.value wei
                   gas gas_remaining wei
                  args caller, call.data[cd[292] + 36 len ('cd', 292).length], cd[164]
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
              if not address(permit):
                  if not -eth.balance(this.address):
                      revert with ZeroReturnAmount()
                  if not bool(cd[228]):
                      if eth.balance(this.address) - 1 < cd[196]:
                          revert with ReturnAmountIsNotEnough()
                      require cd[132] == address(cd[132])
                      if address(cd[132]):
                          require cd[132] == address(cd[132])
                      else:
                          if not eth.balance(this.address) - 1:
                              return eth.balance(this.address) - 1, cd[164]
                          if address(permit):
                              if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(permit):
                  else:
                      if not address(desc):
                          if eth.balance(this.address) <= 1:
                              if cd[164] != cd[164] * cd[196] / cd[196] and cd[196]:
                                  revert with 0, 17
                              if cd[164] != eth.balance(this.address) * cd[164] / eth.balance(this.address) - 1 and eth.balance(this.address) - 1:
                                  revert with 0, 17
                              if eth.balance(this.address) * cd[164] < cd[164] * cd[196]:
                                  revert with ReturnAmountIsNotEnough()
                          else:
                              if cd[164] + -eth.balance(this.address) - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff > cd[164]:
                                  revert with 0, 17
                              if eth.balance(this.address) - 1:
                      else:
                          if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(desc):
                              if eth.balance(this.address) <= 1:
                                  if cd[164] != cd[164] * cd[196] / cd[196] and cd[196]:
                                      revert with 0, 17
                                  if cd[164] != eth.balance(this.address) * cd[164] / eth.balance(this.address) - 1 and eth.balance(this.address) - 1:
                                      revert with 0, 17
                                  if eth.balance(this.address) * cd[164] < cd[164] * cd[196]:
                                      revert with ReturnAmountIsNotEnough()
                              else:
                                  if cd[164] + -eth.balance(this.address) - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff > cd[164]:
                                      revert with 0, 17
                                  if eth.balance(this.address) - 1:
                          else:
                              static call address(desc).balanceOf(address account) with:
                                      gas gas_remaining wei
                                     args this.address
                              if not ext_call.success:
                                  revert with ext_call.return_data[0 len return_data.size]
                              require return_data.size >=′ 32
                              if ext_call.return_data[0] <= 1:
                                  if cd[164] != cd[164] * cd[196] / cd[196] and cd[196]:
                                      revert with 0, 17
                              else:
                                  if cd[164] + -ext_call.return_data[0] - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff > cd[164]:
                                      revert with 0, 17
              else:
                  if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(permit):
                      if not -eth.balance(this.address):
                          revert with ZeroReturnAmount()
                      if not bool(cd[228]):
                          if eth.balance(this.address) - 1 < cd[196]:
                              revert with ReturnAmountIsNotEnough()
                          require cd[132] == address(cd[132])
                          if address(cd[132]):
                              require cd[132] == address(cd[132])
                          else:
                              if not eth.balance(this.address) - 1:
                                  return eth.balance(this.address) - 1, cd[164]
                              if address(permit):
                                  if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(permit):
                      else:
                          if not address(desc):
                              if eth.balance(this.address) <= 1:
                                  if cd[164] != cd[164] * cd[196] / cd[196] and cd[196]:
                                      revert with 0, 17
                                  if cd[164] != eth.balance(this.address) * cd[164] / eth.balance(this.address) - 1 and eth.balance(this.address) - 1:
                                      revert with 0, 17
                                  if eth.balance(this.address) * cd[164] < cd[164] * cd[196]:
                                      revert with ReturnAmountIsNotEnough()
                              else:
                                  if cd[164] + -eth.balance(this.address) - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff > cd[164]:
                                      revert with 0, 17
                                  if eth.balance(this.address) - 1:
                          else:
                              if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(desc):
                                  if eth.balance(this.address) <= 1:
                                      if cd[164] != cd[164] * cd[196] / cd[196] and cd[196]:
                                          revert with 0, 17
                                      if cd[164] != eth.balance(this.address) * cd[164] / eth.balance(this.address) - 1 and eth.balance(this.address) - 1:
                                          revert with 0, 17
                                      if eth.balance(this.address) * cd[164] < cd[164] * cd[196]:
                                          revert with ReturnAmountIsNotEnough()
                                  else:
                                      if cd[164] + -eth.balance(this.address) - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff > cd[164]:
                                          revert with 0, 17
                                      if eth.balance(this.address) - 1:
                              else:
                                  static call address(desc).balanceOf(address account) with:
                                          gas gas_remaining wei
                                         args this.address
                                  if not ext_call.success:
                                      revert with ext_call.return_data[0 len return_data.size]
                                  require return_data.size >=′ 32
                                  if ext_call.return_data[0] <= 1:
                                      if cd[164] != cd[164] * cd[196] / cd[196] and cd[196]:
                                          revert with 0, 17
                                  else:
                                      if cd[164] + -ext_call.return_data[0] - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff > cd[164]:
                                          revert with 0, 17
                  else:
                      static call address(permit).balanceOf(address account) with:
                              gas gas_remaining wei
                             args this.address
                      if not ext_call.success:
                          revert with ext_call.return_data[0 len return_data.size]
                      require return_data.size >=′ 32
                      if not -ext_call.return_data[0]:
                          revert with ZeroReturnAmount()
                      if not bool(cd[228]):
                          if ext_call.return_data[0] - 1 < cd[196]:
                              revert with ReturnAmountIsNotEnough()
                          require cd[132] == address(cd[132])
                          if address(cd[132]):
                      else:
                          if not address(desc):
                              if eth.balance(this.address) <= 1:
                                  if cd[164] != cd[164] * cd[196] / cd[196] and cd[196]:
                                      revert with 0, 17
                              else:
                                  if cd[164] + -eth.balance(this.address) - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff > cd[164]:
                                      revert with 0, 17
                          else:
                              if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == address(desc):
                                  if eth.balance(this.address) <= 1:
                                      if cd[164] != cd[164] * cd[196] / cd[196] and cd[196]:
                                          revert with 0, 17
                                  else:
                                      if cd[164] + -eth.balance(this.address) - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff > cd[164]:
                                          revert with 0, 17
                              else:
                                  static call address(desc).balanceOf(address account) with:
                                          gas gas_remaining wei
                                         args this.address
                                  if not ext_call.success:
                                      revert with ext_call.return_data[0 len return_data.size]
                                  require return_data.size >=′ 32
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def gt(uint256 value, bytes data): # not payable
  require calldata.size - 4 >=′ 64
  require data <= LOCK8605463013()
  require data + 35 <′ calldata.size
  require data.length <= LOCK8605463013()
  require data + data.length + 36 <= calldata.size
  if data.length < 4:
      revert with IncorrectDataLength()
  if data.length < 36:
      revert with IncorrectDataLength()
  if not (uint32(cd[(data + 36)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
      if block.timestamp < cd[(data + 40)] % unknown10000000() >> 208:
          if not nonce[address(cd[(data + 40)])]:
              return (1 > value)
      return (0 > value)
  if uint32(cd[(data + 36)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
      if uint32(cd[(data + 36)]) >> 224 < lt(uint256 value, bytes data):
          if (uint32(cd[(data + 36)]) >> 224) - arbitraryStaticCall(address target, bytes data):
              if not (uint32(cd[(data + 36)]) >> 224) - and(uint256 offsets, bytes data):
                  if data.length < 100:
                      revert with IncorrectDataLength()
                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              mem[96 len data.length] = data[all]
              static call this.address.mem[96 len 4] with:
                      gas gas_remaining wei
                     args mem[100 len data.length - 4]
              if return_data.size != 32 or not ext_call.success:
                  return bool(32 == return_data.size and ext_call.success)
          else:
              if data.length < 100:
                  revert with IncorrectDataLength()
              mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
              static call cd[(data + 40)].mem[96 len 4] with:
                      gas gas_remaining wei
                     args mem[100 len data.length - 104]
              if return_data.size != 32 or not ext_call.success:
                  revert with ArbitraryStaticCallFailed()
              if return_data.size != 32 or not ext_call.success:
                  revert with ArbitraryStaticCallFailed()
          ('iszero', ('or', ('iszero', ('eq', 32, 'returndatasize')), ('iszero', 'ext_call.success')))
          return (ext_call.return_data[0] > value)
      if (uint32(cd[(data + 36)]) >> 224) - lt(uint256 value, bytes data):
          if not (uint32(cd[(data + 36)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
              if data.length < 68:
                  revert with IncorrectDataLength()
              if nonce[address(cd[(data + 40)])] == cd[(data + 72)]:
                  return (1 > value)
              return (0 > value)
          mem[96 len data.length] = data[all]
          static call this.address.mem[96 len 4] with:
                  gas gas_remaining wei
                 args mem[100 len data.length - 4]
          if return_data.size != 32 or not ext_call.success:
              return bool(32 == return_data.size and ext_call.success)
          return (ext_call.return_data[0] > value)
      if data.length < 100:
          revert with IncorrectDataLength()
      if data.length - 100 < 4:
          revert with IncorrectDataLength()
      if data.length - 100 < 36:
          revert with IncorrectDataLength()
      if not (uint32(cd[(data + 136)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
          if block.timestamp >= cd[(data + 140)] % unknown10000000() >> 208:
              if 0 < cd[(data + 40)]:
                  return (1 > value)
          else:
              if not nonce[address(cd[(data + 140)])]:
                  if 1 < cd[(data + 40)]:
                      return (1 > value)
              else:
                  if 0 < cd[(data + 40)]:
                      return (1 > value)
          return (0 > value)
      if uint32(cd[(data + 136)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
          if uint32(cd[(data + 136)]) >> 224 >= lt(uint256 value, bytes data):
              if (uint32(cd[(data + 136)]) >> 224) - lt(uint256 value, bytes data):
                  if not (uint32(cd[(data + 136)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                      if data.length - 100 < 68:
                          revert with IncorrectDataLength()
                      if nonce[address(cd[(data + 140)])] == cd[(data + 172)]:
                          if 1 < cd[(data + 40)]:
                              return (1 > value)
                      else:
                          if 0 < cd[(data + 40)]:
                              return (1 > value)
                  else:
                      mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                      static call this.address.mem[96 len 4] with:
                              gas gas_remaining wei
                             args mem[100 len data.length - 104]
                      if 32 == return_data.size and ext_call.success:
                          if ext_call.return_data[0] < cd[(data + 40)]:
                              return (1 > value)
                  return (0 > value)
              if data.length - 100 < 100:
                  revert with IncorrectDataLength()
              if data.length - 200 < 4:
                  revert with IncorrectDataLength()
              if data.length - 200 < 36:
                  revert with IncorrectDataLength()
              if not (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                  if block.timestamp < cd[(data + 240)] % unknown10000000() >> 208:
              else:
                  if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                      if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                          if not (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                              if data.length - 200 < 100:
                                  revert with IncorrectDataLength()
                              if data.length - 300 < 4:
                                  revert with IncorrectDataLength()
                          else:
                              if not (uint32(cd[(data + 236)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                                  if data.length - 200 < 68:
                                      revert with IncorrectDataLength()
                              else:
                                  mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                  static call this.address.mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 204]
                      else:
                          if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - and(uint256 offsets, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                              else:
                                  mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                  static call this.address.mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 204]
                          else:
                              if data.length - 200 < 100:
                                  revert with IncorrectDataLength()
                              mem[96 len data.length - 300] = call.data[data + 336 len data.length - 300]
                              static call cd[(data + 240)].mem[96 len 4] with:
                                      gas gas_remaining wei
                                     args mem[100 len data.length - 304]
                  else:
                      if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                          if not (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                              if data.length - 200 < 100:
                                  revert with IncorrectDataLength()
                              if data.length - 300 < 4:
                                  revert with IncorrectDataLength()
                          else:
                              if not (uint32(cd[(data + 236)]) >> 224) - or(uint256 offsets, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                              else:
                                  mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                  static call this.address.mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 204]
                      else:
                          if not (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
                              if data.length - 200 < 100:
                                  revert with IncorrectDataLength()
                              if data.length - 300 < 4:
                                  revert with IncorrectDataLength()
                          else:
                              if (uint32(cd[(data + 236)]) >> 224) - timestampBelow(uint256 time):
                                  mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                  static call this.address.mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 204]
          else:
              if not (uint32(cd[(data + 136)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                  if data.length - 100 < 100:
                      revert with IncorrectDataLength()
                  mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                  static call cd[(data + 140)].mem[96 len 4] with:
                          gas gas_remaining wei
                         args mem[100 len data.length - 204]
                  if return_data.size != 32 or not ext_call.success:
                      revert with ArbitraryStaticCallFailed()
                  if return_data.size != 32 or not ext_call.success:
                      revert with ArbitraryStaticCallFailed()
              else:
                  if (uint32(cd[(data + 136)]) >> 224) - and(uint256 offsets, bytes data):
                      mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                      static call this.address.mem[96 len 4] with:
                              gas gas_remaining wei
                             args mem[100 len data.length - 104]
                      if 32 == return_data.size and ext_call.success:
                          if ext_call.return_data[0] < cd[(data + 40)]:
                              return (1 > value)
                      return (0 > value)
                  if data.length - 100 < 100:
                      revert with IncorrectDataLength()
                  if uint32(cd[(data + 140)]):
                      require 0 <= uint32(cd[(data + 140)])
                      require uint32(cd[(data + 140)]) <= data.length - 200
                      if uint32(cd[(data + 140)]) < 4:
                          revert with IncorrectDataLength()
                      if uint32(cd[(data + 140)]) < 36:
                          revert with IncorrectDataLength()
                      if (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                          if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                              if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                                  if (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                              else:
                                  if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                          else:
                              if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                                  if (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                              else:
                                  if (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
      else:
          if uint32(cd[(data + 136)]) >> 224 < eq(uint256 value, bytes data):
              if (uint32(cd[(data + 136)]) >> 224) - gt(uint256 value, bytes data):
                  if not (uint32(cd[(data + 136)]) >> 224) - timestampBelow(uint256 time):
                      if block.timestamp < cd[(data + 140)]:
                          if 1 < cd[(data + 40)]:
                              return (1 > value)
                      else:
                          if 0 < cd[(data + 40)]:
                              return (1 > value)
                  else:
                      mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                      static call this.address.mem[96 len 4] with:
                              gas gas_remaining wei
                             args mem[100 len data.length - 104]
                      if 32 == return_data.size and ext_call.success:
                          if ext_call.return_data[0] < cd[(data + 40)]:
                              return (1 > value)
                  return (0 > value)
              if data.length - 100 < 100:
                  revert with IncorrectDataLength()
              if data.length - 200 < 4:
                  revert with IncorrectDataLength()
              if data.length - 200 < 36:
                  revert with IncorrectDataLength()
              if not (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                  if block.timestamp < cd[(data + 240)] % unknown10000000() >> 208:
              else:
                  if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                      if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                          if not (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                              if data.length - 200 < 100:
                                  revert with IncorrectDataLength()
                              if data.length - 300 < 4:
                                  revert with IncorrectDataLength()
                          else:
                              if not (uint32(cd[(data + 236)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                                  if data.length - 200 < 68:
                                      revert with IncorrectDataLength()
                              else:
                                  mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                  static call this.address.mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 204]
                      else:
                          if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - and(uint256 offsets, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                              else:
                                  mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                  static call this.address.mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 204]
                          else:
                              if data.length - 200 < 100:
                                  revert with IncorrectDataLength()
                              mem[96 len data.length - 300] = call.data[data + 336 len data.length - 300]
                              static call cd[(data + 240)].mem[96 len 4] with:
                                      gas gas_remaining wei
                                     args mem[100 len data.length - 304]
                  else:
                      if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                          if not (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                              if data.length - 200 < 100:
                                  revert with IncorrectDataLength()
                              if data.length - 300 < 4:
                                  revert with IncorrectDataLength()
                          else:
                              if not (uint32(cd[(data + 236)]) >> 224) - or(uint256 offsets, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                              else:
                                  mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                  static call this.address.mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 204]
                      else:
                          if not (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
                              if data.length - 200 < 100:
                                  revert with IncorrectDataLength()
                              if data.length - 300 < 4:
                                  revert with IncorrectDataLength()
                          else:
                              if (uint32(cd[(data + 236)]) >> 224) - timestampBelow(uint256 time):
                                  mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                  static call this.address.mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 204]
          else:
              if not (uint32(cd[(data + 136)]) >> 224) - eq(uint256 value, bytes data):
                  if data.length - 100 < 100:
                      revert with IncorrectDataLength()
                  if data.length - 200 < 4:
                      revert with IncorrectDataLength()
                  if data.length - 200 < 36:
                      revert with IncorrectDataLength()
                  if not (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                      if block.timestamp < cd[(data + 240)] % unknown10000000() >> 208:
                  else:
                      if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                          if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                                      if data.length - 200 < 68:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                          else:
                              if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                                  if not (uint32(cd[(data + 236)]) >> 224) - and(uint256 offsets, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                              else:
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  mem[96 len data.length - 300] = call.data[data + 336 len data.length - 300]
                                  static call cd[(data + 240)].mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 304]
                      else:
                          if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - or(uint256 offsets, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                          else:
                              if not (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if (uint32(cd[(data + 236)]) >> 224) - timestampBelow(uint256 time):
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
              else:
                  if (uint32(cd[(data + 136)]) >> 224) - or(uint256 offsets, bytes data):
                      mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                      static call this.address.mem[96 len 4] with:
                              gas gas_remaining wei
                             args mem[100 len data.length - 104]
                      if 32 == return_data.size and ext_call.success:
                          if ext_call.return_data[0] < cd[(data + 40)]:
                              return (1 > value)
                      return (0 > value)
                  if data.length - 100 < 100:
                      revert with IncorrectDataLength()
                  if uint32(cd[(data + 140)]):
                      require 0 <= uint32(cd[(data + 140)])
                      require uint32(cd[(data + 140)]) <= data.length - 200
                      if uint32(cd[(data + 140)]) < 4:
                          revert with IncorrectDataLength()
                      if uint32(cd[(data + 140)]) < 36:
                          revert with IncorrectDataLength()
                      if (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                          if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                              if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                                  if (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                              else:
                                  if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                          else:
                              if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                                  if (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                              else:
                                  if (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
  else:
      if uint32(cd[(data + 36)]) >> 224 >= eq(uint256 value, bytes data):
          if (uint32(cd[(data + 36)]) >> 224) - eq(uint256 value, bytes data):
              if not (uint32(cd[(data + 36)]) >> 224) - or(uint256 offsets, bytes data):
                  if data.length < 100:
                      revert with IncorrectDataLength()
                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              mem[96 len data.length] = data[all]
              static call this.address.mem[96 len 4] with:
                      gas gas_remaining wei
                     args mem[100 len data.length - 4]
              if return_data.size != 32 or not ext_call.success:
                  return bool(32 == return_data.size and ext_call.success)
              return (ext_call.return_data[0] > value)
          if data.length < 100:
              revert with IncorrectDataLength()
          if data.length - 100 < 4:
              revert with IncorrectDataLength()
          if data.length - 100 < 36:
              revert with IncorrectDataLength()
          if not (uint32(cd[(data + 136)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
              if block.timestamp >= cd[(data + 140)] % unknown10000000() >> 208:
                  if not cd[(data + 40)]:
                      return (1 > value)
              else:
                  if not nonce[address(cd[(data + 140)])]:
                      if cd[(data + 40)] == 1:
                          return (1 > value)
                  else:
                      if not cd[(data + 40)]:
                          return (1 > value)
              return (0 > value)
          if uint32(cd[(data + 136)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
              if uint32(cd[(data + 136)]) >> 224 >= lt(uint256 value, bytes data):
                  if (uint32(cd[(data + 136)]) >> 224) - lt(uint256 value, bytes data):
                      if not (uint32(cd[(data + 136)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                          if data.length - 100 < 68:
                              revert with IncorrectDataLength()
                          if nonce[address(cd[(data + 140)])] == cd[(data + 172)]:
                              if cd[(data + 40)] == 1:
                                  return (1 > value)
                          else:
                              if not cd[(data + 40)]:
                                  return (1 > value)
                      else:
                          mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                          static call this.address.mem[96 len 4] with:
                                  gas gas_remaining wei
                                 args mem[100 len data.length - 104]
                          if 32 == return_data.size and ext_call.success:
                              if cd[(data + 40)] == ext_call.return_data[0]:
                                  return (1 > value)
                      return (0 > value)
                  if data.length - 100 < 100:
                      revert with IncorrectDataLength()
                  if data.length - 200 < 4:
                      revert with IncorrectDataLength()
                  if data.length - 200 < 36:
                      revert with IncorrectDataLength()
                  if not (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                      if block.timestamp < cd[(data + 240)] % unknown10000000() >> 208:
                  else:
                      if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                          if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                                      if data.length - 200 < 68:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                          else:
                              if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                                  if not (uint32(cd[(data + 236)]) >> 224) - and(uint256 offsets, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                              else:
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  mem[96 len data.length - 300] = call.data[data + 336 len data.length - 300]
                                  static call cd[(data + 240)].mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 304]
                      else:
                          if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - or(uint256 offsets, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                          else:
                              if not (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if (uint32(cd[(data + 236)]) >> 224) - timestampBelow(uint256 time):
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
              else:
                  if not (uint32(cd[(data + 136)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                      if data.length - 100 < 100:
                          revert with IncorrectDataLength()
                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                      static call cd[(data + 140)].mem[96 len 4] with:
                              gas gas_remaining wei
                             args mem[100 len data.length - 204]
                      if return_data.size != 32 or not ext_call.success:
                          revert with ArbitraryStaticCallFailed()
                      if return_data.size != 32 or not ext_call.success:
                          revert with ArbitraryStaticCallFailed()
                  else:
                      if (uint32(cd[(data + 136)]) >> 224) - and(uint256 offsets, bytes data):
                          mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                          static call this.address.mem[96 len 4] with:
                                  gas gas_remaining wei
                                 args mem[100 len data.length - 104]
                          if 32 == return_data.size and ext_call.success:
                              if cd[(data + 40)] == ext_call.return_data[0]:
                                  return (1 > value)
                          return (0 > value)
                      if data.length - 100 < 100:
                          revert with IncorrectDataLength()
                      if uint32(cd[(data + 140)]):
                          require 0 <= uint32(cd[(data + 140)])
                          require uint32(cd[(data + 140)]) <= data.length - 200
                          if uint32(cd[(data + 140)]) < 4:
                              revert with IncorrectDataLength()
                          if uint32(cd[(data + 140)]) < 36:
                              revert with IncorrectDataLength()
                          if (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                              if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                                  if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                                      if (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                                  else:
                                      if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                              else:
                                  if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                                      if (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                                  else:
                                      if (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
          else:
              if uint32(cd[(data + 136)]) >> 224 < eq(uint256 value, bytes data):
                  if (uint32(cd[(data + 136)]) >> 224) - gt(uint256 value, bytes data):
                      if not (uint32(cd[(data + 136)]) >> 224) - timestampBelow(uint256 time):
                          if block.timestamp < cd[(data + 140)]:
                              if cd[(data + 40)] == 1:
                                  return (1 > value)
                          else:
                              if not cd[(data + 40)]:
                                  return (1 > value)
                      else:
                          mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                          static call this.address.mem[96 len 4] with:
                                  gas gas_remaining wei
                                 args mem[100 len data.length - 104]
                          if 32 == return_data.size and ext_call.success:
                              if cd[(data + 40)] == ext_call.return_data[0]:
                                  return (1 > value)
                      return (0 > value)
                  if data.length - 100 < 100:
                      revert with IncorrectDataLength()
                  if data.length - 200 < 4:
                      revert with IncorrectDataLength()
                  if data.length - 200 < 36:
                      revert with IncorrectDataLength()
                  if not (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                      if block.timestamp < cd[(data + 240)] % unknown10000000() >> 208:
                  else:
                      if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                          if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                                      if data.length - 200 < 68:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                          else:
                              if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                                  if not (uint32(cd[(data + 236)]) >> 224) - and(uint256 offsets, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                              else:
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  mem[96 len data.length - 300] = call.data[data + 336 len data.length - 300]
                                  static call cd[(data + 240)].mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 304]
                      else:
                          if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - or(uint256 offsets, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                          else:
                              if not (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if (uint32(cd[(data + 236)]) >> 224) - timestampBelow(uint256 time):
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
              else:
                  if not (uint32(cd[(data + 136)]) >> 224) - eq(uint256 value, bytes data):
                      if data.length - 100 < 100:
                          revert with IncorrectDataLength()
                      if data.length - 200 < 4:
                          revert with IncorrectDataLength()
                      if data.length - 200 < 36:
                          revert with IncorrectDataLength()
                      if not (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                          if block.timestamp < cd[(data + 240)] % unknown10000000() >> 208:
                      else:
                          if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                              if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                                  if not (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                      if data.length - 300 < 4:
                                          revert with IncorrectDataLength()
                                  else:
                                      if not (uint32(cd[(data + 236)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                                          if data.length - 200 < 68:
                                              revert with IncorrectDataLength()
                                      else:
                                          mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                          static call this.address.mem[96 len 4] with:
                                                  gas gas_remaining wei
                                                 args mem[100 len data.length - 204]
                              else:
                                  if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                                      if not (uint32(cd[(data + 236)]) >> 224) - and(uint256 offsets, bytes data):
                                          if data.length - 200 < 100:
                                              revert with IncorrectDataLength()
                                      else:
                                          mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                          static call this.address.mem[96 len 4] with:
                                                  gas gas_remaining wei
                                                 args mem[100 len data.length - 204]
                                  else:
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                      mem[96 len data.length - 300] = call.data[data + 336 len data.length - 300]
                                      static call cd[(data + 240)].mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 304]
                          else:
                              if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                                  if not (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                      if data.length - 300 < 4:
                                          revert with IncorrectDataLength()
                                  else:
                                      if not (uint32(cd[(data + 236)]) >> 224) - or(uint256 offsets, bytes data):
                                          if data.length - 200 < 100:
                                              revert with IncorrectDataLength()
                                      else:
                                          mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                          static call this.address.mem[96 len 4] with:
                                                  gas gas_remaining wei
                                                 args mem[100 len data.length - 204]
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                      if data.length - 300 < 4:
                                          revert with IncorrectDataLength()
                                  else:
                                      if (uint32(cd[(data + 236)]) >> 224) - timestampBelow(uint256 time):
                                          mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                          static call this.address.mem[96 len 4] with:
                                                  gas gas_remaining wei
                                                 args mem[100 len data.length - 204]
                  else:
                      if (uint32(cd[(data + 136)]) >> 224) - or(uint256 offsets, bytes data):
                          mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                          static call this.address.mem[96 len 4] with:
                                  gas gas_remaining wei
                                 args mem[100 len data.length - 104]
                          if 32 == return_data.size and ext_call.success:
                              if cd[(data + 40)] == ext_call.return_data[0]:
                                  return (1 > value)
                          return (0 > value)
                      if data.length - 100 < 100:
                          revert with IncorrectDataLength()
                      if uint32(cd[(data + 140)]):
                          require 0 <= uint32(cd[(data + 140)])
                          require uint32(cd[(data + 140)]) <= data.length - 200
                          if uint32(cd[(data + 140)]) < 4:
                              revert with IncorrectDataLength()
                          if uint32(cd[(data + 140)]) < 36:
                              revert with IncorrectDataLength()
                          if (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                              if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                                  if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                                      if (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                                  else:
                                      if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                              else:
                                  if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                                      if (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                                  else:
                                      if (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
      else:
          if (uint32(cd[(data + 36)]) >> 224) - gt(uint256 value, bytes data):
              if not (uint32(cd[(data + 36)]) >> 224) - timestampBelow(uint256 time):
                  if block.timestamp < cd[(data + 40)]:
                      return (1 > value)
                  return (0 > value)
              mem[96 len data.length] = data[all]
              static call this.address.mem[96 len 4] with:
                      gas gas_remaining wei
                     args mem[100 len data.length - 4]
              if return_data.size != 32 or not ext_call.success:
                  return bool(32 == return_data.size and ext_call.success)
              return (ext_call.return_data[0] > value)
          if data.length < 100:
              revert with IncorrectDataLength()
          if data.length - 100 < 4:
              revert with IncorrectDataLength()
          if data.length - 100 < 36:
              revert with IncorrectDataLength()
          if not (uint32(cd[(data + 136)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
              if block.timestamp >= cd[(data + 140)] % unknown10000000() >> 208:
                  if 0 > cd[(data + 40)]:
                      return (1 > value)
              else:
                  if not nonce[address(cd[(data + 140)])]:
                      if 1 > cd[(data + 40)]:
                          return (1 > value)
                  else:
                      if 0 > cd[(data + 40)]:
                          return (1 > value)
              return (0 > value)
          if uint32(cd[(data + 136)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
              if uint32(cd[(data + 136)]) >> 224 >= lt(uint256 value, bytes data):
                  if (uint32(cd[(data + 136)]) >> 224) - lt(uint256 value, bytes data):
                      if not (uint32(cd[(data + 136)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                          if data.length - 100 < 68:
                              revert with IncorrectDataLength()
                          if nonce[address(cd[(data + 140)])] == cd[(data + 172)]:
                              if 1 > cd[(data + 40)]:
                                  return (1 > value)
                          else:
                              if 0 > cd[(data + 40)]:
                                  return (1 > value)
                      else:
                          mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                          static call this.address.mem[96 len 4] with:
                                  gas gas_remaining wei
                                 args mem[100 len data.length - 104]
                          if 32 == return_data.size and ext_call.success:
                              if ext_call.return_data[0] > cd[(data + 40)]:
                                  return (1 > value)
                      return (0 > value)
                  if data.length - 100 < 100:
                      revert with IncorrectDataLength()
                  if data.length - 200 < 4:
                      revert with IncorrectDataLength()
                  if data.length - 200 < 36:
                      revert with IncorrectDataLength()
                  if not (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                      if block.timestamp < cd[(data + 240)] % unknown10000000() >> 208:
                  else:
                      if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                          if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                                      if data.length - 200 < 68:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                          else:
                              if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                                  if not (uint32(cd[(data + 236)]) >> 224) - and(uint256 offsets, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                              else:
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  mem[96 len data.length - 300] = call.data[data + 336 len data.length - 300]
                                  static call cd[(data + 240)].mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 304]
                      else:
                          if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - or(uint256 offsets, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                          else:
                              if not (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if (uint32(cd[(data + 236)]) >> 224) - timestampBelow(uint256 time):
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
              else:
                  if not (uint32(cd[(data + 136)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                      if data.length - 100 < 100:
                          revert with IncorrectDataLength()
                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                      static call cd[(data + 140)].mem[96 len 4] with:
                              gas gas_remaining wei
                             args mem[100 len data.length - 204]
                      if return_data.size != 32 or not ext_call.success:
                          revert with ArbitraryStaticCallFailed()
                      if return_data.size != 32 or not ext_call.success:
                          revert with ArbitraryStaticCallFailed()
                  else:
                      if (uint32(cd[(data + 136)]) >> 224) - and(uint256 offsets, bytes data):
                          mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                          static call this.address.mem[96 len 4] with:
                                  gas gas_remaining wei
                                 args mem[100 len data.length - 104]
                          if 32 == return_data.size and ext_call.success:
                              if ext_call.return_data[0] > cd[(data + 40)]:
                                  return (1 > value)
                          return (0 > value)
                      if data.length - 100 < 100:
                          revert with IncorrectDataLength()
                      if uint32(cd[(data + 140)]):
                          require 0 <= uint32(cd[(data + 140)])
                          require uint32(cd[(data + 140)]) <= data.length - 200
                          if uint32(cd[(data + 140)]) < 4:
                              revert with IncorrectDataLength()
                          if uint32(cd[(data + 140)]) < 36:
                              revert with IncorrectDataLength()
                          if (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                              if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                                  if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                                      if (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                                  else:
                                      if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                              else:
                                  if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                                      if (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                                  else:
                                      if (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
          else:
              if uint32(cd[(data + 136)]) >> 224 < eq(uint256 value, bytes data):
                  if (uint32(cd[(data + 136)]) >> 224) - gt(uint256 value, bytes data):
                      if not (uint32(cd[(data + 136)]) >> 224) - timestampBelow(uint256 time):
                          if block.timestamp < cd[(data + 140)]:
                              if 1 > cd[(data + 40)]:
                                  return (1 > value)
                          else:
                              if 0 > cd[(data + 40)]:
                                  return (1 > value)
                      else:
                          mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                          static call this.address.mem[96 len 4] with:
                                  gas gas_remaining wei
                                 args mem[100 len data.length - 104]
                          if 32 == return_data.size and ext_call.success:
                              if ext_call.return_data[0] > cd[(data + 40)]:
                                  return (1 > value)
                      return (0 > value)
                  if data.length - 100 < 100:
                      revert with IncorrectDataLength()
                  if data.length - 200 < 4:
                      revert with IncorrectDataLength()
                  if data.length - 200 < 36:
                      revert with IncorrectDataLength()
                  if not (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                      if block.timestamp < cd[(data + 240)] % unknown10000000() >> 208:
                  else:
                      if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                          if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                                      if data.length - 200 < 68:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                          else:
                              if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                                  if not (uint32(cd[(data + 236)]) >> 224) - and(uint256 offsets, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                              else:
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  mem[96 len data.length - 300] = call.data[data + 336 len data.length - 300]
                                  static call cd[(data + 240)].mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 304]
                      else:
                          if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - or(uint256 offsets, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                          else:
                              if not (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if (uint32(cd[(data + 236)]) >> 224) - timestampBelow(uint256 time):
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
              else:
                  if not (uint32(cd[(data + 136)]) >> 224) - eq(uint256 value, bytes data):
                      if data.length - 100 < 100:
                          revert with IncorrectDataLength()
                      if data.length - 200 < 4:
                          revert with IncorrectDataLength()
                      if data.length - 200 < 36:
                          revert with IncorrectDataLength()
                      if not (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                          if block.timestamp < cd[(data + 240)] % unknown10000000() >> 208:
                      else:
                          if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                              if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                                  if not (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                      if data.length - 300 < 4:
                                          revert with IncorrectDataLength()
                                  else:
                                      if not (uint32(cd[(data + 236)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                                          if data.length - 200 < 68:
                                              revert with IncorrectDataLength()
                                      else:
                                          mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                          static call this.address.mem[96 len 4] with:
                                                  gas gas_remaining wei
                                                 args mem[100 len data.length - 204]
                              else:
                                  if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                                      if not (uint32(cd[(data + 236)]) >> 224) - and(uint256 offsets, bytes data):
                                          if data.length - 200 < 100:
                                              revert with IncorrectDataLength()
                                      else:
                                          mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                          static call this.address.mem[96 len 4] with:
                                                  gas gas_remaining wei
                                                 args mem[100 len data.length - 204]
                                  else:
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                      mem[96 len data.length - 300] = call.data[data + 336 len data.length - 300]
                                      static call cd[(data + 240)].mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 304]
                          else:
                              if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                                  if not (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                      if data.length - 300 < 4:
                                          revert with IncorrectDataLength()
                                  else:
                                      if not (uint32(cd[(data + 236)]) >> 224) - or(uint256 offsets, bytes data):
                                          if data.length - 200 < 100:
                                              revert with IncorrectDataLength()
                                      else:
                                          mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                          static call this.address.mem[96 len 4] with:
                                                  gas gas_remaining wei
                                                 args mem[100 len data.length - 204]
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                      if data.length - 300 < 4:
                                          revert with IncorrectDataLength()
                                  else:
                                      if (uint32(cd[(data + 236)]) >> 224) - timestampBelow(uint256 time):
                                          mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                          static call this.address.mem[96 len 4] with:
                                                  gas gas_remaining wei
                                                 args mem[100 len data.length - 204]
                  else:
                      if (uint32(cd[(data + 136)]) >> 224) - or(uint256 offsets, bytes data):
                          mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                          static call this.address.mem[96 len 4] with:
                                  gas gas_remaining wei
                                 args mem[100 len data.length - 104]
                          if 32 == return_data.size and ext_call.success:
                              if ext_call.return_data[0] > cd[(data + 40)]:
                                  return (1 > value)
                          return (0 > value)
                      if data.length - 100 < 100:
                          revert with IncorrectDataLength()
                      if uint32(cd[(data + 140)]):
                          require 0 <= uint32(cd[(data + 140)])
                          require uint32(cd[(data + 140)]) <= data.length - 200
                          if uint32(cd[(data + 140)]) < 4:
                              revert with IncorrectDataLength()
                          if uint32(cd[(data + 140)]) < 36:
                              revert with IncorrectDataLength()
                          if (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                              if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                                  if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                                      if (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                                  else:
                                      if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                              else:
                                  if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                                      if (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                                  else:
                                      if (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def eq(uint256 value, bytes data): # not payable
  require calldata.size - 4 >=′ 64
  require data <= LOCK8605463013()
  require data + 35 <′ calldata.size
  require data.length <= LOCK8605463013()
  require data + data.length + 36 <= calldata.size
  if data.length < 4:
      revert with IncorrectDataLength()
  if data.length < 36:
      revert with IncorrectDataLength()
  if not (uint32(cd[(data + 36)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
      if block.timestamp < cd[(data + 40)] % unknown10000000() >> 208:
          if not nonce[address(cd[(data + 40)])]:
              return (value == 1)
      return not value
  if uint32(cd[(data + 36)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
      if uint32(cd[(data + 36)]) >> 224 < lt(uint256 value, bytes data):
          if (uint32(cd[(data + 36)]) >> 224) - arbitraryStaticCall(address target, bytes data):
              if not (uint32(cd[(data + 36)]) >> 224) - and(uint256 offsets, bytes data):
                  if data.length < 100:
                      revert with IncorrectDataLength()
                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              mem[96 len data.length] = data[all]
              static call this.address.mem[96 len 4] with:
                      gas gas_remaining wei
                     args mem[100 len data.length - 4]
              if return_data.size != 32 or not ext_call.success:
                  return bool(32 == return_data.size and ext_call.success)
          else:
              if data.length < 100:
                  revert with IncorrectDataLength()
              mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
              static call cd[(data + 40)].mem[96 len 4] with:
                      gas gas_remaining wei
                     args mem[100 len data.length - 104]
              if return_data.size != 32 or not ext_call.success:
                  revert with ArbitraryStaticCallFailed()
              if return_data.size != 32 or not ext_call.success:
                  revert with ArbitraryStaticCallFailed()
          ('iszero', ('or', ('iszero', ('eq', 32, 'returndatasize')), ('iszero', 'ext_call.success')))
          return (value == ext_call.return_data[0])
      if (uint32(cd[(data + 36)]) >> 224) - lt(uint256 value, bytes data):
          if not (uint32(cd[(data + 36)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
              if data.length < 68:
                  revert with IncorrectDataLength()
              if nonce[address(cd[(data + 40)])] == cd[(data + 72)]:
                  return (value == 1)
              return not value
          mem[96 len data.length] = data[all]
          static call this.address.mem[96 len 4] with:
                  gas gas_remaining wei
                 args mem[100 len data.length - 4]
          if return_data.size != 32 or not ext_call.success:
              return bool(32 == return_data.size and ext_call.success)
          return (value == ext_call.return_data[0])
      if data.length < 100:
          revert with IncorrectDataLength()
      if data.length - 100 < 4:
          revert with IncorrectDataLength()
      if data.length - 100 < 36:
          revert with IncorrectDataLength()
      if not (uint32(cd[(data + 136)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
          if block.timestamp >= cd[(data + 140)] % unknown10000000() >> 208:
              if 0 < cd[(data + 40)]:
                  return (value == 1)
          else:
              if not nonce[address(cd[(data + 140)])]:
                  if 1 < cd[(data + 40)]:
                      return (value == 1)
              else:
                  if 0 < cd[(data + 40)]:
                      return (value == 1)
          return not value
      if uint32(cd[(data + 136)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
          if uint32(cd[(data + 136)]) >> 224 >= lt(uint256 value, bytes data):
              if (uint32(cd[(data + 136)]) >> 224) - lt(uint256 value, bytes data):
                  if not (uint32(cd[(data + 136)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                      if data.length - 100 < 68:
                          revert with IncorrectDataLength()
                      if nonce[address(cd[(data + 140)])] == cd[(data + 172)]:
                          if 1 < cd[(data + 40)]:
                              return (value == 1)
                      else:
                          if 0 < cd[(data + 40)]:
                              return (value == 1)
                  else:
                      mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                      static call this.address.mem[96 len 4] with:
                              gas gas_remaining wei
                             args mem[100 len data.length - 104]
                      if 32 == return_data.size and ext_call.success:
                          if ext_call.return_data[0] < cd[(data + 40)]:
                              return (value == 1)
                  return not value
              if data.length - 100 < 100:
                  revert with IncorrectDataLength()
              if data.length - 200 < 4:
                  revert with IncorrectDataLength()
              if data.length - 200 < 36:
                  revert with IncorrectDataLength()
              if not (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                  if block.timestamp < cd[(data + 240)] % unknown10000000() >> 208:
              else:
                  if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                      if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                          if not (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                              if data.length - 200 < 100:
                                  revert with IncorrectDataLength()
                              if data.length - 300 < 4:
                                  revert with IncorrectDataLength()
                          else:
                              if not (uint32(cd[(data + 236)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                                  if data.length - 200 < 68:
                                      revert with IncorrectDataLength()
                              else:
                                  mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                  static call this.address.mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 204]
                      else:
                          if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - and(uint256 offsets, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                              else:
                                  mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                  static call this.address.mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 204]
                          else:
                              if data.length - 200 < 100:
                                  revert with IncorrectDataLength()
                              mem[96 len data.length - 300] = call.data[data + 336 len data.length - 300]
                              static call cd[(data + 240)].mem[96 len 4] with:
                                      gas gas_remaining wei
                                     args mem[100 len data.length - 304]
                  else:
                      if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                          if not (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                              if data.length - 200 < 100:
                                  revert with IncorrectDataLength()
                              if data.length - 300 < 4:
                                  revert with IncorrectDataLength()
                          else:
                              if not (uint32(cd[(data + 236)]) >> 224) - or(uint256 offsets, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                              else:
                                  mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                  static call this.address.mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 204]
                      else:
                          if not (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
                              if data.length - 200 < 100:
                                  revert with IncorrectDataLength()
                              if data.length - 300 < 4:
                                  revert with IncorrectDataLength()
                          else:
                              if (uint32(cd[(data + 236)]) >> 224) - timestampBelow(uint256 time):
                                  mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                  static call this.address.mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 204]
          else:
              if not (uint32(cd[(data + 136)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                  if data.length - 100 < 100:
                      revert with IncorrectDataLength()
                  mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                  static call cd[(data + 140)].mem[96 len 4] with:
                          gas gas_remaining wei
                         args mem[100 len data.length - 204]
                  if return_data.size != 32 or not ext_call.success:
                      revert with ArbitraryStaticCallFailed()
                  if return_data.size != 32 or not ext_call.success:
                      revert with ArbitraryStaticCallFailed()
                  if ext_call.return_data[0] < cd[(data + 40)]:
                      return (value == 1)
                  return not value
              if (uint32(cd[(data + 136)]) >> 224) - and(uint256 offsets, bytes data):
                  mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                  static call this.address.mem[96 len 4] with:
                          gas gas_remaining wei
                         args mem[100 len data.length - 104]
                  if 32 == return_data.size and ext_call.success:
                      if ext_call.return_data[0] < cd[(data + 40)]:
                          return (value == 1)
                  return not value
              if data.length - 100 < 100:
                  revert with IncorrectDataLength()
              if not uint32(cd[(data + 140)]):
                  if 1 < cd[(data + 40)]:
                      return (value == 1)
                  return not value
              require 0 <= uint32(cd[(data + 140)])
              require uint32(cd[(data + 140)]) <= data.length - 200
              if uint32(cd[(data + 140)]) < 4:
                  revert with IncorrectDataLength()
              if uint32(cd[(data + 140)]) < 36:
                  revert with IncorrectDataLength()
              if (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                  if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                      if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                          if (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                      else:
                          if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                  else:
                      if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                          if (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                      else:
                          if (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
      else:
          if uint32(cd[(data + 136)]) >> 224 < eq(uint256 value, bytes data):
              if (uint32(cd[(data + 136)]) >> 224) - gt(uint256 value, bytes data):
                  if not (uint32(cd[(data + 136)]) >> 224) - timestampBelow(uint256 time):
                      if block.timestamp < cd[(data + 140)]:
                          if 1 < cd[(data + 40)]:
                              return (value == 1)
                      else:
                          if 0 < cd[(data + 40)]:
                              return (value == 1)
                  else:
                      mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                      static call this.address.mem[96 len 4] with:
                              gas gas_remaining wei
                             args mem[100 len data.length - 104]
                      if 32 == return_data.size and ext_call.success:
                          if ext_call.return_data[0] < cd[(data + 40)]:
                              return (value == 1)
                  return not value
              if data.length - 100 < 100:
                  revert with IncorrectDataLength()
              if data.length - 200 < 4:
                  revert with IncorrectDataLength()
              if data.length - 200 < 36:
                  revert with IncorrectDataLength()
              if not (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                  if block.timestamp < cd[(data + 240)] % unknown10000000() >> 208:
              else:
                  if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                      if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                          if not (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                              if data.length - 200 < 100:
                                  revert with IncorrectDataLength()
                              if data.length - 300 < 4:
                                  revert with IncorrectDataLength()
                          else:
                              if not (uint32(cd[(data + 236)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                                  if data.length - 200 < 68:
                                      revert with IncorrectDataLength()
                              else:
                                  mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                  static call this.address.mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 204]
                      else:
                          if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - and(uint256 offsets, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                              else:
                                  mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                  static call this.address.mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 204]
                          else:
                              if data.length - 200 < 100:
                                  revert with IncorrectDataLength()
                              mem[96 len data.length - 300] = call.data[data + 336 len data.length - 300]
                              static call cd[(data + 240)].mem[96 len 4] with:
                                      gas gas_remaining wei
                                     args mem[100 len data.length - 304]
                  else:
                      if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                          if not (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                              if data.length - 200 < 100:
                                  revert with IncorrectDataLength()
                              if data.length - 300 < 4:
                                  revert with IncorrectDataLength()
                          else:
                              if not (uint32(cd[(data + 236)]) >> 224) - or(uint256 offsets, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                              else:
                                  mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                  static call this.address.mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 204]
                      else:
                          if not (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
                              if data.length - 200 < 100:
                                  revert with IncorrectDataLength()
                              if data.length - 300 < 4:
                                  revert with IncorrectDataLength()
                          else:
                              if (uint32(cd[(data + 236)]) >> 224) - timestampBelow(uint256 time):
                                  mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                  static call this.address.mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 204]
          else:
              if not (uint32(cd[(data + 136)]) >> 224) - eq(uint256 value, bytes data):
                  if data.length - 100 < 100:
                      revert with IncorrectDataLength()
                  if data.length - 200 < 4:
                      revert with IncorrectDataLength()
                  if data.length - 200 < 36:
                      revert with IncorrectDataLength()
                  if not (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                      if block.timestamp < cd[(data + 240)] % unknown10000000() >> 208:
                  else:
                      if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                          if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                                      if data.length - 200 < 68:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                          else:
                              if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                                  if not (uint32(cd[(data + 236)]) >> 224) - and(uint256 offsets, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                              else:
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  mem[96 len data.length - 300] = call.data[data + 336 len data.length - 300]
                                  static call cd[(data + 240)].mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 304]
                      else:
                          if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - or(uint256 offsets, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                          else:
                              if not (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if (uint32(cd[(data + 236)]) >> 224) - timestampBelow(uint256 time):
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
              else:
                  if (uint32(cd[(data + 136)]) >> 224) - or(uint256 offsets, bytes data):
                      mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                      static call this.address.mem[96 len 4] with:
                              gas gas_remaining wei
                             args mem[100 len data.length - 104]
                      if 32 == return_data.size and ext_call.success:
                          if ext_call.return_data[0] < cd[(data + 40)]:
                              return (value == 1)
                      return not value
                  if data.length - 100 < 100:
                      revert with IncorrectDataLength()
                  if not uint32(cd[(data + 140)]):
                      if 0 < cd[(data + 40)]:
                          return (value == 1)
                      return not value
                  require 0 <= uint32(cd[(data + 140)])
                  require uint32(cd[(data + 140)]) <= data.length - 200
                  if uint32(cd[(data + 140)]) < 4:
                      revert with IncorrectDataLength()
                  if uint32(cd[(data + 140)]) < 36:
                      revert with IncorrectDataLength()
                  if (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                      if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                          if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                              if (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                          else:
                              if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                      else:
                          if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                              if (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                          else:
                              if (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
  else:
      if uint32(cd[(data + 36)]) >> 224 >= eq(uint256 value, bytes data):
          if (uint32(cd[(data + 36)]) >> 224) - eq(uint256 value, bytes data):
              if not (uint32(cd[(data + 36)]) >> 224) - or(uint256 offsets, bytes data):
                  if data.length < 100:
                      revert with IncorrectDataLength()
                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              mem[96 len data.length] = data[all]
              static call this.address.mem[96 len 4] with:
                      gas gas_remaining wei
                     args mem[100 len data.length - 4]
              if return_data.size != 32 or not ext_call.success:
                  return bool(32 == return_data.size and ext_call.success)
              return (value == ext_call.return_data[0])
          if data.length < 100:
              revert with IncorrectDataLength()
          if data.length - 100 < 4:
              revert with IncorrectDataLength()
          if data.length - 100 < 36:
              revert with IncorrectDataLength()
          if not (uint32(cd[(data + 136)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
              if block.timestamp >= cd[(data + 140)] % unknown10000000() >> 208:
                  if not cd[(data + 40)]:
                      return (value == 1)
              else:
                  if not nonce[address(cd[(data + 140)])]:
                      if cd[(data + 40)] == 1:
                          return (value == 1)
                  else:
                      if not cd[(data + 40)]:
                          return (value == 1)
              return not value
          if uint32(cd[(data + 136)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
              if uint32(cd[(data + 136)]) >> 224 >= lt(uint256 value, bytes data):
                  if (uint32(cd[(data + 136)]) >> 224) - lt(uint256 value, bytes data):
                      if not (uint32(cd[(data + 136)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                          if data.length - 100 < 68:
                              revert with IncorrectDataLength()
                          if nonce[address(cd[(data + 140)])] == cd[(data + 172)]:
                              if cd[(data + 40)] == 1:
                                  return (value == 1)
                          else:
                              if not cd[(data + 40)]:
                                  return (value == 1)
                      else:
                          mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                          static call this.address.mem[96 len 4] with:
                                  gas gas_remaining wei
                                 args mem[100 len data.length - 104]
                          if 32 == return_data.size and ext_call.success:
                              if cd[(data + 40)] == ext_call.return_data[0]:
                                  return (value == 1)
                      return not value
                  if data.length - 100 < 100:
                      revert with IncorrectDataLength()
                  if data.length - 200 < 4:
                      revert with IncorrectDataLength()
                  if data.length - 200 < 36:
                      revert with IncorrectDataLength()
                  if not (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                      if block.timestamp < cd[(data + 240)] % unknown10000000() >> 208:
                  else:
                      if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                          if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                                      if data.length - 200 < 68:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                          else:
                              if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                                  if not (uint32(cd[(data + 236)]) >> 224) - and(uint256 offsets, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                              else:
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  mem[96 len data.length - 300] = call.data[data + 336 len data.length - 300]
                                  static call cd[(data + 240)].mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 304]
                      else:
                          if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - or(uint256 offsets, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                          else:
                              if not (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if (uint32(cd[(data + 236)]) >> 224) - timestampBelow(uint256 time):
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
              else:
                  if not (uint32(cd[(data + 136)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                      if data.length - 100 < 100:
                          revert with IncorrectDataLength()
                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                      static call cd[(data + 140)].mem[96 len 4] with:
                              gas gas_remaining wei
                             args mem[100 len data.length - 204]
                      if return_data.size != 32 or not ext_call.success:
                          revert with ArbitraryStaticCallFailed()
                      if return_data.size != 32 or not ext_call.success:
                          revert with ArbitraryStaticCallFailed()
                      if cd[(data + 40)] == ext_call.return_data[0]:
                          return (value == 1)
                      return not value
                  if (uint32(cd[(data + 136)]) >> 224) - and(uint256 offsets, bytes data):
                      mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                      static call this.address.mem[96 len 4] with:
                              gas gas_remaining wei
                             args mem[100 len data.length - 104]
                      if 32 == return_data.size and ext_call.success:
                          if cd[(data + 40)] == ext_call.return_data[0]:
                              return (value == 1)
                      return not value
                  if data.length - 100 < 100:
                      revert with IncorrectDataLength()
                  if not uint32(cd[(data + 140)]):
                      if cd[(data + 40)] == 1:
                          return (value == 1)
                      return not value
                  require 0 <= uint32(cd[(data + 140)])
                  require uint32(cd[(data + 140)]) <= data.length - 200
                  if uint32(cd[(data + 140)]) < 4:
                      revert with IncorrectDataLength()
                  if uint32(cd[(data + 140)]) < 36:
                      revert with IncorrectDataLength()
                  if (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                      if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                          if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                              if (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                          else:
                              if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                      else:
                          if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                              if (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                          else:
                              if (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
          else:
              if uint32(cd[(data + 136)]) >> 224 < eq(uint256 value, bytes data):
                  if (uint32(cd[(data + 136)]) >> 224) - gt(uint256 value, bytes data):
                      if not (uint32(cd[(data + 136)]) >> 224) - timestampBelow(uint256 time):
                          if block.timestamp < cd[(data + 140)]:
                              if cd[(data + 40)] == 1:
                                  return (value == 1)
                          else:
                              if not cd[(data + 40)]:
                                  return (value == 1)
                      else:
                          mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                          static call this.address.mem[96 len 4] with:
                                  gas gas_remaining wei
                                 args mem[100 len data.length - 104]
                          if 32 == return_data.size and ext_call.success:
                              if cd[(data + 40)] == ext_call.return_data[0]:
                                  return (value == 1)
                      return not value
                  if data.length - 100 < 100:
                      revert with IncorrectDataLength()
                  if data.length - 200 < 4:
                      revert with IncorrectDataLength()
                  if data.length - 200 < 36:
                      revert with IncorrectDataLength()
                  if not (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                      if block.timestamp < cd[(data + 240)] % unknown10000000() >> 208:
                  else:
                      if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                          if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                                      if data.length - 200 < 68:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                          else:
                              if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                                  if not (uint32(cd[(data + 236)]) >> 224) - and(uint256 offsets, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                              else:
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  mem[96 len data.length - 300] = call.data[data + 336 len data.length - 300]
                                  static call cd[(data + 240)].mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 304]
                      else:
                          if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - or(uint256 offsets, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                          else:
                              if not (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if (uint32(cd[(data + 236)]) >> 224) - timestampBelow(uint256 time):
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
              else:
                  if not (uint32(cd[(data + 136)]) >> 224) - eq(uint256 value, bytes data):
                      if data.length - 100 < 100:
                          revert with IncorrectDataLength()
                      if data.length - 200 < 4:
                          revert with IncorrectDataLength()
                      if data.length - 200 < 36:
                          revert with IncorrectDataLength()
                      if not (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                          if block.timestamp < cd[(data + 240)] % unknown10000000() >> 208:
                      else:
                          if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                              if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                                  if not (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                      if data.length - 300 < 4:
                                          revert with IncorrectDataLength()
                                  else:
                                      if not (uint32(cd[(data + 236)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                                          if data.length - 200 < 68:
                                              revert with IncorrectDataLength()
                                      else:
                                          mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                          static call this.address.mem[96 len 4] with:
                                                  gas gas_remaining wei
                                                 args mem[100 len data.length - 204]
                              else:
                                  if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                                      if not (uint32(cd[(data + 236)]) >> 224) - and(uint256 offsets, bytes data):
                                          if data.length - 200 < 100:
                                              revert with IncorrectDataLength()
                                      else:
                                          mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                          static call this.address.mem[96 len 4] with:
                                                  gas gas_remaining wei
                                                 args mem[100 len data.length - 204]
                                  else:
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                      mem[96 len data.length - 300] = call.data[data + 336 len data.length - 300]
                                      static call cd[(data + 240)].mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 304]
                          else:
                              if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                                  if not (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                      if data.length - 300 < 4:
                                          revert with IncorrectDataLength()
                                  else:
                                      if not (uint32(cd[(data + 236)]) >> 224) - or(uint256 offsets, bytes data):
                                          if data.length - 200 < 100:
                                              revert with IncorrectDataLength()
                                      else:
                                          mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                          static call this.address.mem[96 len 4] with:
                                                  gas gas_remaining wei
                                                 args mem[100 len data.length - 204]
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                      if data.length - 300 < 4:
                                          revert with IncorrectDataLength()
                                  else:
                                      if (uint32(cd[(data + 236)]) >> 224) - timestampBelow(uint256 time):
                                          mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                          static call this.address.mem[96 len 4] with:
                                                  gas gas_remaining wei
                                                 args mem[100 len data.length - 204]
                  else:
                      if (uint32(cd[(data + 136)]) >> 224) - or(uint256 offsets, bytes data):
                          mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                          static call this.address.mem[96 len 4] with:
                                  gas gas_remaining wei
                                 args mem[100 len data.length - 104]
                          if 32 == return_data.size and ext_call.success:
                              if cd[(data + 40)] == ext_call.return_data[0]:
                                  return (value == 1)
                          return not value
                      if data.length - 100 < 100:
                          revert with IncorrectDataLength()
                      if not uint32(cd[(data + 140)]):
                          if not cd[(data + 40)]:
                              return (value == 1)
                          return not value
                      require 0 <= uint32(cd[(data + 140)])
                      require uint32(cd[(data + 140)]) <= data.length - 200
                      if uint32(cd[(data + 140)]) < 4:
                          revert with IncorrectDataLength()
                      if uint32(cd[(data + 140)]) < 36:
                          revert with IncorrectDataLength()
                      if (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                          if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                              if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                                  if (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                              else:
                                  if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                          else:
                              if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                                  if (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                              else:
                                  if (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
      else:
          if (uint32(cd[(data + 36)]) >> 224) - gt(uint256 value, bytes data):
              if not (uint32(cd[(data + 36)]) >> 224) - timestampBelow(uint256 time):
                  if block.timestamp < cd[(data + 40)]:
                      return (value == 1)
                  return not value
              mem[96 len data.length] = data[all]
              static call this.address.mem[96 len 4] with:
                      gas gas_remaining wei
                     args mem[100 len data.length - 4]
              if return_data.size != 32 or not ext_call.success:
                  return bool(32 == return_data.size and ext_call.success)
              return (value == ext_call.return_data[0])
          if data.length < 100:
              revert with IncorrectDataLength()
          if data.length - 100 < 4:
              revert with IncorrectDataLength()
          if data.length - 100 < 36:
              revert with IncorrectDataLength()
          if not (uint32(cd[(data + 136)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
              if block.timestamp >= cd[(data + 140)] % unknown10000000() >> 208:
                  if 0 > cd[(data + 40)]:
                      return (value == 1)
              else:
                  if not nonce[address(cd[(data + 140)])]:
                      if 1 > cd[(data + 40)]:
                          return (value == 1)
                  else:
                      if 0 > cd[(data + 40)]:
                          return (value == 1)
              return not value
          if uint32(cd[(data + 136)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
              if uint32(cd[(data + 136)]) >> 224 >= lt(uint256 value, bytes data):
                  if (uint32(cd[(data + 136)]) >> 224) - lt(uint256 value, bytes data):
                      if not (uint32(cd[(data + 136)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                          if data.length - 100 < 68:
                              revert with IncorrectDataLength()
                          if nonce[address(cd[(data + 140)])] == cd[(data + 172)]:
                              if 1 > cd[(data + 40)]:
                                  return (value == 1)
                          else:
                              if 0 > cd[(data + 40)]:
                                  return (value == 1)
                      else:
                          mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                          static call this.address.mem[96 len 4] with:
                                  gas gas_remaining wei
                                 args mem[100 len data.length - 104]
                          if 32 == return_data.size and ext_call.success:
                              if ext_call.return_data[0] > cd[(data + 40)]:
                                  return (value == 1)
                      return not value
                  if data.length - 100 < 100:
                      revert with IncorrectDataLength()
                  if data.length - 200 < 4:
                      revert with IncorrectDataLength()
                  if data.length - 200 < 36:
                      revert with IncorrectDataLength()
                  if not (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                      if block.timestamp < cd[(data + 240)] % unknown10000000() >> 208:
                  else:
                      if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                          if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                                      if data.length - 200 < 68:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                          else:
                              if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                                  if not (uint32(cd[(data + 236)]) >> 224) - and(uint256 offsets, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                              else:
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  mem[96 len data.length - 300] = call.data[data + 336 len data.length - 300]
                                  static call cd[(data + 240)].mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 304]
                      else:
                          if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - or(uint256 offsets, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                          else:
                              if not (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if (uint32(cd[(data + 236)]) >> 224) - timestampBelow(uint256 time):
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
              else:
                  if not (uint32(cd[(data + 136)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                      if data.length - 100 < 100:
                          revert with IncorrectDataLength()
                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                      static call cd[(data + 140)].mem[96 len 4] with:
                              gas gas_remaining wei
                             args mem[100 len data.length - 204]
                      if return_data.size != 32 or not ext_call.success:
                          revert with ArbitraryStaticCallFailed()
                      if return_data.size != 32 or not ext_call.success:
                          revert with ArbitraryStaticCallFailed()
                  else:
                      if (uint32(cd[(data + 136)]) >> 224) - and(uint256 offsets, bytes data):
                          mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                          static call this.address.mem[96 len 4] with:
                                  gas gas_remaining wei
                                 args mem[100 len data.length - 104]
                          if 32 == return_data.size and ext_call.success:
                              if ext_call.return_data[0] > cd[(data + 40)]:
                                  return (value == 1)
                          return not value
                      if data.length - 100 < 100:
                          revert with IncorrectDataLength()
                      if uint32(cd[(data + 140)]):
                          require 0 <= uint32(cd[(data + 140)])
                          require uint32(cd[(data + 140)]) <= data.length - 200
                          if uint32(cd[(data + 140)]) < 4:
                              revert with IncorrectDataLength()
                          if uint32(cd[(data + 140)]) < 36:
                              revert with IncorrectDataLength()
                          if (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                              if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                                  if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                                      if (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                                  else:
                                      if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                              else:
                                  if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                                      if (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                                  else:
                                      if (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
          else:
              if uint32(cd[(data + 136)]) >> 224 < eq(uint256 value, bytes data):
                  if (uint32(cd[(data + 136)]) >> 224) - gt(uint256 value, bytes data):
                      if not (uint32(cd[(data + 136)]) >> 224) - timestampBelow(uint256 time):
                          if block.timestamp < cd[(data + 140)]:
                              if 1 > cd[(data + 40)]:
                                  return (value == 1)
                          else:
                              if 0 > cd[(data + 40)]:
                                  return (value == 1)
                      else:
                          mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                          static call this.address.mem[96 len 4] with:
                                  gas gas_remaining wei
                                 args mem[100 len data.length - 104]
                          if 32 == return_data.size and ext_call.success:
                              if ext_call.return_data[0] > cd[(data + 40)]:
                                  return (value == 1)
                      return not value
                  if data.length - 100 < 100:
                      revert with IncorrectDataLength()
                  if data.length - 200 < 4:
                      revert with IncorrectDataLength()
                  if data.length - 200 < 36:
                      revert with IncorrectDataLength()
                  if not (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                      if block.timestamp < cd[(data + 240)] % unknown10000000() >> 208:
                  else:
                      if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                          if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                                      if data.length - 200 < 68:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                          else:
                              if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                                  if not (uint32(cd[(data + 236)]) >> 224) - and(uint256 offsets, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                              else:
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  mem[96 len data.length - 300] = call.data[data + 336 len data.length - 300]
                                  static call cd[(data + 240)].mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 304]
                      else:
                          if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - or(uint256 offsets, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                          else:
                              if not (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if (uint32(cd[(data + 236)]) >> 224) - timestampBelow(uint256 time):
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
              else:
                  if not (uint32(cd[(data + 136)]) >> 224) - eq(uint256 value, bytes data):
                      if data.length - 100 < 100:
                          revert with IncorrectDataLength()
                      if data.length - 200 < 4:
                          revert with IncorrectDataLength()
                      if data.length - 200 < 36:
                          revert with IncorrectDataLength()
                      if not (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                          if block.timestamp < cd[(data + 240)] % unknown10000000() >> 208:
                      else:
                          if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                              if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                                  if not (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                      if data.length - 300 < 4:
                                          revert with IncorrectDataLength()
                                  else:
                                      if not (uint32(cd[(data + 236)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                                          if data.length - 200 < 68:
                                              revert with IncorrectDataLength()
                                      else:
                                          mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                          static call this.address.mem[96 len 4] with:
                                                  gas gas_remaining wei
                                                 args mem[100 len data.length - 204]
                              else:
                                  if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                                      if not (uint32(cd[(data + 236)]) >> 224) - and(uint256 offsets, bytes data):
                                          if data.length - 200 < 100:
                                              revert with IncorrectDataLength()
                                      else:
                                          mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                          static call this.address.mem[96 len 4] with:
                                                  gas gas_remaining wei
                                                 args mem[100 len data.length - 204]
                                  else:
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                      mem[96 len data.length - 300] = call.data[data + 336 len data.length - 300]
                                      static call cd[(data + 240)].mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 304]
                          else:
                              if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                                  if not (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                      if data.length - 300 < 4:
                                          revert with IncorrectDataLength()
                                  else:
                                      if not (uint32(cd[(data + 236)]) >> 224) - or(uint256 offsets, bytes data):
                                          if data.length - 200 < 100:
                                              revert with IncorrectDataLength()
                                      else:
                                          mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                          static call this.address.mem[96 len 4] with:
                                                  gas gas_remaining wei
                                                 args mem[100 len data.length - 204]
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                      if data.length - 300 < 4:
                                          revert with IncorrectDataLength()
                                  else:
                                      if (uint32(cd[(data + 236)]) >> 224) - timestampBelow(uint256 time):
                                          mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                          static call this.address.mem[96 len 4] with:
                                                  gas gas_remaining wei
                                                 args mem[100 len data.length - 204]
                  else:
                      if (uint32(cd[(data + 136)]) >> 224) - or(uint256 offsets, bytes data):
                          mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                          static call this.address.mem[96 len 4] with:
                                  gas gas_remaining wei
                                 args mem[100 len data.length - 104]
                          if 32 == return_data.size and ext_call.success:
                              if ext_call.return_data[0] > cd[(data + 40)]:
                                  return (value == 1)
                          return not value
                      if data.length - 100 < 100:
                          revert with IncorrectDataLength()
                      if uint32(cd[(data + 140)]):
                          require 0 <= uint32(cd[(data + 140)])
                          require uint32(cd[(data + 140)]) <= data.length - 200
                          if uint32(cd[(data + 140)]) < 4:
                              revert with IncorrectDataLength()
                          if uint32(cd[(data + 140)]) < 36:
                              revert with IncorrectDataLength()
                          if (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                              if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                                  if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                                      if (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                                  else:
                                      if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                              else:
                                  if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                                      if (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                                  else:
                                      if (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def lt(uint256 value, bytes data): # not payable
  require calldata.size - 4 >=′ 64
  require data <= LOCK8605463013()
  require data + 35 <′ calldata.size
  require data.length <= LOCK8605463013()
  require data + data.length + 36 <= calldata.size
  if data.length < 4:
      revert with IncorrectDataLength()
  if data.length < 36:
      revert with IncorrectDataLength()
  if not (uint32(cd[(data + 36)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
      if block.timestamp < cd[(data + 40)] % unknown10000000() >> 208:
          if not nonce[address(cd[(data + 40)])]:
              return (1 < value)
      return (0 < value)
  if uint32(cd[(data + 36)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
      if uint32(cd[(data + 36)]) >> 224 < lt(uint256 value, bytes data):
          if (uint32(cd[(data + 36)]) >> 224) - arbitraryStaticCall(address target, bytes data):
              if not (uint32(cd[(data + 36)]) >> 224) - and(uint256 offsets, bytes data):
                  if data.length < 100:
                      revert with IncorrectDataLength()
                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              mem[96 len data.length] = data[all]
              static call this.address.mem[96 len 4] with:
                      gas gas_remaining wei
                     args mem[100 len data.length - 4]
              if return_data.size != 32 or not ext_call.success:
                  return bool(32 == return_data.size and ext_call.success)
          else:
              if data.length < 100:
                  revert with IncorrectDataLength()
              mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
              static call cd[(data + 40)].mem[96 len 4] with:
                      gas gas_remaining wei
                     args mem[100 len data.length - 104]
              if return_data.size != 32 or not ext_call.success:
                  revert with ArbitraryStaticCallFailed()
              if return_data.size != 32 or not ext_call.success:
                  revert with ArbitraryStaticCallFailed()
          ('iszero', ('or', ('iszero', ('eq', 32, 'returndatasize')), ('iszero', 'ext_call.success')))
          return (ext_call.return_data[0] < value)
      if (uint32(cd[(data + 36)]) >> 224) - lt(uint256 value, bytes data):
          if not (uint32(cd[(data + 36)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
              if data.length < 68:
                  revert with IncorrectDataLength()
              if nonce[address(cd[(data + 40)])] == cd[(data + 72)]:
                  return (1 < value)
              return (0 < value)
          mem[96 len data.length] = data[all]
          static call this.address.mem[96 len 4] with:
                  gas gas_remaining wei
                 args mem[100 len data.length - 4]
          if return_data.size != 32 or not ext_call.success:
              return bool(32 == return_data.size and ext_call.success)
          return (ext_call.return_data[0] < value)
      if data.length < 100:
          revert with IncorrectDataLength()
      if data.length - 100 < 4:
          revert with IncorrectDataLength()
      if data.length - 100 < 36:
          revert with IncorrectDataLength()
      if not (uint32(cd[(data + 136)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
          if block.timestamp >= cd[(data + 140)] % unknown10000000() >> 208:
              if 0 < cd[(data + 40)]:
                  return (1 < value)
          else:
              if not nonce[address(cd[(data + 140)])]:
                  if 1 < cd[(data + 40)]:
                      return (1 < value)
              else:
                  if 0 < cd[(data + 40)]:
                      return (1 < value)
          return (0 < value)
      if uint32(cd[(data + 136)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
          if uint32(cd[(data + 136)]) >> 224 >= lt(uint256 value, bytes data):
              if (uint32(cd[(data + 136)]) >> 224) - lt(uint256 value, bytes data):
                  if not (uint32(cd[(data + 136)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                      if data.length - 100 < 68:
                          revert with IncorrectDataLength()
                      if nonce[address(cd[(data + 140)])] == cd[(data + 172)]:
                          if 1 < cd[(data + 40)]:
                              return (1 < value)
                      else:
                          if 0 < cd[(data + 40)]:
                              return (1 < value)
                  else:
                      mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                      static call this.address.mem[96 len 4] with:
                              gas gas_remaining wei
                             args mem[100 len data.length - 104]
                      if 32 == return_data.size and ext_call.success:
                          if ext_call.return_data[0] < cd[(data + 40)]:
                              return (1 < value)
                  return (0 < value)
              if data.length - 100 < 100:
                  revert with IncorrectDataLength()
              if data.length - 200 < 4:
                  revert with IncorrectDataLength()
              if data.length - 200 < 36:
                  revert with IncorrectDataLength()
              if not (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                  if block.timestamp < cd[(data + 240)] % unknown10000000() >> 208:
              else:
                  if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                      if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                          if not (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                              if data.length - 200 < 100:
                                  revert with IncorrectDataLength()
                              if data.length - 300 < 4:
                                  revert with IncorrectDataLength()
                          else:
                              if not (uint32(cd[(data + 236)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                                  if data.length - 200 < 68:
                                      revert with IncorrectDataLength()
                              else:
                                  mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                  static call this.address.mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 204]
                      else:
                          if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - and(uint256 offsets, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                              else:
                                  mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                  static call this.address.mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 204]
                          else:
                              if data.length - 200 < 100:
                                  revert with IncorrectDataLength()
                              mem[96 len data.length - 300] = call.data[data + 336 len data.length - 300]
                              static call cd[(data + 240)].mem[96 len 4] with:
                                      gas gas_remaining wei
                                     args mem[100 len data.length - 304]
                  else:
                      if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                          if not (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                              if data.length - 200 < 100:
                                  revert with IncorrectDataLength()
                              if data.length - 300 < 4:
                                  revert with IncorrectDataLength()
                          else:
                              if not (uint32(cd[(data + 236)]) >> 224) - or(uint256 offsets, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                              else:
                                  mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                  static call this.address.mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 204]
                      else:
                          if not (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
                              if data.length - 200 < 100:
                                  revert with IncorrectDataLength()
                              if data.length - 300 < 4:
                                  revert with IncorrectDataLength()
                          else:
                              if (uint32(cd[(data + 236)]) >> 224) - timestampBelow(uint256 time):
                                  mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                  static call this.address.mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 204]
          else:
              if not (uint32(cd[(data + 136)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                  if data.length - 100 < 100:
                      revert with IncorrectDataLength()
                  mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                  static call cd[(data + 140)].mem[96 len 4] with:
                          gas gas_remaining wei
                         args mem[100 len data.length - 204]
                  if return_data.size != 32 or not ext_call.success:
                      revert with ArbitraryStaticCallFailed()
                  if return_data.size != 32 or not ext_call.success:
                      revert with ArbitraryStaticCallFailed()
                  if ext_call.return_data[0] < cd[(data + 40)]:
                      return (1 < value)
                  return (0 < value)
              if (uint32(cd[(data + 136)]) >> 224) - and(uint256 offsets, bytes data):
                  mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                  static call this.address.mem[96 len 4] with:
                          gas gas_remaining wei
                         args mem[100 len data.length - 104]
                  if 32 == return_data.size and ext_call.success:
                      if ext_call.return_data[0] < cd[(data + 40)]:
                          return (1 < value)
                  return (0 < value)
              if data.length - 100 < 100:
                  revert with IncorrectDataLength()
              if not uint32(cd[(data + 140)]):
                  if 1 < cd[(data + 40)]:
                      return (1 < value)
                  return (0 < value)
              require 0 <= uint32(cd[(data + 140)])
              require uint32(cd[(data + 140)]) <= data.length - 200
              if uint32(cd[(data + 140)]) < 4:
                  revert with IncorrectDataLength()
              if uint32(cd[(data + 140)]) < 36:
                  revert with IncorrectDataLength()
              if (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                  if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                      if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                          if (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                      else:
                          if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                  else:
                      if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                          if (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                      else:
                          if (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
      else:
          if uint32(cd[(data + 136)]) >> 224 < eq(uint256 value, bytes data):
              if (uint32(cd[(data + 136)]) >> 224) - gt(uint256 value, bytes data):
                  if not (uint32(cd[(data + 136)]) >> 224) - timestampBelow(uint256 time):
                      if block.timestamp < cd[(data + 140)]:
                          if 1 < cd[(data + 40)]:
                              return (1 < value)
                      else:
                          if 0 < cd[(data + 40)]:
                              return (1 < value)
                  else:
                      mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                      static call this.address.mem[96 len 4] with:
                              gas gas_remaining wei
                             args mem[100 len data.length - 104]
                      if 32 == return_data.size and ext_call.success:
                          if ext_call.return_data[0] < cd[(data + 40)]:
                              return (1 < value)
                  return (0 < value)
              if data.length - 100 < 100:
                  revert with IncorrectDataLength()
              if data.length - 200 < 4:
                  revert with IncorrectDataLength()
              if data.length - 200 < 36:
                  revert with IncorrectDataLength()
              if not (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                  if block.timestamp < cd[(data + 240)] % unknown10000000() >> 208:
              else:
                  if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                      if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                          if not (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                              if data.length - 200 < 100:
                                  revert with IncorrectDataLength()
                              if data.length - 300 < 4:
                                  revert with IncorrectDataLength()
                          else:
                              if not (uint32(cd[(data + 236)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                                  if data.length - 200 < 68:
                                      revert with IncorrectDataLength()
                              else:
                                  mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                  static call this.address.mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 204]
                      else:
                          if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - and(uint256 offsets, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                              else:
                                  mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                  static call this.address.mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 204]
                          else:
                              if data.length - 200 < 100:
                                  revert with IncorrectDataLength()
                              mem[96 len data.length - 300] = call.data[data + 336 len data.length - 300]
                              static call cd[(data + 240)].mem[96 len 4] with:
                                      gas gas_remaining wei
                                     args mem[100 len data.length - 304]
                  else:
                      if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                          if not (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                              if data.length - 200 < 100:
                                  revert with IncorrectDataLength()
                              if data.length - 300 < 4:
                                  revert with IncorrectDataLength()
                          else:
                              if not (uint32(cd[(data + 236)]) >> 224) - or(uint256 offsets, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                              else:
                                  mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                  static call this.address.mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 204]
                      else:
                          if not (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
                              if data.length - 200 < 100:
                                  revert with IncorrectDataLength()
                              if data.length - 300 < 4:
                                  revert with IncorrectDataLength()
                          else:
                              if (uint32(cd[(data + 236)]) >> 224) - timestampBelow(uint256 time):
                                  mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                  static call this.address.mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 204]
          else:
              if not (uint32(cd[(data + 136)]) >> 224) - eq(uint256 value, bytes data):
                  if data.length - 100 < 100:
                      revert with IncorrectDataLength()
                  if data.length - 200 < 4:
                      revert with IncorrectDataLength()
                  if data.length - 200 < 36:
                      revert with IncorrectDataLength()
                  if not (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                      if block.timestamp < cd[(data + 240)] % unknown10000000() >> 208:
                  else:
                      if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                          if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                                      if data.length - 200 < 68:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                          else:
                              if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                                  if not (uint32(cd[(data + 236)]) >> 224) - and(uint256 offsets, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                              else:
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  mem[96 len data.length - 300] = call.data[data + 336 len data.length - 300]
                                  static call cd[(data + 240)].mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 304]
                      else:
                          if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - or(uint256 offsets, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                          else:
                              if not (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if (uint32(cd[(data + 236)]) >> 224) - timestampBelow(uint256 time):
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
              else:
                  if (uint32(cd[(data + 136)]) >> 224) - or(uint256 offsets, bytes data):
                      mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                      static call this.address.mem[96 len 4] with:
                              gas gas_remaining wei
                             args mem[100 len data.length - 104]
                      if 32 == return_data.size and ext_call.success:
                          if ext_call.return_data[0] < cd[(data + 40)]:
                              return (1 < value)
                      return (0 < value)
                  if data.length - 100 < 100:
                      revert with IncorrectDataLength()
                  if not uint32(cd[(data + 140)]):
                      if 0 < cd[(data + 40)]:
                          return (1 < value)
                      return (0 < value)
                  require 0 <= uint32(cd[(data + 140)])
                  require uint32(cd[(data + 140)]) <= data.length - 200
                  if uint32(cd[(data + 140)]) < 4:
                      revert with IncorrectDataLength()
                  if uint32(cd[(data + 140)]) < 36:
                      revert with IncorrectDataLength()
                  if (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                      if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                          if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                              if (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                          else:
                              if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                      else:
                          if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                              if (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                          else:
                              if (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
  else:
      if uint32(cd[(data + 36)]) >> 224 >= eq(uint256 value, bytes data):
          if (uint32(cd[(data + 36)]) >> 224) - eq(uint256 value, bytes data):
              if not (uint32(cd[(data + 36)]) >> 224) - or(uint256 offsets, bytes data):
                  if data.length < 100:
                      revert with IncorrectDataLength()
                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              mem[96 len data.length] = data[all]
              static call this.address.mem[96 len 4] with:
                      gas gas_remaining wei
                     args mem[100 len data.length - 4]
              if return_data.size != 32 or not ext_call.success:
                  return bool(32 == return_data.size and ext_call.success)
              return (ext_call.return_data[0] < value)
          if data.length < 100:
              revert with IncorrectDataLength()
          if data.length - 100 < 4:
              revert with IncorrectDataLength()
          if data.length - 100 < 36:
              revert with IncorrectDataLength()
          if not (uint32(cd[(data + 136)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
              if block.timestamp >= cd[(data + 140)] % unknown10000000() >> 208:
                  if not cd[(data + 40)]:
                      return (1 < value)
              else:
                  if not nonce[address(cd[(data + 140)])]:
                      if cd[(data + 40)] == 1:
                          return (1 < value)
                  else:
                      if not cd[(data + 40)]:
                          return (1 < value)
              return (0 < value)
          if uint32(cd[(data + 136)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
              if uint32(cd[(data + 136)]) >> 224 >= lt(uint256 value, bytes data):
                  if (uint32(cd[(data + 136)]) >> 224) - lt(uint256 value, bytes data):
                      if not (uint32(cd[(data + 136)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                          if data.length - 100 < 68:
                              revert with IncorrectDataLength()
                          if nonce[address(cd[(data + 140)])] == cd[(data + 172)]:
                              if cd[(data + 40)] == 1:
                                  return (1 < value)
                          else:
                              if not cd[(data + 40)]:
                                  return (1 < value)
                      else:
                          mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                          static call this.address.mem[96 len 4] with:
                                  gas gas_remaining wei
                                 args mem[100 len data.length - 104]
                          if 32 == return_data.size and ext_call.success:
                              if cd[(data + 40)] == ext_call.return_data[0]:
                                  return (1 < value)
                      return (0 < value)
                  if data.length - 100 < 100:
                      revert with IncorrectDataLength()
                  if data.length - 200 < 4:
                      revert with IncorrectDataLength()
                  if data.length - 200 < 36:
                      revert with IncorrectDataLength()
                  if not (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                      if block.timestamp < cd[(data + 240)] % unknown10000000() >> 208:
                  else:
                      if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                          if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                                      if data.length - 200 < 68:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                          else:
                              if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                                  if not (uint32(cd[(data + 236)]) >> 224) - and(uint256 offsets, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                              else:
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  mem[96 len data.length - 300] = call.data[data + 336 len data.length - 300]
                                  static call cd[(data + 240)].mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 304]
                      else:
                          if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - or(uint256 offsets, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                          else:
                              if not (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if (uint32(cd[(data + 236)]) >> 224) - timestampBelow(uint256 time):
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
              else:
                  if not (uint32(cd[(data + 136)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                      if data.length - 100 < 100:
                          revert with IncorrectDataLength()
                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                      static call cd[(data + 140)].mem[96 len 4] with:
                              gas gas_remaining wei
                             args mem[100 len data.length - 204]
                      if return_data.size != 32 or not ext_call.success:
                          revert with ArbitraryStaticCallFailed()
                      if return_data.size != 32 or not ext_call.success:
                          revert with ArbitraryStaticCallFailed()
                      if cd[(data + 40)] == ext_call.return_data[0]:
                          return (1 < value)
                      return (0 < value)
                  if (uint32(cd[(data + 136)]) >> 224) - and(uint256 offsets, bytes data):
                      mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                      static call this.address.mem[96 len 4] with:
                              gas gas_remaining wei
                             args mem[100 len data.length - 104]
                      if 32 == return_data.size and ext_call.success:
                          if cd[(data + 40)] == ext_call.return_data[0]:
                              return (1 < value)
                      return (0 < value)
                  if data.length - 100 < 100:
                      revert with IncorrectDataLength()
                  if not uint32(cd[(data + 140)]):
                      if cd[(data + 40)] == 1:
                          return (1 < value)
                      return (0 < value)
                  require 0 <= uint32(cd[(data + 140)])
                  require uint32(cd[(data + 140)]) <= data.length - 200
                  if uint32(cd[(data + 140)]) < 4:
                      revert with IncorrectDataLength()
                  if uint32(cd[(data + 140)]) < 36:
                      revert with IncorrectDataLength()
                  if (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                      if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                          if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                              if (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                          else:
                              if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                      else:
                          if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                              if (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                          else:
                              if (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
          else:
              if uint32(cd[(data + 136)]) >> 224 < eq(uint256 value, bytes data):
                  if (uint32(cd[(data + 136)]) >> 224) - gt(uint256 value, bytes data):
                      if not (uint32(cd[(data + 136)]) >> 224) - timestampBelow(uint256 time):
                          if block.timestamp < cd[(data + 140)]:
                              if cd[(data + 40)] == 1:
                                  return (1 < value)
                          else:
                              if not cd[(data + 40)]:
                                  return (1 < value)
                      else:
                          mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                          static call this.address.mem[96 len 4] with:
                                  gas gas_remaining wei
                                 args mem[100 len data.length - 104]
                          if 32 == return_data.size and ext_call.success:
                              if cd[(data + 40)] == ext_call.return_data[0]:
                                  return (1 < value)
                      return (0 < value)
                  if data.length - 100 < 100:
                      revert with IncorrectDataLength()
                  if data.length - 200 < 4:
                      revert with IncorrectDataLength()
                  if data.length - 200 < 36:
                      revert with IncorrectDataLength()
                  if not (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                      if block.timestamp < cd[(data + 240)] % unknown10000000() >> 208:
                  else:
                      if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                          if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                                      if data.length - 200 < 68:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                          else:
                              if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                                  if not (uint32(cd[(data + 236)]) >> 224) - and(uint256 offsets, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                              else:
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  mem[96 len data.length - 300] = call.data[data + 336 len data.length - 300]
                                  static call cd[(data + 240)].mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 304]
                      else:
                          if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - or(uint256 offsets, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                          else:
                              if not (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if (uint32(cd[(data + 236)]) >> 224) - timestampBelow(uint256 time):
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
              else:
                  if not (uint32(cd[(data + 136)]) >> 224) - eq(uint256 value, bytes data):
                      if data.length - 100 < 100:
                          revert with IncorrectDataLength()
                      if data.length - 200 < 4:
                          revert with IncorrectDataLength()
                      if data.length - 200 < 36:
                          revert with IncorrectDataLength()
                      if not (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                          if block.timestamp < cd[(data + 240)] % unknown10000000() >> 208:
                      else:
                          if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                              if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                                  if not (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                      if data.length - 300 < 4:
                                          revert with IncorrectDataLength()
                                  else:
                                      if not (uint32(cd[(data + 236)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                                          if data.length - 200 < 68:
                                              revert with IncorrectDataLength()
                                      else:
                                          mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                          static call this.address.mem[96 len 4] with:
                                                  gas gas_remaining wei
                                                 args mem[100 len data.length - 204]
                              else:
                                  if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                                      if not (uint32(cd[(data + 236)]) >> 224) - and(uint256 offsets, bytes data):
                                          if data.length - 200 < 100:
                                              revert with IncorrectDataLength()
                                      else:
                                          mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                          static call this.address.mem[96 len 4] with:
                                                  gas gas_remaining wei
                                                 args mem[100 len data.length - 204]
                                  else:
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                      mem[96 len data.length - 300] = call.data[data + 336 len data.length - 300]
                                      static call cd[(data + 240)].mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 304]
                          else:
                              if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                                  if not (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                      if data.length - 300 < 4:
                                          revert with IncorrectDataLength()
                                  else:
                                      if not (uint32(cd[(data + 236)]) >> 224) - or(uint256 offsets, bytes data):
                                          if data.length - 200 < 100:
                                              revert with IncorrectDataLength()
                                      else:
                                          mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                          static call this.address.mem[96 len 4] with:
                                                  gas gas_remaining wei
                                                 args mem[100 len data.length - 204]
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                      if data.length - 300 < 4:
                                          revert with IncorrectDataLength()
                                  else:
                                      if (uint32(cd[(data + 236)]) >> 224) - timestampBelow(uint256 time):
                                          mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                          static call this.address.mem[96 len 4] with:
                                                  gas gas_remaining wei
                                                 args mem[100 len data.length - 204]
                  else:
                      if (uint32(cd[(data + 136)]) >> 224) - or(uint256 offsets, bytes data):
                          mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                          static call this.address.mem[96 len 4] with:
                                  gas gas_remaining wei
                                 args mem[100 len data.length - 104]
                          if 32 == return_data.size and ext_call.success:
                              if cd[(data + 40)] == ext_call.return_data[0]:
                                  return (1 < value)
                          return (0 < value)
                      if data.length - 100 < 100:
                          revert with IncorrectDataLength()
                      if not uint32(cd[(data + 140)]):
                          if not cd[(data + 40)]:
                              return (1 < value)
                          return (0 < value)
                      require 0 <= uint32(cd[(data + 140)])
                      require uint32(cd[(data + 140)]) <= data.length - 200
                      if uint32(cd[(data + 140)]) < 4:
                          revert with IncorrectDataLength()
                      if uint32(cd[(data + 140)]) < 36:
                          revert with IncorrectDataLength()
                      if (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                          if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                              if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                                  if (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                              else:
                                  if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                          else:
                              if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                                  if (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                              else:
                                  if (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
      else:
          if (uint32(cd[(data + 36)]) >> 224) - gt(uint256 value, bytes data):
              if not (uint32(cd[(data + 36)]) >> 224) - timestampBelow(uint256 time):
                  if block.timestamp < cd[(data + 40)]:
                      return (1 < value)
                  return (0 < value)
              mem[96 len data.length] = data[all]
              static call this.address.mem[96 len 4] with:
                      gas gas_remaining wei
                     args mem[100 len data.length - 4]
              if return_data.size != 32 or not ext_call.success:
                  return bool(32 == return_data.size and ext_call.success)
              return (ext_call.return_data[0] < value)
          if data.length < 100:
              revert with IncorrectDataLength()
          if data.length - 100 < 4:
              revert with IncorrectDataLength()
          if data.length - 100 < 36:
              revert with IncorrectDataLength()
          if not (uint32(cd[(data + 136)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
              if block.timestamp >= cd[(data + 140)] % unknown10000000() >> 208:
                  if 0 > cd[(data + 40)]:
                      return (1 < value)
              else:
                  if not nonce[address(cd[(data + 140)])]:
                      if 1 > cd[(data + 40)]:
                          return (1 < value)
                  else:
                      if 0 > cd[(data + 40)]:
                          return (1 < value)
              return (0 < value)
          if uint32(cd[(data + 136)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
              if uint32(cd[(data + 136)]) >> 224 >= lt(uint256 value, bytes data):
                  if (uint32(cd[(data + 136)]) >> 224) - lt(uint256 value, bytes data):
                      if not (uint32(cd[(data + 136)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                          if data.length - 100 < 68:
                              revert with IncorrectDataLength()
                          if nonce[address(cd[(data + 140)])] == cd[(data + 172)]:
                              if 1 > cd[(data + 40)]:
                                  return (1 < value)
                          else:
                              if 0 > cd[(data + 40)]:
                                  return (1 < value)
                      else:
                          mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                          static call this.address.mem[96 len 4] with:
                                  gas gas_remaining wei
                                 args mem[100 len data.length - 104]
                          if 32 == return_data.size and ext_call.success:
                              if ext_call.return_data[0] > cd[(data + 40)]:
                                  return (1 < value)
                      return (0 < value)
                  if data.length - 100 < 100:
                      revert with IncorrectDataLength()
                  if data.length - 200 < 4:
                      revert with IncorrectDataLength()
                  if data.length - 200 < 36:
                      revert with IncorrectDataLength()
                  if not (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                      if block.timestamp < cd[(data + 240)] % unknown10000000() >> 208:
                  else:
                      if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                          if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                                      if data.length - 200 < 68:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                          else:
                              if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                                  if not (uint32(cd[(data + 236)]) >> 224) - and(uint256 offsets, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                              else:
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  mem[96 len data.length - 300] = call.data[data + 336 len data.length - 300]
                                  static call cd[(data + 240)].mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 304]
                      else:
                          if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - or(uint256 offsets, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                          else:
                              if not (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if (uint32(cd[(data + 236)]) >> 224) - timestampBelow(uint256 time):
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
              else:
                  if not (uint32(cd[(data + 136)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                      if data.length - 100 < 100:
                          revert with IncorrectDataLength()
                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                      static call cd[(data + 140)].mem[96 len 4] with:
                              gas gas_remaining wei
                             args mem[100 len data.length - 204]
                      if return_data.size != 32 or not ext_call.success:
                          revert with ArbitraryStaticCallFailed()
                      if return_data.size != 32 or not ext_call.success:
                          revert with ArbitraryStaticCallFailed()
                  else:
                      if (uint32(cd[(data + 136)]) >> 224) - and(uint256 offsets, bytes data):
                          mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                          static call this.address.mem[96 len 4] with:
                                  gas gas_remaining wei
                                 args mem[100 len data.length - 104]
                          if 32 == return_data.size and ext_call.success:
                              if ext_call.return_data[0] > cd[(data + 40)]:
                                  return (1 < value)
                          return (0 < value)
                      if data.length - 100 < 100:
                          revert with IncorrectDataLength()
                      if uint32(cd[(data + 140)]):
                          require 0 <= uint32(cd[(data + 140)])
                          require uint32(cd[(data + 140)]) <= data.length - 200
                          if uint32(cd[(data + 140)]) < 4:
                              revert with IncorrectDataLength()
                          if uint32(cd[(data + 140)]) < 36:
                              revert with IncorrectDataLength()
                          if (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                              if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                                  if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                                      if (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                                  else:
                                      if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                              else:
                                  if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                                      if (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                                  else:
                                      if (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
          else:
              if uint32(cd[(data + 136)]) >> 224 < eq(uint256 value, bytes data):
                  if (uint32(cd[(data + 136)]) >> 224) - gt(uint256 value, bytes data):
                      if not (uint32(cd[(data + 136)]) >> 224) - timestampBelow(uint256 time):
                          if block.timestamp < cd[(data + 140)]:
                              if 1 > cd[(data + 40)]:
                                  return (1 < value)
                          else:
                              if 0 > cd[(data + 40)]:
                                  return (1 < value)
                      else:
                          mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                          static call this.address.mem[96 len 4] with:
                                  gas gas_remaining wei
                                 args mem[100 len data.length - 104]
                          if 32 == return_data.size and ext_call.success:
                              if ext_call.return_data[0] > cd[(data + 40)]:
                                  return (1 < value)
                      return (0 < value)
                  if data.length - 100 < 100:
                      revert with IncorrectDataLength()
                  if data.length - 200 < 4:
                      revert with IncorrectDataLength()
                  if data.length - 200 < 36:
                      revert with IncorrectDataLength()
                  if not (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                      if block.timestamp < cd[(data + 240)] % unknown10000000() >> 208:
                  else:
                      if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                          if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                                      if data.length - 200 < 68:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                          else:
                              if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                                  if not (uint32(cd[(data + 236)]) >> 224) - and(uint256 offsets, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                              else:
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  mem[96 len data.length - 300] = call.data[data + 336 len data.length - 300]
                                  static call cd[(data + 240)].mem[96 len 4] with:
                                          gas gas_remaining wei
                                         args mem[100 len data.length - 304]
                      else:
                          if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                              if not (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - or(uint256 offsets, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                  else:
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
                          else:
                              if not (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
                                  if data.length - 200 < 100:
                                      revert with IncorrectDataLength()
                                  if data.length - 300 < 4:
                                      revert with IncorrectDataLength()
                              else:
                                  if (uint32(cd[(data + 236)]) >> 224) - timestampBelow(uint256 time):
                                      mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                      static call this.address.mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 204]
              else:
                  if not (uint32(cd[(data + 136)]) >> 224) - eq(uint256 value, bytes data):
                      if data.length - 100 < 100:
                          revert with IncorrectDataLength()
                      if data.length - 200 < 4:
                          revert with IncorrectDataLength()
                      if data.length - 200 < 36:
                          revert with IncorrectDataLength()
                      if not (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                          if block.timestamp < cd[(data + 240)] % unknown10000000() >> 208:
                      else:
                          if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                              if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                                  if not (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                      if data.length - 300 < 4:
                                          revert with IncorrectDataLength()
                                  else:
                                      if not (uint32(cd[(data + 236)]) >> 224) - nonceEquals(address makerAddress, uint256 makerNonce):
                                          if data.length - 200 < 68:
                                              revert with IncorrectDataLength()
                                      else:
                                          mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                          static call this.address.mem[96 len 4] with:
                                                  gas gas_remaining wei
                                                 args mem[100 len data.length - 204]
                              else:
                                  if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                                      if not (uint32(cd[(data + 236)]) >> 224) - and(uint256 offsets, bytes data):
                                          if data.length - 200 < 100:
                                              revert with IncorrectDataLength()
                                      else:
                                          mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                          static call this.address.mem[96 len 4] with:
                                                  gas gas_remaining wei
                                                 args mem[100 len data.length - 204]
                                  else:
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                      mem[96 len data.length - 300] = call.data[data + 336 len data.length - 300]
                                      static call cd[(data + 240)].mem[96 len 4] with:
                                              gas gas_remaining wei
                                             args mem[100 len data.length - 304]
                          else:
                              if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                                  if not (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                      if data.length - 300 < 4:
                                          revert with IncorrectDataLength()
                                  else:
                                      if not (uint32(cd[(data + 236)]) >> 224) - or(uint256 offsets, bytes data):
                                          if data.length - 200 < 100:
                                              revert with IncorrectDataLength()
                                      else:
                                          mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                          static call this.address.mem[96 len 4] with:
                                                  gas gas_remaining wei
                                                 args mem[100 len data.length - 204]
                              else:
                                  if not (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
                                      if data.length - 200 < 100:
                                          revert with IncorrectDataLength()
                                      if data.length - 300 < 4:
                                          revert with IncorrectDataLength()
                                  else:
                                      if (uint32(cd[(data + 236)]) >> 224) - timestampBelow(uint256 time):
                                          mem[96 len data.length - 200] = call.data[data + 236 len data.length - 200]
                                          static call this.address.mem[96 len 4] with:
                                                  gas gas_remaining wei
                                                 args mem[100 len data.length - 204]
                  else:
                      if (uint32(cd[(data + 136)]) >> 224) - or(uint256 offsets, bytes data):
                          mem[96 len data.length - 100] = call.data[data + 136 len data.length - 100]
                          static call this.address.mem[96 len 4] with:
                                  gas gas_remaining wei
                                 args mem[100 len data.length - 104]
                          if 32 == return_data.size and ext_call.success:
                              if ext_call.return_data[0] > cd[(data + 40)]:
                                  return (1 < value)
                          return (0 < value)
                      if data.length - 100 < 100:
                          revert with IncorrectDataLength()
                      if uint32(cd[(data + 140)]):
                          require 0 <= uint32(cd[(data + 140)])
                          require uint32(cd[(data + 140)]) <= data.length - 200
                          if uint32(cd[(data + 140)]) < 4:
                              revert with IncorrectDataLength()
                          if uint32(cd[(data + 140)]) < 36:
                              revert with IncorrectDataLength()
                          if (uint32(cd[(data + 236)]) >> 224) - timestampBelowAndNonceEquals(uint256 timeNonceAccount):
                              if uint32(cd[(data + 236)]) >> 224 >= arbitraryStaticCall(address target, bytes data):
                                  if uint32(cd[(data + 236)]) >> 224 >= lt(uint256 value, bytes data):
                                      if (uint32(cd[(data + 236)]) >> 224) - lt(uint256 value, bytes data):
                                  else:
                                      if (uint32(cd[(data + 236)]) >> 224) - arbitraryStaticCall(address target, bytes data):
                              else:
                                  if uint32(cd[(data + 236)]) >> 224 >= eq(uint256 value, bytes data):
                                      if (uint32(cd[(data + 236)]) >> 224) - eq(uint256 value, bytes data):
                                  else:
                                      if (uint32(cd[(data + 236)]) >> 224) - gt(uint256 value, bytes data):
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def fillOrderToWithPermit(tuple order, bytes signature, bytes interaction, uint256 makingAmount, uint256 takingAmount, uint256 skipPermitAndThresholdAmount, address target, bytes permit): # not payable
  require calldata.size - 4 >=′ 256
  require order <= LOCK8605463013()
  require calldata.size + -order - 4 >=′ 320
  require signature <= LOCK8605463013()
  require signature + 35 <′ calldata.size
  require signature.length <= LOCK8605463013()
  require signature + signature.length + 36 <= calldata.size
  require LOCK8605463013() >= interaction
  require interaction + 35 <′ calldata.size
  require interaction.length <= LOCK8605463013()
  require interaction + interaction.length + 36 <= calldata.size
  require target == target
  require permit <= LOCK8605463013()
  require permit + 35 <′ calldata.size
  require permit.length <= LOCK8605463013()
  require permit + permit.length + 36 <= calldata.size
  if permit.length < 20:
      revert with PermitLengthTooLow()
  if not -permit.length - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0c:
      call Mask(64, 96, cd[(permit + 36)]) >> 96.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
           gas gas_remaining wei
          args call.data[permit + 56 len permit.length - 20]
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      if not return_data.size:
          if ext_code.size(Mask(64, 96, cd[(permit + 36)]) >> 96) <= 0:
              revert with ext_call.return_data[0 len return_data.size]
      else:
          if return_data.size <= 31 or ext_call.return_data[0] != 1:
              revert with ext_call.return_data[0 len return_data.size]
      if not target:
          revert with ZeroTargetIsForbidden()
      require cd[(order + 292)] <′ calldata.size + -order - 35
      require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
      require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
      if this.address != 0x1111111254eeb25477b68fb85ed929f73a960582:
          if not remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))] - 1:
              revert with RemainingAmountIsZero()
          require cd[(order + 164)] == address(cd[(order + 164)])
          if address(cd[(order + 164)]):
              require cd[(order + 164)] == address(cd[(order + 164)])
              if address(cd[(order + 164)]) != caller:
                  revert with PrivateOrder()
              if remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))]:
                  require cd[(order + 292)] <′ calldata.size + -order - 35
                  require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                  require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                  require 0 <= cd[(order + cd[(order + 292)] + 4)]
              else:
                  require cd[(order + 100)] == address(cd[(order + 100)])
                  if not address(cd[(order + 100)]):
                      revert with BadSignature()
                  if signature.length != 64:
                      if signature.length != 65:
                          static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                  gas gas_remaining wei
                                 args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                      else:
                          if call.data[signature + 68] < 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                  else:
                      if signature.length == 65:
                          if call.data[signature + 68] < 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                      else:
                          if signature.length == 64:
                              if uint255(cd[(signature + 68)]) < 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                                  signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), (bool(cd[(signature + 68)]) >> 255) + 27, call.data[signature + 36], uint255(cd[(signature + 68)])) # precompiled
          else:
              if remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))]:
                  require cd[(order + 292)] <′ calldata.size + -order - 35
                  require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                  require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                  require 0 <= cd[(order + cd[(order + 292)] + 4)]
                  if not not takingAmount - not makingAmount:
                      revert with OnlyOneAmountShouldBeZero()
                  if -takingAmount:
                      require cd[(order + 292)] <′ calldata.size + -order - 35
                  else:
                      if makingAmount <= remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))] - 1:
              else:
                  require cd[(order + 100)] == address(cd[(order + 100)])
                  if not address(cd[(order + 100)]):
                      revert with BadSignature()
                  if signature.length != 64:
                      if signature.length != 65:
                          static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                  gas gas_remaining wei
                                 args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                          if not ext_call.success:
                              revert with BadSignature()
                          if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                              revert with BadSignature()
                          require cd[(order + 292)] <′ calldata.size + -order - 35
                      else:
                          if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if address(cd[(order + 100)]):
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                          else:
                              signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                              if address(signer) != address(cd[(order + 100)]):
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                  else:
                      if signature.length == 65:
                          if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if address(cd[(order + 100)]):
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                          else:
                              signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                              if address(signer) != address(cd[(order + 100)]):
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                      else:
                          if signature.length != 64:
                              if address(cd[(order + 100)]):
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                          else:
                              if uint255(cd[(signature + 68)]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                                  if address(cd[(order + 100)]):
                                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              else:
                                  signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), (bool(cd[(signature + 68)]) >> 255) + 27, call.data[signature + 36], uint255(cd[(signature + 68)])) # precompiled
                                  if address(signer) != address(cd[(order + 100)]):
                                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
      else:
          if 1 != chainid:
              if not remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))] - 1:
                  revert with RemainingAmountIsZero()
              require cd[(order + 164)] == address(cd[(order + 164)])
              if address(cd[(order + 164)]):
                  require cd[(order + 164)] == address(cd[(order + 164)])
                  if address(cd[(order + 164)]) != caller:
                      revert with PrivateOrder()
                  if remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))]:
                      require cd[(order + 292)] <′ calldata.size + -order - 35
                      require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                      require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                      require 0 <= cd[(order + cd[(order + 292)] + 4)]
                  else:
                      require cd[(order + 100)] == address(cd[(order + 100)])
                      if not address(cd[(order + 100)]):
                          revert with BadSignature()
                      if signature.length == 64:
                          if signature.length == 65:
                              if call.data[signature + 68] < 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                                  signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                          else:
                              if signature.length == 64:
                      else:
                          if signature.length != 65:
                              static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
              else:
                  if remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))]:
                      require cd[(order + 292)] <′ calldata.size + -order - 35
                      require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                      require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                      require 0 <= cd[(order + cd[(order + 292)] + 4)]
                      if not not takingAmount - not makingAmount:
                          revert with OnlyOneAmountShouldBeZero()
                      if not -takingAmount:
                  else:
                      require cd[(order + 100)] == address(cd[(order + 100)])
                      if not address(cd[(order + 100)]):
                          revert with BadSignature()
                      if signature.length != 64:
                          if signature.length != 65:
                              static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              if not ext_call.success:
                                  revert with BadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with BadSignature()
                          else:
                              if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                                  if address(cd[(order + 100)]):
                                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              else:
                                  signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                                  if address(signer) != address(cd[(order + 100)]):
                                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                      else:
                          if signature.length == 65:
                              if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                                  if address(cd[(order + 100)]):
                                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              else:
                                  signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                                  if address(signer) != address(cd[(order + 100)]):
                                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                          else:
                              if signature.length != 64:
                                  if address(cd[(order + 100)]):
                                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              else:
                                  if uint255(cd[(signature + 68)]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                                      if address(cd[(order + 100)]):
                                          static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                                  gas gas_remaining wei
                                                 args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  else:
                                      signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), (bool(cd[(signature + 68)]) >> 255) + 27, call.data[signature + 36], uint255(cd[(signature + 68)])) # precompiled
                                      if address(signer) != address(cd[(order + 100)]):
                                          static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                                  gas gas_remaining wei
                                                 args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
          else:
              if not remainingRaw[6401][0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))] - 1:
                  revert with RemainingAmountIsZero()
              require cd[(order + 164)] == address(cd[(order + 164)])
              if address(cd[(order + 164)]):
                  require cd[(order + 164)] == address(cd[(order + 164)])
                  if address(cd[(order + 164)]) != caller:
                      revert with PrivateOrder()
                  if remainingRaw[6401][0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))]:
                      require cd[(order + 292)] <′ calldata.size + -order - 35
                      require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                      require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                      require 0 <= cd[(order + cd[(order + 292)] + 4)]
                  else:
                      require cd[(order + 100)] == address(cd[(order + 100)])
                      if not address(cd[(order + 100)]):
                          revert with BadSignature()
                      if signature.length == 64:
                          if signature.length == 65:
                              if call.data[signature + 68] < 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                                  signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                          else:
                              if signature.length == 64:
                      else:
                          if signature.length != 65:
                              static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
              else:
                  if remainingRaw[6401][0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))]:
                      require cd[(order + 292)] <′ calldata.size + -order - 35
                      require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                      require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                      require 0 <= cd[(order + cd[(order + 292)] + 4)]
                      if not not takingAmount - not makingAmount:
                          revert with OnlyOneAmountShouldBeZero()
                      if not -takingAmount:
                  else:
                      require cd[(order + 100)] == address(cd[(order + 100)])
                      if not address(cd[(order + 100)]):
                          revert with BadSignature()
                      if signature.length != 64:
                          if signature.length != 65:
                              static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              if not ext_call.success:
                                  revert with BadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with BadSignature()
                          else:
                              if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                                  if address(cd[(order + 100)]):
                                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              else:
                                  signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                                  if address(signer) != address(cd[(order + 100)]):
                                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                      else:
                          if signature.length == 65:
                              if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                                  if address(cd[(order + 100)]):
                                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              else:
                                  signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                                  if address(signer) != address(cd[(order + 100)]):
                                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                          else:
                              if signature.length != 64:
                                  if address(cd[(order + 100)]):
                                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              else:
                                  if uint255(cd[(signature + 68)]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                                      if address(cd[(order + 100)]):
                                          static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                                  gas gas_remaining wei
                                                 args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  else:
                                      signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), (bool(cd[(signature + 68)]) >> 255) + 27, call.data[signature + 36], uint255(cd[(signature + 68)])) # precompiled
                                      if address(signer) != address(cd[(order + 100)]):
                                          static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                                  gas gas_remaining wei
                                                 args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
  else:
      if -permit.length - 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeec:
          revert with 'h'XW'
      call Mask(64, 96, cd[(permit + 36)]) >> 96.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) with:
           gas gas_remaining wei
          args call.data[permit + 56 len permit.length - 20]
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      if not return_data.size:
          if ext_code.size(Mask(64, 96, cd[(permit + 36)]) >> 96) <= 0:
              revert with ext_call.return_data[0 len return_data.size]
      else:
          if return_data.size <= 31 or ext_call.return_data[0] != 1:
              revert with ext_call.return_data[0 len return_data.size]
      if not target:
          revert with ZeroTargetIsForbidden()
      require cd[(order + 292)] <′ calldata.size + -order - 35
      require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
      require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
      if this.address != 0x1111111254eeb25477b68fb85ed929f73a960582:
          if not remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))] - 1:
              revert with RemainingAmountIsZero()
          require cd[(order + 164)] == address(cd[(order + 164)])
          if address(cd[(order + 164)]):
              require cd[(order + 164)] == address(cd[(order + 164)])
              if address(cd[(order + 164)]) != caller:
                  revert with PrivateOrder()
              if remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))]:
                  require cd[(order + 292)] <′ calldata.size + -order - 35
                  require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                  require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                  require 0 <= cd[(order + cd[(order + 292)] + 4)]
              else:
                  require cd[(order + 100)] == address(cd[(order + 100)])
                  if not address(cd[(order + 100)]):
                      revert with BadSignature()
                  if signature.length == 64:
                      if signature.length == 65:
                          if call.data[signature + 68] < 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                      else:
                          if signature.length == 64:
                  else:
                      if signature.length != 65:
                          static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                  gas gas_remaining wei
                                 args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
          else:
              if remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))]:
                  require cd[(order + 292)] <′ calldata.size + -order - 35
                  require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                  require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                  require 0 <= cd[(order + cd[(order + 292)] + 4)]
                  if not not takingAmount - not makingAmount:
                      revert with OnlyOneAmountShouldBeZero()
                  if not -takingAmount:
              else:
                  require cd[(order + 100)] == address(cd[(order + 100)])
                  if not address(cd[(order + 100)]):
                      revert with BadSignature()
                  if signature.length != 64:
                      if signature.length != 65:
                          static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                  gas gas_remaining wei
                                 args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                          if not ext_call.success:
                              revert with BadSignature()
                          if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                              revert with BadSignature()
                      else:
                          if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if address(cd[(order + 100)]):
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                          else:
                              signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                              if address(signer) != address(cd[(order + 100)]):
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                  else:
                      if signature.length == 65:
                          if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if address(cd[(order + 100)]):
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                          else:
                              signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                              if address(signer) != address(cd[(order + 100)]):
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                      else:
                          if signature.length != 64:
                              if address(cd[(order + 100)]):
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                          else:
                              if uint255(cd[(signature + 68)]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                                  if address(cd[(order + 100)]):
                                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              else:
                                  signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), (bool(cd[(signature + 68)]) >> 255) + 27, call.data[signature + 36], uint255(cd[(signature + 68)])) # precompiled
                                  if address(signer) != address(cd[(order + 100)]):
                                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
      else:
          if 1 != chainid:
              if not remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))] - 1:
                  revert with RemainingAmountIsZero()
              require cd[(order + 164)] == address(cd[(order + 164)])
              if address(cd[(order + 164)]):
                  require cd[(order + 164)] == address(cd[(order + 164)])
                  if address(cd[(order + 164)]) != caller:
                      revert with PrivateOrder()
                  if remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))]:
                      require cd[(order + 292)] <′ calldata.size + -order - 35
                      require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                      require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                      require 0 <= cd[(order + cd[(order + 292)] + 4)]
                  else:
                      require cd[(order + 100)] == address(cd[(order + 100)])
                      if not address(cd[(order + 100)]):
                          revert with BadSignature()
                      if signature.length == 64:
                          if signature.length != 65:
                      else:
                          if signature.length != 65:
                              static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
              else:
                  if remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))]:
                      require cd[(order + 292)] <′ calldata.size + -order - 35
                      require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                      require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                      require 0 <= cd[(order + cd[(order + 292)] + 4)]
                      if not not takingAmount - not makingAmount:
                          revert with OnlyOneAmountShouldBeZero()
                      if not -takingAmount:
                  else:
                      require cd[(order + 100)] == address(cd[(order + 100)])
                      if not address(cd[(order + 100)]):
                          revert with BadSignature()
                      if signature.length != 64:
                          if signature.length != 65:
                              static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              if not ext_call.success:
                                  revert with BadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with BadSignature()
                          else:
                              if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                                  if address(cd[(order + 100)]):
                                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              else:
                                  signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                                  if address(signer) != address(cd[(order + 100)]):
                                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                      else:
                          if signature.length == 65:
                              if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                                  if address(cd[(order + 100)]):
                                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              else:
                                  signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                                  if address(signer) != address(cd[(order + 100)]):
                                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                          else:
                              if signature.length != 64:
                                  if address(cd[(order + 100)]):
                                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              else:
                                  if uint255(cd[(signature + 68)]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                                      if address(cd[(order + 100)]):
                                          static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                                  gas gas_remaining wei
                                                 args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  else:
                                      signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), (bool(cd[(signature + 68)]) >> 255) + 27, call.data[signature + 36], uint255(cd[(signature + 68)])) # precompiled
                                      if address(signer) != address(cd[(order + 100)]):
                                          static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                                  gas gas_remaining wei
                                                 args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
          else:
              if not remainingRaw[6401][0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))] - 1:
                  revert with RemainingAmountIsZero()
              require cd[(order + 164)] == address(cd[(order + 164)])
              if address(cd[(order + 164)]):
                  require cd[(order + 164)] == address(cd[(order + 164)])
                  if address(cd[(order + 164)]) != caller:
                      revert with PrivateOrder()
                  if remainingRaw[6401][0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))]:
                      require cd[(order + 292)] <′ calldata.size + -order - 35
                      require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                      require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                      require 0 <= cd[(order + cd[(order + 292)] + 4)]
                  else:
                      require cd[(order + 100)] == address(cd[(order + 100)])
                      if not address(cd[(order + 100)]):
                          revert with BadSignature()
                      if signature.length == 64:
                          if signature.length != 65:
                      else:
                          if signature.length != 65:
                              static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
              else:
                  if remainingRaw[6401][0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))]:
                      require cd[(order + 292)] <′ calldata.size + -order - 35
                      require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                      require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                      require 0 <= cd[(order + cd[(order + 292)] + 4)]
                      if not not takingAmount - not makingAmount:
                          revert with OnlyOneAmountShouldBeZero()
                      if not -takingAmount:
                  else:
                      require cd[(order + 100)] == address(cd[(order + 100)])
                      if not address(cd[(order + 100)]):
                          revert with BadSignature()
                      if signature.length != 64:
                          if signature.length != 65:
                              static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              if not ext_call.success:
                                  revert with BadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with BadSignature()
                          else:
                              if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                                  if address(cd[(order + 100)]):
                                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              else:
                                  signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                                  if address(signer) != address(cd[(order + 100)]):
                                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                      else:
                          if signature.length == 65:
                              if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                                  if address(cd[(order + 100)]):
                                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              else:
                                  signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                                  if address(signer) != address(cd[(order + 100)]):
                                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                          else:
                              if signature.length != 64:
                                  if address(cd[(order + 100)]):
                                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              else:
                                  if uint255(cd[(signature + 68)]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                                      if address(cd[(order + 100)]):
                                          static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                                  gas gas_remaining wei
                                                 args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  else:
                                      signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), (bool(cd[(signature + 68)]) >> 255) + 27, call.data[signature + 36], uint255(cd[(signature + 68)])) # precompiled
                                      if address(signer) != address(cd[(order + 100)]):
                                          static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                                  gas gas_remaining wei
                                                 args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def fillOrderRFQToWithPermit(tuple order, bytes signature, uint256 flagsAndAmount, address target, bytes permit): # not payable
  require calldata.size - 4 >=′ 352
  require calldata.size - 4 >=′ 224
  require signature == address(signature)
  require flagsAndAmount == address(flagsAndAmount)
  require target == target
  require permit == address(permit)
  require cd[228] <= LOCK8605463013()
  require cd[228] + 35 <′ calldata.size
  require ('cd', 228).length <= LOCK8605463013()
  require cd[228] + ('cd', 228).length + 36 <= calldata.size
  require cd[292] == address(cd[292])
  require cd[324] <= LOCK8605463013()
  require cd[324] + 35 <′ calldata.size
  require ('cd', 324).length <= LOCK8605463013()
  require cd[324] + ('cd', 324).length + 36 <= calldata.size
  if -('cd', 324).length + 224:
      if -('cd', 324).length + 256:
          revert with 'h'XW'
      call address(flagsAndAmount).permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) with:
           gas gas_remaining wei
          args call.data[cd[324] + 36 len ('cd', 324).length]
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      if not return_data.size:
          if ext_code.size(address(flagsAndAmount)) <= 0:
              revert with ext_call.return_data[0 len return_data.size]
      else:
          if return_data.size <= 31 or ext_call.return_data[0] != 1:
              revert with ext_call.return_data[0 len return_data.size]
      if this.address != 0x1111111254eeb25477b68fb85ed929f73a960582:
          if not Mask(1, 254, cd[260]):
              if not target:
                  revert with RFQBadSignature()
              if ('cd', 228).length == 64:
                  if ('cd', 228).length == 65:
                      if call.data[cd[228] + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                          if not target:
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                          else:
                              static call target.isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with RFQBadSignature()
                      else:
                          signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) - 256, call.data[cd[228] + 36 len 64]) # precompiled
                          if address(signer) == target:
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                          else:
                              static call target.isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                  else:
                      if ('cd', 228).length != 64:
                          if not target:
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                          else:
                              static call target.isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with RFQBadSignature()
                      else:
                          if uint255(('cd', 228)[1]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if not target:
                                  if not address(cd[292]):
                                      revert with RFQZeroTargetIsForbidden()
                              else:
                                  static call target.isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                                  if not ext_call.success:
                                      revert with RFQBadSignature()
                          else:
                              signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), (bool(('cd', 228)[1]) >> 255) + 27, call.data[cd[228] + 36], uint255(('cd', 228)[1])) # precompiled
                              if address(signer) != target:
                                  static call target.isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
              else:
                  if ('cd', 228).length == 65:
                      if call.data[cd[228] + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                          if not target:
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                          else:
                              static call target.isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                      else:
                          signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) - 256, call.data[cd[228] + 36 len 64]) # precompiled
                          if address(signer) != target:
                              static call target.isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                  else:
                      static call target.isValidSignature(bytes32 , bytes ) with:
                              gas gas_remaining wei
                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                      if not ext_call.success:
                          revert with RFQBadSignature()
                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                          revert with RFQBadSignature()
                      if not address(cd[292]):
                          revert with RFQZeroTargetIsForbidden()
                      if not address(permit):
                          if Mask(64, 64, order):
                      else:
                          if address(permit) != caller:
                              revert with RFQPrivateOrder()
          else:
              if not Mask(1, 253, cd[260]):
                  static call target.isValidSignature(bytes32 , bytes ) with:
                          gas gas_remaining wei
                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                  if not ext_call.success:
                      revert with RFQBadSignature()
                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                      revert with RFQBadSignature()
                  if not address(cd[292]):
                      revert with RFQZeroTargetIsForbidden()
                  if not address(permit):
                      if not Mask(64, 64, order):
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                      else:
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                  else:
                      if address(permit) != caller:
                          revert with RFQPrivateOrder()
                      if Mask(64, 64, order):
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                          revert with InvalidatedOrder()
                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
              else:
                  if ('cd', 228).length != 65:
                      revert with RFQBadSignature()
                  static call target.isValidSignature(bytes32 , bytes ) with:
                          gas gas_remaining wei
                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                  if not ext_call.success:
                      revert with RFQBadSignature()
                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                      revert with RFQBadSignature()
                  if not address(cd[292]):
                      revert with RFQZeroTargetIsForbidden()
                  if not address(permit):
                      if Mask(64, 64, order):
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                          revert with InvalidatedOrder()
                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                  else:
                      if address(permit) != caller:
                          revert with RFQPrivateOrder()
                      if not Mask(64, 64, order):
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                      else:
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
      else:
          if 1 != chainid:
              if not Mask(1, 254, cd[260]):
                  if not target:
                      revert with RFQBadSignature()
                  if ('cd', 228).length == 64:
                      if ('cd', 228).length == 65:
                          if call.data[cd[228] + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if not target:
                                  if not address(cd[292]):
                                      revert with RFQZeroTargetIsForbidden()
                              else:
                                  static call target.isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                                  if not ext_call.success:
                                      revert with RFQBadSignature()
                          else:
                              signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) - 256, call.data[cd[228] + 36 len 64]) # precompiled
                              if address(signer) != target:
                                  static call target.isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                      else:
                          if ('cd', 228).length != 64:
                              if not target:
                                  if not address(cd[292]):
                                      revert with RFQZeroTargetIsForbidden()
                              else:
                                  static call target.isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                                  if not ext_call.success:
                                      revert with RFQBadSignature()
                          else:
                              if uint255(('cd', 228)[1]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                                  if target:
                                      static call target.isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              else:
                                  signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), (bool(('cd', 228)[1]) >> 255) + 27, call.data[cd[228] + 36], uint255(('cd', 228)[1])) # precompiled
                                  if address(signer) != target:
                                      static call target.isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                  else:
                      if ('cd', 228).length == 65:
                          if call.data[cd[228] + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if target:
                                  static call target.isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                          else:
                              signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) - 256, call.data[cd[228] + 36 len 64]) # precompiled
                              if address(signer) != target:
                                  static call target.isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                      else:
                          static call target.isValidSignature(bytes32 , bytes ) with:
                                  gas gas_remaining wei
                                 args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                          if not ext_call.success:
                              revert with RFQBadSignature()
                          if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                              revert with RFQBadSignature()
                          if not address(cd[292]):
                              revert with RFQZeroTargetIsForbidden()
                          if address(permit):
                              if address(permit) != caller:
                                  revert with RFQPrivateOrder()
              else:
                  if not Mask(1, 253, cd[260]):
                      static call target.isValidSignature(bytes32 , bytes ) with:
                              gas gas_remaining wei
                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                      if not ext_call.success:
                          revert with RFQBadSignature()
                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                          revert with RFQBadSignature()
                      if not address(cd[292]):
                          revert with RFQZeroTargetIsForbidden()
                      if not address(permit):
                          if Mask(64, 64, order):
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                      else:
                          if address(permit) != caller:
                              revert with RFQPrivateOrder()
                          if not Mask(64, 64, order):
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          else:
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                  else:
                      if ('cd', 228).length != 65:
                          revert with RFQBadSignature()
                      static call target.isValidSignature(bytes32 , bytes ) with:
                              gas gas_remaining wei
                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                      if not ext_call.success:
                          revert with RFQBadSignature()
                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                          revert with RFQBadSignature()
                      if not address(cd[292]):
                          revert with RFQZeroTargetIsForbidden()
                      if not address(permit):
                          if not Mask(64, 64, order):
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          else:
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                      else:
                          if address(permit) != caller:
                              revert with RFQPrivateOrder()
                          if Mask(64, 64, order):
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
          else:
              if not Mask(1, 254, cd[260]):
                  if not target:
                      revert with RFQBadSignature()
                  if ('cd', 228).length == 64:
                      if ('cd', 228).length == 65:
                          if call.data[cd[228] + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if not target:
                                  if not address(cd[292]):
                                      revert with RFQZeroTargetIsForbidden()
                              else:
                                  static call target.isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                                  if not ext_call.success:
                                      revert with RFQBadSignature()
                          else:
                              signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) - 256, call.data[cd[228] + 36 len 64]) # precompiled
                              if address(signer) != target:
                                  static call target.isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                      else:
                          if ('cd', 228).length != 64:
                              if not target:
                                  if not address(cd[292]):
                                      revert with RFQZeroTargetIsForbidden()
                              else:
                                  static call target.isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                                  if not ext_call.success:
                                      revert with RFQBadSignature()
                          else:
                              if uint255(('cd', 228)[1]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                                  if target:
                                      static call target.isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              else:
                                  signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), (bool(('cd', 228)[1]) >> 255) + 27, call.data[cd[228] + 36], uint255(('cd', 228)[1])) # precompiled
                                  if address(signer) != target:
                                      static call target.isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                  else:
                      if ('cd', 228).length == 65:
                          if call.data[cd[228] + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if target:
                                  static call target.isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                          else:
                              signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) - 256, call.data[cd[228] + 36 len 64]) # precompiled
                              if address(signer) != target:
                                  static call target.isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                      else:
                          static call target.isValidSignature(bytes32 , bytes ) with:
                                  gas gas_remaining wei
                                 args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                          if not ext_call.success:
                              revert with RFQBadSignature()
                          if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                              revert with RFQBadSignature()
                          if not address(cd[292]):
                              revert with RFQZeroTargetIsForbidden()
                          if address(permit):
                              if address(permit) != caller:
                                  revert with RFQPrivateOrder()
              else:
                  if not Mask(1, 253, cd[260]):
                      static call target.isValidSignature(bytes32 , bytes ) with:
                              gas gas_remaining wei
                             args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                      if not ext_call.success:
                          revert with RFQBadSignature()
                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                          revert with RFQBadSignature()
                      if not address(cd[292]):
                          revert with RFQZeroTargetIsForbidden()
                      if not address(permit):
                          if Mask(64, 64, order):
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                      else:
                          if address(permit) != caller:
                              revert with RFQPrivateOrder()
                          if not Mask(64, 64, order):
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          else:
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                  else:
                      if ('cd', 228).length != 65:
                          revert with RFQBadSignature()
                      static call target.isValidSignature(bytes32 , bytes ) with:
                              gas gas_remaining wei
                             args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                      if not ext_call.success:
                          revert with RFQBadSignature()
                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                          revert with RFQBadSignature()
                      if not address(cd[292]):
                          revert with RFQZeroTargetIsForbidden()
                      if not address(permit):
                          if not Mask(64, 64, order):
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          else:
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                      else:
                          if address(permit) != caller:
                              revert with RFQPrivateOrder()
                          if Mask(64, 64, order):
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
  else:
      call address(flagsAndAmount).permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
           gas gas_remaining wei
          args call.data[cd[324] + 36 len ('cd', 324).length]
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      if not return_data.size:
          if ext_code.size(address(flagsAndAmount)) <= 0:
              revert with ext_call.return_data[0 len return_data.size]
      else:
          if return_data.size <= 31 or ext_call.return_data[0] != 1:
              revert with ext_call.return_data[0 len return_data.size]
      if this.address != 0x1111111254eeb25477b68fb85ed929f73a960582:
          if not Mask(1, 254, cd[260]):
              if not target:
                  revert with RFQBadSignature()
              if ('cd', 228).length == 64:
                  if ('cd', 228).length == 65:
                      if call.data[cd[228] + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                          if not target:
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                              if address(permit):
                          else:
                              static call target.isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with RFQBadSignature()
                      else:
                          signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) - 256, call.data[cd[228] + 36 len 64]) # precompiled
                          if address(signer) == target:
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                          else:
                              static call target.isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with RFQBadSignature()
                  else:
                      if ('cd', 228).length != 64:
                          if not target:
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                              if address(permit):
                          else:
                              static call target.isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with RFQBadSignature()
                      else:
                          if uint255(('cd', 228)[1]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if not target:
                                  if not address(cd[292]):
                                      revert with RFQZeroTargetIsForbidden()
                              else:
                                  static call target.isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                                  if not ext_call.success:
                                      revert with RFQBadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with RFQBadSignature()
                          else:
                              signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), (bool(('cd', 228)[1]) >> 255) + 27, call.data[cd[228] + 36], uint255(('cd', 228)[1])) # precompiled
                              if address(signer) == target:
                                  if not address(cd[292]):
                                      revert with RFQZeroTargetIsForbidden()
                              else:
                                  static call target.isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                                  if not ext_call.success:
                                      revert with RFQBadSignature()
              else:
                  if ('cd', 228).length == 65:
                      if call.data[cd[228] + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                          if not target:
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                          else:
                              static call target.isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with RFQBadSignature()
                      else:
                          signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) - 256, call.data[cd[228] + 36 len 64]) # precompiled
                          if address(signer) == target:
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                          else:
                              static call target.isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                  else:
                      static call target.isValidSignature(bytes32 , bytes ) with:
                              gas gas_remaining wei
                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                      if not ext_call.success:
                          revert with RFQBadSignature()
                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                          revert with RFQBadSignature()
                      if not address(cd[292]):
                          revert with RFQZeroTargetIsForbidden()
                      if not address(permit):
                          if Mask(64, 64, order):
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                      else:
                          if address(permit) != caller:
                              revert with RFQPrivateOrder()
                          if Mask(64, 64, order):
          else:
              if not Mask(1, 253, cd[260]):
                  static call target.isValidSignature(bytes32 , bytes ) with:
                          gas gas_remaining wei
                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                  if not ext_call.success:
                      revert with RFQBadSignature()
                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                      revert with RFQBadSignature()
                  if not address(cd[292]):
                      revert with RFQZeroTargetIsForbidden()
                  if not address(permit):
                      if not Mask(64, 64, order):
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if Mask(1, 255, cd[260]):
                      else:
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                  else:
                      if address(permit) != caller:
                          revert with RFQPrivateOrder()
                      if not Mask(64, 64, order):
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                      else:
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
              else:
                  if ('cd', 228).length != 65:
                      revert with RFQBadSignature()
                  static call target.isValidSignature(bytes32 , bytes ) with:
                          gas gas_remaining wei
                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                  if not ext_call.success:
                      revert with RFQBadSignature()
                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                      revert with RFQBadSignature()
                  if not address(cd[292]):
                      revert with RFQZeroTargetIsForbidden()
                  if not address(permit):
                      if not Mask(64, 64, order):
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                      else:
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                  else:
                      if address(permit) != caller:
                          revert with RFQPrivateOrder()
                      if Mask(64, 64, order):
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                          revert with InvalidatedOrder()
                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
      else:
          if 1 != chainid:
              if not Mask(1, 254, cd[260]):
                  if not target:
                      revert with RFQBadSignature()
                  if ('cd', 228).length == 64:
                      if ('cd', 228).length == 65:
                          if call.data[cd[228] + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if not target:
                                  if not address(cd[292]):
                                      revert with RFQZeroTargetIsForbidden()
                              else:
                                  static call target.isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                                  if not ext_call.success:
                                      revert with RFQBadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with RFQBadSignature()
                          else:
                              signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) - 256, call.data[cd[228] + 36 len 64]) # precompiled
                              if address(signer) == target:
                                  if not address(cd[292]):
                                      revert with RFQZeroTargetIsForbidden()
                              else:
                                  static call target.isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                                  if not ext_call.success:
                                      revert with RFQBadSignature()
                      else:
                          if ('cd', 228).length != 64:
                              if not target:
                                  if not address(cd[292]):
                                      revert with RFQZeroTargetIsForbidden()
                              else:
                                  static call target.isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                                  if not ext_call.success:
                                      revert with RFQBadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with RFQBadSignature()
                          else:
                              if uint255(('cd', 228)[1]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                                  if not target:
                                      if not address(cd[292]):
                                          revert with RFQZeroTargetIsForbidden()
                                  else:
                                      static call target.isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                                      if not ext_call.success:
                                          revert with RFQBadSignature()
                              else:
                                  signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), (bool(('cd', 228)[1]) >> 255) + 27, call.data[cd[228] + 36], uint255(('cd', 228)[1])) # precompiled
                                  if address(signer) != target:
                                      static call target.isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                  else:
                      if ('cd', 228).length == 65:
                          if call.data[cd[228] + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if not target:
                                  if not address(cd[292]):
                                      revert with RFQZeroTargetIsForbidden()
                              else:
                                  static call target.isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                                  if not ext_call.success:
                                      revert with RFQBadSignature()
                          else:
                              signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) - 256, call.data[cd[228] + 36 len 64]) # precompiled
                              if address(signer) != target:
                                  static call target.isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                      else:
                          static call target.isValidSignature(bytes32 , bytes ) with:
                                  gas gas_remaining wei
                                 args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                          if not ext_call.success:
                              revert with RFQBadSignature()
                          if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                              revert with RFQBadSignature()
                          if not address(cd[292]):
                              revert with RFQZeroTargetIsForbidden()
                          if not address(permit):
                              if Mask(64, 64, order):
                          else:
                              if address(permit) != caller:
                                  revert with RFQPrivateOrder()
              else:
                  if not Mask(1, 253, cd[260]):
                      static call target.isValidSignature(bytes32 , bytes ) with:
                              gas gas_remaining wei
                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                      if not ext_call.success:
                          revert with RFQBadSignature()
                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                          revert with RFQBadSignature()
                      if not address(cd[292]):
                          revert with RFQZeroTargetIsForbidden()
                      if not address(permit):
                          if not Mask(64, 64, order):
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[260]):
                          else:
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                      else:
                          if address(permit) != caller:
                              revert with RFQPrivateOrder()
                          if Mask(64, 64, order):
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                  else:
                      if ('cd', 228).length != 65:
                          revert with RFQBadSignature()
                      static call target.isValidSignature(bytes32 , bytes ) with:
                              gas gas_remaining wei
                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                      if not ext_call.success:
                          revert with RFQBadSignature()
                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                          revert with RFQBadSignature()
                      if not address(cd[292]):
                          revert with RFQZeroTargetIsForbidden()
                      if not address(permit):
                          if Mask(64, 64, order):
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                      else:
                          if address(permit) != caller:
                              revert with RFQPrivateOrder()
                          if not Mask(64, 64, order):
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          else:
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
          else:
              if not Mask(1, 254, cd[260]):
                  if not target:
                      revert with RFQBadSignature()
                  if ('cd', 228).length == 64:
                      if ('cd', 228).length == 65:
                          if call.data[cd[228] + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if not target:
                                  if not address(cd[292]):
                                      revert with RFQZeroTargetIsForbidden()
                              else:
                                  static call target.isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                                  if not ext_call.success:
                                      revert with RFQBadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with RFQBadSignature()
                          else:
                              signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) - 256, call.data[cd[228] + 36 len 64]) # precompiled
                              if address(signer) == target:
                                  if not address(cd[292]):
                                      revert with RFQZeroTargetIsForbidden()
                              else:
                                  static call target.isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                                  if not ext_call.success:
                                      revert with RFQBadSignature()
                      else:
                          if ('cd', 228).length != 64:
                              if not target:
                                  if not address(cd[292]):
                                      revert with RFQZeroTargetIsForbidden()
                              else:
                                  static call target.isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                                  if not ext_call.success:
                                      revert with RFQBadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with RFQBadSignature()
                          else:
                              if uint255(('cd', 228)[1]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                                  if not target:
                                      if not address(cd[292]):
                                          revert with RFQZeroTargetIsForbidden()
                                  else:
                                      static call target.isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                                      if not ext_call.success:
                                          revert with RFQBadSignature()
                              else:
                                  signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), (bool(('cd', 228)[1]) >> 255) + 27, call.data[cd[228] + 36], uint255(('cd', 228)[1])) # precompiled
                                  if address(signer) != target:
                                      static call target.isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                  else:
                      if ('cd', 228).length == 65:
                          if call.data[cd[228] + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if not target:
                                  if not address(cd[292]):
                                      revert with RFQZeroTargetIsForbidden()
                              else:
                                  static call target.isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                                  if not ext_call.success:
                                      revert with RFQBadSignature()
                          else:
                              signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) - 256, call.data[cd[228] + 36 len 64]) # precompiled
                              if address(signer) != target:
                                  static call target.isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                      else:
                          static call target.isValidSignature(bytes32 , bytes ) with:
                                  gas gas_remaining wei
                                 args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                          if not ext_call.success:
                              revert with RFQBadSignature()
                          if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                              revert with RFQBadSignature()
                          if not address(cd[292]):
                              revert with RFQZeroTargetIsForbidden()
                          if not address(permit):
                              if Mask(64, 64, order):
                          else:
                              if address(permit) != caller:
                                  revert with RFQPrivateOrder()
              else:
                  if not Mask(1, 253, cd[260]):
                      static call target.isValidSignature(bytes32 , bytes ) with:
                              gas gas_remaining wei
                             args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                      if not ext_call.success:
                          revert with RFQBadSignature()
                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                          revert with RFQBadSignature()
                      if not address(cd[292]):
                          revert with RFQZeroTargetIsForbidden()
                      if not address(permit):
                          if not Mask(64, 64, order):
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[260]):
                          else:
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                      else:
                          if address(permit) != caller:
                              revert with RFQPrivateOrder()
                          if Mask(64, 64, order):
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                  else:
                      if ('cd', 228).length != 65:
                          revert with RFQBadSignature()
                      static call target.isValidSignature(bytes32 , bytes ) with:
                              gas gas_remaining wei
                             args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, permit, cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                      if not ext_call.success:
                          revert with RFQBadSignature()
                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                          revert with RFQBadSignature()
                      if not address(cd[292]):
                          revert with RFQZeroTargetIsForbidden()
                      if not address(permit):
                          if Mask(64, 64, order):
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                      else:
                          if address(permit) != caller:
                              revert with RFQPrivateOrder()
                          if not Mask(64, 64, order):
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          else:
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def fillOrder(tuple order, bytes signature, bytes interaction, uint256 makingAmount, uint256 takingAmount, uint256 skipPermitAndThresholdAmount) payable: 
  require calldata.size - 4 >=′ 192
  require order <= LOCK8605463013()
  require calldata.size + -order - 4 >=′ 320
  require signature <= LOCK8605463013()
  require signature + 35 <′ calldata.size
  require signature.length <= LOCK8605463013()
  require signature + signature.length + 36 <= calldata.size
  require interaction <= LOCK8605463013()
  require interaction + 35 <′ calldata.size
  require interaction.length <= LOCK8605463013()
  require interaction + interaction.length + 36 <= calldata.size
  if not caller:
      revert with ZeroTargetIsForbidden()
  require cd[(order + 292)] <′ calldata.size + -order - 35
  require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
  require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
  if this.address != 0x1111111254eeb25477b68fb85ed929f73a960582:
      if not remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))] - 1:
          revert with RemainingAmountIsZero()
      require cd[(order + 164)] == address(cd[(order + 164)])
      if not address(cd[(order + 164)]):
          if not remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))]:
              require cd[(order + 100)] == address(cd[(order + 100)])
              if not address(cd[(order + 100)]):
                  revert with BadSignature()
              if signature.length != 64:
                  if signature.length != 65:
                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                              gas gas_remaining wei
                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                      if not ext_call.success:
                          revert with BadSignature()
                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                          revert with BadSignature()
                      require cd[(order + 292)] <′ calldata.size + -order - 35
                      require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                      require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                      require 0 <= cd[(order + cd[(order + 292)] + 4)]
                      if Mask(1, 255, skipPermitAndThresholdAmount):
                  else:
                      if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                          if address(cd[(order + 100)]):
                              static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              if not ext_call.success:
                                  revert with BadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with BadSignature()
                      else:
                          signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                          if address(signer) != address(cd[(order + 100)]):
                              static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              if not ext_call.success:
                                  revert with BadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with BadSignature()
                      require cd[(order + 292)] <′ calldata.size + -order - 35
                      require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                      require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                      require 0 <= cd[(order + cd[(order + 292)] + 4)]
              else:
                  if signature.length == 65:
                      if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                          if address(cd[(order + 100)]):
                              static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              if not ext_call.success:
                                  revert with BadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with BadSignature()
                      else:
                          signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                          if address(signer) != address(cd[(order + 100)]):
                              static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              if not ext_call.success:
                                  revert with BadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with BadSignature()
                  else:
                      if signature.length != 64:
                          if address(cd[(order + 100)]):
                              static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              if not ext_call.success:
                                  revert with BadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with BadSignature()
                      else:
                          if uint255(cd[(signature + 68)]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if address(cd[(order + 100)]):
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                          else:
                              signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), (bool(cd[(signature + 68)]) >> 255) + 27, call.data[signature + 36], uint255(cd[(signature + 68)])) # precompiled
                              if address(signer) != address(cd[(order + 100)]):
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                  require cd[(order + 292)] <′ calldata.size + -order - 35
                  require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                  require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                  require 0 <= cd[(order + cd[(order + 292)] + 4)]
          else:
              require cd[(order + 292)] <′ calldata.size + -order - 35
              require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
              require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
              require 0 <= cd[(order + cd[(order + 292)] + 4)]
              if not not takingAmount - not makingAmount:
                  revert with OnlyOneAmountShouldBeZero()
              require cd[(order + 292)] <′ calldata.size + -order - 35
              require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
              require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
              if -takingAmount:
                  require Mask(32, 32, cd[(order + 260)]) >> 32 <= Mask(32, 64, cd[(order + 260)]) >> 64
                  require Mask(32, 64, cd[(order + 260)]) >> 64 <= cd[(order + cd[(order + 292)] + 4)]
                  if not -(Mask(32, 64, cd[(order + 260)]) >> 64) + (Mask(32, 32, cd[(order + 260)]) >> 32):
                      if cd[(order + 196)] != cd[(order + 196)] * takingAmount / takingAmount and takingAmount:
                          revert with 0, 17
                  else:
                      if -(Mask(32, 64, cd[(order + 260)]) >> 64) + (Mask(32, 32, cd[(order + 260)]) >> 32) + 1:
                          if (Mask(32, 64, cd[(order + 260)]) >> 64) - (Mask(32, 32, cd[(order + 260)]) >> 32) < 20:
                              revert with IncorrectDataLength()
                      else:
                          if (Mask(32, 64, cd[(order + 260)]) >> 64) - (Mask(32, 32, cd[(order + 260)]) >> 32) == 1:
              else:
                  require Mask(32, 64, cd[(order + 260)]) >> 64 <= Mask(32, 96, cd[(order + 260)]) >> 96
                  require Mask(32, 96, cd[(order + 260)]) >> 96 <= cd[(order + cd[(order + 292)] + 4)]
                  if makingAmount > remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))] - 1:
                      if -(Mask(32, 96, cd[(order + 260)]) >> 96) + (Mask(32, 64, cd[(order + 260)]) >> 64):
                          if not -(Mask(32, 96, cd[(order + 260)]) >> 96) + (Mask(32, 64, cd[(order + 260)]) >> 64) + 1:
                  else:
                      if not -(Mask(32, 96, cd[(order + 260)]) >> 96) + (Mask(32, 64, cd[(order + 260)]) >> 64):
                          if cd[(order + 228)] != cd[(order + 228)] * makingAmount / makingAmount and makingAmount:
                              revert with 0, 17
                      else:
                          if -(Mask(32, 96, cd[(order + 260)]) >> 96) + (Mask(32, 64, cd[(order + 260)]) >> 64) + 1:
                              if (Mask(32, 96, cd[(order + 260)]) >> 96) - (Mask(32, 64, cd[(order + 260)]) >> 64) < 20:
                                  revert with IncorrectDataLength()
                          else:
                              if (Mask(32, 96, cd[(order + 260)]) >> 96) - (Mask(32, 64, cd[(order + 260)]) >> 64) == 1:
      else:
          require cd[(order + 164)] == address(cd[(order + 164)])
          if address(cd[(order + 164)]) != caller:
              revert with PrivateOrder()
          if remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))]:
              require cd[(order + 292)] <′ calldata.size + -order - 35
              require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
              require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
              require 0 <= cd[(order + cd[(order + 292)] + 4)]
              if not not takingAmount - not makingAmount:
                  revert with OnlyOneAmountShouldBeZero()
              require cd[(order + 292)] <′ calldata.size + -order - 35
              require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
              require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
              if -takingAmount:
                  require Mask(32, 32, cd[(order + 260)]) >> 32 <= Mask(32, 64, cd[(order + 260)]) >> 64
                  require Mask(32, 64, cd[(order + 260)]) >> 64 <= cd[(order + cd[(order + 292)] + 4)]
              else:
                  require Mask(32, 64, cd[(order + 260)]) >> 64 <= Mask(32, 96, cd[(order + 260)]) >> 96
                  require Mask(32, 96, cd[(order + 260)]) >> 96 <= cd[(order + cd[(order + 292)] + 4)]
          else:
              require cd[(order + 100)] == address(cd[(order + 100)])
              if not address(cd[(order + 100)]):
                  revert with BadSignature()
              if signature.length != 64:
                  if signature.length != 65:
                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                              gas gas_remaining wei
                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                      if not ext_call.success:
                          revert with BadSignature()
                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                          revert with BadSignature()
                      require cd[(order + 292)] <′ calldata.size + -order - 35
                      require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                      require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                      require 0 <= cd[(order + cd[(order + 292)] + 4)]
                  else:
                      if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                          if address(cd[(order + 100)]):
                              static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              if not ext_call.success:
                                  revert with BadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with BadSignature()
                          require cd[(order + 292)] <′ calldata.size + -order - 35
                          require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                          require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                      else:
                          signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                          if address(signer) == address(cd[(order + 100)]):
                              require cd[(order + 292)] <′ calldata.size + -order - 35
                              require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                              require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                          else:
                              static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              if not ext_call.success:
                                  revert with BadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with BadSignature()
                              require cd[(order + 292)] <′ calldata.size + -order - 35
                              require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
              else:
                  if signature.length == 65:
                      if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                          if not address(cd[(order + 100)]):
                              require cd[(order + 292)] <′ calldata.size + -order - 35
                              require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                              require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                              require 0 <= cd[(order + cd[(order + 292)] + 4)]
                          else:
                              static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              if not ext_call.success:
                                  revert with BadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with BadSignature()
                              require cd[(order + 292)] <′ calldata.size + -order - 35
                              require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                              require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                      else:
                          signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                          if address(signer) != address(cd[(order + 100)]):
                              static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              if not ext_call.success:
                                  revert with BadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with BadSignature()
                          require cd[(order + 292)] <′ calldata.size + -order - 35
                          require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                          require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                  else:
                      if signature.length != 64:
                          if not address(cd[(order + 100)]):
                              require cd[(order + 292)] <′ calldata.size + -order - 35
                              require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                              require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                              require 0 <= cd[(order + cd[(order + 292)] + 4)]
                          else:
                              static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              if not ext_call.success:
                                  revert with BadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with BadSignature()
                              require cd[(order + 292)] <′ calldata.size + -order - 35
                              require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                              require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                      else:
                          if uint255(cd[(signature + 68)]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if address(cd[(order + 100)]):
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                              require cd[(order + 292)] <′ calldata.size + -order - 35
                              require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                              require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                          else:
                              signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), (bool(cd[(signature + 68)]) >> 255) + 27, call.data[signature + 36], uint255(cd[(signature + 68)])) # precompiled
                              if address(signer) == address(cd[(order + 100)]):
                                  require cd[(order + 292)] <′ calldata.size + -order - 35
                                  require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                                  require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                              else:
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                                  require cd[(order + 292)] <′ calldata.size + -order - 35
                                  require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
  else:
      if 1 != chainid:
          if not remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))] - 1:
              revert with RemainingAmountIsZero()
          require cd[(order + 164)] == address(cd[(order + 164)])
          if not address(cd[(order + 164)]):
              if remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))]:
                  require cd[(order + 292)] <′ calldata.size + -order - 35
                  require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                  require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                  require 0 <= cd[(order + cd[(order + 292)] + 4)]
                  if not not takingAmount - not makingAmount:
                      revert with OnlyOneAmountShouldBeZero()
                  require cd[(order + 292)] <′ calldata.size + -order - 35
                  require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                  require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                  if -takingAmount:
                      require Mask(32, 32, cd[(order + 260)]) >> 32 <= Mask(32, 64, cd[(order + 260)]) >> 64
                      require Mask(32, 64, cd[(order + 260)]) >> 64 <= cd[(order + cd[(order + 292)] + 4)]
                      if not -(Mask(32, 64, cd[(order + 260)]) >> 64) + (Mask(32, 32, cd[(order + 260)]) >> 32):
                          if cd[(order + 196)] != cd[(order + 196)] * takingAmount / takingAmount and takingAmount:
                              revert with 0, 17
                      else:
                          if -(Mask(32, 64, cd[(order + 260)]) >> 64) + (Mask(32, 32, cd[(order + 260)]) >> 32) + 1:
                              if (Mask(32, 64, cd[(order + 260)]) >> 64) - (Mask(32, 32, cd[(order + 260)]) >> 32) < 20:
                                  revert with IncorrectDataLength()
                          else:
                              if (Mask(32, 64, cd[(order + 260)]) >> 64) - (Mask(32, 32, cd[(order + 260)]) >> 32) == 1:
                  else:
                      require Mask(32, 64, cd[(order + 260)]) >> 64 <= Mask(32, 96, cd[(order + 260)]) >> 96
                      require Mask(32, 96, cd[(order + 260)]) >> 96 <= cd[(order + cd[(order + 292)] + 4)]
                      if makingAmount > remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))] - 1:
                          if not -(Mask(32, 96, cd[(order + 260)]) >> 96) + (Mask(32, 64, cd[(order + 260)]) >> 64):
                      else:
                          if -(Mask(32, 96, cd[(order + 260)]) >> 96) + (Mask(32, 64, cd[(order + 260)]) >> 64):
                              if not -(Mask(32, 96, cd[(order + 260)]) >> 96) + (Mask(32, 64, cd[(order + 260)]) >> 64) + 1:
              else:
                  require cd[(order + 100)] == address(cd[(order + 100)])
                  if not address(cd[(order + 100)]):
                      revert with BadSignature()
                  if signature.length != 64:
                      if signature.length != 65:
                          static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                  gas gas_remaining wei
                                 args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                          if not ext_call.success:
                              revert with BadSignature()
                          if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                              revert with BadSignature()
                      else:
                          if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if address(cd[(order + 100)]):
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                          else:
                              signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                              if address(signer) != address(cd[(order + 100)]):
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                  else:
                      if signature.length == 65:
                          if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if address(cd[(order + 100)]):
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                          else:
                              signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                              if address(signer) != address(cd[(order + 100)]):
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                      else:
                          if signature.length != 64:
                              if address(cd[(order + 100)]):
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                          else:
                              if uint255(cd[(signature + 68)]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                                  if address(cd[(order + 100)]):
                                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                      if not ext_call.success:
                                          revert with BadSignature()
                                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                          revert with BadSignature()
                              else:
                                  signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), (bool(cd[(signature + 68)]) >> 255) + 27, call.data[signature + 36], uint255(cd[(signature + 68)])) # precompiled
                                  if address(signer) != address(cd[(order + 100)]):
                                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                      if not ext_call.success:
                                          revert with BadSignature()
                                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                          revert with BadSignature()
                  require cd[(order + 292)] <′ calldata.size + -order - 35
                  require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                  require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                  require 0 <= cd[(order + cd[(order + 292)] + 4)]
          else:
              require cd[(order + 164)] == address(cd[(order + 164)])
              if address(cd[(order + 164)]) != caller:
                  revert with PrivateOrder()
              if remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))]:
                  require cd[(order + 292)] <′ calldata.size + -order - 35
                  require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                  require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                  require 0 <= cd[(order + cd[(order + 292)] + 4)]
                  if not not takingAmount - not makingAmount:
                      revert with OnlyOneAmountShouldBeZero()
                  require cd[(order + 292)] <′ calldata.size + -order - 35
                  require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                  require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                  if -takingAmount:
                      require Mask(32, 32, cd[(order + 260)]) >> 32 <= Mask(32, 64, cd[(order + 260)]) >> 64
                      require Mask(32, 64, cd[(order + 260)]) >> 64 <= cd[(order + cd[(order + 292)] + 4)]
                  else:
                      require Mask(32, 64, cd[(order + 260)]) >> 64 <= Mask(32, 96, cd[(order + 260)]) >> 96
                      require Mask(32, 96, cd[(order + 260)]) >> 96 <= cd[(order + cd[(order + 292)] + 4)]
              else:
                  require cd[(order + 100)] == address(cd[(order + 100)])
                  if not address(cd[(order + 100)]):
                      revert with BadSignature()
                  if signature.length != 64:
                      if signature.length != 65:
                          static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                  gas gas_remaining wei
                                 args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                          if not ext_call.success:
                              revert with BadSignature()
                          if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                              revert with BadSignature()
                          require cd[(order + 292)] <′ calldata.size + -order - 35
                          require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                          require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                          require 0 <= cd[(order + cd[(order + 292)] + 4)]
                      else:
                          if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if not address(cd[(order + 100)]):
                                  require cd[(order + 292)] <′ calldata.size + -order - 35
                                  require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                                  require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                              else:
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                                  require cd[(order + 292)] <′ calldata.size + -order - 35
                                  require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                          else:
                              signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                              if address(signer) == address(cd[(order + 100)]):
                                  require cd[(order + 292)] <′ calldata.size + -order - 35
                                  require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                                  require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                              else:
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                                  require cd[(order + 292)] <′ calldata.size + -order - 35
                  else:
                      if signature.length == 65:
                          if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if address(cd[(order + 100)]):
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                              require cd[(order + 292)] <′ calldata.size + -order - 35
                              require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                              require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                          else:
                              signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                              if address(signer) == address(cd[(order + 100)]):
                                  require cd[(order + 292)] <′ calldata.size + -order - 35
                                  require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                                  require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                              else:
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                                  require cd[(order + 292)] <′ calldata.size + -order - 35
                                  require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                      else:
                          if signature.length != 64:
                              if address(cd[(order + 100)]):
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                              require cd[(order + 292)] <′ calldata.size + -order - 35
                              require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                              require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                          else:
                              if uint255(cd[(signature + 68)]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                                  if not address(cd[(order + 100)]):
                                      require cd[(order + 292)] <′ calldata.size + -order - 35
                                      require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                                      require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                                  else:
                                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                      if not ext_call.success:
                                          revert with BadSignature()
                                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                          revert with BadSignature()
                                      require cd[(order + 292)] <′ calldata.size + -order - 35
                                      require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                              else:
                                  signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), (bool(cd[(signature + 68)]) >> 255) + 27, call.data[signature + 36], uint255(cd[(signature + 68)])) # precompiled
                                  if address(signer) == address(cd[(order + 100)]):
                                      require cd[(order + 292)] <′ calldata.size + -order - 35
                                      require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                                      require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                                  else:
                                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                      if not ext_call.success:
                                          revert with BadSignature()
                                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                          revert with BadSignature()
                                      require cd[(order + 292)] <′ calldata.size + -order - 35
      else:
          if not remainingRaw[6401][0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))] - 1:
              revert with RemainingAmountIsZero()
          require cd[(order + 164)] == address(cd[(order + 164)])
          if not address(cd[(order + 164)]):
              if remainingRaw[6401][0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))]:
                  require cd[(order + 292)] <′ calldata.size + -order - 35
                  require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                  require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                  require 0 <= cd[(order + cd[(order + 292)] + 4)]
                  if not not takingAmount - not makingAmount:
                      revert with OnlyOneAmountShouldBeZero()
                  require cd[(order + 292)] <′ calldata.size + -order - 35
                  require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                  require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                  if -takingAmount:
                      require Mask(32, 32, cd[(order + 260)]) >> 32 <= Mask(32, 64, cd[(order + 260)]) >> 64
                      require Mask(32, 64, cd[(order + 260)]) >> 64 <= cd[(order + cd[(order + 292)] + 4)]
                      if not -(Mask(32, 64, cd[(order + 260)]) >> 64) + (Mask(32, 32, cd[(order + 260)]) >> 32):
                          if cd[(order + 196)] != cd[(order + 196)] * takingAmount / takingAmount and takingAmount:
                              revert with 0, 17
                      else:
                          if -(Mask(32, 64, cd[(order + 260)]) >> 64) + (Mask(32, 32, cd[(order + 260)]) >> 32) + 1:
                              if (Mask(32, 64, cd[(order + 260)]) >> 64) - (Mask(32, 32, cd[(order + 260)]) >> 32) < 20:
                                  revert with IncorrectDataLength()
                          else:
                              if (Mask(32, 64, cd[(order + 260)]) >> 64) - (Mask(32, 32, cd[(order + 260)]) >> 32) == 1:
                  else:
                      require Mask(32, 64, cd[(order + 260)]) >> 64 <= Mask(32, 96, cd[(order + 260)]) >> 96
                      require Mask(32, 96, cd[(order + 260)]) >> 96 <= cd[(order + cd[(order + 292)] + 4)]
                      if makingAmount > remainingRaw[6401][0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))] - 1:
                          if not -(Mask(32, 96, cd[(order + 260)]) >> 96) + (Mask(32, 64, cd[(order + 260)]) >> 64):
                      else:
                          if -(Mask(32, 96, cd[(order + 260)]) >> 96) + (Mask(32, 64, cd[(order + 260)]) >> 64):
                              if not -(Mask(32, 96, cd[(order + 260)]) >> 96) + (Mask(32, 64, cd[(order + 260)]) >> 64) + 1:
              else:
                  require cd[(order + 100)] == address(cd[(order + 100)])
                  if not address(cd[(order + 100)]):
                      revert with BadSignature()
                  if signature.length != 64:
                      if signature.length != 65:
                          static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                  gas gas_remaining wei
                                 args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                          if not ext_call.success:
                              revert with BadSignature()
                          if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                              revert with BadSignature()
                      else:
                          if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if address(cd[(order + 100)]):
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                          else:
                              signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                              if address(signer) != address(cd[(order + 100)]):
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                  else:
                      if signature.length == 65:
                          if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if address(cd[(order + 100)]):
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                          else:
                              signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                              if address(signer) != address(cd[(order + 100)]):
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                      else:
                          if signature.length != 64:
                              if address(cd[(order + 100)]):
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                          else:
                              if uint255(cd[(signature + 68)]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                                  if address(cd[(order + 100)]):
                                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                      if not ext_call.success:
                                          revert with BadSignature()
                                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                          revert with BadSignature()
                              else:
                                  signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), (bool(cd[(signature + 68)]) >> 255) + 27, call.data[signature + 36], uint255(cd[(signature + 68)])) # precompiled
                                  if address(signer) != address(cd[(order + 100)]):
                                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                      if not ext_call.success:
                                          revert with BadSignature()
                                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                          revert with BadSignature()
                  require cd[(order + 292)] <′ calldata.size + -order - 35
                  require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                  require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                  require 0 <= cd[(order + cd[(order + 292)] + 4)]
          else:
              require cd[(order + 164)] == address(cd[(order + 164)])
              if address(cd[(order + 164)]) != caller:
                  revert with PrivateOrder()
              if remainingRaw[6401][0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))]:
                  require cd[(order + 292)] <′ calldata.size + -order - 35
                  require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                  require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                  require 0 <= cd[(order + cd[(order + 292)] + 4)]
                  if not not takingAmount - not makingAmount:
                      revert with OnlyOneAmountShouldBeZero()
                  require cd[(order + 292)] <′ calldata.size + -order - 35
                  require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                  require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                  if -takingAmount:
                      require Mask(32, 32, cd[(order + 260)]) >> 32 <= Mask(32, 64, cd[(order + 260)]) >> 64
                      require Mask(32, 64, cd[(order + 260)]) >> 64 <= cd[(order + cd[(order + 292)] + 4)]
                  else:
                      require Mask(32, 64, cd[(order + 260)]) >> 64 <= Mask(32, 96, cd[(order + 260)]) >> 96
                      require Mask(32, 96, cd[(order + 260)]) >> 96 <= cd[(order + cd[(order + 292)] + 4)]
              else:
                  require cd[(order + 100)] == address(cd[(order + 100)])
                  if not address(cd[(order + 100)]):
                      revert with BadSignature()
                  if signature.length != 64:
                      if signature.length != 65:
                          static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                  gas gas_remaining wei
                                 args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                          if not ext_call.success:
                              revert with BadSignature()
                          if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                              revert with BadSignature()
                          require cd[(order + 292)] <′ calldata.size + -order - 35
                          require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                          require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                          require 0 <= cd[(order + cd[(order + 292)] + 4)]
                      else:
                          if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if not address(cd[(order + 100)]):
                                  require cd[(order + 292)] <′ calldata.size + -order - 35
                                  require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                                  require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                              else:
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                                  require cd[(order + 292)] <′ calldata.size + -order - 35
                                  require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                          else:
                              signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                              if address(signer) == address(cd[(order + 100)]):
                                  require cd[(order + 292)] <′ calldata.size + -order - 35
                                  require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                                  require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                              else:
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                                  require cd[(order + 292)] <′ calldata.size + -order - 35
                  else:
                      if signature.length == 65:
                          if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if address(cd[(order + 100)]):
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                              require cd[(order + 292)] <′ calldata.size + -order - 35
                              require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                              require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                          else:
                              signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                              if address(signer) == address(cd[(order + 100)]):
                                  require cd[(order + 292)] <′ calldata.size + -order - 35
                                  require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                                  require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                              else:
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                                  require cd[(order + 292)] <′ calldata.size + -order - 35
                                  require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                      else:
                          if signature.length != 64:
                              if address(cd[(order + 100)]):
                                  static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                              require cd[(order + 292)] <′ calldata.size + -order - 35
                              require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                              require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                          else:
                              if uint255(cd[(signature + 68)]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                                  if not address(cd[(order + 100)]):
                                      require cd[(order + 292)] <′ calldata.size + -order - 35
                                      require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                                      require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                                  else:
                                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                      if not ext_call.success:
                                          revert with BadSignature()
                                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                          revert with BadSignature()
                                      require cd[(order + 292)] <′ calldata.size + -order - 35
                                      require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                              else:
                                  signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), (bool(cd[(signature + 68)]) >> 255) + 27, call.data[signature + 36], uint255(cd[(signature + 68)])) # precompiled
                                  if address(signer) == address(cd[(order + 100)]):
                                      require cd[(order + 292)] <′ calldata.size + -order - 35
                                      require cd[(order + cd[(order + 292)] + 4)] <= LOCK8605463013()
                                      require order + cd[(order + 292)] + 36 <=′ calldata.size - cd[(order + cd[(order + 292)] + 4)]
                                  else:
                                      static call cd[(order + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order + 4 len 288], sha3(call.data[order + cd[(order + 292)] + 36 len cd[(order + cd[(order + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                      if not ext_call.success:
                                          revert with BadSignature()
                                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                          revert with BadSignature()
                                      require cd[(order + 292)] <′ calldata.size + -order - 35
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def fillOrderTo(tuple order_, bytes signature, bytes interaction, uint256 makingAmount, uint256 takingAmount, uint256 skipPermitAndThresholdAmount, address target) payable: 
  require calldata.size - 4 >=′ 224
  require order_ <= LOCK8605463013()
  require calldata.size + -order_ - 4 >=′ 320
  require signature <= LOCK8605463013()
  require signature + 35 <′ calldata.size
  require signature.length <= LOCK8605463013()
  require signature + signature.length + 36 <= calldata.size
  require interaction <= LOCK8605463013()
  require interaction + 35 <′ calldata.size
  require interaction.length <= LOCK8605463013()
  require interaction + interaction.length + 36 <= calldata.size
  require target == target
  if not target:
      revert with ZeroTargetIsForbidden()
  require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
  require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
  require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
  if this.address != 0x1111111254eeb25477b68fb85ed929f73a960582:
      if not remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))] - 1:
          revert with RemainingAmountIsZero()
      require cd[(order_ + 164)] == address(cd[(order_ + 164)])
      if not address(cd[(order_ + 164)]):
          if not remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))]:
              require cd[(order_ + 100)] == address(cd[(order_ + 100)])
              if not address(cd[(order_ + 100)]):
                  revert with BadSignature()
              if signature.length != 64:
                  if signature.length != 65:
                      static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                              gas gas_remaining wei
                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                      if not ext_call.success:
                          revert with BadSignature()
                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                          revert with BadSignature()
                      require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                      require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                      require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                      require 0 <= cd[(order_ + cd[(order_ + 292)] + 4)]
                      if Mask(1, 255, skipPermitAndThresholdAmount):
                  else:
                      if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                          if address(cd[(order_ + 100)]):
                              static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              if not ext_call.success:
                                  revert with BadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with BadSignature()
                      else:
                          signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                          if address(signer) != address(cd[(order_ + 100)]):
                              static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              if not ext_call.success:
                                  revert with BadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with BadSignature()
                      require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                      require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                      require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                      require 0 <= cd[(order_ + cd[(order_ + 292)] + 4)]
              else:
                  if signature.length == 65:
                      if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                          if address(cd[(order_ + 100)]):
                              static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              if not ext_call.success:
                                  revert with BadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with BadSignature()
                      else:
                          signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                          if address(signer) != address(cd[(order_ + 100)]):
                              static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              if not ext_call.success:
                                  revert with BadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with BadSignature()
                  else:
                      if signature.length != 64:
                          if address(cd[(order_ + 100)]):
                              static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              if not ext_call.success:
                                  revert with BadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with BadSignature()
                      else:
                          if uint255(cd[(signature + 68)]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if address(cd[(order_ + 100)]):
                                  static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                          else:
                              signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), (bool(cd[(signature + 68)]) >> 255) + 27, call.data[signature + 36], uint255(cd[(signature + 68)])) # precompiled
                              if address(signer) != address(cd[(order_ + 100)]):
                                  static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                  require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                  require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                  require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                  require 0 <= cd[(order_ + cd[(order_ + 292)] + 4)]
          else:
              require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
              require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
              require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
              require 0 <= cd[(order_ + cd[(order_ + 292)] + 4)]
              if not not takingAmount - not makingAmount:
                  revert with OnlyOneAmountShouldBeZero()
              require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
              require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
              require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
              if -takingAmount:
                  require Mask(32, 32, cd[(order_ + 260)]) >> 32 <= Mask(32, 64, cd[(order_ + 260)]) >> 64
                  require Mask(32, 64, cd[(order_ + 260)]) >> 64 <= cd[(order_ + cd[(order_ + 292)] + 4)]
                  if not -(Mask(32, 64, cd[(order_ + 260)]) >> 64) + (Mask(32, 32, cd[(order_ + 260)]) >> 32):
                      if cd[(order_ + 196)] != cd[(order_ + 196)] * takingAmount / takingAmount and takingAmount:
                          revert with 0, 17
                  else:
                      if -(Mask(32, 64, cd[(order_ + 260)]) >> 64) + (Mask(32, 32, cd[(order_ + 260)]) >> 32) + 1:
                          if (Mask(32, 64, cd[(order_ + 260)]) >> 64) - (Mask(32, 32, cd[(order_ + 260)]) >> 32) < 20:
                              revert with IncorrectDataLength()
                      else:
                          if (Mask(32, 64, cd[(order_ + 260)]) >> 64) - (Mask(32, 32, cd[(order_ + 260)]) >> 32) == 1:
              else:
                  require Mask(32, 64, cd[(order_ + 260)]) >> 64 <= Mask(32, 96, cd[(order_ + 260)]) >> 96
                  require Mask(32, 96, cd[(order_ + 260)]) >> 96 <= cd[(order_ + cd[(order_ + 292)] + 4)]
                  if makingAmount > remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))] - 1:
                      if -(Mask(32, 96, cd[(order_ + 260)]) >> 96) + (Mask(32, 64, cd[(order_ + 260)]) >> 64):
                          if not -(Mask(32, 96, cd[(order_ + 260)]) >> 96) + (Mask(32, 64, cd[(order_ + 260)]) >> 64) + 1:
                  else:
                      if not -(Mask(32, 96, cd[(order_ + 260)]) >> 96) + (Mask(32, 64, cd[(order_ + 260)]) >> 64):
                          if cd[(order_ + 228)] != cd[(order_ + 228)] * makingAmount / makingAmount and makingAmount:
                              revert with 0, 17
                      else:
                          if -(Mask(32, 96, cd[(order_ + 260)]) >> 96) + (Mask(32, 64, cd[(order_ + 260)]) >> 64) + 1:
                              if (Mask(32, 96, cd[(order_ + 260)]) >> 96) - (Mask(32, 64, cd[(order_ + 260)]) >> 64) < 20:
                                  revert with IncorrectDataLength()
                          else:
                              if (Mask(32, 96, cd[(order_ + 260)]) >> 96) - (Mask(32, 64, cd[(order_ + 260)]) >> 64) == 1:
      else:
          require cd[(order_ + 164)] == address(cd[(order_ + 164)])
          if address(cd[(order_ + 164)]) != caller:
              revert with PrivateOrder()
          if remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))]:
              require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
              require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
              require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
              require 0 <= cd[(order_ + cd[(order_ + 292)] + 4)]
              if not not takingAmount - not makingAmount:
                  revert with OnlyOneAmountShouldBeZero()
              require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
              require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
              require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
              if -takingAmount:
                  require Mask(32, 32, cd[(order_ + 260)]) >> 32 <= Mask(32, 64, cd[(order_ + 260)]) >> 64
                  require Mask(32, 64, cd[(order_ + 260)]) >> 64 <= cd[(order_ + cd[(order_ + 292)] + 4)]
              else:
                  require Mask(32, 64, cd[(order_ + 260)]) >> 64 <= Mask(32, 96, cd[(order_ + 260)]) >> 96
                  require Mask(32, 96, cd[(order_ + 260)]) >> 96 <= cd[(order_ + cd[(order_ + 292)] + 4)]
          else:
              require cd[(order_ + 100)] == address(cd[(order_ + 100)])
              if not address(cd[(order_ + 100)]):
                  revert with BadSignature()
              if signature.length != 64:
                  if signature.length != 65:
                      static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                              gas gas_remaining wei
                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                      if not ext_call.success:
                          revert with BadSignature()
                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                          revert with BadSignature()
                      require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                      require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                      require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                      require 0 <= cd[(order_ + cd[(order_ + 292)] + 4)]
                  else:
                      if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                          if address(cd[(order_ + 100)]):
                              static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              if not ext_call.success:
                                  revert with BadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with BadSignature()
                          require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                          require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                          require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                      else:
                          signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                          if address(signer) == address(cd[(order_ + 100)]):
                              require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                              require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                              require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                          else:
                              static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              if not ext_call.success:
                                  revert with BadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with BadSignature()
                              require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                              require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
              else:
                  if signature.length == 65:
                      if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                          if not address(cd[(order_ + 100)]):
                              require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                              require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                              require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                              require 0 <= cd[(order_ + cd[(order_ + 292)] + 4)]
                          else:
                              static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              if not ext_call.success:
                                  revert with BadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with BadSignature()
                              require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                              require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                              require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                      else:
                          signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                          if address(signer) != address(cd[(order_ + 100)]):
                              static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              if not ext_call.success:
                                  revert with BadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with BadSignature()
                          require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                          require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                          require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                  else:
                      if signature.length != 64:
                          if not address(cd[(order_ + 100)]):
                              require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                              require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                              require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                              require 0 <= cd[(order_ + cd[(order_ + 292)] + 4)]
                          else:
                              static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                              if not ext_call.success:
                                  revert with BadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with BadSignature()
                              require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                              require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                              require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                      else:
                          if uint255(cd[(signature + 68)]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if address(cd[(order_ + 100)]):
                                  static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                              require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                              require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                              require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                          else:
                              signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), (bool(cd[(signature + 68)]) >> 255) + 27, call.data[signature + 36], uint255(cd[(signature + 68)])) # precompiled
                              if address(signer) == address(cd[(order_ + 100)]):
                                  require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                                  require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                                  require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                              else:
                                  static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                                  require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                                  require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
  else:
      if 1 != chainid:
          if not remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))] - 1:
              revert with RemainingAmountIsZero()
          require cd[(order_ + 164)] == address(cd[(order_ + 164)])
          if not address(cd[(order_ + 164)]):
              if remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))]:
                  require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                  require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                  require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                  require 0 <= cd[(order_ + cd[(order_ + 292)] + 4)]
                  if not not takingAmount - not makingAmount:
                      revert with OnlyOneAmountShouldBeZero()
                  require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                  require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                  require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                  if -takingAmount:
                      require Mask(32, 32, cd[(order_ + 260)]) >> 32 <= Mask(32, 64, cd[(order_ + 260)]) >> 64
                      require Mask(32, 64, cd[(order_ + 260)]) >> 64 <= cd[(order_ + cd[(order_ + 292)] + 4)]
                      if not -(Mask(32, 64, cd[(order_ + 260)]) >> 64) + (Mask(32, 32, cd[(order_ + 260)]) >> 32):
                          if cd[(order_ + 196)] != cd[(order_ + 196)] * takingAmount / takingAmount and takingAmount:
                              revert with 0, 17
                      else:
                          if -(Mask(32, 64, cd[(order_ + 260)]) >> 64) + (Mask(32, 32, cd[(order_ + 260)]) >> 32) + 1:
                              if (Mask(32, 64, cd[(order_ + 260)]) >> 64) - (Mask(32, 32, cd[(order_ + 260)]) >> 32) < 20:
                                  revert with IncorrectDataLength()
                          else:
                              if (Mask(32, 64, cd[(order_ + 260)]) >> 64) - (Mask(32, 32, cd[(order_ + 260)]) >> 32) == 1:
                  else:
                      require Mask(32, 64, cd[(order_ + 260)]) >> 64 <= Mask(32, 96, cd[(order_ + 260)]) >> 96
                      require Mask(32, 96, cd[(order_ + 260)]) >> 96 <= cd[(order_ + cd[(order_ + 292)] + 4)]
                      if makingAmount > remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))] - 1:
                          if not -(Mask(32, 96, cd[(order_ + 260)]) >> 96) + (Mask(32, 64, cd[(order_ + 260)]) >> 64):
                      else:
                          if -(Mask(32, 96, cd[(order_ + 260)]) >> 96) + (Mask(32, 64, cd[(order_ + 260)]) >> 64):
                              if not -(Mask(32, 96, cd[(order_ + 260)]) >> 96) + (Mask(32, 64, cd[(order_ + 260)]) >> 64) + 1:
              else:
                  require cd[(order_ + 100)] == address(cd[(order_ + 100)])
                  if not address(cd[(order_ + 100)]):
                      revert with BadSignature()
                  if signature.length != 64:
                      if signature.length != 65:
                          static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                  gas gas_remaining wei
                                 args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                          if not ext_call.success:
                              revert with BadSignature()
                          if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                              revert with BadSignature()
                      else:
                          if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if address(cd[(order_ + 100)]):
                                  static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                          else:
                              signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                              if address(signer) != address(cd[(order_ + 100)]):
                                  static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                  else:
                      if signature.length == 65:
                          if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if address(cd[(order_ + 100)]):
                                  static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                          else:
                              signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                              if address(signer) != address(cd[(order_ + 100)]):
                                  static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                      else:
                          if signature.length != 64:
                              if address(cd[(order_ + 100)]):
                                  static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                          else:
                              if uint255(cd[(signature + 68)]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                                  if address(cd[(order_ + 100)]):
                                      static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                      if not ext_call.success:
                                          revert with BadSignature()
                                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                          revert with BadSignature()
                              else:
                                  signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), (bool(cd[(signature + 68)]) >> 255) + 27, call.data[signature + 36], uint255(cd[(signature + 68)])) # precompiled
                                  if address(signer) != address(cd[(order_ + 100)]):
                                      static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                      if not ext_call.success:
                                          revert with BadSignature()
                                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                          revert with BadSignature()
                  require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                  require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                  require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                  require 0 <= cd[(order_ + cd[(order_ + 292)] + 4)]
          else:
              require cd[(order_ + 164)] == address(cd[(order_ + 164)])
              if address(cd[(order_ + 164)]) != caller:
                  revert with PrivateOrder()
              if remainingRaw[6401][sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address)][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))]:
                  require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                  require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                  require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                  require 0 <= cd[(order_ + cd[(order_ + 292)] + 4)]
                  if not not takingAmount - not makingAmount:
                      revert with OnlyOneAmountShouldBeZero()
                  require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                  require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                  require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                  if -takingAmount:
                      require Mask(32, 32, cd[(order_ + 260)]) >> 32 <= Mask(32, 64, cd[(order_ + 260)]) >> 64
                      require Mask(32, 64, cd[(order_ + 260)]) >> 64 <= cd[(order_ + cd[(order_ + 292)] + 4)]
                  else:
                      require Mask(32, 64, cd[(order_ + 260)]) >> 64 <= Mask(32, 96, cd[(order_ + 260)]) >> 96
                      require Mask(32, 96, cd[(order_ + 260)]) >> 96 <= cd[(order_ + cd[(order_ + 292)] + 4)]
              else:
                  require cd[(order_ + 100)] == address(cd[(order_ + 100)])
                  if not address(cd[(order_ + 100)]):
                      revert with BadSignature()
                  if signature.length != 64:
                      if signature.length != 65:
                          static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                  gas gas_remaining wei
                                 args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                          if not ext_call.success:
                              revert with BadSignature()
                          if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                              revert with BadSignature()
                          require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                          require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                          require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                          require 0 <= cd[(order_ + cd[(order_ + 292)] + 4)]
                      else:
                          if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if not address(cd[(order_ + 100)]):
                                  require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                                  require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                                  require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                              else:
                                  static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                                  require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                                  require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                          else:
                              signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                              if address(signer) == address(cd[(order_ + 100)]):
                                  require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                                  require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                                  require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                              else:
                                  static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                                  require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                  else:
                      if signature.length == 65:
                          if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if address(cd[(order_ + 100)]):
                                  static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                              require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                              require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                              require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                          else:
                              signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                              if address(signer) == address(cd[(order_ + 100)]):
                                  require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                                  require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                                  require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                              else:
                                  static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                                  require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                                  require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                      else:
                          if signature.length != 64:
                              if address(cd[(order_ + 100)]):
                                  static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                              require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                              require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                              require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                          else:
                              if uint255(cd[(signature + 68)]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                                  if not address(cd[(order_ + 100)]):
                                      require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                                      require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                                      require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                                  else:
                                      static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                      if not ext_call.success:
                                          revert with BadSignature()
                                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                          revert with BadSignature()
                                      require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                                      require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                              else:
                                  signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), (bool(cd[(signature + 68)]) >> 255) + 27, call.data[signature + 36], uint255(cd[(signature + 68)])) # precompiled
                                  if address(signer) == address(cd[(order_ + 100)]):
                                      require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                                      require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                                      require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                                  else:
                                      static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                      if not ext_call.success:
                                          revert with BadSignature()
                                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                          revert with BadSignature()
                                      require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
      else:
          if not remainingRaw[6401][0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))] - 1:
              revert with RemainingAmountIsZero()
          require cd[(order_ + 164)] == address(cd[(order_ + 164)])
          if not address(cd[(order_ + 164)]):
              if remainingRaw[6401][0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))]:
                  require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                  require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                  require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                  require 0 <= cd[(order_ + cd[(order_ + 292)] + 4)]
                  if not not takingAmount - not makingAmount:
                      revert with OnlyOneAmountShouldBeZero()
                  require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                  require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                  require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                  if -takingAmount:
                      require Mask(32, 32, cd[(order_ + 260)]) >> 32 <= Mask(32, 64, cd[(order_ + 260)]) >> 64
                      require Mask(32, 64, cd[(order_ + 260)]) >> 64 <= cd[(order_ + cd[(order_ + 292)] + 4)]
                      if not -(Mask(32, 64, cd[(order_ + 260)]) >> 64) + (Mask(32, 32, cd[(order_ + 260)]) >> 32):
                          if cd[(order_ + 196)] != cd[(order_ + 196)] * takingAmount / takingAmount and takingAmount:
                              revert with 0, 17
                      else:
                          if -(Mask(32, 64, cd[(order_ + 260)]) >> 64) + (Mask(32, 32, cd[(order_ + 260)]) >> 32) + 1:
                              if (Mask(32, 64, cd[(order_ + 260)]) >> 64) - (Mask(32, 32, cd[(order_ + 260)]) >> 32) < 20:
                                  revert with IncorrectDataLength()
                          else:
                              if (Mask(32, 64, cd[(order_ + 260)]) >> 64) - (Mask(32, 32, cd[(order_ + 260)]) >> 32) == 1:
                  else:
                      require Mask(32, 64, cd[(order_ + 260)]) >> 64 <= Mask(32, 96, cd[(order_ + 260)]) >> 96
                      require Mask(32, 96, cd[(order_ + 260)]) >> 96 <= cd[(order_ + cd[(order_ + 292)] + 4)]
                      if makingAmount > remainingRaw[6401][0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))] - 1:
                          if not -(Mask(32, 96, cd[(order_ + 260)]) >> 96) + (Mask(32, 64, cd[(order_ + 260)]) >> 64):
                      else:
                          if -(Mask(32, 96, cd[(order_ + 260)]) >> 96) + (Mask(32, 64, cd[(order_ + 260)]) >> 64):
                              if not -(Mask(32, 96, cd[(order_ + 260)]) >> 96) + (Mask(32, 64, cd[(order_ + 260)]) >> 64) + 1:
              else:
                  require cd[(order_ + 100)] == address(cd[(order_ + 100)])
                  if not address(cd[(order_ + 100)]):
                      revert with BadSignature()
                  if signature.length != 64:
                      if signature.length != 65:
                          static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                  gas gas_remaining wei
                                 args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                          if not ext_call.success:
                              revert with BadSignature()
                          if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                              revert with BadSignature()
                      else:
                          if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if address(cd[(order_ + 100)]):
                                  static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                          else:
                              signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                              if address(signer) != address(cd[(order_ + 100)]):
                                  static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                  else:
                      if signature.length == 65:
                          if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if address(cd[(order_ + 100)]):
                                  static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                          else:
                              signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                              if address(signer) != address(cd[(order_ + 100)]):
                                  static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                      else:
                          if signature.length != 64:
                              if address(cd[(order_ + 100)]):
                                  static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                          else:
                              if uint255(cd[(signature + 68)]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                                  if address(cd[(order_ + 100)]):
                                      static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                      if not ext_call.success:
                                          revert with BadSignature()
                                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                          revert with BadSignature()
                              else:
                                  signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), (bool(cd[(signature + 68)]) >> 255) + 27, call.data[signature + 36], uint255(cd[(signature + 68)])) # precompiled
                                  if address(signer) != address(cd[(order_ + 100)]):
                                      static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                      if not ext_call.success:
                                          revert with BadSignature()
                                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                          revert with BadSignature()
                  require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                  require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                  require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                  require 0 <= cd[(order_ + cd[(order_ + 292)] + 4)]
          else:
              require cd[(order_ + 164)] == address(cd[(order_ + 164)])
              if address(cd[(order_ + 164)]) != caller:
                  revert with PrivateOrder()
              if remainingRaw[6401][0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca][sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))]:
                  require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                  require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                  require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                  require 0 <= cd[(order_ + cd[(order_ + 292)] + 4)]
                  if not not takingAmount - not makingAmount:
                      revert with OnlyOneAmountShouldBeZero()
                  require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                  require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                  require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                  if -takingAmount:
                      require Mask(32, 32, cd[(order_ + 260)]) >> 32 <= Mask(32, 64, cd[(order_ + 260)]) >> 64
                      require Mask(32, 64, cd[(order_ + 260)]) >> 64 <= cd[(order_ + cd[(order_ + 292)] + 4)]
                  else:
                      require Mask(32, 64, cd[(order_ + 260)]) >> 64 <= Mask(32, 96, cd[(order_ + 260)]) >> 96
                      require Mask(32, 96, cd[(order_ + 260)]) >> 96 <= cd[(order_ + cd[(order_ + 292)] + 4)]
              else:
                  require cd[(order_ + 100)] == address(cd[(order_ + 100)])
                  if not address(cd[(order_ + 100)]):
                      revert with BadSignature()
                  if signature.length != 64:
                      if signature.length != 65:
                          static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                  gas gas_remaining wei
                                 args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                          if not ext_call.success:
                              revert with BadSignature()
                          if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                              revert with BadSignature()
                          require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                          require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                          require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                          require 0 <= cd[(order_ + cd[(order_ + 292)] + 4)]
                      else:
                          if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if not address(cd[(order_ + 100)]):
                                  require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                                  require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                                  require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                              else:
                                  static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                                  require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                                  require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                          else:
                              signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                              if address(signer) == address(cd[(order_ + 100)]):
                                  require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                                  require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                                  require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                              else:
                                  static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                                  require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                  else:
                      if signature.length == 65:
                          if call.data[signature + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if address(cd[(order_ + 100)]):
                                  static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                              require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                              require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                              require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                          else:
                              signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('param', 'signature')))), 0) - 256, call.data[signature + 36 len 64]) # precompiled
                              if address(signer) == address(cd[(order_ + 100)]):
                                  require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                                  require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                                  require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                              else:
                                  static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                                  require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                                  require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                      else:
                          if signature.length != 64:
                              if address(cd[(order_ + 100)]):
                                  static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                  if not ext_call.success:
                                      revert with BadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with BadSignature()
                              require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                              require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                              require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                          else:
                              if uint255(cd[(signature + 68)]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                                  if not address(cd[(order_ + 100)]):
                                      require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                                      require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                                      require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                                  else:
                                      static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                      if not ext_call.success:
                                          revert with BadSignature()
                                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                          revert with BadSignature()
                                      require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                                      require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                              else:
                                  signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), (bool(cd[(signature + 68)]) >> 255) + 27, call.data[signature + 36], uint255(cd[(signature + 68)])) # precompiled
                                  if address(signer) == address(cd[(order_ + 100)]):
                                      require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
                                      require cd[(order_ + cd[(order_ + 292)] + 4)] <= LOCK8605463013()
                                      require order_ + cd[(order_ + 292)] + 36 <=′ calldata.size - cd[(order_ + cd[(order_ + 292)] + 4)]
                                  else:
                                      static call cd[(order_ + 100)].isValidSignature(bytes32 , bytes ) with:
                                              gas gas_remaining wei
                                             args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0xa244ca8a150ac294c14fcff9277051ced9a5b23e966a0ff0522e989da23116c, call.data[order_ + 4 len 288], sha3(call.data[order_ + cd[(order_ + 292)] + 36 len cd[(order_ + cd[(order_ + 292)] + 4)]]))), Array(len=signature.length, data=signature[all])
                                      if not ext_call.success:
                                          revert with BadSignature()
                                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                          revert with BadSignature()
                                      require cd[(order_ + 292)] <′ calldata.size + -order_ - 35
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def fillOrderRFQ(tuple order, bytes signature, uint256 flagsAndAmount) payable: 
  require calldata.size - 4 >=′ 288
  require calldata.size - 4 >=′ 224
  require signature == address(signature)
  require flagsAndAmount == address(flagsAndAmount)
  require cd[100] == address(cd[100])
  require cd[132] == address(cd[132])
  require cd[228] <= LOCK8605463013()
  require cd[228] + 35 <′ calldata.size
  require ('cd', 228).length <= LOCK8605463013()
  require cd[228] + ('cd', 228).length + 36 <= calldata.size
  if this.address != 0x1111111254eeb25477b68fb85ed929f73a960582:
      if not Mask(1, 254, cd[260]):
          if not address(cd[100]):
              revert with RFQBadSignature()
          if ('cd', 228).length == 64:
              if ('cd', 228).length == 65:
                  if call.data[cd[228] + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                      if address(cd[100]):
                          static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                  gas gas_remaining wei
                                 args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                          if not ext_call.success:
                              revert with RFQBadSignature()
                          if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                              revert with RFQBadSignature()
                          if not caller:
                              revert with RFQZeroTargetIsForbidden()
                          if not address(cd[132]):
                              if Mask(64, 64, order):
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                          else:
                              if address(cd[132]) != caller:
                                  revert with RFQPrivateOrder()
                              if not Mask(64, 64, order):
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                              else:
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                      else:
                          if not caller:
                              revert with RFQZeroTargetIsForbidden()
                          if not address(cd[132]):
                              if not Mask(64, 64, order):
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                  if -Mask(252, 0, cd[260]):
                                      if not Mask(1, 255, cd[260]):
                                          if Mask(252, 0, cd[260]) > cd[196]:
                                              revert with TakingAmountExceeded()
                                      else:
                                          if Mask(252, 0, cd[260]) > cd[164]:
                                              revert with MakingAmountExceeded()
                              else:
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                  if -Mask(252, 0, cd[260]):
                                      if Mask(1, 255, cd[260]):
                          else:
                              if address(cd[132]) != caller:
                                  revert with RFQPrivateOrder()
                              if not Mask(64, 64, order):
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                  if -Mask(252, 0, cd[260]):
                                      if Mask(1, 255, cd[260]):
                              else:
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                  if -Mask(252, 0, cd[260]):
                  else:
                      signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) - 256, call.data[cd[228] + 36 len 64]) # precompiled
                      if address(signer) != address(cd[100]):
                          static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                  gas gas_remaining wei
                                 args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                          if not ext_call.success:
                              revert with RFQBadSignature()
                          if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                              revert with RFQBadSignature()
                          if not caller:
                              revert with RFQZeroTargetIsForbidden()
                          if not address(cd[132]):
                              if not Mask(64, 64, order):
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                              else:
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                          else:
                              if address(cd[132]) != caller:
                                  revert with RFQPrivateOrder()
                              if Mask(64, 64, order):
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                      else:
                          if not caller:
                              revert with RFQZeroTargetIsForbidden()
                          if not address(cd[132]):
                              if not Mask(64, 64, order):
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                  if -Mask(252, 0, cd[260]):
                                      if Mask(1, 255, cd[260]):
                              else:
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                  if -Mask(252, 0, cd[260]):
                          else:
                              if address(cd[132]) != caller:
                                  revert with RFQPrivateOrder()
                              if not Mask(64, 64, order):
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                  if -Mask(252, 0, cd[260]):
                              else:
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
              else:
                  if ('cd', 228).length != 64:
                      if address(cd[100]):
                          static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                  gas gas_remaining wei
                                 args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                          if not ext_call.success:
                              revert with RFQBadSignature()
                          if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                              revert with RFQBadSignature()
                          if not caller:
                              revert with RFQZeroTargetIsForbidden()
                          if not address(cd[132]):
                              if Mask(64, 64, order):
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                          else:
                              if address(cd[132]) != caller:
                                  revert with RFQPrivateOrder()
                              if not Mask(64, 64, order):
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                              else:
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                      else:
                          if not caller:
                              revert with RFQZeroTargetIsForbidden()
                          if not address(cd[132]):
                              if not Mask(64, 64, order):
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                  if -Mask(252, 0, cd[260]):
                                      if not Mask(1, 255, cd[260]):
                                          if Mask(252, 0, cd[260]) > cd[196]:
                                              revert with TakingAmountExceeded()
                                      else:
                                          if Mask(252, 0, cd[260]) > cd[164]:
                                              revert with MakingAmountExceeded()
                              else:
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                  if -Mask(252, 0, cd[260]):
                                      if Mask(1, 255, cd[260]):
                          else:
                              if address(cd[132]) != caller:
                                  revert with RFQPrivateOrder()
                              if not Mask(64, 64, order):
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                  if -Mask(252, 0, cd[260]):
                                      if Mask(1, 255, cd[260]):
                              else:
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                  if -Mask(252, 0, cd[260]):
                  else:
                      if uint255(('cd', 228)[1]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                          if address(cd[100]):
                              static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with RFQBadSignature()
                              if not caller:
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                          else:
                              if not caller:
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                                          if Mask(1, 255, cd[260]):
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                      else:
                          signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), (bool(('cd', 228)[1]) >> 255) + 27, call.data[cd[228] + 36], uint255(('cd', 228)[1])) # precompiled
                          if address(signer) == address(cd[100]):
                              if not caller:
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                          else:
                              static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with RFQBadSignature()
                              if not caller:
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if Mask(64, 64, order):
          else:
              if ('cd', 228).length == 65:
                  if call.data[cd[228] + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                      if address(cd[100]):
                          static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                  gas gas_remaining wei
                                 args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                          if not ext_call.success:
                              revert with RFQBadSignature()
                          if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                              revert with RFQBadSignature()
                          if not caller:
                              revert with RFQZeroTargetIsForbidden()
                          if not address(cd[132]):
                              if not Mask(64, 64, order):
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                              else:
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                          else:
                              if address(cd[132]) != caller:
                                  revert with RFQPrivateOrder()
                              if Mask(64, 64, order):
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                      else:
                          if not caller:
                              revert with RFQZeroTargetIsForbidden()
                          if not address(cd[132]):
                              if not Mask(64, 64, order):
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                  if -Mask(252, 0, cd[260]):
                                      if Mask(1, 255, cd[260]):
                              else:
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                  if -Mask(252, 0, cd[260]):
                          else:
                              if address(cd[132]) != caller:
                                  revert with RFQPrivateOrder()
                              if not Mask(64, 64, order):
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                  if -Mask(252, 0, cd[260]):
                              else:
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                  else:
                      signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) - 256, call.data[cd[228] + 36 len 64]) # precompiled
                      if address(signer) == address(cd[100]):
                          if not caller:
                              revert with RFQZeroTargetIsForbidden()
                          if not address(cd[132]):
                              if not Mask(64, 64, order):
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                  if -Mask(252, 0, cd[260]):
                              else:
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                          else:
                              if address(cd[132]) != caller:
                                  revert with RFQPrivateOrder()
                              if Mask(64, 64, order):
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                      else:
                          static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                  gas gas_remaining wei
                                 args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                          if not ext_call.success:
                              revert with RFQBadSignature()
                          if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                              revert with RFQBadSignature()
                          if not caller:
                              revert with RFQZeroTargetIsForbidden()
                          if not address(cd[132]):
                              if Mask(64, 64, order):
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                          else:
                              if address(cd[132]) != caller:
                                  revert with RFQPrivateOrder()
                              if Mask(64, 64, order):
              else:
                  static call cd[100].isValidSignature(bytes32 , bytes ) with:
                          gas gas_remaining wei
                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                  if not ext_call.success:
                      revert with RFQBadSignature()
                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                      revert with RFQBadSignature()
                  if not caller:
                      revert with RFQZeroTargetIsForbidden()
                  if not address(cd[132]):
                      if Mask(64, 64, order):
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                          revert with InvalidatedOrder()
                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                      if -Mask(252, 0, cd[260]):
                          if not Mask(1, 255, cd[260]):
                              if Mask(252, 0, cd[260]) > cd[196]:
                                  revert with TakingAmountExceeded()
                          else:
                              if Mask(252, 0, cd[260]) > cd[164]:
                                  revert with MakingAmountExceeded()
                      else:
                          if not cd[164]:
                              revert with RFQSwapWithZeroAmount()
                          if not cd[196]:
                              revert with RFQSwapWithZeroAmount()
                  else:
                      if address(cd[132]) != caller:
                          revert with RFQPrivateOrder()
                      if not Mask(64, 64, order):
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                      else:
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
      else:
          if not Mask(1, 253, cd[260]):
              static call cd[100].isValidSignature(bytes32 , bytes ) with:
                      gas gas_remaining wei
                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
              if not ext_call.success:
                  revert with RFQBadSignature()
              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                  revert with RFQBadSignature()
              if not caller:
                  revert with RFQZeroTargetIsForbidden()
              if not address(cd[132]):
                  if not Mask(64, 64, order):
                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                          revert with InvalidatedOrder()
                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                      if -Mask(252, 0, cd[260]):
                          if not Mask(1, 255, cd[260]):
                              if Mask(252, 0, cd[260]) > cd[196]:
                                  revert with TakingAmountExceeded()
                              if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                  revert with 0, 17
                              if not cd[196]:
                                  revert with 0, 18
                          else:
                              if Mask(252, 0, cd[260]) > cd[164]:
                                  revert with MakingAmountExceeded()
                              if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                  revert with 0, 17
                              if cd[196] * Mask(252, 0, cd[260]) > cd[164] + (cd[196] * Mask(252, 0, cd[260])):
                                  revert with 0, 17
                      else:
                          if not cd[164]:
                              revert with RFQSwapWithZeroAmount()
                          if not cd[196]:
                              revert with RFQSwapWithZeroAmount()
                          if address(signature) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                              call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args cd[100], caller, cd[164]
                              if not ext_call.success:
                                  revert with SafeTransferFromFailed()
                          else:
                              if not Mask(1, 252, cd[260]):
                                  call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args cd[100], caller, cd[164]
                                  if ext_call.success:
                              else:
                                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args address(cd[100]), this.address, cd[164]
                                  if not ext_call.success:
                                      revert with ext_call.return_data[0 len return_data.size]
                  else:
                      if block.timestamp > uint64(order):
                          revert with OrderExpired()
                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                          revert with InvalidatedOrder()
                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                      if -Mask(252, 0, cd[260]):
                          if not Mask(1, 255, cd[260]):
                              if Mask(252, 0, cd[260]) > cd[196]:
                                  revert with TakingAmountExceeded()
                              if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                  revert with 0, 17
                              if not cd[196]:
                                  revert with 0, 18
                          else:
                              if Mask(252, 0, cd[260]) > cd[164]:
                                  revert with MakingAmountExceeded()
                              if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                  revert with 0, 17
                      else:
                          if not cd[164]:
                              revert with RFQSwapWithZeroAmount()
                          if not cd[196]:
                              revert with RFQSwapWithZeroAmount()
                          if address(signature) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                              call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args cd[100], caller, cd[164]
                              if ext_call.success:
                          else:
                              if not Mask(1, 252, cd[260]):
                                  call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args cd[100], caller, cd[164]
                              else:
                                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args address(cd[100]), this.address, cd[164]
                                  if not ext_call.success:
                                      revert with ext_call.return_data[0 len return_data.size]
              else:
                  if address(cd[132]) != caller:
                      revert with RFQPrivateOrder()
                  if not Mask(64, 64, order):
                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                          revert with InvalidatedOrder()
                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                      if -Mask(252, 0, cd[260]):
                          if not Mask(1, 255, cd[260]):
                              if Mask(252, 0, cd[260]) > cd[196]:
                                  revert with TakingAmountExceeded()
                              if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                  revert with 0, 17
                              if not cd[196]:
                                  revert with 0, 18
                          else:
                              if Mask(252, 0, cd[260]) > cd[164]:
                                  revert with MakingAmountExceeded()
                              if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                  revert with 0, 17
                      else:
                          if not cd[164]:
                              revert with RFQSwapWithZeroAmount()
                          if not cd[196]:
                              revert with RFQSwapWithZeroAmount()
                          if address(signature) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                              call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args cd[100], caller, cd[164]
                              if ext_call.success:
                          else:
                              if not Mask(1, 252, cd[260]):
                                  call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args cd[100], caller, cd[164]
                              else:
                                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args address(cd[100]), this.address, cd[164]
                                  if not ext_call.success:
                                      revert with ext_call.return_data[0 len return_data.size]
                  else:
                      if block.timestamp > uint64(order):
                          revert with OrderExpired()
                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                          revert with InvalidatedOrder()
                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                      if -Mask(252, 0, cd[260]):
                          if not Mask(1, 255, cd[260]):
                              if Mask(252, 0, cd[260]) > cd[196]:
                                  revert with TakingAmountExceeded()
                              if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                  revert with 0, 17
                          else:
                              if Mask(252, 0, cd[260]) > cd[164]:
                                  revert with MakingAmountExceeded()
                              if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                  revert with 0, 17
                      else:
                          if not cd[164]:
                              revert with RFQSwapWithZeroAmount()
                          if not cd[196]:
                              revert with RFQSwapWithZeroAmount()
                          if address(signature) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                              call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args cd[100], caller, cd[164]
                          else:
                              if Mask(1, 252, cd[260]):
                                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args address(cd[100]), this.address, cd[164]
          else:
              if ('cd', 228).length != 65:
                  revert with RFQBadSignature()
              static call cd[100].isValidSignature(bytes32 , bytes ) with:
                      gas gas_remaining wei
                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
              if not ext_call.success:
                  revert with RFQBadSignature()
              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                  revert with RFQBadSignature()
              if not caller:
                  revert with RFQZeroTargetIsForbidden()
              if not address(cd[132]):
                  if not Mask(64, 64, order):
                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                          revert with InvalidatedOrder()
                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                      if -Mask(252, 0, cd[260]):
                          if not Mask(1, 255, cd[260]):
                              if Mask(252, 0, cd[260]) > cd[196]:
                                  revert with TakingAmountExceeded()
                              if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                  revert with 0, 17
                              if not cd[196]:
                                  revert with 0, 18
                          else:
                              if Mask(252, 0, cd[260]) > cd[164]:
                                  revert with MakingAmountExceeded()
                              if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                  revert with 0, 17
                      else:
                          if not cd[164]:
                              revert with RFQSwapWithZeroAmount()
                          if not cd[196]:
                              revert with RFQSwapWithZeroAmount()
                          if address(signature) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                              call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args cd[100], caller, cd[164]
                              if ext_call.success:
                          else:
                              if not Mask(1, 252, cd[260]):
                                  call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args cd[100], caller, cd[164]
                              else:
                                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args address(cd[100]), this.address, cd[164]
                                  if not ext_call.success:
                                      revert with ext_call.return_data[0 len return_data.size]
                  else:
                      if block.timestamp > uint64(order):
                          revert with OrderExpired()
                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                          revert with InvalidatedOrder()
                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                      if -Mask(252, 0, cd[260]):
                          if not Mask(1, 255, cd[260]):
                              if Mask(252, 0, cd[260]) > cd[196]:
                                  revert with TakingAmountExceeded()
                              if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                  revert with 0, 17
                          else:
                              if Mask(252, 0, cd[260]) > cd[164]:
                                  revert with MakingAmountExceeded()
                              if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                  revert with 0, 17
                      else:
                          if not cd[164]:
                              revert with RFQSwapWithZeroAmount()
                          if not cd[196]:
                              revert with RFQSwapWithZeroAmount()
                          if address(signature) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                              call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args cd[100], caller, cd[164]
                          else:
                              if Mask(1, 252, cd[260]):
                                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args address(cd[100]), this.address, cd[164]
              else:
                  if address(cd[132]) != caller:
                      revert with RFQPrivateOrder()
                  if Mask(64, 64, order):
                      if block.timestamp > uint64(order):
                          revert with OrderExpired()
                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                          revert with InvalidatedOrder()
                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                      if -Mask(252, 0, cd[260]):
                          if not Mask(1, 255, cd[260]):
                              if Mask(252, 0, cd[260]) > cd[196]:
                                  revert with TakingAmountExceeded()
                              if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                  revert with 0, 17
                          else:
                              if Mask(252, 0, cd[260]) > cd[164]:
                                  revert with MakingAmountExceeded()
                              if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                  revert with 0, 17
                      else:
                          if not cd[164]:
                              revert with RFQSwapWithZeroAmount()
                          if not cd[196]:
                              revert with RFQSwapWithZeroAmount()
                          if address(signature) == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                  else:
                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                          revert with InvalidatedOrder()
                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                      if -Mask(252, 0, cd[260]):
                          if not Mask(1, 255, cd[260]):
                              if Mask(252, 0, cd[260]) > cd[196]:
                                  revert with TakingAmountExceeded()
                              if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                  revert with 0, 17
                          else:
                              if Mask(252, 0, cd[260]) > cd[164]:
                                  revert with MakingAmountExceeded()
                              if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                  revert with 0, 17
                      else:
                          if not cd[164]:
                              revert with RFQSwapWithZeroAmount()
                          if not cd[196]:
                              revert with RFQSwapWithZeroAmount()
                          if address(signature) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                              call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args cd[100], caller, cd[164]
                          else:
                              if Mask(1, 252, cd[260]):
                                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args address(cd[100]), this.address, cd[164]
  else:
      if 1 != chainid:
          if not Mask(1, 254, cd[260]):
              if not address(cd[100]):
                  revert with RFQBadSignature()
              if ('cd', 228).length == 64:
                  if ('cd', 228).length == 65:
                      if call.data[cd[228] + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                          if address(cd[100]):
                              static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with RFQBadSignature()
                              if not caller:
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                          else:
                              if not caller:
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                                          if Mask(1, 255, cd[260]):
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                      else:
                          signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) - 256, call.data[cd[228] + 36 len 64]) # precompiled
                          if address(signer) == address(cd[100]):
                              if not caller:
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                          else:
                              static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with RFQBadSignature()
                              if not caller:
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if Mask(64, 64, order):
                  else:
                      if ('cd', 228).length != 64:
                          if address(cd[100]):
                              static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with RFQBadSignature()
                              if not caller:
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                          else:
                              if not caller:
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                                          if Mask(1, 255, cd[260]):
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                      else:
                          if uint255(('cd', 228)[1]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if not address(cd[100]):
                                  if not caller:
                                      revert with RFQZeroTargetIsForbidden()
                                  if not address(cd[132]):
                                      if not Mask(64, 64, order):
                                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                              revert with InvalidatedOrder()
                                          invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                          if -Mask(252, 0, cd[260]):
                                      else:
                                          if block.timestamp > uint64(order):
                                              revert with OrderExpired()
                                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                              revert with InvalidatedOrder()
                                          invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                  else:
                                      if address(cd[132]) != caller:
                                          revert with RFQPrivateOrder()
                                      if Mask(64, 64, order):
                                          if block.timestamp > uint64(order):
                                              revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                              else:
                                  static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                                  if not ext_call.success:
                                      revert with RFQBadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with RFQBadSignature()
                                  if not caller:
                                      revert with RFQZeroTargetIsForbidden()
                                  if not address(cd[132]):
                                      if Mask(64, 64, order):
                                          if block.timestamp > uint64(order):
                                              revert with OrderExpired()
                                  else:
                                      if address(cd[132]) != caller:
                                          revert with RFQPrivateOrder()
                                      if Mask(64, 64, order):
                          else:
                              signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), (bool(('cd', 228)[1]) >> 255) + 27, call.data[cd[228] + 36], uint255(('cd', 228)[1])) # precompiled
                              if address(signer) == address(cd[100]):
                                  if not caller:
                                      revert with RFQZeroTargetIsForbidden()
                                  if not address(cd[132]):
                                      if Mask(64, 64, order):
                                          if block.timestamp > uint64(order):
                                              revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                  else:
                                      if address(cd[132]) != caller:
                                          revert with RFQPrivateOrder()
                                      if not Mask(64, 64, order):
                                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                              revert with InvalidatedOrder()
                                          invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                      else:
                                          if block.timestamp > uint64(order):
                                              revert with OrderExpired()
                              else:
                                  static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                                  if not ext_call.success:
                                      revert with RFQBadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with RFQBadSignature()
                                  if not caller:
                                      revert with RFQZeroTargetIsForbidden()
                                  if not address(cd[132]):
                                      if Mask(64, 64, order):
                                  else:
                                      if address(cd[132]) != caller:
                                          revert with RFQPrivateOrder()
              else:
                  if ('cd', 228).length == 65:
                      if call.data[cd[228] + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                          if not address(cd[100]):
                              if not caller:
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                          else:
                              static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with RFQBadSignature()
                              if not caller:
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if Mask(64, 64, order):
                      else:
                          signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) - 256, call.data[cd[228] + 36 len 64]) # precompiled
                          if address(signer) == address(cd[100]):
                              if not caller:
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                          else:
                              static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with RFQBadSignature()
                              if not caller:
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if Mask(64, 64, order):
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                  else:
                      static call cd[100].isValidSignature(bytes32 , bytes ) with:
                              gas gas_remaining wei
                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                      if not ext_call.success:
                          revert with RFQBadSignature()
                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                          revert with RFQBadSignature()
                      if not caller:
                          revert with RFQZeroTargetIsForbidden()
                      if not address(cd[132]):
                          if not Mask(64, 64, order):
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[260]):
                                  if not Mask(1, 255, cd[260]):
                                      if Mask(252, 0, cd[260]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                  else:
                                      if Mask(252, 0, cd[260]) > cd[164]:
                                          revert with MakingAmountExceeded()
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                          else:
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[260]):
                                  if not Mask(1, 255, cd[260]):
                                      if Mask(252, 0, cd[260]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                  else:
                                      if Mask(252, 0, cd[260]) > cd[164]:
                                          revert with MakingAmountExceeded()
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                      else:
                          if address(cd[132]) != caller:
                              revert with RFQPrivateOrder()
                          if not Mask(64, 64, order):
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[260]):
                                  if not Mask(1, 255, cd[260]):
                                      if Mask(252, 0, cd[260]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                  else:
                                      if Mask(252, 0, cd[260]) > cd[164]:
                                          revert with MakingAmountExceeded()
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                          else:
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[260]):
                                  if not Mask(1, 255, cd[260]):
                                      if Mask(252, 0, cd[260]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                  else:
                                      if Mask(252, 0, cd[260]) > cd[164]:
                                          revert with MakingAmountExceeded()
          else:
              if not Mask(1, 253, cd[260]):
                  static call cd[100].isValidSignature(bytes32 , bytes ) with:
                          gas gas_remaining wei
                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                  if not ext_call.success:
                      revert with RFQBadSignature()
                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                      revert with RFQBadSignature()
                  if not caller:
                      revert with RFQZeroTargetIsForbidden()
                  if not address(cd[132]):
                      if not Mask(64, 64, order):
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                                  if not cd[196]:
                                      revert with 0, 18
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(signature) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args cd[100], caller, cd[164]
                                  if ext_call.success:
                              else:
                                  if not Mask(1, 252, cd[260]):
                                      call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args cd[100], caller, cd[164]
                                  else:
                                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args address(cd[100]), this.address, cd[164]
                                      if not ext_call.success:
                                          revert with ext_call.return_data[0 len return_data.size]
                      else:
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(signature) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args cd[100], caller, cd[164]
                              else:
                                  if Mask(1, 252, cd[260]):
                                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args address(cd[100]), this.address, cd[164]
                  else:
                      if address(cd[132]) != caller:
                          revert with RFQPrivateOrder()
                      if Mask(64, 64, order):
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(signature) == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      else:
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(signature) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args cd[100], caller, cd[164]
                              else:
                                  if Mask(1, 252, cd[260]):
                                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args address(cd[100]), this.address, cd[164]
              else:
                  if ('cd', 228).length != 65:
                      revert with RFQBadSignature()
                  static call cd[100].isValidSignature(bytes32 , bytes ) with:
                          gas gas_remaining wei
                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                  if not ext_call.success:
                      revert with RFQBadSignature()
                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                      revert with RFQBadSignature()
                  if not caller:
                      revert with RFQZeroTargetIsForbidden()
                  if address(cd[132]):
                      if address(cd[132]) != caller:
                          revert with RFQPrivateOrder()
                      if not Mask(64, 64, order):
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(signature) == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      else:
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                  else:
                      if Mask(64, 64, order):
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(signature) == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      else:
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(signature) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args cd[100], caller, cd[164]
                              else:
                                  if Mask(1, 252, cd[260]):
                                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args address(cd[100]), this.address, cd[164]
      else:
          if not Mask(1, 254, cd[260]):
              if not address(cd[100]):
                  revert with RFQBadSignature()
              if ('cd', 228).length == 64:
                  if ('cd', 228).length == 65:
                      if call.data[cd[228] + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                          if address(cd[100]):
                              static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with RFQBadSignature()
                              if not caller:
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                          else:
                              if not caller:
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                                          if Mask(1, 255, cd[260]):
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                      else:
                          signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) - 256, call.data[cd[228] + 36 len 64]) # precompiled
                          if address(signer) == address(cd[100]):
                              if not caller:
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                          else:
                              static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with RFQBadSignature()
                              if not caller:
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if Mask(64, 64, order):
                  else:
                      if ('cd', 228).length != 64:
                          if address(cd[100]):
                              static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with RFQBadSignature()
                              if not caller:
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                          else:
                              if not caller:
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                                          if Mask(1, 255, cd[260]):
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                      else:
                          if uint255(('cd', 228)[1]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if not address(cd[100]):
                                  if not caller:
                                      revert with RFQZeroTargetIsForbidden()
                                  if not address(cd[132]):
                                      if not Mask(64, 64, order):
                                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                              revert with InvalidatedOrder()
                                          invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                          if -Mask(252, 0, cd[260]):
                                      else:
                                          if block.timestamp > uint64(order):
                                              revert with OrderExpired()
                                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                              revert with InvalidatedOrder()
                                          invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                  else:
                                      if address(cd[132]) != caller:
                                          revert with RFQPrivateOrder()
                                      if Mask(64, 64, order):
                                          if block.timestamp > uint64(order):
                                              revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                              else:
                                  static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                                  if not ext_call.success:
                                      revert with RFQBadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with RFQBadSignature()
                                  if not caller:
                                      revert with RFQZeroTargetIsForbidden()
                                  if not address(cd[132]):
                                      if Mask(64, 64, order):
                                          if block.timestamp > uint64(order):
                                              revert with OrderExpired()
                                  else:
                                      if address(cd[132]) != caller:
                                          revert with RFQPrivateOrder()
                                      if Mask(64, 64, order):
                          else:
                              signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), (bool(('cd', 228)[1]) >> 255) + 27, call.data[cd[228] + 36], uint255(('cd', 228)[1])) # precompiled
                              if address(signer) == address(cd[100]):
                                  if not caller:
                                      revert with RFQZeroTargetIsForbidden()
                                  if not address(cd[132]):
                                      if Mask(64, 64, order):
                                          if block.timestamp > uint64(order):
                                              revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                  else:
                                      if address(cd[132]) != caller:
                                          revert with RFQPrivateOrder()
                                      if not Mask(64, 64, order):
                                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                              revert with InvalidatedOrder()
                                          invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                      else:
                                          if block.timestamp > uint64(order):
                                              revert with OrderExpired()
                              else:
                                  static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                                  if not ext_call.success:
                                      revert with RFQBadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with RFQBadSignature()
                                  if not caller:
                                      revert with RFQZeroTargetIsForbidden()
                                  if not address(cd[132]):
                                      if Mask(64, 64, order):
                                  else:
                                      if address(cd[132]) != caller:
                                          revert with RFQPrivateOrder()
              else:
                  if ('cd', 228).length == 65:
                      if call.data[cd[228] + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                          if not address(cd[100]):
                              if not caller:
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                          else:
                              static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with RFQBadSignature()
                              if not caller:
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if Mask(64, 64, order):
                      else:
                          signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) - 256, call.data[cd[228] + 36 len 64]) # precompiled
                          if address(signer) == address(cd[100]):
                              if not caller:
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                          else:
                              static call cd[100].isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with RFQBadSignature()
                              if not caller:
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if Mask(64, 64, order):
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                  else:
                      static call cd[100].isValidSignature(bytes32 , bytes ) with:
                              gas gas_remaining wei
                             args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                      if not ext_call.success:
                          revert with RFQBadSignature()
                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                          revert with RFQBadSignature()
                      if not caller:
                          revert with RFQZeroTargetIsForbidden()
                      if not address(cd[132]):
                          if not Mask(64, 64, order):
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[260]):
                                  if not Mask(1, 255, cd[260]):
                                      if Mask(252, 0, cd[260]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                  else:
                                      if Mask(252, 0, cd[260]) > cd[164]:
                                          revert with MakingAmountExceeded()
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                          else:
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[260]):
                                  if not Mask(1, 255, cd[260]):
                                      if Mask(252, 0, cd[260]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                  else:
                                      if Mask(252, 0, cd[260]) > cd[164]:
                                          revert with MakingAmountExceeded()
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                      else:
                          if address(cd[132]) != caller:
                              revert with RFQPrivateOrder()
                          if not Mask(64, 64, order):
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[260]):
                                  if not Mask(1, 255, cd[260]):
                                      if Mask(252, 0, cd[260]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                  else:
                                      if Mask(252, 0, cd[260]) > cd[164]:
                                          revert with MakingAmountExceeded()
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                          else:
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[260]):
                                  if not Mask(1, 255, cd[260]):
                                      if Mask(252, 0, cd[260]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                  else:
                                      if Mask(252, 0, cd[260]) > cd[164]:
                                          revert with MakingAmountExceeded()
          else:
              if not Mask(1, 253, cd[260]):
                  static call cd[100].isValidSignature(bytes32 , bytes ) with:
                          gas gas_remaining wei
                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                  if not ext_call.success:
                      revert with RFQBadSignature()
                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                      revert with RFQBadSignature()
                  if not caller:
                      revert with RFQZeroTargetIsForbidden()
                  if not address(cd[132]):
                      if not Mask(64, 64, order):
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                                  if not cd[196]:
                                      revert with 0, 18
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(signature) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args cd[100], caller, cd[164]
                                  if ext_call.success:
                              else:
                                  if not Mask(1, 252, cd[260]):
                                      call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args cd[100], caller, cd[164]
                                  else:
                                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args address(cd[100]), this.address, cd[164]
                                      if not ext_call.success:
                                          revert with ext_call.return_data[0 len return_data.size]
                      else:
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(signature) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args cd[100], caller, cd[164]
                              else:
                                  if Mask(1, 252, cd[260]):
                                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args address(cd[100]), this.address, cd[164]
                  else:
                      if address(cd[132]) != caller:
                          revert with RFQPrivateOrder()
                      if Mask(64, 64, order):
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(signature) == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      else:
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(signature) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args cd[100], caller, cd[164]
                              else:
                                  if Mask(1, 252, cd[260]):
                                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args address(cd[100]), this.address, cd[164]
              else:
                  if ('cd', 228).length != 65:
                      revert with RFQBadSignature()
                  static call cd[100].isValidSignature(bytes32 , bytes ) with:
                          gas gas_remaining wei
                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, cd[100], cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                  if not ext_call.success:
                      revert with RFQBadSignature()
                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                      revert with RFQBadSignature()
                  if not caller:
                      revert with RFQZeroTargetIsForbidden()
                  if address(cd[132]):
                      if address(cd[132]) != caller:
                          revert with RFQPrivateOrder()
                      if not Mask(64, 64, order):
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(signature) == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      else:
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                  else:
                      if Mask(64, 64, order):
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(signature) == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      else:
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(cd[100])][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(signature) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args cd[100], caller, cd[164]
                              else:
                                  if Mask(1, 252, cd[260]):
                                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args address(cd[100]), this.address, cd[164]
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def fillOrderRFQCompact(tuple order, bytes32 r, bytes32 vs, uint256 flagsAndAmount) payable: 
  require calldata.size - 4 >=′ 320
  require calldata.size - 4 >=′ 224
  require r == address(r)
  require vs == address(vs)
  require flagsAndAmount == address(flagsAndAmount)
  require cd[132] == address(cd[132])
  if this.address != 0x1111111254eeb25477b68fb85ed929f73a960582:
      if not Mask(1, 254, cd[292]):
          if not address(flagsAndAmount):
              revert with RFQBadSignature()
          if uint255(cd[260]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
              if not -address(flagsAndAmount):
                  if not caller:
                      revert with RFQZeroTargetIsForbidden()
                  if not address(cd[132]):
                      if not Mask(64, 64, order):
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[292]):
                              if not Mask(1, 255, cd[292]):
                                  if Mask(252, 0, cd[292]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                      revert with 0, 17
                                  if not cd[196]:
                                      revert with 0, 18
                              else:
                                  if Mask(252, 0, cd[292]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                      revert with 0, 17
                                  if cd[196] * Mask(252, 0, cd[292]) > cd[164] + (cd[196] * Mask(252, 0, cd[292])):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args flagsAndAmount, caller, cd[164]
                                  if not ext_call.success:
                                      revert with SafeTransferFromFailed()
                              else:
                                  if not Mask(1, 252, cd[292]):
                                      call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args flagsAndAmount, caller, cd[164]
                                      if not ext_call.success:
                                          revert with SafeTransferFromFailed()
                                  else:
                                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args address(flagsAndAmount), this.address, cd[164]
                                      if not ext_call.success:
                                          revert with ext_call.return_data[0 len return_data.size]
                                      require return_data.size >=′ 32
                      else:
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[292]):
                              if not Mask(1, 255, cd[292]):
                                  if Mask(252, 0, cd[292]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                      revert with 0, 17
                                  if not cd[196]:
                                      revert with 0, 18
                              else:
                                  if Mask(252, 0, cd[292]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                      revert with 0, 17
                                  if cd[196] * Mask(252, 0, cd[292]) > cd[164] + (cd[196] * Mask(252, 0, cd[292])):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args flagsAndAmount, caller, cd[164]
                                  if not ext_call.success:
                                      revert with SafeTransferFromFailed()
                              else:
                                  if not Mask(1, 252, cd[292]):
                                      call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args flagsAndAmount, caller, cd[164]
                                      if ext_call.success:
                                  else:
                                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args address(flagsAndAmount), this.address, cd[164]
                                      if not ext_call.success:
                                          revert with ext_call.return_data[0 len return_data.size]
                  else:
                      if address(cd[132]) != caller:
                          revert with RFQPrivateOrder()
                      if not Mask(64, 64, order):
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[292]):
                              if not Mask(1, 255, cd[292]):
                                  if Mask(252, 0, cd[292]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                      revert with 0, 17
                                  if not cd[196]:
                                      revert with 0, 18
                              else:
                                  if Mask(252, 0, cd[292]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                      revert with 0, 17
                                  if cd[196] * Mask(252, 0, cd[292]) > cd[164] + (cd[196] * Mask(252, 0, cd[292])):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args flagsAndAmount, caller, cd[164]
                                  if not ext_call.success:
                                      revert with SafeTransferFromFailed()
                              else:
                                  if not Mask(1, 252, cd[292]):
                                      call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args flagsAndAmount, caller, cd[164]
                                      if ext_call.success:
                                  else:
                                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args address(flagsAndAmount), this.address, cd[164]
                                      if not ext_call.success:
                                          revert with ext_call.return_data[0 len return_data.size]
                      else:
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[292]):
                              if not Mask(1, 255, cd[292]):
                                  if Mask(252, 0, cd[292]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                      revert with 0, 17
                                  if not cd[196]:
                                      revert with 0, 18
                              else:
                                  if Mask(252, 0, cd[292]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args flagsAndAmount, caller, cd[164]
                                  if ext_call.success:
                              else:
                                  if not Mask(1, 252, cd[292]):
                                      call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args flagsAndAmount, caller, cd[164]
                                  else:
                                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args address(flagsAndAmount), this.address, cd[164]
                                      if not ext_call.success:
                                          revert with ext_call.return_data[0 len return_data.size]
              else:
                  static call flagsAndAmount.isValidSignature(bytes32 , bytes ) with:
                          gas gas_remaining wei
                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, r, vs, flagsAndAmount, cd[132], cd[164], cd[196])), 64, 64, cd[228], cd[260]
                  if not ext_call.success:
                      revert with RFQBadSignature()
                  if return_data.size != 32 or ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000:
                      revert with RFQBadSignature()
                  if not caller:
                      revert with RFQZeroTargetIsForbidden()
                  if not address(cd[132]):
                      if not Mask(64, 64, order):
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[292]):
                              if not Mask(1, 255, cd[292]):
                                  if Mask(252, 0, cd[292]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                      revert with 0, 17
                                  if not cd[196]:
                                      revert with 0, 18
                              else:
                                  if Mask(252, 0, cd[292]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args flagsAndAmount, caller, cd[164]
                                  if ext_call.success:
                              else:
                                  if not Mask(1, 252, cd[292]):
                                      call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args flagsAndAmount, caller, cd[164]
                                  else:
                                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args address(flagsAndAmount), this.address, cd[164]
                                      if not ext_call.success:
                                          revert with ext_call.return_data[0 len return_data.size]
                      else:
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[292]):
                              if not Mask(1, 255, cd[292]):
                                  if Mask(252, 0, cd[292]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                      revert with 0, 17
                              else:
                                  if Mask(252, 0, cd[292]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args flagsAndAmount, caller, cd[164]
                              else:
                                  if Mask(1, 252, cd[292]):
                                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args address(flagsAndAmount), this.address, cd[164]
                  else:
                      if address(cd[132]) != caller:
                          revert with RFQPrivateOrder()
                      if Mask(64, 64, order):
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[292]):
                              if not Mask(1, 255, cd[292]):
                                  if Mask(252, 0, cd[292]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                      revert with 0, 17
                              else:
                                  if Mask(252, 0, cd[292]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(r) == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      else:
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[292]):
                              if not Mask(1, 255, cd[292]):
                                  if Mask(252, 0, cd[292]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                      revert with 0, 17
                              else:
                                  if Mask(252, 0, cd[292]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args flagsAndAmount, caller, cd[164]
                              else:
                                  if Mask(1, 252, cd[292]):
                                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args address(flagsAndAmount), this.address, cd[164]
          else:
              signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, r, vs, flagsAndAmount, cd[132], cd[164], cd[196])), (bool(cd[260]) >> 255) + 27, cd[228], uint255(cd[260])) # precompiled
              if not address(signer) - address(flagsAndAmount):
                  if not caller:
                      revert with RFQZeroTargetIsForbidden()
                  if not address(cd[132]):
                      if not Mask(64, 64, order):
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[292]):
                              if not Mask(1, 255, cd[292]):
                                  if Mask(252, 0, cd[292]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                      revert with 0, 17
                                  if not cd[196]:
                                      revert with 0, 18
                              else:
                                  if Mask(252, 0, cd[292]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                      revert with 0, 17
                                  if cd[196] * Mask(252, 0, cd[292]) > cd[164] + (cd[196] * Mask(252, 0, cd[292])):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args flagsAndAmount, caller, cd[164]
                                  if not ext_call.success:
                                      revert with SafeTransferFromFailed()
                              else:
                                  if not Mask(1, 252, cd[292]):
                                      call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args flagsAndAmount, caller, cd[164]
                                      if not ext_call.success:
                                          revert with SafeTransferFromFailed()
                                  else:
                                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args address(flagsAndAmount), this.address, cd[164]
                                      if not ext_call.success:
                                          revert with ext_call.return_data[0 len return_data.size]
                                      require return_data.size >=′ 32
                      else:
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[292]):
                              if not Mask(1, 255, cd[292]):
                                  if Mask(252, 0, cd[292]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                      revert with 0, 17
                                  if not cd[196]:
                                      revert with 0, 18
                              else:
                                  if Mask(252, 0, cd[292]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                      revert with 0, 17
                                  if cd[196] * Mask(252, 0, cd[292]) > cd[164] + (cd[196] * Mask(252, 0, cd[292])):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args flagsAndAmount, caller, cd[164]
                                  if not ext_call.success:
                                      revert with SafeTransferFromFailed()
                              else:
                                  if not Mask(1, 252, cd[292]):
                                      call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args flagsAndAmount, caller, cd[164]
                                      if ext_call.success:
                                  else:
                                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args address(flagsAndAmount), this.address, cd[164]
                                      if not ext_call.success:
                                          revert with ext_call.return_data[0 len return_data.size]
                  else:
                      if address(cd[132]) != caller:
                          revert with RFQPrivateOrder()
                      if not Mask(64, 64, order):
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[292]):
                              if not Mask(1, 255, cd[292]):
                                  if Mask(252, 0, cd[292]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                      revert with 0, 17
                                  if not cd[196]:
                                      revert with 0, 18
                              else:
                                  if Mask(252, 0, cd[292]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                      revert with 0, 17
                                  if cd[196] * Mask(252, 0, cd[292]) > cd[164] + (cd[196] * Mask(252, 0, cd[292])):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args flagsAndAmount, caller, cd[164]
                                  if not ext_call.success:
                                      revert with SafeTransferFromFailed()
                              else:
                                  if not Mask(1, 252, cd[292]):
                                      call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args flagsAndAmount, caller, cd[164]
                                      if ext_call.success:
                                  else:
                                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args address(flagsAndAmount), this.address, cd[164]
                                      if not ext_call.success:
                                          revert with ext_call.return_data[0 len return_data.size]
                      else:
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[292]):
                              if not Mask(1, 255, cd[292]):
                                  if Mask(252, 0, cd[292]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                      revert with 0, 17
                                  if not cd[196]:
                                      revert with 0, 18
                              else:
                                  if Mask(252, 0, cd[292]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args flagsAndAmount, caller, cd[164]
                                  if ext_call.success:
                              else:
                                  if not Mask(1, 252, cd[292]):
                                      call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args flagsAndAmount, caller, cd[164]
                                  else:
                                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args address(flagsAndAmount), this.address, cd[164]
                                      if not ext_call.success:
                                          revert with ext_call.return_data[0 len return_data.size]
              else:
                  static call flagsAndAmount.isValidSignature(bytes32 , bytes ) with:
                          gas gas_remaining wei
                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, r, vs, flagsAndAmount, cd[132], cd[164], cd[196])), 64, 64, cd[228], cd[260]
                  if not ext_call.success:
                      revert with RFQBadSignature()
                  if return_data.size != 32 or ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000:
                      revert with RFQBadSignature()
                  if not caller:
                      revert with RFQZeroTargetIsForbidden()
                  if not address(cd[132]):
                      if not Mask(64, 64, order):
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[292]):
                              if not Mask(1, 255, cd[292]):
                                  if Mask(252, 0, cd[292]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                      revert with 0, 17
                                  if not cd[196]:
                                      revert with 0, 18
                              else:
                                  if Mask(252, 0, cd[292]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args flagsAndAmount, caller, cd[164]
                                  if ext_call.success:
                              else:
                                  if not Mask(1, 252, cd[292]):
                                      call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args flagsAndAmount, caller, cd[164]
                                  else:
                                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args address(flagsAndAmount), this.address, cd[164]
                                      if not ext_call.success:
                                          revert with ext_call.return_data[0 len return_data.size]
                      else:
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[292]):
                              if not Mask(1, 255, cd[292]):
                                  if Mask(252, 0, cd[292]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                      revert with 0, 17
                              else:
                                  if Mask(252, 0, cd[292]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args flagsAndAmount, caller, cd[164]
                              else:
                                  if Mask(1, 252, cd[292]):
                                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args address(flagsAndAmount), this.address, cd[164]
                  else:
                      if address(cd[132]) != caller:
                          revert with RFQPrivateOrder()
                      if Mask(64, 64, order):
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[292]):
                              if not Mask(1, 255, cd[292]):
                                  if Mask(252, 0, cd[292]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                      revert with 0, 17
                              else:
                                  if Mask(252, 0, cd[292]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(r) == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      else:
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[292]):
                              if not Mask(1, 255, cd[292]):
                                  if Mask(252, 0, cd[292]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                      revert with 0, 17
                              else:
                                  if Mask(252, 0, cd[292]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args flagsAndAmount, caller, cd[164]
                              else:
                                  if Mask(1, 252, cd[292]):
                                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args address(flagsAndAmount), this.address, cd[164]
      else:
          if not Mask(1, 253, cd[292]):
              static call flagsAndAmount.isValidSignature(bytes32 , bytes ) with:
                      gas gas_remaining wei
                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, r, vs, flagsAndAmount, cd[132], cd[164], cd[196])), 64, 64, cd[228], cd[260]
          else:
              static call flagsAndAmount.isValidSignature(bytes32 , bytes ) with:
                      gas gas_remaining wei
                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, r, vs, flagsAndAmount, cd[132], cd[164], cd[196])), Array(len=65, data=cd[228], 2 * cd[260], Mask(8, 248, (bool(cd[260]) >> 255) + 27) >> 248)
          if not ext_call.success:
              revert with RFQBadSignature()
          if return_data.size != 32 or ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000:
              revert with RFQBadSignature()
          if not caller:
              revert with RFQZeroTargetIsForbidden()
          if address(cd[132]):
              if address(cd[132]) != caller:
                  revert with RFQPrivateOrder()
              if not Mask(64, 64, order):
                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                      revert with InvalidatedOrder()
                  invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                  if -Mask(252, 0, cd[292]):
                      if Mask(1, 255, cd[292]):
                          if Mask(252, 0, cd[292]) > cd[164]:
                              revert with MakingAmountExceeded()
                          if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                              revert with 0, 17
                          if cd[196] * Mask(252, 0, cd[292]) > cd[164] + (cd[196] * Mask(252, 0, cd[292])):
                              revert with 0, 17
                      else:
                          if Mask(252, 0, cd[292]) > cd[196]:
                              revert with TakingAmountExceeded()
                          if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                              revert with 0, 17
                          if not cd[196]:
                              revert with 0, 18
                  else:
                      if not cd[164]:
                          revert with RFQSwapWithZeroAmount()
                      if not cd[196]:
                          revert with RFQSwapWithZeroAmount()
                      if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                          call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                               gas gas_remaining wei
                              args flagsAndAmount, caller, cd[164]
                          if not ext_call.success:
                              revert with SafeTransferFromFailed()
                          if not return_data.size:
                              if ext_code.size(address(r)) <= 0:
                                  revert with SafeTransferFromFailed()
                          else:
                              if return_data.size <= 31 or ext_call.return_data[0] != 1:
                                  revert with SafeTransferFromFailed()
                      else:
                          if not Mask(1, 252, cd[292]):
                              call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args flagsAndAmount, caller, cd[164]
                              if not ext_call.success:
                                  revert with SafeTransferFromFailed()
                              if return_data.size:
                          else:
                              call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args address(flagsAndAmount), this.address, cd[164]
                              if not ext_call.success:
                                  revert with ext_call.return_data[0 len return_data.size]
                              require return_data.size >=′ 32
                              require ext_call.return_data[0] == bool(ext_call.return_data[0])
              else:
                  if block.timestamp > uint64(order):
                      revert with OrderExpired()
                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                      revert with InvalidatedOrder()
                  invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                  if -Mask(252, 0, cd[292]):
                      if Mask(1, 255, cd[292]):
                          if Mask(252, 0, cd[292]) > cd[164]:
                              revert with MakingAmountExceeded()
                          if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                              revert with 0, 17
                          if cd[196] * Mask(252, 0, cd[292]) > cd[164] + (cd[196] * Mask(252, 0, cd[292])):
                              revert with 0, 17
                      else:
                          if Mask(252, 0, cd[292]) > cd[196]:
                              revert with TakingAmountExceeded()
                          if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                              revert with 0, 17
                          if not cd[196]:
                              revert with 0, 18
                  else:
                      if not cd[164]:
                          revert with RFQSwapWithZeroAmount()
                      if not cd[196]:
                          revert with RFQSwapWithZeroAmount()
                      if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                          call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                               gas gas_remaining wei
                              args flagsAndAmount, caller, cd[164]
                          if not ext_call.success:
                              revert with SafeTransferFromFailed()
                          if return_data.size:
                      else:
                          if not Mask(1, 252, cd[292]):
                              call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args flagsAndAmount, caller, cd[164]
                              if not ext_call.success:
                                  revert with SafeTransferFromFailed()
                          else:
                              call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args address(flagsAndAmount), this.address, cd[164]
                              if not ext_call.success:
                                  revert with ext_call.return_data[0 len return_data.size]
                              require return_data.size >=′ 32
                              require ext_call.return_data[0] == bool(ext_call.return_data[0])
          else:
              if Mask(64, 64, order):
                  if block.timestamp > uint64(order):
                      revert with OrderExpired()
                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                      revert with InvalidatedOrder()
                  invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                  if -Mask(252, 0, cd[292]):
                      if Mask(1, 255, cd[292]):
                          if Mask(252, 0, cd[292]) > cd[164]:
                              revert with MakingAmountExceeded()
                          if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                              revert with 0, 17
                          if cd[196] * Mask(252, 0, cd[292]) > cd[164] + (cd[196] * Mask(252, 0, cd[292])):
                              revert with 0, 17
                      else:
                          if Mask(252, 0, cd[292]) > cd[196]:
                              revert with TakingAmountExceeded()
                          if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                              revert with 0, 17
                          if not cd[196]:
                              revert with 0, 18
                  else:
                      if not cd[164]:
                          revert with RFQSwapWithZeroAmount()
                      if not cd[196]:
                          revert with RFQSwapWithZeroAmount()
                      if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                          call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                               gas gas_remaining wei
                              args flagsAndAmount, caller, cd[164]
                          if not ext_call.success:
                              revert with SafeTransferFromFailed()
                          if not return_data.size:
                              if ext_code.size(address(r)) <= 0:
                                  revert with SafeTransferFromFailed()
                          else:
                              if return_data.size <= 31 or ext_call.return_data[0] != 1:
                                  revert with SafeTransferFromFailed()
                      else:
                          if not Mask(1, 252, cd[292]):
                              call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args flagsAndAmount, caller, cd[164]
                              if not ext_call.success:
                                  revert with SafeTransferFromFailed()
                              if return_data.size:
                          else:
                              call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args address(flagsAndAmount), this.address, cd[164]
                              if not ext_call.success:
                                  revert with ext_call.return_data[0 len return_data.size]
                              require return_data.size >=′ 32
                              require ext_call.return_data[0] == bool(ext_call.return_data[0])
              else:
                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                      revert with InvalidatedOrder()
                  invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                  if -Mask(252, 0, cd[292]):
                      if Mask(1, 255, cd[292]):
                          if Mask(252, 0, cd[292]) > cd[164]:
                              revert with MakingAmountExceeded()
                          if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                              revert with 0, 17
                          if cd[196] * Mask(252, 0, cd[292]) > cd[164] + (cd[196] * Mask(252, 0, cd[292])):
                              revert with 0, 17
                      else:
                          if Mask(252, 0, cd[292]) > cd[196]:
                              revert with TakingAmountExceeded()
                          if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                              revert with 0, 17
                          if not cd[196]:
                              revert with 0, 18
                          if not cd[164] * Mask(252, 0, cd[292]) / cd[196]:
                              revert with RFQSwapWithZeroAmount()
                  else:
                      if not cd[164]:
                          revert with RFQSwapWithZeroAmount()
                      if not cd[196]:
                          revert with RFQSwapWithZeroAmount()
                      if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                          call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                               gas gas_remaining wei
                              args flagsAndAmount, caller, cd[164]
                          if not ext_call.success:
                              revert with SafeTransferFromFailed()
                          if not return_data.size:
                              if ext_code.size(address(r)) <= 0:
                                  revert with SafeTransferFromFailed()
                          else:
                              if return_data.size <= 31 or ext_call.return_data[0] != 1:
                                  revert with SafeTransferFromFailed()
                      else:
                          if not Mask(1, 252, cd[292]):
                              call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args flagsAndAmount, caller, cd[164]
                              if not ext_call.success:
                                  revert with SafeTransferFromFailed()
                              if not return_data.size:
                                  if ext_code.size(address(r)) <= 0:
                                      revert with SafeTransferFromFailed()
                              else:
                                  if return_data.size <= 31 or ext_call.return_data[0] != 1:
                                      revert with SafeTransferFromFailed()
                          else:
                              call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args address(flagsAndAmount), this.address, cd[164]
                              if not ext_call.success:
                                  revert with ext_call.return_data[0 len return_data.size]
                              require return_data.size >=′ 32
                              require ext_call.return_data[0] == bool(ext_call.return_data[0])
                              require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
                              call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.withdraw(uint256 amount) with:
                                   gas gas_remaining wei
                                  args cd[164]
  else:
      if 1 != chainid:
          if not Mask(1, 254, cd[292]):
              if not address(flagsAndAmount):
                  revert with RFQBadSignature()
              if uint255(cd[260]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                  if not -address(flagsAndAmount):
                      if not caller:
                          revert with RFQZeroTargetIsForbidden()
                      if not address(cd[132]):
                          if not Mask(64, 64, order):
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[292]):
                                  if not Mask(1, 255, cd[292]):
                                      if Mask(252, 0, cd[292]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                      if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                                      if not cd[196]:
                                          revert with 0, 18
                                  else:
                                      if Mask(252, 0, cd[292]) > cd[164]:
                                          revert with MakingAmountExceeded()
                                      if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                                      if cd[196] * Mask(252, 0, cd[292]) > cd[164] + (cd[196] * Mask(252, 0, cd[292])):
                                          revert with 0, 17
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                                  if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                      call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args flagsAndAmount, caller, cd[164]
                                      if not ext_call.success:
                                          revert with SafeTransferFromFailed()
                                  else:
                                      if not Mask(1, 252, cd[292]):
                                          call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args flagsAndAmount, caller, cd[164]
                                          if ext_call.success:
                                      else:
                                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args address(flagsAndAmount), this.address, cd[164]
                                          if not ext_call.success:
                                              revert with ext_call.return_data[0 len return_data.size]
                          else:
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[292]):
                                  if not Mask(1, 255, cd[292]):
                                      if Mask(252, 0, cd[292]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                      if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                                      if not cd[196]:
                                          revert with 0, 18
                                  else:
                                      if Mask(252, 0, cd[292]) > cd[164]:
                                          revert with MakingAmountExceeded()
                                      if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                                  if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                      call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args flagsAndAmount, caller, cd[164]
                                      if ext_call.success:
                                  else:
                                      if not Mask(1, 252, cd[292]):
                                          call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args flagsAndAmount, caller, cd[164]
                                      else:
                                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args address(flagsAndAmount), this.address, cd[164]
                                          if not ext_call.success:
                                              revert with ext_call.return_data[0 len return_data.size]
                      else:
                          if address(cd[132]) != caller:
                              revert with RFQPrivateOrder()
                          if not Mask(64, 64, order):
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[292]):
                                  if not Mask(1, 255, cd[292]):
                                      if Mask(252, 0, cd[292]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                      if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                                      if not cd[196]:
                                          revert with 0, 18
                                  else:
                                      if Mask(252, 0, cd[292]) > cd[164]:
                                          revert with MakingAmountExceeded()
                                      if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                                  if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                      call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args flagsAndAmount, caller, cd[164]
                                      if ext_call.success:
                                  else:
                                      if not Mask(1, 252, cd[292]):
                                          call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args flagsAndAmount, caller, cd[164]
                                      else:
                                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args address(flagsAndAmount), this.address, cd[164]
                                          if not ext_call.success:
                                              revert with ext_call.return_data[0 len return_data.size]
                          else:
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[292]):
                                  if not Mask(1, 255, cd[292]):
                                      if Mask(252, 0, cd[292]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                      if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                                  else:
                                      if Mask(252, 0, cd[292]) > cd[164]:
                                          revert with MakingAmountExceeded()
                                      if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                                  if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                      call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args flagsAndAmount, caller, cd[164]
                                  else:
                                      if Mask(1, 252, cd[292]):
                                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args address(flagsAndAmount), this.address, cd[164]
                  else:
                      static call flagsAndAmount.isValidSignature(bytes32 , bytes ) with:
                              gas gas_remaining wei
                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, r, vs, flagsAndAmount, cd[132], cd[164], cd[196])), 64, 64, cd[228], cd[260]
                      if not ext_call.success:
                          revert with RFQBadSignature()
                      if return_data.size != 32 or ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000:
                          revert with RFQBadSignature()
                      if not caller:
                          revert with RFQZeroTargetIsForbidden()
                      if address(cd[132]):
                          if address(cd[132]) != caller:
                              revert with RFQPrivateOrder()
                          if not Mask(64, 64, order):
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[292]):
                                  if not Mask(1, 255, cd[292]):
                                      if Mask(252, 0, cd[292]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                      if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                                  else:
                                      if Mask(252, 0, cd[292]) > cd[164]:
                                          revert with MakingAmountExceeded()
                                      if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                                  if address(r) == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                          else:
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[292]):
                                  if not Mask(1, 255, cd[292]):
                                      if Mask(252, 0, cd[292]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                  else:
                                      if Mask(252, 0, cd[292]) > cd[164]:
                                          revert with MakingAmountExceeded()
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                      else:
                          if Mask(64, 64, order):
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[292]):
                                  if not Mask(1, 255, cd[292]):
                                      if Mask(252, 0, cd[292]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                      if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                                  else:
                                      if Mask(252, 0, cd[292]) > cd[164]:
                                          revert with MakingAmountExceeded()
                                      if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                                  if address(r) == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                          else:
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[292]):
                                  if not Mask(1, 255, cd[292]):
                                      if Mask(252, 0, cd[292]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                      if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                                  else:
                                      if Mask(252, 0, cd[292]) > cd[164]:
                                          revert with MakingAmountExceeded()
                                      if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                                  if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                      call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args flagsAndAmount, caller, cd[164]
                                  else:
                                      if Mask(1, 252, cd[292]):
                                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args address(flagsAndAmount), this.address, cd[164]
              else:
                  signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, r, vs, flagsAndAmount, cd[132], cd[164], cd[196])), (bool(cd[260]) >> 255) + 27, cd[228], uint255(cd[260])) # precompiled
                  if not address(signer) - address(flagsAndAmount):
                      if not caller:
                          revert with RFQZeroTargetIsForbidden()
                      if not address(cd[132]):
                          if not Mask(64, 64, order):
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[292]):
                                  if not Mask(1, 255, cd[292]):
                                      if Mask(252, 0, cd[292]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                      if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                                      if not cd[196]:
                                          revert with 0, 18
                                  else:
                                      if Mask(252, 0, cd[292]) > cd[164]:
                                          revert with MakingAmountExceeded()
                                      if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                                      if cd[196] * Mask(252, 0, cd[292]) > cd[164] + (cd[196] * Mask(252, 0, cd[292])):
                                          revert with 0, 17
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                                  if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                      call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args flagsAndAmount, caller, cd[164]
                                      if not ext_call.success:
                                          revert with SafeTransferFromFailed()
                                  else:
                                      if not Mask(1, 252, cd[292]):
                                          call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args flagsAndAmount, caller, cd[164]
                                          if ext_call.success:
                                      else:
                                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args address(flagsAndAmount), this.address, cd[164]
                                          if not ext_call.success:
                                              revert with ext_call.return_data[0 len return_data.size]
                          else:
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[292]):
                                  if not Mask(1, 255, cd[292]):
                                      if Mask(252, 0, cd[292]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                      if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                                      if not cd[196]:
                                          revert with 0, 18
                                  else:
                                      if Mask(252, 0, cd[292]) > cd[164]:
                                          revert with MakingAmountExceeded()
                                      if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                                  if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                      call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args flagsAndAmount, caller, cd[164]
                                      if ext_call.success:
                                  else:
                                      if not Mask(1, 252, cd[292]):
                                          call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args flagsAndAmount, caller, cd[164]
                                      else:
                                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args address(flagsAndAmount), this.address, cd[164]
                                          if not ext_call.success:
                                              revert with ext_call.return_data[0 len return_data.size]
                      else:
                          if address(cd[132]) != caller:
                              revert with RFQPrivateOrder()
                          if not Mask(64, 64, order):
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[292]):
                                  if not Mask(1, 255, cd[292]):
                                      if Mask(252, 0, cd[292]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                      if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                                      if not cd[196]:
                                          revert with 0, 18
                                  else:
                                      if Mask(252, 0, cd[292]) > cd[164]:
                                          revert with MakingAmountExceeded()
                                      if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                                  if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                      call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args flagsAndAmount, caller, cd[164]
                                      if ext_call.success:
                                  else:
                                      if not Mask(1, 252, cd[292]):
                                          call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args flagsAndAmount, caller, cd[164]
                                      else:
                                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args address(flagsAndAmount), this.address, cd[164]
                                          if not ext_call.success:
                                              revert with ext_call.return_data[0 len return_data.size]
                          else:
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[292]):
                                  if not Mask(1, 255, cd[292]):
                                      if Mask(252, 0, cd[292]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                      if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                                  else:
                                      if Mask(252, 0, cd[292]) > cd[164]:
                                          revert with MakingAmountExceeded()
                                      if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                                  if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                      call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args flagsAndAmount, caller, cd[164]
                                  else:
                                      if Mask(1, 252, cd[292]):
                                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args address(flagsAndAmount), this.address, cd[164]
                  else:
                      static call flagsAndAmount.isValidSignature(bytes32 , bytes ) with:
                              gas gas_remaining wei
                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, r, vs, flagsAndAmount, cd[132], cd[164], cd[196])), 64, 64, cd[228], cd[260]
                      if not ext_call.success:
                          revert with RFQBadSignature()
                      if return_data.size != 32 or ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000:
                          revert with RFQBadSignature()
                      if not caller:
                          revert with RFQZeroTargetIsForbidden()
                      if address(cd[132]):
                          if address(cd[132]) != caller:
                              revert with RFQPrivateOrder()
                          if not Mask(64, 64, order):
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[292]):
                                  if not Mask(1, 255, cd[292]):
                                      if Mask(252, 0, cd[292]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                      if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                                  else:
                                      if Mask(252, 0, cd[292]) > cd[164]:
                                          revert with MakingAmountExceeded()
                                      if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                                  if address(r) == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                          else:
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[292]):
                                  if not Mask(1, 255, cd[292]):
                                      if Mask(252, 0, cd[292]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                  else:
                                      if Mask(252, 0, cd[292]) > cd[164]:
                                          revert with MakingAmountExceeded()
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                      else:
                          if Mask(64, 64, order):
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[292]):
                                  if not Mask(1, 255, cd[292]):
                                      if Mask(252, 0, cd[292]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                      if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                                  else:
                                      if Mask(252, 0, cd[292]) > cd[164]:
                                          revert with MakingAmountExceeded()
                                      if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                                  if address(r) == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                          else:
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[292]):
                                  if not Mask(1, 255, cd[292]):
                                      if Mask(252, 0, cd[292]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                      if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                                  else:
                                      if Mask(252, 0, cd[292]) > cd[164]:
                                          revert with MakingAmountExceeded()
                                      if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                                  if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                      call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args flagsAndAmount, caller, cd[164]
                                  else:
                                      if Mask(1, 252, cd[292]):
                                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args address(flagsAndAmount), this.address, cd[164]
          else:
              if not Mask(1, 253, cd[292]):
                  static call flagsAndAmount.isValidSignature(bytes32 , bytes ) with:
                          gas gas_remaining wei
                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, r, vs, flagsAndAmount, cd[132], cd[164], cd[196])), 64, 64, cd[228], cd[260]
              else:
                  static call flagsAndAmount.isValidSignature(bytes32 , bytes ) with:
                          gas gas_remaining wei
                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, r, vs, flagsAndAmount, cd[132], cd[164], cd[196])), Array(len=65, data=cd[228], 2 * cd[260], Mask(8, 248, (bool(cd[260]) >> 255) + 27) >> 248)
              if not ext_call.success:
                  revert with RFQBadSignature()
              if return_data.size != 32 or ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000:
                  revert with RFQBadSignature()
              if not caller:
                  revert with RFQZeroTargetIsForbidden()
              if not address(cd[132]):
                  if not Mask(64, 64, order):
                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                          revert with InvalidatedOrder()
                      invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                      if -Mask(252, 0, cd[292]):
                          if Mask(1, 255, cd[292]):
                              if Mask(252, 0, cd[292]) > cd[164]:
                                  revert with MakingAmountExceeded()
                              if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                  revert with 0, 17
                              if cd[196] * Mask(252, 0, cd[292]) > cd[164] + (cd[196] * Mask(252, 0, cd[292])):
                                  revert with 0, 17
                          else:
                              if Mask(252, 0, cd[292]) > cd[196]:
                                  revert with TakingAmountExceeded()
                              if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                  revert with 0, 17
                              if not cd[196]:
                                  revert with 0, 18
                      else:
                          if not cd[164]:
                              revert with RFQSwapWithZeroAmount()
                          if not cd[196]:
                              revert with RFQSwapWithZeroAmount()
                          if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                              call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args flagsAndAmount, caller, cd[164]
                              if not ext_call.success:
                                  revert with SafeTransferFromFailed()
                              if not return_data.size:
                                  if ext_code.size(address(r)) <= 0:
                                      revert with SafeTransferFromFailed()
                              else:
                                  if return_data.size <= 31 or ext_call.return_data[0] != 1:
                                      revert with SafeTransferFromFailed()
                          else:
                              if not Mask(1, 252, cd[292]):
                                  call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args flagsAndAmount, caller, cd[164]
                                  if not ext_call.success:
                                      revert with SafeTransferFromFailed()
                                  if return_data.size:
                              else:
                                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args address(flagsAndAmount), this.address, cd[164]
                                  if not ext_call.success:
                                      revert with ext_call.return_data[0 len return_data.size]
                                  require return_data.size >=′ 32
                                  require ext_call.return_data[0] == bool(ext_call.return_data[0])
                  else:
                      if block.timestamp > uint64(order):
                          revert with OrderExpired()
                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                          revert with InvalidatedOrder()
                      invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                      if -Mask(252, 0, cd[292]):
                          if Mask(1, 255, cd[292]):
                              if Mask(252, 0, cd[292]) > cd[164]:
                                  revert with MakingAmountExceeded()
                              if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                  revert with 0, 17
                              if cd[196] * Mask(252, 0, cd[292]) > cd[164] + (cd[196] * Mask(252, 0, cd[292])):
                                  revert with 0, 17
                          else:
                              if Mask(252, 0, cd[292]) > cd[196]:
                                  revert with TakingAmountExceeded()
                              if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                  revert with 0, 17
                              if not cd[196]:
                                  revert with 0, 18
                      else:
                          if not cd[164]:
                              revert with RFQSwapWithZeroAmount()
                          if not cd[196]:
                              revert with RFQSwapWithZeroAmount()
                          if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                              call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args flagsAndAmount, caller, cd[164]
                              if not ext_call.success:
                                  revert with SafeTransferFromFailed()
                              if return_data.size:
                          else:
                              if not Mask(1, 252, cd[292]):
                                  call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args flagsAndAmount, caller, cd[164]
                                  if not ext_call.success:
                                      revert with SafeTransferFromFailed()
                              else:
                                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args address(flagsAndAmount), this.address, cd[164]
                                  if not ext_call.success:
                                      revert with ext_call.return_data[0 len return_data.size]
                                  require return_data.size >=′ 32
                                  require ext_call.return_data[0] == bool(ext_call.return_data[0])
              else:
                  if address(cd[132]) != caller:
                      revert with RFQPrivateOrder()
                  if not Mask(64, 64, order):
                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                          revert with InvalidatedOrder()
                      invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                      if -Mask(252, 0, cd[292]):
                          if Mask(1, 255, cd[292]):
                              if Mask(252, 0, cd[292]) > cd[164]:
                                  revert with MakingAmountExceeded()
                              if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                  revert with 0, 17
                              if cd[196] * Mask(252, 0, cd[292]) > cd[164] + (cd[196] * Mask(252, 0, cd[292])):
                                  revert with 0, 17
                          else:
                              if Mask(252, 0, cd[292]) > cd[196]:
                                  revert with TakingAmountExceeded()
                              if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                  revert with 0, 17
                              if not cd[196]:
                                  revert with 0, 18
                      else:
                          if not cd[164]:
                              revert with RFQSwapWithZeroAmount()
                          if not cd[196]:
                              revert with RFQSwapWithZeroAmount()
                          if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                              call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args flagsAndAmount, caller, cd[164]
                              if not ext_call.success:
                                  revert with SafeTransferFromFailed()
                              if return_data.size:
                          else:
                              if not Mask(1, 252, cd[292]):
                                  call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args flagsAndAmount, caller, cd[164]
                                  if not ext_call.success:
                                      revert with SafeTransferFromFailed()
                              else:
                                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args address(flagsAndAmount), this.address, cd[164]
                                  if not ext_call.success:
                                      revert with ext_call.return_data[0 len return_data.size]
                                  require return_data.size >=′ 32
                                  require ext_call.return_data[0] == bool(ext_call.return_data[0])
                  else:
                      if block.timestamp > uint64(order):
                          revert with OrderExpired()
                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                          revert with InvalidatedOrder()
                      invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                      if -Mask(252, 0, cd[292]):
                          if not Mask(1, 255, cd[292]):
                              if Mask(252, 0, cd[292]) > cd[196]:
                                  revert with TakingAmountExceeded()
                              if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                  revert with 0, 17
                              if not cd[196]:
                                  revert with 0, 18
                          else:
                              if Mask(252, 0, cd[292]) > cd[164]:
                                  revert with MakingAmountExceeded()
                              if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                  revert with 0, 17
                              if cd[196] * Mask(252, 0, cd[292]) > cd[164] + (cd[196] * Mask(252, 0, cd[292])):
                                  revert with 0, 17
                      else:
                          if not cd[164]:
                              revert with RFQSwapWithZeroAmount()
                          if not cd[196]:
                              revert with RFQSwapWithZeroAmount()
                          if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                              call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args flagsAndAmount, caller, cd[164]
                              if not ext_call.success:
                                  revert with SafeTransferFromFailed()
                          else:
                              if not Mask(1, 252, cd[292]):
                                  call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args flagsAndAmount, caller, cd[164]
                                  if not ext_call.success:
                                      revert with SafeTransferFromFailed()
                              else:
                                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args address(flagsAndAmount), this.address, cd[164]
                                  if not ext_call.success:
                                      revert with ext_call.return_data[0 len return_data.size]
                                  require return_data.size >=′ 32
      else:
          if not Mask(1, 254, cd[292]):
              if not address(flagsAndAmount):
                  revert with RFQBadSignature()
              if uint255(cd[260]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                  if not -address(flagsAndAmount):
                      if not caller:
                          revert with RFQZeroTargetIsForbidden()
                      if not address(cd[132]):
                          if not Mask(64, 64, order):
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[292]):
                                  if not Mask(1, 255, cd[292]):
                                      if Mask(252, 0, cd[292]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                      if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                                      if not cd[196]:
                                          revert with 0, 18
                                  else:
                                      if Mask(252, 0, cd[292]) > cd[164]:
                                          revert with MakingAmountExceeded()
                                      if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                                      if cd[196] * Mask(252, 0, cd[292]) > cd[164] + (cd[196] * Mask(252, 0, cd[292])):
                                          revert with 0, 17
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                                  if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                      call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args flagsAndAmount, caller, cd[164]
                                      if not ext_call.success:
                                          revert with SafeTransferFromFailed()
                                  else:
                                      if not Mask(1, 252, cd[292]):
                                          call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args flagsAndAmount, caller, cd[164]
                                          if ext_call.success:
                                      else:
                                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args address(flagsAndAmount), this.address, cd[164]
                                          if not ext_call.success:
                                              revert with ext_call.return_data[0 len return_data.size]
                          else:
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[292]):
                                  if not Mask(1, 255, cd[292]):
                                      if Mask(252, 0, cd[292]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                      if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                                      if not cd[196]:
                                          revert with 0, 18
                                  else:
                                      if Mask(252, 0, cd[292]) > cd[164]:
                                          revert with MakingAmountExceeded()
                                      if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                                  if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                      call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args flagsAndAmount, caller, cd[164]
                                      if ext_call.success:
                                  else:
                                      if not Mask(1, 252, cd[292]):
                                          call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args flagsAndAmount, caller, cd[164]
                                      else:
                                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args address(flagsAndAmount), this.address, cd[164]
                                          if not ext_call.success:
                                              revert with ext_call.return_data[0 len return_data.size]
                      else:
                          if address(cd[132]) != caller:
                              revert with RFQPrivateOrder()
                          if not Mask(64, 64, order):
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[292]):
                                  if not Mask(1, 255, cd[292]):
                                      if Mask(252, 0, cd[292]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                      if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                                      if not cd[196]:
                                          revert with 0, 18
                                  else:
                                      if Mask(252, 0, cd[292]) > cd[164]:
                                          revert with MakingAmountExceeded()
                                      if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                                  if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                      call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args flagsAndAmount, caller, cd[164]
                                      if ext_call.success:
                                  else:
                                      if not Mask(1, 252, cd[292]):
                                          call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args flagsAndAmount, caller, cd[164]
                                      else:
                                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args address(flagsAndAmount), this.address, cd[164]
                                          if not ext_call.success:
                                              revert with ext_call.return_data[0 len return_data.size]
                          else:
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[292]):
                                  if not Mask(1, 255, cd[292]):
                                      if Mask(252, 0, cd[292]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                      if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                                  else:
                                      if Mask(252, 0, cd[292]) > cd[164]:
                                          revert with MakingAmountExceeded()
                                      if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                                  if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                      call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args flagsAndAmount, caller, cd[164]
                                  else:
                                      if Mask(1, 252, cd[292]):
                                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args address(flagsAndAmount), this.address, cd[164]
                  else:
                      static call flagsAndAmount.isValidSignature(bytes32 , bytes ) with:
                              gas gas_remaining wei
                             args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, r, vs, flagsAndAmount, cd[132], cd[164], cd[196])), 64, 64, cd[228], cd[260]
                      if not ext_call.success:
                          revert with RFQBadSignature()
                      if return_data.size != 32 or ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000:
                          revert with RFQBadSignature()
                      if not caller:
                          revert with RFQZeroTargetIsForbidden()
                      if address(cd[132]):
                          if address(cd[132]) != caller:
                              revert with RFQPrivateOrder()
                          if not Mask(64, 64, order):
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[292]):
                                  if not Mask(1, 255, cd[292]):
                                      if Mask(252, 0, cd[292]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                      if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                                  else:
                                      if Mask(252, 0, cd[292]) > cd[164]:
                                          revert with MakingAmountExceeded()
                                      if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                                  if address(r) == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                          else:
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[292]):
                                  if not Mask(1, 255, cd[292]):
                                      if Mask(252, 0, cd[292]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                  else:
                                      if Mask(252, 0, cd[292]) > cd[164]:
                                          revert with MakingAmountExceeded()
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                      else:
                          if Mask(64, 64, order):
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[292]):
                                  if not Mask(1, 255, cd[292]):
                                      if Mask(252, 0, cd[292]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                      if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                                  else:
                                      if Mask(252, 0, cd[292]) > cd[164]:
                                          revert with MakingAmountExceeded()
                                      if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                                  if address(r) == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                          else:
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[292]):
                                  if not Mask(1, 255, cd[292]):
                                      if Mask(252, 0, cd[292]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                      if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                                  else:
                                      if Mask(252, 0, cd[292]) > cd[164]:
                                          revert with MakingAmountExceeded()
                                      if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                                  if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                      call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args flagsAndAmount, caller, cd[164]
                                  else:
                                      if Mask(1, 252, cd[292]):
                                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args address(flagsAndAmount), this.address, cd[164]
              else:
                  signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, r, vs, flagsAndAmount, cd[132], cd[164], cd[196])), (bool(cd[260]) >> 255) + 27, cd[228], uint255(cd[260])) # precompiled
                  if not address(signer) - address(flagsAndAmount):
                      if not caller:
                          revert with RFQZeroTargetIsForbidden()
                      if not address(cd[132]):
                          if not Mask(64, 64, order):
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[292]):
                                  if not Mask(1, 255, cd[292]):
                                      if Mask(252, 0, cd[292]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                      if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                                      if not cd[196]:
                                          revert with 0, 18
                                  else:
                                      if Mask(252, 0, cd[292]) > cd[164]:
                                          revert with MakingAmountExceeded()
                                      if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                                      if cd[196] * Mask(252, 0, cd[292]) > cd[164] + (cd[196] * Mask(252, 0, cd[292])):
                                          revert with 0, 17
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                                  if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                      call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args flagsAndAmount, caller, cd[164]
                                      if not ext_call.success:
                                          revert with SafeTransferFromFailed()
                                  else:
                                      if not Mask(1, 252, cd[292]):
                                          call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args flagsAndAmount, caller, cd[164]
                                          if ext_call.success:
                                      else:
                                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args address(flagsAndAmount), this.address, cd[164]
                                          if not ext_call.success:
                                              revert with ext_call.return_data[0 len return_data.size]
                          else:
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[292]):
                                  if not Mask(1, 255, cd[292]):
                                      if Mask(252, 0, cd[292]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                      if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                                      if not cd[196]:
                                          revert with 0, 18
                                  else:
                                      if Mask(252, 0, cd[292]) > cd[164]:
                                          revert with MakingAmountExceeded()
                                      if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                                  if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                      call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args flagsAndAmount, caller, cd[164]
                                      if ext_call.success:
                                  else:
                                      if not Mask(1, 252, cd[292]):
                                          call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args flagsAndAmount, caller, cd[164]
                                      else:
                                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args address(flagsAndAmount), this.address, cd[164]
                                          if not ext_call.success:
                                              revert with ext_call.return_data[0 len return_data.size]
                      else:
                          if address(cd[132]) != caller:
                              revert with RFQPrivateOrder()
                          if not Mask(64, 64, order):
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[292]):
                                  if not Mask(1, 255, cd[292]):
                                      if Mask(252, 0, cd[292]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                      if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                                      if not cd[196]:
                                          revert with 0, 18
                                  else:
                                      if Mask(252, 0, cd[292]) > cd[164]:
                                          revert with MakingAmountExceeded()
                                      if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                                  if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                      call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args flagsAndAmount, caller, cd[164]
                                      if ext_call.success:
                                  else:
                                      if not Mask(1, 252, cd[292]):
                                          call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args flagsAndAmount, caller, cd[164]
                                      else:
                                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args address(flagsAndAmount), this.address, cd[164]
                                          if not ext_call.success:
                                              revert with ext_call.return_data[0 len return_data.size]
                          else:
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[292]):
                                  if not Mask(1, 255, cd[292]):
                                      if Mask(252, 0, cd[292]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                      if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                                  else:
                                      if Mask(252, 0, cd[292]) > cd[164]:
                                          revert with MakingAmountExceeded()
                                      if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                                  if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                      call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args flagsAndAmount, caller, cd[164]
                                  else:
                                      if Mask(1, 252, cd[292]):
                                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args address(flagsAndAmount), this.address, cd[164]
                  else:
                      static call flagsAndAmount.isValidSignature(bytes32 , bytes ) with:
                              gas gas_remaining wei
                             args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, r, vs, flagsAndAmount, cd[132], cd[164], cd[196])), 64, 64, cd[228], cd[260]
                      if not ext_call.success:
                          revert with RFQBadSignature()
                      if return_data.size != 32 or ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000:
                          revert with RFQBadSignature()
                      if not caller:
                          revert with RFQZeroTargetIsForbidden()
                      if address(cd[132]):
                          if address(cd[132]) != caller:
                              revert with RFQPrivateOrder()
                          if not Mask(64, 64, order):
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[292]):
                                  if not Mask(1, 255, cd[292]):
                                      if Mask(252, 0, cd[292]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                      if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                                  else:
                                      if Mask(252, 0, cd[292]) > cd[164]:
                                          revert with MakingAmountExceeded()
                                      if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                                  if address(r) == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                          else:
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[292]):
                                  if not Mask(1, 255, cd[292]):
                                      if Mask(252, 0, cd[292]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                  else:
                                      if Mask(252, 0, cd[292]) > cd[164]:
                                          revert with MakingAmountExceeded()
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                      else:
                          if Mask(64, 64, order):
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[292]):
                                  if not Mask(1, 255, cd[292]):
                                      if Mask(252, 0, cd[292]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                      if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                                  else:
                                      if Mask(252, 0, cd[292]) > cd[164]:
                                          revert with MakingAmountExceeded()
                                      if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                                  if address(r) == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                          else:
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[292]):
                                  if not Mask(1, 255, cd[292]):
                                      if Mask(252, 0, cd[292]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                      if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                                  else:
                                      if Mask(252, 0, cd[292]) > cd[164]:
                                          revert with MakingAmountExceeded()
                                      if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                          revert with 0, 17
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                                  if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                      call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args flagsAndAmount, caller, cd[164]
                                  else:
                                      if Mask(1, 252, cd[292]):
                                          call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                               gas gas_remaining wei
                                              args address(flagsAndAmount), this.address, cd[164]
          else:
              if not Mask(1, 253, cd[292]):
                  static call flagsAndAmount.isValidSignature(bytes32 , bytes ) with:
                          gas gas_remaining wei
                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, r, vs, flagsAndAmount, cd[132], cd[164], cd[196])), 64, 64, cd[228], cd[260]
              else:
                  static call flagsAndAmount.isValidSignature(bytes32 , bytes ) with:
                          gas gas_remaining wei
                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, r, vs, flagsAndAmount, cd[132], cd[164], cd[196])), Array(len=65, data=cd[228], 2 * cd[260], Mask(8, 248, (bool(cd[260]) >> 255) + 27) >> 248)
              if not ext_call.success:
                  revert with RFQBadSignature()
              if return_data.size != 32 or ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000:
                  revert with RFQBadSignature()
              if not caller:
                  revert with RFQZeroTargetIsForbidden()
              if not address(cd[132]):
                  if not Mask(64, 64, order):
                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                          revert with InvalidatedOrder()
                      invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                      if -Mask(252, 0, cd[292]):
                          if Mask(1, 255, cd[292]):
                              if Mask(252, 0, cd[292]) > cd[164]:
                                  revert with MakingAmountExceeded()
                              if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                  revert with 0, 17
                              if cd[196] * Mask(252, 0, cd[292]) > cd[164] + (cd[196] * Mask(252, 0, cd[292])):
                                  revert with 0, 17
                          else:
                              if Mask(252, 0, cd[292]) > cd[196]:
                                  revert with TakingAmountExceeded()
                              if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                  revert with 0, 17
                              if not cd[196]:
                                  revert with 0, 18
                      else:
                          if not cd[164]:
                              revert with RFQSwapWithZeroAmount()
                          if not cd[196]:
                              revert with RFQSwapWithZeroAmount()
                          if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                              call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args flagsAndAmount, caller, cd[164]
                              if not ext_call.success:
                                  revert with SafeTransferFromFailed()
                              if not return_data.size:
                                  if ext_code.size(address(r)) <= 0:
                                      revert with SafeTransferFromFailed()
                              else:
                                  if return_data.size <= 31 or ext_call.return_data[0] != 1:
                                      revert with SafeTransferFromFailed()
                          else:
                              if not Mask(1, 252, cd[292]):
                                  call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args flagsAndAmount, caller, cd[164]
                                  if not ext_call.success:
                                      revert with SafeTransferFromFailed()
                                  if return_data.size:
                              else:
                                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args address(flagsAndAmount), this.address, cd[164]
                                  if not ext_call.success:
                                      revert with ext_call.return_data[0 len return_data.size]
                                  require return_data.size >=′ 32
                                  require ext_call.return_data[0] == bool(ext_call.return_data[0])
                  else:
                      if block.timestamp > uint64(order):
                          revert with OrderExpired()
                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                          revert with InvalidatedOrder()
                      invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                      if -Mask(252, 0, cd[292]):
                          if Mask(1, 255, cd[292]):
                              if Mask(252, 0, cd[292]) > cd[164]:
                                  revert with MakingAmountExceeded()
                              if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                  revert with 0, 17
                              if cd[196] * Mask(252, 0, cd[292]) > cd[164] + (cd[196] * Mask(252, 0, cd[292])):
                                  revert with 0, 17
                          else:
                              if Mask(252, 0, cd[292]) > cd[196]:
                                  revert with TakingAmountExceeded()
                              if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                  revert with 0, 17
                              if not cd[196]:
                                  revert with 0, 18
                      else:
                          if not cd[164]:
                              revert with RFQSwapWithZeroAmount()
                          if not cd[196]:
                              revert with RFQSwapWithZeroAmount()
                          if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                              call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args flagsAndAmount, caller, cd[164]
                              if not ext_call.success:
                                  revert with SafeTransferFromFailed()
                              if return_data.size:
                          else:
                              if not Mask(1, 252, cd[292]):
                                  call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args flagsAndAmount, caller, cd[164]
                                  if not ext_call.success:
                                      revert with SafeTransferFromFailed()
                              else:
                                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args address(flagsAndAmount), this.address, cd[164]
                                  if not ext_call.success:
                                      revert with ext_call.return_data[0 len return_data.size]
                                  require return_data.size >=′ 32
                                  require ext_call.return_data[0] == bool(ext_call.return_data[0])
              else:
                  if address(cd[132]) != caller:
                      revert with RFQPrivateOrder()
                  if not Mask(64, 64, order):
                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                          revert with InvalidatedOrder()
                      invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                      if -Mask(252, 0, cd[292]):
                          if Mask(1, 255, cd[292]):
                              if Mask(252, 0, cd[292]) > cd[164]:
                                  revert with MakingAmountExceeded()
                              if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                  revert with 0, 17
                              if cd[196] * Mask(252, 0, cd[292]) > cd[164] + (cd[196] * Mask(252, 0, cd[292])):
                                  revert with 0, 17
                          else:
                              if Mask(252, 0, cd[292]) > cd[196]:
                                  revert with TakingAmountExceeded()
                              if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                  revert with 0, 17
                              if not cd[196]:
                                  revert with 0, 18
                      else:
                          if not cd[164]:
                              revert with RFQSwapWithZeroAmount()
                          if not cd[196]:
                              revert with RFQSwapWithZeroAmount()
                          if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                              call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args flagsAndAmount, caller, cd[164]
                              if not ext_call.success:
                                  revert with SafeTransferFromFailed()
                              if return_data.size:
                          else:
                              if not Mask(1, 252, cd[292]):
                                  call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args flagsAndAmount, caller, cd[164]
                                  if not ext_call.success:
                                      revert with SafeTransferFromFailed()
                              else:
                                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args address(flagsAndAmount), this.address, cd[164]
                                  if not ext_call.success:
                                      revert with ext_call.return_data[0 len return_data.size]
                                  require return_data.size >=′ 32
                                  require ext_call.return_data[0] == bool(ext_call.return_data[0])
                  else:
                      if block.timestamp > uint64(order):
                          revert with OrderExpired()
                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                          revert with InvalidatedOrder()
                      invalidatorForOrderRFQ[address(flagsAndAmount)][Mask(56, 8, order) << 192] = 1
                      if -Mask(252, 0, cd[292]):
                          if not Mask(1, 255, cd[292]):
                              if Mask(252, 0, cd[292]) > cd[196]:
                                  revert with TakingAmountExceeded()
                              if cd[164] != cd[164] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                  revert with 0, 17
                              if not cd[196]:
                                  revert with 0, 18
                          else:
                              if Mask(252, 0, cd[292]) > cd[164]:
                                  revert with MakingAmountExceeded()
                              if cd[196] != cd[196] * Mask(252, 0, cd[292]) / Mask(252, 0, cd[292]) and Mask(252, 0, cd[292]):
                                  revert with 0, 17
                              if cd[196] * Mask(252, 0, cd[292]) > cd[164] + (cd[196] * Mask(252, 0, cd[292])):
                                  revert with 0, 17
                      else:
                          if not cd[164]:
                              revert with RFQSwapWithZeroAmount()
                          if not cd[196]:
                              revert with RFQSwapWithZeroAmount()
                          if address(r) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                              call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args flagsAndAmount, caller, cd[164]
                              if not ext_call.success:
                                  revert with SafeTransferFromFailed()
                          else:
                              if not Mask(1, 252, cd[292]):
                                  call address(r).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args flagsAndAmount, caller, cd[164]
                                  if not ext_call.success:
                                      revert with SafeTransferFromFailed()
                              else:
                                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args address(flagsAndAmount), this.address, cd[164]
                                  if not ext_call.success:
                                      revert with ext_call.return_data[0 len return_data.size]
                                  require return_data.size >=′ 32
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def fillOrderRFQTo(tuple order, bytes signature, uint256 flagsAndAmount, address target) payable: 
  require calldata.size - 4 >=′ 320
  require calldata.size - 4 >=′ 224
  require signature == address(signature)
  require flagsAndAmount == address(flagsAndAmount)
  require target == target
  require cd[132] == address(cd[132])
  require cd[228] <= LOCK8605463013()
  require cd[228] + 35 <′ calldata.size
  require ('cd', 228).length <= LOCK8605463013()
  require cd[228] + ('cd', 228).length + 36 <= calldata.size
  require cd[292] == address(cd[292])
  if this.address != 0x1111111254eeb25477b68fb85ed929f73a960582:
      if not Mask(1, 254, cd[260]):
          if not target:
              revert with RFQBadSignature()
          if ('cd', 228).length == 64:
              if ('cd', 228).length == 65:
                  if call.data[cd[228] + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                      if target:
                          static call target.isValidSignature(bytes32 , bytes ) with:
                                  gas gas_remaining wei
                                 args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                          if not ext_call.success:
                              revert with RFQBadSignature()
                          if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                              revert with RFQBadSignature()
                          if not address(cd[292]):
                              revert with RFQZeroTargetIsForbidden()
                          if not address(cd[132]):
                              if Mask(64, 64, order):
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          else:
                              if address(cd[132]) != caller:
                                  revert with RFQPrivateOrder()
                              if not Mask(64, 64, order):
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                              else:
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                      else:
                          if not address(cd[292]):
                              revert with RFQZeroTargetIsForbidden()
                          if not address(cd[132]):
                              if not Mask(64, 64, order):
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                  if -Mask(252, 0, cd[260]):
                                      if not Mask(1, 255, cd[260]):
                                          if Mask(252, 0, cd[260]) > cd[196]:
                                              revert with TakingAmountExceeded()
                                      else:
                                          if Mask(252, 0, cd[260]) > cd[164]:
                                              revert with MakingAmountExceeded()
                              else:
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                  if -Mask(252, 0, cd[260]):
                                      if Mask(1, 255, cd[260]):
                          else:
                              if address(cd[132]) != caller:
                                  revert with RFQPrivateOrder()
                              if not Mask(64, 64, order):
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                  if -Mask(252, 0, cd[260]):
                                      if Mask(1, 255, cd[260]):
                              else:
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                  if -Mask(252, 0, cd[260]):
                  else:
                      signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) - 256, call.data[cd[228] + 36 len 64]) # precompiled
                      if address(signer) != target:
                          static call target.isValidSignature(bytes32 , bytes ) with:
                                  gas gas_remaining wei
                                 args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                          if not ext_call.success:
                              revert with RFQBadSignature()
                          if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                              revert with RFQBadSignature()
                          if not address(cd[292]):
                              revert with RFQZeroTargetIsForbidden()
                          if not address(cd[132]):
                              if not Mask(64, 64, order):
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                              else:
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                          else:
                              if address(cd[132]) != caller:
                                  revert with RFQPrivateOrder()
                              if Mask(64, 64, order):
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                      else:
                          if not address(cd[292]):
                              revert with RFQZeroTargetIsForbidden()
                          if not address(cd[132]):
                              if not Mask(64, 64, order):
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                  if -Mask(252, 0, cd[260]):
                                      if Mask(1, 255, cd[260]):
                              else:
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                  if -Mask(252, 0, cd[260]):
                          else:
                              if address(cd[132]) != caller:
                                  revert with RFQPrivateOrder()
                              if not Mask(64, 64, order):
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                  if -Mask(252, 0, cd[260]):
                              else:
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
              else:
                  if ('cd', 228).length != 64:
                      if target:
                          static call target.isValidSignature(bytes32 , bytes ) with:
                                  gas gas_remaining wei
                                 args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                          if not ext_call.success:
                              revert with RFQBadSignature()
                          if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                              revert with RFQBadSignature()
                          if not address(cd[292]):
                              revert with RFQZeroTargetIsForbidden()
                          if not address(cd[132]):
                              if Mask(64, 64, order):
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          else:
                              if address(cd[132]) != caller:
                                  revert with RFQPrivateOrder()
                              if not Mask(64, 64, order):
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                              else:
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                      else:
                          if not address(cd[292]):
                              revert with RFQZeroTargetIsForbidden()
                          if not address(cd[132]):
                              if not Mask(64, 64, order):
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                  if -Mask(252, 0, cd[260]):
                                      if not Mask(1, 255, cd[260]):
                                          if Mask(252, 0, cd[260]) > cd[196]:
                                              revert with TakingAmountExceeded()
                                      else:
                                          if Mask(252, 0, cd[260]) > cd[164]:
                                              revert with MakingAmountExceeded()
                              else:
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                  if -Mask(252, 0, cd[260]):
                                      if Mask(1, 255, cd[260]):
                          else:
                              if address(cd[132]) != caller:
                                  revert with RFQPrivateOrder()
                              if not Mask(64, 64, order):
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                  if -Mask(252, 0, cd[260]):
                                      if Mask(1, 255, cd[260]):
                              else:
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                  if -Mask(252, 0, cd[260]):
                  else:
                      if uint255(('cd', 228)[1]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                          if target:
                              static call target.isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with RFQBadSignature()
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                          else:
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                                          if Mask(1, 255, cd[260]):
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                      else:
                          signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), (bool(('cd', 228)[1]) >> 255) + 27, call.data[cd[228] + 36], uint255(('cd', 228)[1])) # precompiled
                          if address(signer) == target:
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          else:
                              static call target.isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with RFQBadSignature()
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if Mask(64, 64, order):
          else:
              if ('cd', 228).length == 65:
                  if call.data[cd[228] + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                      if target:
                          static call target.isValidSignature(bytes32 , bytes ) with:
                                  gas gas_remaining wei
                                 args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                          if not ext_call.success:
                              revert with RFQBadSignature()
                          if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                              revert with RFQBadSignature()
                          if not address(cd[292]):
                              revert with RFQZeroTargetIsForbidden()
                          if not address(cd[132]):
                              if not Mask(64, 64, order):
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                              else:
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                          else:
                              if address(cd[132]) != caller:
                                  revert with RFQPrivateOrder()
                              if Mask(64, 64, order):
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                      else:
                          if not address(cd[292]):
                              revert with RFQZeroTargetIsForbidden()
                          if not address(cd[132]):
                              if not Mask(64, 64, order):
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                  if -Mask(252, 0, cd[260]):
                                      if Mask(1, 255, cd[260]):
                              else:
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                  if -Mask(252, 0, cd[260]):
                          else:
                              if address(cd[132]) != caller:
                                  revert with RFQPrivateOrder()
                              if not Mask(64, 64, order):
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                  if -Mask(252, 0, cd[260]):
                              else:
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                  else:
                      signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) - 256, call.data[cd[228] + 36 len 64]) # precompiled
                      if address(signer) == target:
                          if not address(cd[292]):
                              revert with RFQZeroTargetIsForbidden()
                          if not address(cd[132]):
                              if not Mask(64, 64, order):
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                  if -Mask(252, 0, cd[260]):
                              else:
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          else:
                              if address(cd[132]) != caller:
                                  revert with RFQPrivateOrder()
                              if Mask(64, 64, order):
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                      else:
                          static call target.isValidSignature(bytes32 , bytes ) with:
                                  gas gas_remaining wei
                                 args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                          if not ext_call.success:
                              revert with RFQBadSignature()
                          if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                              revert with RFQBadSignature()
                          if not address(cd[292]):
                              revert with RFQZeroTargetIsForbidden()
                          if not address(cd[132]):
                              if Mask(64, 64, order):
                                  if block.timestamp > uint64(order):
                                      revert with OrderExpired()
                          else:
                              if address(cd[132]) != caller:
                                  revert with RFQPrivateOrder()
                              if Mask(64, 64, order):
              else:
                  static call target.isValidSignature(bytes32 , bytes ) with:
                          gas gas_remaining wei
                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                  if not ext_call.success:
                      revert with RFQBadSignature()
                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                      revert with RFQBadSignature()
                  if not address(cd[292]):
                      revert with RFQZeroTargetIsForbidden()
                  if not address(cd[132]):
                      if Mask(64, 64, order):
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                          revert with InvalidatedOrder()
                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                      if -Mask(252, 0, cd[260]):
                          if not Mask(1, 255, cd[260]):
                              if Mask(252, 0, cd[260]) > cd[196]:
                                  revert with TakingAmountExceeded()
                          else:
                              if Mask(252, 0, cd[260]) > cd[164]:
                                  revert with MakingAmountExceeded()
                      else:
                          if not cd[164]:
                              revert with RFQSwapWithZeroAmount()
                          if not cd[196]:
                              revert with RFQSwapWithZeroAmount()
                  else:
                      if address(cd[132]) != caller:
                          revert with RFQPrivateOrder()
                      if not Mask(64, 64, order):
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                      else:
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
      else:
          if not Mask(1, 253, cd[260]):
              static call target.isValidSignature(bytes32 , bytes ) with:
                      gas gas_remaining wei
                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
              if not ext_call.success:
                  revert with RFQBadSignature()
              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                  revert with RFQBadSignature()
              if not address(cd[292]):
                  revert with RFQZeroTargetIsForbidden()
              if not address(cd[132]):
                  if not Mask(64, 64, order):
                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                          revert with InvalidatedOrder()
                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                      if -Mask(252, 0, cd[260]):
                          if not Mask(1, 255, cd[260]):
                              if Mask(252, 0, cd[260]) > cd[196]:
                                  revert with TakingAmountExceeded()
                              if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                  revert with 0, 17
                              if not cd[196]:
                                  revert with 0, 18
                          else:
                              if Mask(252, 0, cd[260]) > cd[164]:
                                  revert with MakingAmountExceeded()
                              if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                  revert with 0, 17
                              if cd[196] * Mask(252, 0, cd[260]) > cd[164] + (cd[196] * Mask(252, 0, cd[260])):
                                  revert with 0, 17
                      else:
                          if not cd[164]:
                              revert with RFQSwapWithZeroAmount()
                          if not cd[196]:
                              revert with RFQSwapWithZeroAmount()
                          if address(signature) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                              call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args target, cd[292], cd[164]
                              if not ext_call.success:
                                  revert with SafeTransferFromFailed()
                          else:
                              if not Mask(1, 252, cd[260]):
                                  call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args target, cd[292], cd[164]
                                  if ext_call.success:
                              else:
                                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args address(target), this.address, cd[164]
                                  if not ext_call.success:
                                      revert with ext_call.return_data[0 len return_data.size]
                  else:
                      if block.timestamp > uint64(order):
                          revert with OrderExpired()
                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                          revert with InvalidatedOrder()
                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                      if -Mask(252, 0, cd[260]):
                          if not Mask(1, 255, cd[260]):
                              if Mask(252, 0, cd[260]) > cd[196]:
                                  revert with TakingAmountExceeded()
                              if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                  revert with 0, 17
                              if not cd[196]:
                                  revert with 0, 18
                          else:
                              if Mask(252, 0, cd[260]) > cd[164]:
                                  revert with MakingAmountExceeded()
                              if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                  revert with 0, 17
                      else:
                          if not cd[164]:
                              revert with RFQSwapWithZeroAmount()
                          if not cd[196]:
                              revert with RFQSwapWithZeroAmount()
                          if address(signature) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                              call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args target, cd[292], cd[164]
                              if ext_call.success:
                          else:
                              if not Mask(1, 252, cd[260]):
                                  call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args target, cd[292], cd[164]
                              else:
                                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args address(target), this.address, cd[164]
                                  if not ext_call.success:
                                      revert with ext_call.return_data[0 len return_data.size]
              else:
                  if address(cd[132]) != caller:
                      revert with RFQPrivateOrder()
                  if not Mask(64, 64, order):
                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                          revert with InvalidatedOrder()
                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                      if -Mask(252, 0, cd[260]):
                          if not Mask(1, 255, cd[260]):
                              if Mask(252, 0, cd[260]) > cd[196]:
                                  revert with TakingAmountExceeded()
                              if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                  revert with 0, 17
                              if not cd[196]:
                                  revert with 0, 18
                          else:
                              if Mask(252, 0, cd[260]) > cd[164]:
                                  revert with MakingAmountExceeded()
                              if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                  revert with 0, 17
                      else:
                          if not cd[164]:
                              revert with RFQSwapWithZeroAmount()
                          if not cd[196]:
                              revert with RFQSwapWithZeroAmount()
                          if address(signature) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                              call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args target, cd[292], cd[164]
                              if ext_call.success:
                          else:
                              if not Mask(1, 252, cd[260]):
                                  call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args target, cd[292], cd[164]
                              else:
                                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args address(target), this.address, cd[164]
                                  if not ext_call.success:
                                      revert with ext_call.return_data[0 len return_data.size]
                  else:
                      if block.timestamp > uint64(order):
                          revert with OrderExpired()
                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                          revert with InvalidatedOrder()
                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                      if -Mask(252, 0, cd[260]):
                          if not Mask(1, 255, cd[260]):
                              if Mask(252, 0, cd[260]) > cd[196]:
                                  revert with TakingAmountExceeded()
                              if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                  revert with 0, 17
                          else:
                              if Mask(252, 0, cd[260]) > cd[164]:
                                  revert with MakingAmountExceeded()
                              if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                  revert with 0, 17
                      else:
                          if not cd[164]:
                              revert with RFQSwapWithZeroAmount()
                          if not cd[196]:
                              revert with RFQSwapWithZeroAmount()
                          if address(signature) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                              call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args target, cd[292], cd[164]
                          else:
                              if Mask(1, 252, cd[260]):
                                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args address(target), this.address, cd[164]
          else:
              if ('cd', 228).length != 65:
                  revert with RFQBadSignature()
              static call target.isValidSignature(bytes32 , bytes ) with:
                      gas gas_remaining wei
                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
              if not ext_call.success:
                  revert with RFQBadSignature()
              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                  revert with RFQBadSignature()
              if not address(cd[292]):
                  revert with RFQZeroTargetIsForbidden()
              if not address(cd[132]):
                  if not Mask(64, 64, order):
                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                          revert with InvalidatedOrder()
                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                      if -Mask(252, 0, cd[260]):
                          if not Mask(1, 255, cd[260]):
                              if Mask(252, 0, cd[260]) > cd[196]:
                                  revert with TakingAmountExceeded()
                              if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                  revert with 0, 17
                              if not cd[196]:
                                  revert with 0, 18
                          else:
                              if Mask(252, 0, cd[260]) > cd[164]:
                                  revert with MakingAmountExceeded()
                              if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                  revert with 0, 17
                      else:
                          if not cd[164]:
                              revert with RFQSwapWithZeroAmount()
                          if not cd[196]:
                              revert with RFQSwapWithZeroAmount()
                          if address(signature) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                              call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args target, cd[292], cd[164]
                              if ext_call.success:
                          else:
                              if not Mask(1, 252, cd[260]):
                                  call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args target, cd[292], cd[164]
                              else:
                                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args address(target), this.address, cd[164]
                                  if not ext_call.success:
                                      revert with ext_call.return_data[0 len return_data.size]
                  else:
                      if block.timestamp > uint64(order):
                          revert with OrderExpired()
                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                          revert with InvalidatedOrder()
                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                      if -Mask(252, 0, cd[260]):
                          if not Mask(1, 255, cd[260]):
                              if Mask(252, 0, cd[260]) > cd[196]:
                                  revert with TakingAmountExceeded()
                              if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                  revert with 0, 17
                          else:
                              if Mask(252, 0, cd[260]) > cd[164]:
                                  revert with MakingAmountExceeded()
                              if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                  revert with 0, 17
                      else:
                          if not cd[164]:
                              revert with RFQSwapWithZeroAmount()
                          if not cd[196]:
                              revert with RFQSwapWithZeroAmount()
                          if address(signature) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                              call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args target, cd[292], cd[164]
                          else:
                              if Mask(1, 252, cd[260]):
                                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args address(target), this.address, cd[164]
              else:
                  if address(cd[132]) != caller:
                      revert with RFQPrivateOrder()
                  if Mask(64, 64, order):
                      if block.timestamp > uint64(order):
                          revert with OrderExpired()
                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                          revert with InvalidatedOrder()
                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                      if -Mask(252, 0, cd[260]):
                          if not Mask(1, 255, cd[260]):
                              if Mask(252, 0, cd[260]) > cd[196]:
                                  revert with TakingAmountExceeded()
                              if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                  revert with 0, 17
                          else:
                              if Mask(252, 0, cd[260]) > cd[164]:
                                  revert with MakingAmountExceeded()
                              if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                  revert with 0, 17
                      else:
                          if not cd[164]:
                              revert with RFQSwapWithZeroAmount()
                          if not cd[196]:
                              revert with RFQSwapWithZeroAmount()
                          if address(signature) == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                  else:
                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                          revert with InvalidatedOrder()
                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                      if -Mask(252, 0, cd[260]):
                          if not Mask(1, 255, cd[260]):
                              if Mask(252, 0, cd[260]) > cd[196]:
                                  revert with TakingAmountExceeded()
                              if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                  revert with 0, 17
                          else:
                              if Mask(252, 0, cd[260]) > cd[164]:
                                  revert with MakingAmountExceeded()
                              if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                  revert with 0, 17
                      else:
                          if not cd[164]:
                              revert with RFQSwapWithZeroAmount()
                          if not cd[196]:
                              revert with RFQSwapWithZeroAmount()
                          if address(signature) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                              call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                   gas gas_remaining wei
                                  args target, cd[292], cd[164]
                          else:
                              if Mask(1, 252, cd[260]):
                                  call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args address(target), this.address, cd[164]
  else:
      if 1 != chainid:
          if not Mask(1, 254, cd[260]):
              if not target:
                  revert with RFQBadSignature()
              if ('cd', 228).length == 64:
                  if ('cd', 228).length == 65:
                      if call.data[cd[228] + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                          if target:
                              static call target.isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with RFQBadSignature()
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                          else:
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                                          if Mask(1, 255, cd[260]):
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                      else:
                          signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) - 256, call.data[cd[228] + 36 len 64]) # precompiled
                          if address(signer) == target:
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          else:
                              static call target.isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with RFQBadSignature()
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if Mask(64, 64, order):
                  else:
                      if ('cd', 228).length != 64:
                          if target:
                              static call target.isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with RFQBadSignature()
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                          else:
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                                          if Mask(1, 255, cd[260]):
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                      else:
                          if uint255(('cd', 228)[1]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if not target:
                                  if not address(cd[292]):
                                      revert with RFQZeroTargetIsForbidden()
                                  if not address(cd[132]):
                                      if not Mask(64, 64, order):
                                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                              revert with InvalidatedOrder()
                                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                          if -Mask(252, 0, cd[260]):
                                      else:
                                          if block.timestamp > uint64(order):
                                              revert with OrderExpired()
                                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                              revert with InvalidatedOrder()
                                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                  else:
                                      if address(cd[132]) != caller:
                                          revert with RFQPrivateOrder()
                                      if Mask(64, 64, order):
                                          if block.timestamp > uint64(order):
                                              revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                              else:
                                  static call target.isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                                  if not ext_call.success:
                                      revert with RFQBadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with RFQBadSignature()
                                  if not address(cd[292]):
                                      revert with RFQZeroTargetIsForbidden()
                                  if not address(cd[132]):
                                      if Mask(64, 64, order):
                                          if block.timestamp > uint64(order):
                                              revert with OrderExpired()
                                  else:
                                      if address(cd[132]) != caller:
                                          revert with RFQPrivateOrder()
                                      if Mask(64, 64, order):
                          else:
                              signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), (bool(('cd', 228)[1]) >> 255) + 27, call.data[cd[228] + 36], uint255(('cd', 228)[1])) # precompiled
                              if address(signer) == target:
                                  if not address(cd[292]):
                                      revert with RFQZeroTargetIsForbidden()
                                  if not address(cd[132]):
                                      if Mask(64, 64, order):
                                          if block.timestamp > uint64(order):
                                              revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                  else:
                                      if address(cd[132]) != caller:
                                          revert with RFQPrivateOrder()
                                      if not Mask(64, 64, order):
                                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                              revert with InvalidatedOrder()
                                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                      else:
                                          if block.timestamp > uint64(order):
                                              revert with OrderExpired()
                              else:
                                  static call target.isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                                  if not ext_call.success:
                                      revert with RFQBadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with RFQBadSignature()
                                  if not address(cd[292]):
                                      revert with RFQZeroTargetIsForbidden()
                                  if not address(cd[132]):
                                      if Mask(64, 64, order):
                                  else:
                                      if address(cd[132]) != caller:
                                          revert with RFQPrivateOrder()
              else:
                  if ('cd', 228).length == 65:
                      if call.data[cd[228] + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                          if not target:
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          else:
                              static call target.isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with RFQBadSignature()
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if Mask(64, 64, order):
                      else:
                          signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) - 256, call.data[cd[228] + 36 len 64]) # precompiled
                          if address(signer) == target:
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                          else:
                              static call target.isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with RFQBadSignature()
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if Mask(64, 64, order):
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                  else:
                      static call target.isValidSignature(bytes32 , bytes ) with:
                              gas gas_remaining wei
                             args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                      if not ext_call.success:
                          revert with RFQBadSignature()
                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                          revert with RFQBadSignature()
                      if not address(cd[292]):
                          revert with RFQZeroTargetIsForbidden()
                      if not address(cd[132]):
                          if not Mask(64, 64, order):
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[260]):
                                  if not Mask(1, 255, cd[260]):
                                      if Mask(252, 0, cd[260]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                  else:
                                      if Mask(252, 0, cd[260]) > cd[164]:
                                          revert with MakingAmountExceeded()
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                          else:
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[260]):
                                  if not Mask(1, 255, cd[260]):
                                      if Mask(252, 0, cd[260]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                  else:
                                      if Mask(252, 0, cd[260]) > cd[164]:
                                          revert with MakingAmountExceeded()
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                      else:
                          if address(cd[132]) != caller:
                              revert with RFQPrivateOrder()
                          if not Mask(64, 64, order):
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[260]):
                                  if not Mask(1, 255, cd[260]):
                                      if Mask(252, 0, cd[260]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                  else:
                                      if Mask(252, 0, cd[260]) > cd[164]:
                                          revert with MakingAmountExceeded()
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                          else:
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[260]):
                                  if not Mask(1, 255, cd[260]):
                                      if Mask(252, 0, cd[260]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                  else:
                                      if Mask(252, 0, cd[260]) > cd[164]:
                                          revert with MakingAmountExceeded()
          else:
              if not Mask(1, 253, cd[260]):
                  static call target.isValidSignature(bytes32 , bytes ) with:
                          gas gas_remaining wei
                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                  if not ext_call.success:
                      revert with RFQBadSignature()
                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                      revert with RFQBadSignature()
                  if not address(cd[292]):
                      revert with RFQZeroTargetIsForbidden()
                  if not address(cd[132]):
                      if not Mask(64, 64, order):
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                                  if not cd[196]:
                                      revert with 0, 18
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(signature) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args target, cd[292], cd[164]
                                  if ext_call.success:
                              else:
                                  if not Mask(1, 252, cd[260]):
                                      call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args target, cd[292], cd[164]
                                  else:
                                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args address(target), this.address, cd[164]
                                      if not ext_call.success:
                                          revert with ext_call.return_data[0 len return_data.size]
                      else:
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(signature) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args target, cd[292], cd[164]
                              else:
                                  if Mask(1, 252, cd[260]):
                                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args address(target), this.address, cd[164]
                  else:
                      if address(cd[132]) != caller:
                          revert with RFQPrivateOrder()
                      if Mask(64, 64, order):
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(signature) == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      else:
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(signature) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args target, cd[292], cd[164]
                              else:
                                  if Mask(1, 252, cd[260]):
                                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args address(target), this.address, cd[164]
              else:
                  if ('cd', 228).length != 65:
                      revert with RFQBadSignature()
                  static call target.isValidSignature(bytes32 , bytes ) with:
                          gas gas_remaining wei
                         args sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0x5c6cbfb2848b981a8f93044b3530be1fac304ecd5042396ca8729cb8fdd718f3, 0xceebf77a833b30520287ddd9478ff51abbdffa30aa90a8d655dba0e8a79ce0c1, chainid, this.address), sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                  if not ext_call.success:
                      revert with RFQBadSignature()
                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                      revert with RFQBadSignature()
                  if not address(cd[292]):
                      revert with RFQZeroTargetIsForbidden()
                  if address(cd[132]):
                      if address(cd[132]) != caller:
                          revert with RFQPrivateOrder()
                      if not Mask(64, 64, order):
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(signature) == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      else:
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                  else:
                      if Mask(64, 64, order):
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(signature) == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      else:
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(signature) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args target, cd[292], cd[164]
                              else:
                                  if Mask(1, 252, cd[260]):
                                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args address(target), this.address, cd[164]
      else:
          if not Mask(1, 254, cd[260]):
              if not target:
                  revert with RFQBadSignature()
              if ('cd', 228).length == 64:
                  if ('cd', 228).length == 65:
                      if call.data[cd[228] + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                          if target:
                              static call target.isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with RFQBadSignature()
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                          else:
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                                          if Mask(1, 255, cd[260]):
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                      else:
                          signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) - 256, call.data[cd[228] + 36 len 64]) # precompiled
                          if address(signer) == target:
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          else:
                              static call target.isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with RFQBadSignature()
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if Mask(64, 64, order):
                  else:
                      if ('cd', 228).length != 64:
                          if target:
                              static call target.isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with RFQBadSignature()
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                          else:
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                                          if Mask(1, 255, cd[260]):
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                      else:
                          if uint255(('cd', 228)[1]) >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                              if not target:
                                  if not address(cd[292]):
                                      revert with RFQZeroTargetIsForbidden()
                                  if not address(cd[132]):
                                      if not Mask(64, 64, order):
                                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                              revert with InvalidatedOrder()
                                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                          if -Mask(252, 0, cd[260]):
                                      else:
                                          if block.timestamp > uint64(order):
                                              revert with OrderExpired()
                                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                              revert with InvalidatedOrder()
                                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                  else:
                                      if address(cd[132]) != caller:
                                          revert with RFQPrivateOrder()
                                      if Mask(64, 64, order):
                                          if block.timestamp > uint64(order):
                                              revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                              else:
                                  static call target.isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                                  if not ext_call.success:
                                      revert with RFQBadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with RFQBadSignature()
                                  if not address(cd[292]):
                                      revert with RFQZeroTargetIsForbidden()
                                  if not address(cd[132]):
                                      if Mask(64, 64, order):
                                          if block.timestamp > uint64(order):
                                              revert with OrderExpired()
                                  else:
                                      if address(cd[132]) != caller:
                                          revert with RFQPrivateOrder()
                                      if Mask(64, 64, order):
                          else:
                              signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), (bool(('cd', 228)[1]) >> 255) + 27, call.data[cd[228] + 36], uint255(('cd', 228)[1])) # precompiled
                              if address(signer) == target:
                                  if not address(cd[292]):
                                      revert with RFQZeroTargetIsForbidden()
                                  if not address(cd[132]):
                                      if Mask(64, 64, order):
                                          if block.timestamp > uint64(order):
                                              revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                  else:
                                      if address(cd[132]) != caller:
                                          revert with RFQPrivateOrder()
                                      if not Mask(64, 64, order):
                                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                              revert with InvalidatedOrder()
                                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                      else:
                                          if block.timestamp > uint64(order):
                                              revert with OrderExpired()
                              else:
                                  static call target.isValidSignature(bytes32 , bytes ) with:
                                          gas gas_remaining wei
                                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                                  if not ext_call.success:
                                      revert with RFQBadSignature()
                                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                      revert with RFQBadSignature()
                                  if not address(cd[292]):
                                      revert with RFQZeroTargetIsForbidden()
                                  if not address(cd[132]):
                                      if Mask(64, 64, order):
                                  else:
                                      if address(cd[132]) != caller:
                                          revert with RFQPrivateOrder()
              else:
                  if ('cd', 228).length == 65:
                      if call.data[cd[228] + 68] >= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1:
                          if not target:
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                      if -Mask(252, 0, cd[260]):
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          else:
                              static call target.isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with RFQBadSignature()
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if Mask(64, 64, order):
                      else:
                          signer = erecover(sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Mask(8, -(('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('cd', ('add', 100, ('cd', 228)))), 0) - 256, call.data[cd[228] + 36 len 64]) # precompiled
                          if address(signer) == target:
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if Mask(64, 64, order):
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                                  if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                      revert with InvalidatedOrder()
                                  invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                                  if not Mask(64, 64, order):
                                      if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                          revert with InvalidatedOrder()
                                      invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                                  else:
                                      if block.timestamp > uint64(order):
                                          revert with OrderExpired()
                          else:
                              static call target.isValidSignature(bytes32 , bytes ) with:
                                      gas gas_remaining wei
                                     args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                              if not ext_call.success:
                                  revert with RFQBadSignature()
                              if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                                  revert with RFQBadSignature()
                              if not address(cd[292]):
                                  revert with RFQZeroTargetIsForbidden()
                              if not address(cd[132]):
                                  if Mask(64, 64, order):
                              else:
                                  if address(cd[132]) != caller:
                                      revert with RFQPrivateOrder()
                  else:
                      static call target.isValidSignature(bytes32 , bytes ) with:
                              gas gas_remaining wei
                             args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                      if not ext_call.success:
                          revert with RFQBadSignature()
                      if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                          revert with RFQBadSignature()
                      if not address(cd[292]):
                          revert with RFQZeroTargetIsForbidden()
                      if not address(cd[132]):
                          if not Mask(64, 64, order):
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[260]):
                                  if not Mask(1, 255, cd[260]):
                                      if Mask(252, 0, cd[260]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                  else:
                                      if Mask(252, 0, cd[260]) > cd[164]:
                                          revert with MakingAmountExceeded()
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                                  if not cd[196]:
                                      revert with RFQSwapWithZeroAmount()
                          else:
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[260]):
                                  if not Mask(1, 255, cd[260]):
                                      if Mask(252, 0, cd[260]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                  else:
                                      if Mask(252, 0, cd[260]) > cd[164]:
                                          revert with MakingAmountExceeded()
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                      else:
                          if address(cd[132]) != caller:
                              revert with RFQPrivateOrder()
                          if not Mask(64, 64, order):
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[260]):
                                  if not Mask(1, 255, cd[260]):
                                      if Mask(252, 0, cd[260]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                  else:
                                      if Mask(252, 0, cd[260]) > cd[164]:
                                          revert with MakingAmountExceeded()
                              else:
                                  if not cd[164]:
                                      revert with RFQSwapWithZeroAmount()
                          else:
                              if block.timestamp > uint64(order):
                                  revert with OrderExpired()
                              if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                                  revert with InvalidatedOrder()
                              invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                              if -Mask(252, 0, cd[260]):
                                  if not Mask(1, 255, cd[260]):
                                      if Mask(252, 0, cd[260]) > cd[196]:
                                          revert with TakingAmountExceeded()
                                  else:
                                      if Mask(252, 0, cd[260]) > cd[164]:
                                          revert with MakingAmountExceeded()
          else:
              if not Mask(1, 253, cd[260]):
                  static call target.isValidSignature(bytes32 , bytes ) with:
                          gas gas_remaining wei
                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                  if not ext_call.success:
                      revert with RFQBadSignature()
                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                      revert with RFQBadSignature()
                  if not address(cd[292]):
                      revert with RFQZeroTargetIsForbidden()
                  if not address(cd[132]):
                      if not Mask(64, 64, order):
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                                  if not cd[196]:
                                      revert with 0, 18
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(signature) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args target, cd[292], cd[164]
                                  if ext_call.success:
                              else:
                                  if not Mask(1, 252, cd[260]):
                                      call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args target, cd[292], cd[164]
                                  else:
                                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args address(target), this.address, cd[164]
                                      if not ext_call.success:
                                          revert with ext_call.return_data[0 len return_data.size]
                      else:
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(signature) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args target, cd[292], cd[164]
                              else:
                                  if Mask(1, 252, cd[260]):
                                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args address(target), this.address, cd[164]
                  else:
                      if address(cd[132]) != caller:
                          revert with RFQPrivateOrder()
                      if Mask(64, 64, order):
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(signature) == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      else:
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(signature) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args target, cd[292], cd[164]
                              else:
                                  if Mask(1, 252, cd[260]):
                                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args address(target), this.address, cd[164]
              else:
                  if ('cd', 228).length != 65:
                      revert with RFQBadSignature()
                  static call target.isValidSignature(bytes32 , bytes ) with:
                          gas gas_remaining wei
                         args sha3(6401, 0x1c0eb4c27d5b523ca136c0b3b83a4dcac8b70225b38be8507ba1a3f2af03cfca, sha3(0x74ab4f0cde46aaf927859983f7d04002116dd057d4c4941f6dbfb775c3e31f45, order, signature, flagsAndAmount, target, cd[132], cd[164], cd[196])), Array(len=('cd', 228).length, data=call.data[cd[228] + 36 len ('cd', 228).length])
                  if not ext_call.success:
                      revert with RFQBadSignature()
                  if ext_call.return_data[0] != 0x1626ba7e00000000000000000000000000000000000000000000000000000000 or 32 != return_data.size:
                      revert with RFQBadSignature()
                  if not address(cd[292]):
                      revert with RFQZeroTargetIsForbidden()
                  if address(cd[132]):
                      if address(cd[132]) != caller:
                          revert with RFQPrivateOrder()
                      if not Mask(64, 64, order):
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(signature) == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      else:
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                  else:
                      if Mask(64, 64, order):
                          if block.timestamp > uint64(order):
                              revert with OrderExpired()
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(signature) == 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                      else:
                          if not (1 << uint8(order) and invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192]) - (1 << uint8(order)):
                              revert with InvalidatedOrder()
                          invalidatorForOrderRFQ[address(target)][Mask(56, 8, order) << 192] = 1
                          if -Mask(252, 0, cd[260]):
                              if not Mask(1, 255, cd[260]):
                                  if Mask(252, 0, cd[260]) > cd[196]:
                                      revert with TakingAmountExceeded()
                                  if cd[164] != cd[164] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                              else:
                                  if Mask(252, 0, cd[260]) > cd[164]:
                                      revert with MakingAmountExceeded()
                                  if cd[196] != cd[196] * Mask(252, 0, cd[260]) / Mask(252, 0, cd[260]) and Mask(252, 0, cd[260]):
                                      revert with 0, 17
                          else:
                              if not cd[164]:
                                  revert with RFQSwapWithZeroAmount()
                              if not cd[196]:
                                  revert with RFQSwapWithZeroAmount()
                              if address(signature) != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
                                  call address(signature).transferFrom(address sender, address recipient, uint256 amount) with:
                                       gas gas_remaining wei
                                      args target, cd[292], cd[164]
                              else:
                                  if Mask(1, 252, cd[260]):
                                      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transferFrom(address sender, address recipient, uint256 amount) with:
                                           gas gas_remaining wei
                                          args address(target), this.address, cd[164]
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)


