# Palkeoramix decompiler. 

const name = 'Uniswap V2'
const decimals = 18
const symbol = 'UNI-V2'
const PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9
const MINIMUM_LIQUIDITY = 1000

def storage:
  totalSupply is uint256 at storage 0
  balanceOf is mapping of uint256 at storage 1
  allowance is mapping of uint256 at storage 2
  DOMAIN_SEPARATOR is uint256 at storage 3
  nonces is mapping of uint256 at storage 4
  factoryAddress is address at storage 5
  token0Address is address at storage 6
  token1Address is address at storage 7
  stor8 is uint32 at storage 8 offset 224
  stor8 is uint128 at storage 8
  stor8 is uint128 at storage 8 offset 112
  price0CumulativeLast is uint256 at storage 9
  price1CumulativeLast is uint256 at storage 10
  kLast is uint256 at storage 11
  stor12 is uint256 at storage 12

def token0() payable: 
  return token0Address

def totalSupply() payable: 
  return totalSupply

def DOMAIN_SEPARATOR() payable: 
  return DOMAIN_SEPARATOR

def price0CumulativeLast() payable: 
  return price0CumulativeLast

def price1CumulativeLast() payable: 
  return price1CumulativeLast

def balanceOf(address account) payable: 
  require calldata.size - 4 >= 32
  return balanceOf[account]

def kLast() payable: 
  return kLast

def nonces(address _param1) payable: 
  require calldata.size - 4 >= 32
  return nonces[_param1]

def factory() payable: 
  return factoryAddress

def token1() payable: 
  return token1Address

def allowance(address owner, address spender) payable: 
  require calldata.size - 4 >= 64
  return allowance[owner][spender]

#
#  Regular functions
#

def _fallback(?) payable: # default function
  revert

def getReserves() payable: 
  return Mask(112, 0, stor8.field_0), Mask(112, 0, stor8.field_0), uint32(stor8.field_224)

def initialize(address _token0, address _token1) payable: 
  require calldata.size - 4 >= 64
  if factoryAddress != caller:
      revert with 0, 'UniswapV2: FORBIDDEN'
  token0Address = _token0
  token1Address = _token1

def approve(address spender, uint256 amount) payable: 
  require calldata.size - 4 >= 64
  allowance[caller][address(spender)] = amount
  log Approval(
        address owner=amount,
        address spender=caller,
        uint256 value=spender)
  return 1

def transfer(address recipient, uint256 amount) payable: 
  require calldata.size - 4 >= 64
  if balanceOf[caller] - amount > balanceOf[caller]:
      revert with 0, 'ds-math-sub-underflow'
  balanceOf[caller] -= amount
  if balanceOf[recipient] + amount < balanceOf[recipient]:
      revert with 0, 'ds-math-add-overflow'
  balanceOf[address(recipient)] = balanceOf[recipient] + amount
  log Transfer(
        address from=amount,
        address to=caller,
        uint256 value=recipient)
  return 1

def permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) payable: 
  require calldata.size - 4 >= 224
  if deadline < block.timestamp:
      revert with 0, 'UniswapV2: EXPIRED'
  nonces[address(owner)]++
  signer = erecover(sha3(0, DOMAIN_SEPARATOR, sha3(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9, address(owner), address(spender), value, nonces[address(owner)], deadline)), v << 248, r, s) # precompiled
  if not erecover.result:
      revert with ext_call.return_data[0 len return_data.size]
  if not address(signer):
      revert with 0, 'UniswapV2: INVALID_SIGNATURE'
  if address(signer) != owner:
      revert with 0, 'UniswapV2: INVALID_SIGNATURE'
  allowance[address(owner)][address(spender)] = value
  log Approval(
        address owner=value,
        address spender=owner,
        uint256 value=spender)

def transferFrom(address sender, address recipient, uint256 amount) payable: 
  require calldata.size - 4 >= 96
  if allowance[address(sender)][caller] != -1:
      if allowance[address(sender)][caller] - amount > allowance[address(sender)][caller]:
          revert with 0, 'ds-math-sub-underflow'
      allowance[address(sender)][caller] -= amount
  if balanceOf[address(sender)] - amount > balanceOf[address(sender)]:
      revert with 0, 'ds-math-sub-underflow'
  balanceOf[address(sender)] -= amount
  if balanceOf[recipient] + amount < balanceOf[recipient]:
      revert with 0, 'ds-math-add-overflow'
  balanceOf[address(recipient)] = balanceOf[recipient] + amount
  log Transfer(
        address from=amount,
        address to=sender,
        uint256 value=recipient)
  return 1

def sync() payable: 
  if stor12 != 1:
      revert with 0, 'UniswapV2: LOCKED'
  stor12 = 0
  require ext_code.size(token0Address)
  static call token0Address.balanceOf(address account) with:
          gas gas_remaining wei
         args this.address
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  require return_data.size >= 32
  require ext_code.size(token1Address)
  static call token1Address.balanceOf(address account) with:
          gas gas_remaining wei
         args this.address
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  require return_data.size >= 32
  if ext_call.return_data[0] > LOCK8605463013():
      revert with 0, 'UniswapV2: OVERFLOW'
  if ext_call.return_data[0] > LOCK8605463013():
      revert with 0, 'UniswapV2: OVERFLOW'
  if uint32(uint32(block.timestamp) - uint32(stor8.field_224)):
      if Mask(112, 0, stor8.field_0):
          if Mask(112, 0, stor8.field_112):
              require Mask(112, 0, stor8.field_0)
              price0CumulativeLast += Mask(224, 0, Mask(112, 0, Mask(112, 0, stor8.field_112)) << 112 / Mask(112, 0, stor8.field_0)) * uint32(uint32(block.timestamp) - uint32(stor8.field_224))
              require Mask(112, 0, stor8.field_112)
              price1CumulativeLast += Mask(224, 0, Mask(112, 0, stor8.field_0) / Mask(112, 0, stor8.field_112)) * uint32(uint32(block.timestamp) - uint32(stor8.field_224))
  Mask(112, 0, stor8.field_0) = Mask(112, 0, ext_call.return_data[0])
  Mask(112, 0, stor8.field_112) = Mask(112, 0, ext_call.return_data[0])
  uint32(stor8.field_224) = uint32(block.timestamp)
  log Sync(
        uint112 reserve0=ext_call.return_data[0] << 144,
        uint112 reserve1=Mask(112, 0, ext_call.return_data[0]))
  stor12 = 1

def skim(address to) payable: 
  require calldata.size - 4 >= 32
  if stor12 != 1:
      revert with 0, 'UniswapV2: LOCKED'
  stor12 = 0
  require ext_code.size(token0Address)
  static call token0Address.balanceOf(address account) with:
          gas gas_remaining wei
         args this.address
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  require return_data.size >= 32
  if ext_call.return_data[0] - Mask(112, 0, stor8.field_0) > ext_call.return_data[0]:
      revert with 0, 'ds-math-sub-underflow'
  mem[260 len 64] = transfer(address recipient, uint256 amount), address(to) << 64, 0, Mask(224, 32, ext_call.return_data[0] - Mask(112, 0, stor8.field_0)) >> 32
  call token0Address with:
       gas gas_remaining wei
      args Mask(224, 32, ext_call.return_data[0] - Mask(112, 0, stor8.field_0)) << 224, mem[324 len 4]
  if not return_data.size:
      require not ext_call.success
      revert with 0, 'UniswapV2: TRANSFER_FAILED'
  mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
  if not ext_call.success:
      revert with 0, 'UniswapV2: TRANSFER_FAILED'
  if return_data.size:
      require return_data.size >= 32
      if not mem[292]:
          revert with 0, 'UniswapV2: TRANSFER_FAILED'
  require ext_code.size(token1Address)
  static call token1Address.balanceOf(address account) with:
          gas gas_remaining wei
         args this.address
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  require return_data.size >= 32
  if ext_call.return_data[0] - Mask(112, 0, stor8.field_112) > ext_call.return_data[0]:
      revert with 0, 'ds-math-sub-underflow'
  mem[ceil32(return_data.size) + 425 len 64] = 0, address(to), Mask(224, 32, ext_call.return_data[0] - Mask(112, 0, stor8.field_112)) >> 32
  call token1Address with:
       gas gas_remaining wei
      args ext_call.return_data[0] - Mask(112, 0, stor8.field_112), Mask(224, 32, address(to), Mask(224, 32, ext_call.return_data[0] - Mask(112, 0, stor8.field_112)) >> 32) >> 32, mem[ceil32(return_data.size) + 489 len 4]
  if not return_data.size:
      require not ext_call.success
      revert with 0, 'UniswapV2: TRANSFER_FAILED'
  mem[ceil32(return_data.size) + 457 len return_data.size] = ext_call.return_data[0 len return_data.size]
  if not ext_call.success:
      revert with 0, 'UniswapV2: TRANSFER_FAILED'
  if return_data.size:
      require return_data.size >= 32
      if not mem[ceil32(return_data.size) + 457]:
          revert with 0, 'UniswapV2: TRANSFER_FAILED'
  stor12 = 1

def swap(uint256 amount0Out, uint256 amount1Out, address to, bytes data) payable: 
  require calldata.size - 4 >= 128
  require data <= unknown10000000()
  require data + 36 <= calldata.size
  require data.length <= unknown10000000() and data + data.length + 36 <= calldata.size
  if stor12 != 1:
      revert with 0, 'UniswapV2: LOCKED'
  stor12 = 0
  if amount0Out:
      if amount0Out >= Mask(112, 0, stor8.field_0):
          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                      32,
                      33,
                      0x54556e697377617056323a20494e53554646494349454e545f4c49515549444954,
                      mem[197 len 31]
      if amount1Out >= Mask(112, 0, stor8.field_112):
          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                      32,
                      33,
                      0x54556e697377617056323a20494e53554646494349454e545f4c49515549444954,
                      mem[197 len 31]
      if token0Address == to:
          revert with 0, 'UniswapV2: INVALID_TO'
      if to == token1Address:
          revert with 0, 'UniswapV2: INVALID_TO'
      if not amount0Out:
          if not amount1Out:
              if not data.length:
                  require ext_code.size(token0Address)
                  static call token0Address.balanceOf(address account) with:
                          gas gas_remaining wei
                         args this.address
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >= 32
                  require ext_code.size(token1Address)
                  static call token1Address.balanceOf(address account) with:
                          gas gas_remaining wei
                         args this.address
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >= 32
                  if ext_call.return_data[0] <= Mask(112, 0, stor8.field_0) - amount0Out:
                      if ext_call.return_data[0] <= Mask(112, 0, stor8.field_112) - amount1Out:
                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                      32,
                                      36,
                                      0x54556e697377617056323a20494e53554646494349454e545f494e5055545f414d4f554e,
                                      mem[200 len 28]
                      if ext_call.return_data[0] - Mask(112, 0, stor8.field_112) + amount1Out <= 0:
                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                      32,
                                      36,
                                      0x54556e697377617056323a20494e53554646494349454e545f494e5055545f414d4f554e,
                                      mem[200 len 28]
                      if 1000 * ext_call.return_data[0] / 1000 != ext_call.return_data[0]:
                          revert with 0, 'ds-math-mul-overflow'
                      if 1000 * ext_call.return_data[0] > 1000 * ext_call.return_data[0]:
                          revert with 0, 'ds-math-sub-underflow'
                  else:
                      if ext_call.return_data[0] <= Mask(112, 0, stor8.field_112) - amount1Out:
                          if ext_call.return_data[0] - Mask(112, 0, stor8.field_0) + amount0Out <= 0:
                              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                          32,
                                          36,
                                          0x54556e697377617056323a20494e53554646494349454e545f494e5055545f414d4f554e,
                                          mem[200 len 28]
                      else:
                          if ext_call.return_data[0] - Mask(112, 0, stor8.field_0) + amount0Out <= 0:
                              if ext_call.return_data[0] - Mask(112, 0, stor8.field_112) + amount1Out <= 0:
                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                              32,
                                              36,
                                              0x54556e697377617056323a20494e53554646494349454e545f494e5055545f414d4f554e,
                                              mem[200 len 28]
                      if (3 * ext_call.return_data[0]) - (3 * Mask(112, 0, stor8.field_0)) + (3 * amount0Out) / 3 != ext_call.return_data[0] - Mask(112, 0, stor8.field_0) + amount0Out:
                          revert with 0, 'ds-math-mul-overflow'
                      if 1000 * ext_call.return_data[0] / 1000 != ext_call.return_data[0]:
                          revert with 0, 'ds-math-mul-overflow'
                      if (997 * ext_call.return_data[0]) + (3 * Mask(112, 0, stor8.field_0)) - (3 * amount0Out) > 1000 * ext_call.return_data[0]:
                          revert with 0, 'ds-math-sub-underflow'
              else:
                  mem[260 len data.length] = data[all]
                  mem[data.length + 260] = 0
                  require ext_code.size(to)
                  call to.uniswapV2Call(address sender, uint256 amount0, uint256 amount1, bytes data) with:
                       gas gas_remaining wei
                      args 0, uint32(caller), amount0Out, amount1Out, 128, data.length, data[all], mem[data.length + 260 len ceil32(data.length) - data.length]
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require ext_code.size(token0Address)
                  static call token0Address.balanceOf(address account) with:
                          gas gas_remaining wei
                         args this.address
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >= 32
                  require ext_code.size(token1Address)
                  static call token1Address.balanceOf(address account) with:
                          gas gas_remaining wei
                         args this.address
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >= 32
                  if ext_call.return_data[0] <= Mask(112, 0, stor8.field_0) - amount0Out:
                      if ext_call.return_data[0] <= Mask(112, 0, stor8.field_112) - amount1Out:
                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TUniswapV2: INSUFFICIENT_INPUT_AMOUN'
                      if ext_call.return_data[0] - Mask(112, 0, stor8.field_112) + amount1Out <= 0:
                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TUniswapV2: INSUFFICIENT_INPUT_AMOUN'
                      if 1000 * ext_call.return_data[0] / 1000 != ext_call.return_data[0]:
                          revert with 0, 'ds-math-mul-overflow'
                  else:
                      if ext_call.return_data[0] <= Mask(112, 0, stor8.field_112) - amount1Out:
                          if ext_call.return_data[0] - Mask(112, 0, stor8.field_0) + amount0Out <= 0:
                              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TUniswapV2: INSUFFICIENT_INPUT_AMOUN'
                          if (3 * ext_call.return_data[0]) - (3 * Mask(112, 0, stor8.field_0)) + (3 * amount0Out) / 3 != ext_call.return_data[0] - Mask(112, 0, stor8.field_0) + amount0Out:
                              revert with 0, 'ds-math-mul-overflow'
                          if 1000 * ext_call.return_data[0] / 1000 != ext_call.return_data[0]:
                              revert with 0, 'ds-math-mul-overflow'
                          if (997 * ext_call.return_data[0]) + (3 * Mask(112, 0, stor8.field_0)) - (3 * amount0Out) > 1000 * ext_call.return_data[0]:
                              revert with 0, 'ds-math-sub-underflow'
                      else:
                          if ext_call.return_data[0] - Mask(112, 0, stor8.field_0) + amount0Out > 0:
                              if (3 * ext_call.return_data[0]) - (3 * Mask(112, 0, stor8.field_0)) + (3 * amount0Out) / 3 != ext_call.return_data[0] - Mask(112, 0, stor8.field_0) + amount0Out:
                                  revert with 0, 'ds-math-mul-overflow'
                              if 1000 * ext_call.return_data[0] / 1000 != ext_call.return_data[0]:
                                  revert with 0, 'ds-math-mul-overflow'
                              if (997 * ext_call.return_data[0]) + (3 * Mask(112, 0, stor8.field_0)) - (3 * amount0Out) > 1000 * ext_call.return_data[0]:
                                  revert with 0, 'ds-math-sub-underflow'
                          else:
                              if ext_call.return_data[0] - Mask(112, 0, stor8.field_112) + amount1Out <= 0:
                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TUniswapV2: INSUFFICIENT_INPUT_AMOUN'
                              if (3 * ext_call.return_data[0]) - (3 * Mask(112, 0, stor8.field_0)) + (3 * amount0Out) / 3 != ext_call.return_data[0] - Mask(112, 0, stor8.field_0) + amount0Out:
                                  revert with 0, 'ds-math-mul-overflow'
                              if 1000 * ext_call.return_data[0] / 1000 != ext_call.return_data[0]:
                                  revert with 0, 'ds-math-mul-overflow'
  else:
      if amount1Out <= 0:
          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                      32,
                      37,
                      0xfe556e697377617056323a20494e53554646494349454e545f4f55545055545f414d4f554e,
                      mem[201 len 27]
      if amount0Out >= Mask(112, 0, stor8.field_0):
          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                      32,
                      33,
                      0x54556e697377617056323a20494e53554646494349454e545f4c49515549444954,
                      mem[197 len 31]
      if amount1Out >= Mask(112, 0, stor8.field_112):
          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                      32,
                      33,
                      0x54556e697377617056323a20494e53554646494349454e545f4c49515549444954,
                      mem[197 len 31]
      if token0Address == to:
          revert with 0, 'UniswapV2: INVALID_TO'
      if to == token1Address:
          revert with 0, 'UniswapV2: INVALID_TO'
      if not amount0Out:
          if not amount1Out:
              if not data.length:
                  require ext_code.size(token0Address)
                  static call token0Address.balanceOf(address account) with:
                          gas gas_remaining wei
                         args this.address
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >= 32
                  require ext_code.size(token1Address)
                  static call token1Address.balanceOf(address account) with:
                          gas gas_remaining wei
                         args this.address
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >= 32
                  if ext_call.return_data[0] <= Mask(112, 0, stor8.field_0) - amount0Out:
                      if ext_call.return_data[0] <= Mask(112, 0, stor8.field_112) - amount1Out:
                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                      32,
                                      36,
                                      0x54556e697377617056323a20494e53554646494349454e545f494e5055545f414d4f554e,
                                      mem[200 len 28]
                      if ext_call.return_data[0] - Mask(112, 0, stor8.field_112) + amount1Out <= 0:
                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                      32,
                                      36,
                                      0x54556e697377617056323a20494e53554646494349454e545f494e5055545f414d4f554e,
                                      mem[200 len 28]
                      if 1000 * ext_call.return_data[0] / 1000 != ext_call.return_data[0]:
                          revert with 0, 'ds-math-mul-overflow'
                      if 1000 * ext_call.return_data[0] > 1000 * ext_call.return_data[0]:
                          revert with 0, 'ds-math-sub-underflow'
                  else:
                      if ext_call.return_data[0] <= Mask(112, 0, stor8.field_112) - amount1Out:
                          if ext_call.return_data[0] - Mask(112, 0, stor8.field_0) + amount0Out <= 0:
                              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                          32,
                                          36,
                                          0x54556e697377617056323a20494e53554646494349454e545f494e5055545f414d4f554e,
                                          mem[200 len 28]
                      else:
                          if ext_call.return_data[0] - Mask(112, 0, stor8.field_0) + amount0Out <= 0:
                              if ext_call.return_data[0] - Mask(112, 0, stor8.field_112) + amount1Out <= 0:
                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                              32,
                                              36,
                                              0x54556e697377617056323a20494e53554646494349454e545f494e5055545f414d4f554e,
                                              mem[200 len 28]
                      if (3 * ext_call.return_data[0]) - (3 * Mask(112, 0, stor8.field_0)) + (3 * amount0Out) / 3 != ext_call.return_data[0] - Mask(112, 0, stor8.field_0) + amount0Out:
                          revert with 0, 'ds-math-mul-overflow'
                      if 1000 * ext_call.return_data[0] / 1000 != ext_call.return_data[0]:
                          revert with 0, 'ds-math-mul-overflow'
                      if (997 * ext_call.return_data[0]) + (3 * Mask(112, 0, stor8.field_0)) - (3 * amount0Out) > 1000 * ext_call.return_data[0]:
                          revert with 0, 'ds-math-sub-underflow'
              else:
                  mem[260 len data.length] = data[all]
                  mem[data.length + 260] = 0
                  require ext_code.size(to)
                  call to.uniswapV2Call(address sender, uint256 amount0, uint256 amount1, bytes data) with:
                       gas gas_remaining wei
                      args 0, uint32(caller), amount0Out, amount1Out, 128, data.length, data[all], mem[data.length + 260 len ceil32(data.length) - data.length]
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require ext_code.size(token0Address)
                  static call token0Address.balanceOf(address account) with:
                          gas gas_remaining wei
                         args this.address
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >= 32
                  require ext_code.size(token1Address)
                  static call token1Address.balanceOf(address account) with:
                          gas gas_remaining wei
                         args this.address
                  if not ext_call.success:
                      revert with ext_call.return_data[0 len return_data.size]
                  require return_data.size >= 32
                  if ext_call.return_data[0] <= Mask(112, 0, stor8.field_0) - amount0Out:
                      if ext_call.return_data[0] <= Mask(112, 0, stor8.field_112) - amount1Out:
                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TUniswapV2: INSUFFICIENT_INPUT_AMOUN'
                      if ext_call.return_data[0] - Mask(112, 0, stor8.field_112) + amount1Out <= 0:
                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TUniswapV2: INSUFFICIENT_INPUT_AMOUN'
                  else:
                      if ext_call.return_data[0] > Mask(112, 0, stor8.field_112) - amount1Out:
                          if ext_call.return_data[0] - Mask(112, 0, stor8.field_0) + amount0Out <= 0:
                              if ext_call.return_data[0] - Mask(112, 0, stor8.field_112) + amount1Out <= 0:
                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TUniswapV2: INSUFFICIENT_INPUT_AMOUN'
                      else:
                          if ext_call.return_data[0] - Mask(112, 0, stor8.field_0) + amount0Out <= 0:
                              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TUniswapV2: INSUFFICIENT_INPUT_AMOUN'
                      if (3 * ext_call.return_data[0]) - (3 * Mask(112, 0, stor8.field_0)) + (3 * amount0Out) / 3 != ext_call.return_data[0] - Mask(112, 0, stor8.field_0) + amount0Out:
                          revert with 0, 'ds-math-mul-overflow'
                  if 1000 * ext_call.return_data[0] / 1000 != ext_call.return_data[0]:
                      revert with 0, 'ds-math-mul-overflow'
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def burn(address to) payable: 
  require calldata.size - 4 >= 32
  if stor12 != 1:
      revert with 0, 'UniswapV2: LOCKED'
  stor12 = 0
  require ext_code.size(token0Address)
  static call token0Address.balanceOf(address account) with:
          gas gas_remaining wei
         args this.address
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  require return_data.size >= 32
  require ext_code.size(token1Address)
  static call token1Address.balanceOf(address account) with:
          gas gas_remaining wei
         args this.address
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  require return_data.size >= 32
  require ext_code.size(factoryAddress)
  static call factoryAddress.feeTo() with:
          gas gas_remaining wei
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  require return_data.size >= 32
  if not ext_call.return_data[12 len 20]:
      if kLast:
          kLast = 0
      if not ext_call.return_data[0]:
          require totalSupply
          if not ext_call.return_data[0]:
              require totalSupply
              if 0 / totalSupply <= 0:
                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                              32,
                              40,
                              0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                              mem[204 len 24]
          else:
              require ext_call.return_data[0]
              if balanceOf[this.address] * ext_call.return_data[0] / ext_call.return_data[0] != balanceOf[this.address]:
                  revert with 0, 'ds-math-mul-overflow'
              require totalSupply
              if 0 / totalSupply <= 0:
                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                              32,
                              40,
                              0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                              mem[204 len 24]
              if balanceOf[this.address] * ext_call.return_data[0] / totalSupply <= 0:
                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                              32,
                              40,
                              0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                              mem[204 len 24]
      else:
          require ext_call.return_data[0]
          if balanceOf[this.address] * ext_call.return_data[0] / ext_call.return_data[0] != balanceOf[this.address]:
              revert with 0, 'ds-math-mul-overflow'
          require totalSupply
          if not ext_call.return_data[0]:
              require totalSupply
              if balanceOf[this.address] * ext_call.return_data[0] / totalSupply <= 0:
                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                              32,
                              40,
                              0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                              mem[204 len 24]
              if 0 / totalSupply <= 0:
                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                              32,
                              40,
                              0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                              mem[204 len 24]
          else:
              require ext_call.return_data[0]
              if balanceOf[this.address] * ext_call.return_data[0] / ext_call.return_data[0] != balanceOf[this.address]:
                  revert with 0, 'ds-math-mul-overflow'
              require totalSupply
              if balanceOf[this.address] * ext_call.return_data[0] / totalSupply <= 0:
                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                              32,
                              40,
                              0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                              mem[204 len 24]
              if balanceOf[this.address] * ext_call.return_data[0] / totalSupply <= 0:
                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                              32,
                              40,
                              0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                              mem[204 len 24]
      if balanceOf[address(this.address)] - balanceOf[this.address] > balanceOf[address(this.address)]:
          revert with 0, 'ds-math-sub-underflow'
      balanceOf[address(this.address)] -= balanceOf[this.address]
      if totalSupply - balanceOf[this.address] > totalSupply:
          revert with 0, 'ds-math-sub-underflow'
      totalSupply -= balanceOf[this.address]
      log Transfer(
            address from=balanceOf[this.address],
            address to=this.address,
            uint256 value=0)
  else:
      if not kLast:
          if not ext_call.return_data[0]:
              require totalSupply
              if not ext_call.return_data[0]:
                  require totalSupply
                  if 0 / totalSupply <= 0:
                      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                  32,
                                  40,
                                  0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                                  mem[204 len 24]
              else:
                  require ext_call.return_data[0]
                  if balanceOf[this.address] * ext_call.return_data[0] / ext_call.return_data[0] != balanceOf[this.address]:
                      revert with 0, 'ds-math-mul-overflow'
                  require totalSupply
                  if 0 / totalSupply <= 0:
                      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                  32,
                                  40,
                                  0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                                  mem[204 len 24]
                  if balanceOf[this.address] * ext_call.return_data[0] / totalSupply <= 0:
                      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                  32,
                                  40,
                                  0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                                  mem[204 len 24]
          else:
              require ext_call.return_data[0]
              if balanceOf[this.address] * ext_call.return_data[0] / ext_call.return_data[0] != balanceOf[this.address]:
                  revert with 0, 'ds-math-mul-overflow'
              require totalSupply
              if not ext_call.return_data[0]:
                  require totalSupply
                  if balanceOf[this.address] * ext_call.return_data[0] / totalSupply <= 0:
                      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                  32,
                                  40,
                                  0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                                  mem[204 len 24]
                  if 0 / totalSupply <= 0:
                      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                  32,
                                  40,
                                  0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                                  mem[204 len 24]
              else:
                  require ext_call.return_data[0]
                  if balanceOf[this.address] * ext_call.return_data[0] / ext_call.return_data[0] != balanceOf[this.address]:
                      revert with 0, 'ds-math-mul-overflow'
                  require totalSupply
                  if balanceOf[this.address] * ext_call.return_data[0] / totalSupply <= 0:
                      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                  32,
                                  40,
                                  0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                                  mem[204 len 24]
                  if balanceOf[this.address] * ext_call.return_data[0] / totalSupply <= 0:
                      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                  32,
                                  40,
                                  0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                                  mem[204 len 24]
          if balanceOf[address(this.address)] - balanceOf[this.address] > balanceOf[address(this.address)]:
              revert with 0, 'ds-math-sub-underflow'
          balanceOf[address(this.address)] -= balanceOf[this.address]
          if totalSupply - balanceOf[this.address] > totalSupply:
              revert with 0, 'ds-math-sub-underflow'
          totalSupply -= balanceOf[this.address]
          log Transfer(
                address from=balanceOf[this.address],
                address to=this.address,
                uint256 value=0)
      else:
          if not Mask(112, 0, stor8.field_112):
              if kLast <= 3:
                  if not ext_call.return_data[0]:
                      require totalSupply
                      if not ext_call.return_data[0]:
                          require totalSupply
                          if 0 / totalSupply <= 0:
                              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                          32,
                                          40,
                                          0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                                          mem[204 len 24]
                      else:
                          require ext_call.return_data[0]
                          if balanceOf[this.address] * ext_call.return_data[0] / ext_call.return_data[0] != balanceOf[this.address]:
                              revert with 0, 'ds-math-mul-overflow'
                          require totalSupply
                          if 0 / totalSupply <= 0:
                              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                          32,
                                          40,
                                          0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                                          mem[204 len 24]
                          if balanceOf[this.address] * ext_call.return_data[0] / totalSupply <= 0:
                              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                          32,
                                          40,
                                          0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                                          mem[204 len 24]
                  else:
                      require ext_call.return_data[0]
                      if balanceOf[this.address] * ext_call.return_data[0] / ext_call.return_data[0] != balanceOf[this.address]:
                          revert with 0, 'ds-math-mul-overflow'
                      require totalSupply
                      if not ext_call.return_data[0]:
                          require totalSupply
                          if balanceOf[this.address] * ext_call.return_data[0] / totalSupply <= 0:
                              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                          32,
                                          40,
                                          0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                                          mem[204 len 24]
                          if 0 / totalSupply <= 0:
                              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                          32,
                                          40,
                                          0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                                          mem[204 len 24]
                      else:
                          require ext_call.return_data[0]
                          if balanceOf[this.address] * ext_call.return_data[0] / ext_call.return_data[0] != balanceOf[this.address]:
                              revert with 0, 'ds-math-mul-overflow'
                          require totalSupply
                          if balanceOf[this.address] * ext_call.return_data[0] / totalSupply <= 0:
                              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                          32,
                                          40,
                                          0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                                          mem[204 len 24]
                          if balanceOf[this.address] * ext_call.return_data[0] / totalSupply <= 0:
                              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                          32,
                                          40,
                                          0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                                          mem[204 len 24]
                  if balanceOf[address(this.address)] - balanceOf[this.address] > balanceOf[address(this.address)]:
                      revert with 0, 'ds-math-sub-underflow'
                  balanceOf[address(this.address)] -= balanceOf[this.address]
                  if totalSupply - balanceOf[this.address] > totalSupply:
                      revert with 0, 'ds-math-sub-underflow'
                  totalSupply -= balanceOf[this.address]
                  log Transfer(
                        address from=balanceOf[this.address],
                        address to=this.address,
                        uint256 value=0)
          else:
              require Mask(112, 0, stor8.field_112)
              if Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112) / Mask(112, 0, stor8.field_112) != Mask(112, 0, stor8.field_0):
                  revert with 0, 'ds-math-mul-overflow'
              if Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112) <= 3:
                  if not Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112):
                      if kLast <= 3:
                          if not ext_call.return_data[0]:
                              require totalSupply
                              if not ext_call.return_data[0]:
                                  require totalSupply
                                  if 0 / totalSupply <= 0:
                                      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                  32,
                                                  40,
                                                  0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                                                  mem[204 len 24]
                              else:
                                  require ext_call.return_data[0]
                                  if balanceOf[this.address] * ext_call.return_data[0] / ext_call.return_data[0] != balanceOf[this.address]:
                                      revert with 0, 'ds-math-mul-overflow'
                                  require totalSupply
                                  if 0 / totalSupply <= 0:
                                      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                  32,
                                                  40,
                                                  0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                                                  mem[204 len 24]
                                  if balanceOf[this.address] * ext_call.return_data[0] / totalSupply <= 0:
                                      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                  32,
                                                  40,
                                                  0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                                                  mem[204 len 24]
                          else:
                              require ext_call.return_data[0]
                              if balanceOf[this.address] * ext_call.return_data[0] / ext_call.return_data[0] != balanceOf[this.address]:
                                  revert with 0, 'ds-math-mul-overflow'
                              require totalSupply
                              if not ext_call.return_data[0]:
                                  require totalSupply
                                  if balanceOf[this.address] * ext_call.return_data[0] / totalSupply <= 0:
                                      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                  32,
                                                  40,
                                                  0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                                                  mem[204 len 24]
                                  if 0 / totalSupply <= 0:
                                      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                  32,
                                                  40,
                                                  0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                                                  mem[204 len 24]
                              else:
                                  require ext_call.return_data[0]
                                  if balanceOf[this.address] * ext_call.return_data[0] / ext_call.return_data[0] != balanceOf[this.address]:
                                      revert with 0, 'ds-math-mul-overflow'
                                  require totalSupply
                                  if balanceOf[this.address] * ext_call.return_data[0] / totalSupply <= 0:
                                      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                  32,
                                                  40,
                                                  0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                                                  mem[204 len 24]
                                  if balanceOf[this.address] * ext_call.return_data[0] / totalSupply <= 0:
                                      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                  32,
                                                  40,
                                                  0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                                                  mem[204 len 24]
                          if balanceOf[address(this.address)] - balanceOf[this.address] > balanceOf[address(this.address)]:
                              revert with 0, 'ds-math-sub-underflow'
                          balanceOf[address(this.address)] -= balanceOf[this.address]
                          if totalSupply - balanceOf[this.address] > totalSupply:
                              revert with 0, 'ds-math-sub-underflow'
                          totalSupply -= balanceOf[this.address]
                          log Transfer(
                                address from=balanceOf[this.address],
                                address to=this.address,
                                uint256 value=0)
                  else:
                      if kLast <= 3:
                          if not kLast:
                              if totalSupply != totalSupply:
                                  revert with 0, 'ds-math-mul-overflow'
                              if not totalSupply / 5:
                                  if ext_call.return_data[0]:
                                      require ext_call.return_data[0]
                              else:
                                  if totalSupply + (totalSupply / 5) < totalSupply:
                                      revert with 0, 'ds-math-add-overflow'
                                  totalSupply += totalSupply / 5
                                  if balanceOf[ext_call.return_data[12 len 20]] + (totalSupply / 5) < balanceOf[ext_call.return_data[12 len 20]]:
                                      revert with 0, 'ds-math-add-overflow'
                                  balanceOf[address(ext_call.return_data[0])] = balanceOf[ext_call.return_data[12 len 20]] + (totalSupply / 5)
                                  log Transfer(
                                        address from=(totalSupply / 5),
                                        address to=0,
                                        uint256 value=address(ext_call.return_data[0]))
                          else:
                              if not ext_call.return_data[0]:
                                  require totalSupply
                                  if not ext_call.return_data[0]:
                                      require totalSupply
                                      if 0 / totalSupply <= 0:
                                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                      32,
                                                      40,
                                                      0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                                                      mem[204 len 24]
                                  else:
                                      require ext_call.return_data[0]
                                      if balanceOf[this.address] * ext_call.return_data[0] / ext_call.return_data[0] != balanceOf[this.address]:
                                          revert with 0, 'ds-math-mul-overflow'
                                      require totalSupply
                                      if 0 / totalSupply <= 0:
                                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                      32,
                                                      40,
                                                      0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                                                      mem[204 len 24]
                                      if balanceOf[this.address] * ext_call.return_data[0] / totalSupply <= 0:
                                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                      32,
                                                      40,
                                                      0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                                                      mem[204 len 24]
                              else:
                                  require ext_call.return_data[0]
                                  if balanceOf[this.address] * ext_call.return_data[0] / ext_call.return_data[0] != balanceOf[this.address]:
                                      revert with 0, 'ds-math-mul-overflow'
                                  require totalSupply
                                  if not ext_call.return_data[0]:
                                      require totalSupply
                                      if balanceOf[this.address] * ext_call.return_data[0] / totalSupply <= 0:
                                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                      32,
                                                      40,
                                                      0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                                                      mem[204 len 24]
                                      if 0 / totalSupply <= 0:
                                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                      32,
                                                      40,
                                                      0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                                                      mem[204 len 24]
                                  else:
                                      require ext_call.return_data[0]
                                      if balanceOf[this.address] * ext_call.return_data[0] / ext_call.return_data[0] != balanceOf[this.address]:
                                          revert with 0, 'ds-math-mul-overflow'
                                      require totalSupply
                                      if balanceOf[this.address] * ext_call.return_data[0] / totalSupply <= 0:
                                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                      32,
                                                      40,
                                                      0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                                                      mem[204 len 24]
                                      if balanceOf[this.address] * ext_call.return_data[0] / totalSupply <= 0:
                                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                      32,
                                                      40,
                                                      0x59556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e45,
                                                      mem[204 len 24]
                              if balanceOf[address(this.address)] - balanceOf[this.address] > balanceOf[address(this.address)]:
                                  revert with 0, 'ds-math-sub-underflow'
                              balanceOf[address(this.address)] -= balanceOf[this.address]
                              if totalSupply - balanceOf[this.address] > totalSupply:
                                  revert with 0, 'ds-math-sub-underflow'
                              totalSupply -= balanceOf[this.address]
                              log Transfer(
                                    address from=balanceOf[this.address],
                                    address to=this.address,
                                    uint256 value=0)
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def mint(address to) payable: 
  require calldata.size - 4 >= 32
  if stor12 != 1:
      revert with 0, 'UniswapV2: LOCKED'
  stor12 = 0
  require ext_code.size(token0Address)
  static call token0Address.balanceOf(address account) with:
          gas gas_remaining wei
         args this.address
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  require return_data.size >= 32
  require ext_code.size(token1Address)
  static call token1Address.balanceOf(address account) with:
          gas gas_remaining wei
         args this.address
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  require return_data.size >= 32
  if ext_call.return_data[0] - Mask(112, 0, stor8.field_0) > ext_call.return_data[0]:
      revert with 0, 'ds-math-sub-underflow'
  if ext_call.return_data[0] - Mask(112, 0, stor8.field_112) > ext_call.return_data[0]:
      revert with 0, 'ds-math-sub-underflow'
  require ext_code.size(factoryAddress)
  static call factoryAddress.feeTo() with:
          gas gas_remaining wei
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  require return_data.size >= 32
  if ext_call.return_data[12 len 20]:
      if kLast:
          if not Mask(112, 0, stor8.field_112):
              if kLast <= 3:
                  if not totalSupply:
                      if ext_call.return_data[0] - Mask(112, 0, stor8.field_112):
                          require ext_call.return_data[0] - Mask(112, 0, stor8.field_112)
                          if (ext_call.return_data[0] * ext_call.return_data[0]) - (Mask(112, 0, stor8.field_112) * ext_call.return_data[0]) - (ext_call.return_data[0] * Mask(112, 0, stor8.field_0)) + (Mask(112, 0, stor8.field_112) * Mask(112, 0, stor8.field_0)) / ext_call.return_data[0] - Mask(112, 0, stor8.field_112) != ext_call.return_data[0] - Mask(112, 0, stor8.field_0):
                              revert with 0, 'ds-math-mul-overflow'
                          if (ext_call.return_data[0] * ext_call.return_data[0]) - (Mask(112, 0, stor8.field_112) * ext_call.return_data[0]) - (ext_call.return_data[0] * Mask(112, 0, stor8.field_0)) + (Mask(112, 0, stor8.field_112) * Mask(112, 0, stor8.field_0)) > 3:
                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                      revert with 0, 'ds-math-sub-underflow'
                  require totalSupply
                  if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / totalSupply != ext_call.return_data[0] - Mask(112, 0, stor8.field_0):
                      revert with 0, 'ds-math-mul-overflow'
                  require Mask(112, 0, stor8.field_0)
                  if kLast:
                      if not totalSupply:
                          require Mask(112, 0, stor8.field_112)
                          if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0) < 0 / Mask(112, 0, stor8.field_112):
                              if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0) <= 0:
                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                              32,
                                              40,
                                              0x44556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e5445,
                                              mem[204 len 24]
                              if totalSupply + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)) < totalSupply:
                                  revert with 0, 'ds-math-add-overflow'
                              totalSupply += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)
                              if balanceOf[address(to)] + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)) < balanceOf[address(to)]:
                                  revert with 0, 'ds-math-add-overflow'
                              balanceOf[address(to)] += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)
                              log Transfer(
                                    address from=((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)),
                                    address to=0,
                                    uint256 value=to)
                          else:
                              if 0 / Mask(112, 0, stor8.field_112) <= 0:
                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                              32,
                                              40,
                                              0x44556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e5445,
                                              mem[204 len 24]
                              if totalSupply + (0 / Mask(112, 0, stor8.field_112)) < totalSupply:
                                  revert with 0, 'ds-math-add-overflow'
                              totalSupply += 0 / Mask(112, 0, stor8.field_112)
                              if balanceOf[address(to)] + (0 / Mask(112, 0, stor8.field_112)) < balanceOf[address(to)]:
                                  revert with 0, 'ds-math-add-overflow'
                              balanceOf[address(to)] += 0 / Mask(112, 0, stor8.field_112)
                              log Transfer(
                                    address from=(0 / Mask(112, 0, stor8.field_112)),
                                    address to=0,
                                    uint256 value=to)
                          if ext_call.return_data[0] > LOCK8605463013():
                              revert with 0, 'UniswapV2: OVERFLOW'
                      else:
                          require totalSupply
                          if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / totalSupply != ext_call.return_data[0] - Mask(112, 0, stor8.field_112):
                              revert with 0, 'ds-math-mul-overflow'
                          require Mask(112, 0, stor8.field_112)
                          if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0) < (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112):
                              if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0) <= 0:
                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                              32,
                                              40,
                                              0x44556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e5445,
                                              mem[204 len 24]
                              if totalSupply + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)) < totalSupply:
                                  revert with 0, 'ds-math-add-overflow'
                              totalSupply += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)
                              if balanceOf[address(to)] + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)) < balanceOf[address(to)]:
                                  revert with 0, 'ds-math-add-overflow'
                              balanceOf[address(to)] += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)
                              log Transfer(
                                    address from=((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)),
                                    address to=0,
                                    uint256 value=to)
                          else:
                              if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112) <= 0:
                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                              32,
                                              40,
                                              0x44556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e5445,
                                              mem[204 len 24]
                              if totalSupply + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)) < totalSupply:
                                  revert with 0, 'ds-math-add-overflow'
                              totalSupply += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)
                              if balanceOf[address(to)] + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)) < balanceOf[address(to)]:
                                  revert with 0, 'ds-math-add-overflow'
                              balanceOf[address(to)] += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)
                              log Transfer(
                                    address from=((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)),
                                    address to=0,
                                    uint256 value=to)
                      if ext_call.return_data[0] > LOCK8605463013():
                          revert with 0, 'UniswapV2: OVERFLOW'
                  else:
                      if not totalSupply:
                          require Mask(112, 0, stor8.field_112)
                          if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0) < 0 / Mask(112, 0, stor8.field_112):
                              if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0) <= 0:
                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                              32,
                                              40,
                                              0x44556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e5445,
                                              mem[204 len 24]
                              if totalSupply + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)) < totalSupply:
                                  revert with 0, 'ds-math-add-overflow'
                              totalSupply += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)
                              if balanceOf[address(to)] + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)) < balanceOf[address(to)]:
                                  revert with 0, 'ds-math-add-overflow'
                              balanceOf[address(to)] += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)
                              log Transfer(
                                    address from=((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)),
                                    address to=0,
                                    uint256 value=to)
                          else:
                              if 0 / Mask(112, 0, stor8.field_112) <= 0:
                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                              32,
                                              40,
                                              0x44556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e5445,
                                              mem[204 len 24]
                              if totalSupply + (0 / Mask(112, 0, stor8.field_112)) < totalSupply:
                                  revert with 0, 'ds-math-add-overflow'
                              totalSupply += 0 / Mask(112, 0, stor8.field_112)
                              if balanceOf[address(to)] + (0 / Mask(112, 0, stor8.field_112)) < balanceOf[address(to)]:
                                  revert with 0, 'ds-math-add-overflow'
                              balanceOf[address(to)] += 0 / Mask(112, 0, stor8.field_112)
                              log Transfer(
                                    address from=(0 / Mask(112, 0, stor8.field_112)),
                                    address to=0,
                                    uint256 value=to)
                          if ext_call.return_data[0] > LOCK8605463013():
                              revert with 0, 'UniswapV2: OVERFLOW'
                          if ext_call.return_data[0] > LOCK8605463013():
                              revert with 0, 'UniswapV2: OVERFLOW'
                          if uint32(uint32(block.timestamp) - uint32(stor8.field_224)):
                      else:
                          require totalSupply
                          if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / totalSupply != ext_call.return_data[0] - Mask(112, 0, stor8.field_112):
                              revert with 0, 'ds-math-mul-overflow'
                          require Mask(112, 0, stor8.field_112)
                          if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0) < (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112):
                              if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0) <= 0:
                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                              32,
                                              40,
                                              0x44556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e5445,
                                              mem[204 len 24]
                              if totalSupply + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)) < totalSupply:
                                  revert with 0, 'ds-math-add-overflow'
                              totalSupply += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)
                              if balanceOf[address(to)] + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)) < balanceOf[address(to)]:
                                  revert with 0, 'ds-math-add-overflow'
                              balanceOf[address(to)] += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)
                              log Transfer(
                                    address from=((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)),
                                    address to=0,
                                    uint256 value=to)
                          else:
                              if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112) <= 0:
                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                              32,
                                              40,
                                              0x44556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e5445,
                                              mem[204 len 24]
                              if totalSupply + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)) < totalSupply:
                                  revert with 0, 'ds-math-add-overflow'
                              totalSupply += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)
                              if balanceOf[address(to)] + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)) < balanceOf[address(to)]:
                                  revert with 0, 'ds-math-add-overflow'
                              balanceOf[address(to)] += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)
                              log Transfer(
                                    address from=((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)),
                                    address to=0,
                                    uint256 value=to)
                          if ext_call.return_data[0] > LOCK8605463013():
                              revert with 0, 'UniswapV2: OVERFLOW'
                          if ext_call.return_data[0] > LOCK8605463013():
                              revert with 0, 'UniswapV2: OVERFLOW'
          else:
              require Mask(112, 0, stor8.field_112)
              if Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112) / Mask(112, 0, stor8.field_112) != Mask(112, 0, stor8.field_0):
                  revert with 0, 'ds-math-mul-overflow'
              if Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112) <= 3:
                  if Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112):
                      if kLast <= 3:
                          if not kLast:
                              if totalSupply != totalSupply:
                                  revert with 0, 'ds-math-mul-overflow'
                              if not totalSupply / 5:
                                  if totalSupply:
                                      require totalSupply
                                      if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / totalSupply != ext_call.return_data[0] - Mask(112, 0, stor8.field_0):
                                          revert with 0, 'ds-math-mul-overflow'
                                      require Mask(112, 0, stor8.field_0)
                                  else:
                                      if ext_call.return_data[0] - Mask(112, 0, stor8.field_112):
                                          require ext_call.return_data[0] - Mask(112, 0, stor8.field_112)
                                          if (ext_call.return_data[0] * ext_call.return_data[0]) - (Mask(112, 0, stor8.field_112) * ext_call.return_data[0]) - (ext_call.return_data[0] * Mask(112, 0, stor8.field_0)) + (Mask(112, 0, stor8.field_112) * Mask(112, 0, stor8.field_0)) / ext_call.return_data[0] - Mask(112, 0, stor8.field_112) != ext_call.return_data[0] - Mask(112, 0, stor8.field_0):
                                              revert with 0, 'ds-math-mul-overflow'
                                          if (ext_call.return_data[0] * ext_call.return_data[0]) - (Mask(112, 0, stor8.field_112) * ext_call.return_data[0]) - (ext_call.return_data[0] * Mask(112, 0, stor8.field_0)) + (Mask(112, 0, stor8.field_112) * Mask(112, 0, stor8.field_0)) <= 3:
                              else:
                                  if totalSupply + (totalSupply / 5) < totalSupply:
                                      revert with 0, 'ds-math-add-overflow'
                                  totalSupply += totalSupply / 5
                                  if balanceOf[ext_call.return_data[12 len 20]] + (totalSupply / 5) < balanceOf[ext_call.return_data[12 len 20]]:
                                      revert with 0, 'ds-math-add-overflow'
                                  balanceOf[address(ext_call.return_data[0])] = balanceOf[ext_call.return_data[12 len 20]] + (totalSupply / 5)
                                  log Transfer(
                                        address from=(totalSupply / 5),
                                        address to=0,
                                        uint256 value=address(ext_call.return_data[0]))
                          else:
                              if not totalSupply:
                                  if ext_call.return_data[0] - Mask(112, 0, stor8.field_112):
                                      require ext_call.return_data[0] - Mask(112, 0, stor8.field_112)
                                      if (ext_call.return_data[0] * ext_call.return_data[0]) - (Mask(112, 0, stor8.field_112) * ext_call.return_data[0]) - (ext_call.return_data[0] * Mask(112, 0, stor8.field_0)) + (Mask(112, 0, stor8.field_112) * Mask(112, 0, stor8.field_0)) / ext_call.return_data[0] - Mask(112, 0, stor8.field_112) != ext_call.return_data[0] - Mask(112, 0, stor8.field_0):
                                          revert with 0, 'ds-math-mul-overflow'
                                      if (ext_call.return_data[0] * ext_call.return_data[0]) - (Mask(112, 0, stor8.field_112) * ext_call.return_data[0]) - (ext_call.return_data[0] * Mask(112, 0, stor8.field_0)) + (Mask(112, 0, stor8.field_112) * Mask(112, 0, stor8.field_0)) > 3:
                                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                                  revert with 0, 'ds-math-sub-underflow'
                              require totalSupply
                              if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / totalSupply != ext_call.return_data[0] - Mask(112, 0, stor8.field_0):
                                  revert with 0, 'ds-math-mul-overflow'
                              require Mask(112, 0, stor8.field_0)
                              if not totalSupply:
                                  require Mask(112, 0, stor8.field_112)
                                  if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0) < 0 / Mask(112, 0, stor8.field_112):
                                      if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0) <= 0:
                                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                      32,
                                                      40,
                                                      0x44556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e5445,
                                                      mem[204 len 24]
                                      if totalSupply + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)) < totalSupply:
                                          revert with 0, 'ds-math-add-overflow'
                                      totalSupply += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)
                                      if balanceOf[address(to)] + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)) < balanceOf[address(to)]:
                                          revert with 0, 'ds-math-add-overflow'
                                      balanceOf[address(to)] += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)
                                      log Transfer(
                                            address from=((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)),
                                            address to=0,
                                            uint256 value=to)
                                  else:
                                      if 0 / Mask(112, 0, stor8.field_112) <= 0:
                                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                      32,
                                                      40,
                                                      0x44556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e5445,
                                                      mem[204 len 24]
                                      if totalSupply + (0 / Mask(112, 0, stor8.field_112)) < totalSupply:
                                          revert with 0, 'ds-math-add-overflow'
                                      totalSupply += 0 / Mask(112, 0, stor8.field_112)
                                      if balanceOf[address(to)] + (0 / Mask(112, 0, stor8.field_112)) < balanceOf[address(to)]:
                                          revert with 0, 'ds-math-add-overflow'
                                      balanceOf[address(to)] += 0 / Mask(112, 0, stor8.field_112)
                                      log Transfer(
                                            address from=(0 / Mask(112, 0, stor8.field_112)),
                                            address to=0,
                                            uint256 value=to)
                              else:
                                  require totalSupply
                                  if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / totalSupply != ext_call.return_data[0] - Mask(112, 0, stor8.field_112):
                                      revert with 0, 'ds-math-mul-overflow'
                                  require Mask(112, 0, stor8.field_112)
                                  if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0) < (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112):
                                      if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0) <= 0:
                                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                      32,
                                                      40,
                                                      0x44556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e5445,
                                                      mem[204 len 24]
                                      if totalSupply + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)) < totalSupply:
                                          revert with 0, 'ds-math-add-overflow'
                                      totalSupply += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)
                                      if balanceOf[address(to)] + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)) < balanceOf[address(to)]:
                                          revert with 0, 'ds-math-add-overflow'
                                      balanceOf[address(to)] += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)
                                      log Transfer(
                                            address from=((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)),
                                            address to=0,
                                            uint256 value=to)
                                  else:
                                      if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112) <= 0:
                                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                      32,
                                                      40,
                                                      0x44556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e5445,
                                                      mem[204 len 24]
                                      if totalSupply + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)) < totalSupply:
                                          revert with 0, 'ds-math-add-overflow'
                                      totalSupply += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)
                                      if balanceOf[address(to)] + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)) < balanceOf[address(to)]:
                                          revert with 0, 'ds-math-add-overflow'
                                      balanceOf[address(to)] += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)
                                      log Transfer(
                                            address from=((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)),
                                            address to=0,
                                            uint256 value=to)
                  else:
                      if kLast <= 3:
                          if not totalSupply:
                              if ext_call.return_data[0] - Mask(112, 0, stor8.field_112):
                                  require ext_call.return_data[0] - Mask(112, 0, stor8.field_112)
                                  if (ext_call.return_data[0] * ext_call.return_data[0]) - (Mask(112, 0, stor8.field_112) * ext_call.return_data[0]) - (ext_call.return_data[0] * Mask(112, 0, stor8.field_0)) + (Mask(112, 0, stor8.field_112) * Mask(112, 0, stor8.field_0)) / ext_call.return_data[0] - Mask(112, 0, stor8.field_112) != ext_call.return_data[0] - Mask(112, 0, stor8.field_0):
                                      revert with 0, 'ds-math-mul-overflow'
                                  if (ext_call.return_data[0] * ext_call.return_data[0]) - (Mask(112, 0, stor8.field_112) * ext_call.return_data[0]) - (ext_call.return_data[0] * Mask(112, 0, stor8.field_0)) + (Mask(112, 0, stor8.field_112) * Mask(112, 0, stor8.field_0)) > 3:
                                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                              revert with 0, 'ds-math-sub-underflow'
                          require totalSupply
                          if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / totalSupply != ext_call.return_data[0] - Mask(112, 0, stor8.field_0):
                              revert with 0, 'ds-math-mul-overflow'
                          require Mask(112, 0, stor8.field_0)
                          if not kLast:
                              if not totalSupply:
                                  require Mask(112, 0, stor8.field_112)
                                  if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0) < 0 / Mask(112, 0, stor8.field_112):
                                      if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0) <= 0:
                                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                      32,
                                                      40,
                                                      0x44556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e5445,
                                                      mem[204 len 24]
                                      if totalSupply + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)) < totalSupply:
                                          revert with 0, 'ds-math-add-overflow'
                                      totalSupply += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)
                                      if balanceOf[address(to)] + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)) < balanceOf[address(to)]:
                                          revert with 0, 'ds-math-add-overflow'
                                      balanceOf[address(to)] += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)
                                      log Transfer(
                                            address from=((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)),
                                            address to=0,
                                            uint256 value=to)
                                  else:
                                      if 0 / Mask(112, 0, stor8.field_112) <= 0:
                                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                      32,
                                                      40,
                                                      0x44556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e5445,
                                                      mem[204 len 24]
                                      if totalSupply + (0 / Mask(112, 0, stor8.field_112)) < totalSupply:
                                          revert with 0, 'ds-math-add-overflow'
                                      totalSupply += 0 / Mask(112, 0, stor8.field_112)
                                      if balanceOf[address(to)] + (0 / Mask(112, 0, stor8.field_112)) < balanceOf[address(to)]:
                                          revert with 0, 'ds-math-add-overflow'
                                      balanceOf[address(to)] += 0 / Mask(112, 0, stor8.field_112)
                                      log Transfer(
                                            address from=(0 / Mask(112, 0, stor8.field_112)),
                                            address to=0,
                                            uint256 value=to)
                                  if ext_call.return_data[0] > LOCK8605463013():
                                      revert with 0, 'UniswapV2: OVERFLOW'
                                  if ext_call.return_data[0] > LOCK8605463013():
                                      revert with 0, 'UniswapV2: OVERFLOW'
                              else:
                                  require totalSupply
                                  if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / totalSupply != ext_call.return_data[0] - Mask(112, 0, stor8.field_112):
                                      revert with 0, 'ds-math-mul-overflow'
                                  require Mask(112, 0, stor8.field_112)
                                  if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0) < (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112):
                                      if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0) <= 0:
                                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                      32,
                                                      40,
                                                      0x44556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e5445,
                                                      mem[204 len 24]
                                      if totalSupply + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)) < totalSupply:
                                          revert with 0, 'ds-math-add-overflow'
                                      totalSupply += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)
                                      if balanceOf[address(to)] + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)) < balanceOf[address(to)]:
                                          revert with 0, 'ds-math-add-overflow'
                                      balanceOf[address(to)] += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)
                                      log Transfer(
                                            address from=((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)),
                                            address to=0,
                                            uint256 value=to)
                                  else:
                                      if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112) <= 0:
                                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                      32,
                                                      40,
                                                      0x44556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e5445,
                                                      mem[204 len 24]
                                      if totalSupply + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)) < totalSupply:
                                          revert with 0, 'ds-math-add-overflow'
                                      totalSupply += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)
                                      if balanceOf[address(to)] + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)) < balanceOf[address(to)]:
                                          revert with 0, 'ds-math-add-overflow'
                                      balanceOf[address(to)] += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)
                                      log Transfer(
                                            address from=((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)),
                                            address to=0,
                                            uint256 value=to)
                          else:
                              if not totalSupply:
                                  require Mask(112, 0, stor8.field_112)
                                  if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0) < 0 / Mask(112, 0, stor8.field_112):
                                      if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0) <= 0:
                                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                      32,
                                                      40,
                                                      0x44556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e5445,
                                                      mem[204 len 24]
                                      if totalSupply + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)) < totalSupply:
                                          revert with 0, 'ds-math-add-overflow'
                                      totalSupply += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)
                                      if balanceOf[address(to)] + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)) < balanceOf[address(to)]:
                                          revert with 0, 'ds-math-add-overflow'
                                      balanceOf[address(to)] += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)
                                      log Transfer(
                                            address from=((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)),
                                            address to=0,
                                            uint256 value=to)
                                  else:
                                      if 0 / Mask(112, 0, stor8.field_112) <= 0:
                                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                      32,
                                                      40,
                                                      0x44556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e5445,
                                                      mem[204 len 24]
                                      if totalSupply + (0 / Mask(112, 0, stor8.field_112)) < totalSupply:
                                          revert with 0, 'ds-math-add-overflow'
                                      totalSupply += 0 / Mask(112, 0, stor8.field_112)
                                      if balanceOf[address(to)] + (0 / Mask(112, 0, stor8.field_112)) < balanceOf[address(to)]:
                                          revert with 0, 'ds-math-add-overflow'
                                      balanceOf[address(to)] += 0 / Mask(112, 0, stor8.field_112)
                                      log Transfer(
                                            address from=(0 / Mask(112, 0, stor8.field_112)),
                                            address to=0,
                                            uint256 value=to)
                                  if ext_call.return_data[0] > LOCK8605463013():
                                      revert with 0, 'UniswapV2: OVERFLOW'
                              else:
                                  require totalSupply
                                  if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / totalSupply != ext_call.return_data[0] - Mask(112, 0, stor8.field_112):
                                      revert with 0, 'ds-math-mul-overflow'
                                  require Mask(112, 0, stor8.field_112)
                                  if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0) < (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112):
                                      if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0) <= 0:
                                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                      32,
                                                      40,
                                                      0x44556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e5445,
                                                      mem[204 len 24]
                                      if totalSupply + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)) < totalSupply:
                                          revert with 0, 'ds-math-add-overflow'
                                      totalSupply += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)
                                      if balanceOf[address(to)] + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)) < balanceOf[address(to)]:
                                          revert with 0, 'ds-math-add-overflow'
                                      balanceOf[address(to)] += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)
                                      log Transfer(
                                            address from=((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)),
                                            address to=0,
                                            uint256 value=to)
                                  else:
                                      if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112) <= 0:
                                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                      32,
                                                      40,
                                                      0x44556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e5445,
                                                      mem[204 len 24]
                                      if totalSupply + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)) < totalSupply:
                                          revert with 0, 'ds-math-add-overflow'
                                      totalSupply += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)
                                      if balanceOf[address(to)] + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)) < balanceOf[address(to)]:
                                          revert with 0, 'ds-math-add-overflow'
                                      balanceOf[address(to)] += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)
                                      log Transfer(
                                            address from=((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)),
                                            address to=0,
                                            uint256 value=to)
      else:
          if not totalSupply:
              if ext_call.return_data[0] - Mask(112, 0, stor8.field_112):
                  require ext_call.return_data[0] - Mask(112, 0, stor8.field_112)
                  if (ext_call.return_data[0] * ext_call.return_data[0]) - (Mask(112, 0, stor8.field_112) * ext_call.return_data[0]) - (ext_call.return_data[0] * Mask(112, 0, stor8.field_0)) + (Mask(112, 0, stor8.field_112) * Mask(112, 0, stor8.field_0)) / ext_call.return_data[0] - Mask(112, 0, stor8.field_112) != ext_call.return_data[0] - Mask(112, 0, stor8.field_0):
                      revert with 0, 'ds-math-mul-overflow'
                  if (ext_call.return_data[0] * ext_call.return_data[0]) - (Mask(112, 0, stor8.field_112) * ext_call.return_data[0]) - (ext_call.return_data[0] * Mask(112, 0, stor8.field_0)) + (Mask(112, 0, stor8.field_112) * Mask(112, 0, stor8.field_0)) > 3:
                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              revert with 0, 'ds-math-sub-underflow'
          require totalSupply
          if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / totalSupply != ext_call.return_data[0] - Mask(112, 0, stor8.field_0):
              revert with 0, 'ds-math-mul-overflow'
          require Mask(112, 0, stor8.field_0)
          if not totalSupply:
              require Mask(112, 0, stor8.field_112)
              if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0) < 0 / Mask(112, 0, stor8.field_112):
                  if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0) <= 0:
                      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                  32,
                                  40,
                                  0x44556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e5445,
                                  mem[204 len 24]
                  if totalSupply + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)) < totalSupply:
                      revert with 0, 'ds-math-add-overflow'
                  totalSupply += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)
                  if balanceOf[address(to)] + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)) < balanceOf[address(to)]:
                      revert with 0, 'ds-math-add-overflow'
                  balanceOf[address(to)] += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)
                  log Transfer(
                        address from=((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)),
                        address to=0,
                        uint256 value=to)
                  if ext_call.return_data[0] > LOCK8605463013():
                      revert with 0, 'UniswapV2: OVERFLOW'
                  if ext_call.return_data[0] > LOCK8605463013():
                      revert with 0, 'UniswapV2: OVERFLOW'
                  if uint32(uint32(block.timestamp) - uint32(stor8.field_224)):
                      if Mask(112, 0, stor8.field_0):
                          if Mask(112, 0, stor8.field_112):
                              require Mask(112, 0, stor8.field_0)
                              price0CumulativeLast += Mask(224, 0, Mask(112, 0, Mask(112, 0, stor8.field_112)) << 112 / Mask(112, 0, stor8.field_0)) * uint32(uint32(block.timestamp) - uint32(stor8.field_224))
                              require Mask(112, 0, stor8.field_112)
                              price1CumulativeLast += Mask(224, 0, Mask(112, 0, stor8.field_0) / Mask(112, 0, stor8.field_112)) * uint32(uint32(block.timestamp) - uint32(stor8.field_224))
                              Mask(112, 0, stor8.field_0) = Mask(112, 0, ext_call.return_data[0])
                              Mask(112, 0, stor8.field_112) = Mask(112, 0, ext_call.return_data[0])
                              uint32(stor8.field_224) = uint32(block.timestamp)
                              log Sync(
                                    uint112 reserve0=ext_call.return_data[0] << 144,
                                    uint112 reserve1=Mask(112, 0, ext_call.return_data[0]))
                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                  Mask(112, 0, stor8.field_0) = Mask(112, 0, ext_call.return_data[0])
                  Mask(112, 0, stor8.field_112) = Mask(112, 0, ext_call.return_data[0])
                  uint32(stor8.field_224) = uint32(block.timestamp)
                  log Sync(
                        uint112 reserve0=ext_call.return_data[0] << 144,
                        uint112 reserve1=Mask(112, 0, ext_call.return_data[0]))
                  if address(ext_call.return_data[0]):
                      if not Mask(112, 0, stor8.field_112):
                          kLast = 0
                      else:
                          require Mask(112, 0, stor8.field_112)
                          if Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112) / Mask(112, 0, stor8.field_112) != Mask(112, 0, stor8.field_0):
                              revert with 0, 'ds-math-mul-overflow'
                          kLast = Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112)
                  log Mint(
                        address minter=ext_call.return_data[0] - Mask(112, 0, stor8.field_0),
                        uint256 mintAmount=ext_call.return_data[0] - Mask(112, 0, stor8.field_112),
                        uint256 mintTokens=caller)
                  stor12 = 1
                  return ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0))
              if 0 / Mask(112, 0, stor8.field_112) <= 0:
                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                              32,
                              40,
                              0x44556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e5445,
                              mem[204 len 24]
              if totalSupply + (0 / Mask(112, 0, stor8.field_112)) < totalSupply:
                  revert with 0, 'ds-math-add-overflow'
              totalSupply += 0 / Mask(112, 0, stor8.field_112)
              if balanceOf[address(to)] + (0 / Mask(112, 0, stor8.field_112)) < balanceOf[address(to)]:
                  revert with 0, 'ds-math-add-overflow'
              balanceOf[address(to)] += 0 / Mask(112, 0, stor8.field_112)
              log Transfer(
                    address from=(0 / Mask(112, 0, stor8.field_112)),
                    address to=0,
                    uint256 value=to)
              if ext_call.return_data[0] > LOCK8605463013():
                  revert with 0, 'UniswapV2: OVERFLOW'
              if ext_call.return_data[0] > LOCK8605463013():
                  revert with 0, 'UniswapV2: OVERFLOW'
              if uint32(uint32(block.timestamp) - uint32(stor8.field_224)):
                  if Mask(112, 0, stor8.field_0):
                      if Mask(112, 0, stor8.field_112):
                          require Mask(112, 0, stor8.field_0)
                          price0CumulativeLast += Mask(224, 0, Mask(112, 0, Mask(112, 0, stor8.field_112)) << 112 / Mask(112, 0, stor8.field_0)) * uint32(uint32(block.timestamp) - uint32(stor8.field_224))
                          require Mask(112, 0, stor8.field_112)
                          price1CumulativeLast += Mask(224, 0, Mask(112, 0, stor8.field_0) / Mask(112, 0, stor8.field_112)) * uint32(uint32(block.timestamp) - uint32(stor8.field_224))
                          Mask(112, 0, stor8.field_0) = Mask(112, 0, ext_call.return_data[0])
                          Mask(112, 0, stor8.field_112) = Mask(112, 0, ext_call.return_data[0])
                          uint32(stor8.field_224) = uint32(block.timestamp)
                          log Sync(
                                uint112 reserve0=ext_call.return_data[0] << 144,
                                uint112 reserve1=Mask(112, 0, ext_call.return_data[0]))
                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              Mask(112, 0, stor8.field_0) = Mask(112, 0, ext_call.return_data[0])
              Mask(112, 0, stor8.field_112) = Mask(112, 0, ext_call.return_data[0])
              uint32(stor8.field_224) = uint32(block.timestamp)
              log Sync(
                    uint112 reserve0=ext_call.return_data[0] << 144,
                    uint112 reserve1=Mask(112, 0, ext_call.return_data[0]))
              if address(ext_call.return_data[0]):
                  if not Mask(112, 0, stor8.field_112):
                      kLast = 0
                  else:
                      require Mask(112, 0, stor8.field_112)
                      if Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112) / Mask(112, 0, stor8.field_112) != Mask(112, 0, stor8.field_0):
                          revert with 0, 'ds-math-mul-overflow'
                      kLast = Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112)
              log Mint(
                    address minter=ext_call.return_data[0] - Mask(112, 0, stor8.field_0),
                    uint256 mintAmount=ext_call.return_data[0] - Mask(112, 0, stor8.field_112),
                    uint256 mintTokens=caller)
              stor12 = 1
              return (0 / Mask(112, 0, stor8.field_112))
          require totalSupply
          if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / totalSupply != ext_call.return_data[0] - Mask(112, 0, stor8.field_112):
              revert with 0, 'ds-math-mul-overflow'
          require Mask(112, 0, stor8.field_112)
          if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0) < (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112):
              if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0) <= 0:
                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                              32,
                              40,
                              0x44556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e5445,
                              mem[204 len 24]
              if totalSupply + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)) < totalSupply:
                  revert with 0, 'ds-math-add-overflow'
              totalSupply += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)
              if balanceOf[address(to)] + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)) < balanceOf[address(to)]:
                  revert with 0, 'ds-math-add-overflow'
              balanceOf[address(to)] += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)
              log Transfer(
                    address from=((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)),
                    address to=0,
                    uint256 value=to)
              if ext_call.return_data[0] > LOCK8605463013():
                  revert with 0, 'UniswapV2: OVERFLOW'
              if ext_call.return_data[0] > LOCK8605463013():
                  revert with 0, 'UniswapV2: OVERFLOW'
              if not uint32(uint32(block.timestamp) - uint32(stor8.field_224)):
                  Mask(112, 0, stor8.field_0) = Mask(112, 0, ext_call.return_data[0])
                  Mask(112, 0, stor8.field_112) = Mask(112, 0, ext_call.return_data[0])
                  uint32(stor8.field_224) = uint32(block.timestamp)
                  log Sync(
                        uint112 reserve0=ext_call.return_data[0] << 144,
                        uint112 reserve1=Mask(112, 0, ext_call.return_data[0]))
                  if address(ext_call.return_data[0]):
                      if not Mask(112, 0, stor8.field_112):
                          kLast = 0
                      else:
                          require Mask(112, 0, stor8.field_112)
                          if Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112) / Mask(112, 0, stor8.field_112) != Mask(112, 0, stor8.field_0):
                              revert with 0, 'ds-math-mul-overflow'
                          kLast = Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112)
                  log Mint(
                        address minter=ext_call.return_data[0] - Mask(112, 0, stor8.field_0),
                        uint256 mintAmount=ext_call.return_data[0] - Mask(112, 0, stor8.field_112),
                        uint256 mintTokens=caller)
                  stor12 = 1
                  return ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0))
              if not Mask(112, 0, stor8.field_0):
                  Mask(112, 0, stor8.field_0) = Mask(112, 0, ext_call.return_data[0])
                  Mask(112, 0, stor8.field_112) = Mask(112, 0, ext_call.return_data[0])
                  uint32(stor8.field_224) = uint32(block.timestamp)
                  log Sync(
                        uint112 reserve0=ext_call.return_data[0] << 144,
                        uint112 reserve1=Mask(112, 0, ext_call.return_data[0]))
                  if address(ext_call.return_data[0]):
                      if not Mask(112, 0, stor8.field_112):
                          kLast = 0
                      else:
                          require Mask(112, 0, stor8.field_112)
                          if Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112) / Mask(112, 0, stor8.field_112) != Mask(112, 0, stor8.field_0):
                              revert with 0, 'ds-math-mul-overflow'
                          kLast = Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112)
                  log Mint(
                        address minter=ext_call.return_data[0] - Mask(112, 0, stor8.field_0),
                        uint256 mintAmount=ext_call.return_data[0] - Mask(112, 0, stor8.field_112),
                        uint256 mintTokens=caller)
                  stor12 = 1
                  return ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0))
              if Mask(112, 0, stor8.field_112):
                  require Mask(112, 0, stor8.field_0)
                  price0CumulativeLast += Mask(224, 0, Mask(112, 0, Mask(112, 0, stor8.field_112)) << 112 / Mask(112, 0, stor8.field_0)) * uint32(uint32(block.timestamp) - uint32(stor8.field_224))
                  require Mask(112, 0, stor8.field_112)
                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              Mask(112, 0, stor8.field_0) = Mask(112, 0, ext_call.return_data[0])
              Mask(112, 0, stor8.field_112) = Mask(112, 0, ext_call.return_data[0])
              uint32(stor8.field_224) = uint32(block.timestamp)
              log Sync(
                    uint112 reserve0=ext_call.return_data[0] << 144,
                    uint112 reserve1=Mask(112, 0, ext_call.return_data[0]))
              if not address(ext_call.return_data[0]):
                  log Mint(
                        address minter=ext_call.return_data[0] - Mask(112, 0, stor8.field_0),
                        uint256 mintAmount=ext_call.return_data[0] - Mask(112, 0, stor8.field_112),
                        uint256 mintTokens=caller)
                  stor12 = 1
                  return ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0))
              if not Mask(112, 0, stor8.field_112):
                  kLast = 0
                  log Mint(
                        address minter=ext_call.return_data[0] - Mask(112, 0, stor8.field_0),
                        uint256 mintAmount=ext_call.return_data[0] - Mask(112, 0, stor8.field_112),
                        uint256 mintTokens=caller)
                  stor12 = 1
                  return ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0))
          else:
              if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112) <= 0:
                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                              32,
                              40,
                              0x44556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e5445,
                              mem[204 len 24]
              if totalSupply + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)) < totalSupply:
                  revert with 0, 'ds-math-add-overflow'
              totalSupply += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)
              if balanceOf[address(to)] + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)) < balanceOf[address(to)]:
                  revert with 0, 'ds-math-add-overflow'
              balanceOf[address(to)] += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)
              log Transfer(
                    address from=((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)),
                    address to=0,
                    uint256 value=to)
              if ext_call.return_data[0] > LOCK8605463013():
                  revert with 0, 'UniswapV2: OVERFLOW'
              if ext_call.return_data[0] > LOCK8605463013():
                  revert with 0, 'UniswapV2: OVERFLOW'
              if not uint32(uint32(block.timestamp) - uint32(stor8.field_224)):
                  Mask(112, 0, stor8.field_0) = Mask(112, 0, ext_call.return_data[0])
                  Mask(112, 0, stor8.field_112) = Mask(112, 0, ext_call.return_data[0])
                  uint32(stor8.field_224) = uint32(block.timestamp)
                  log Sync(
                        uint112 reserve0=ext_call.return_data[0] << 144,
                        uint112 reserve1=Mask(112, 0, ext_call.return_data[0]))
                  if address(ext_call.return_data[0]):
                      if not Mask(112, 0, stor8.field_112):
                          kLast = 0
                      else:
                          require Mask(112, 0, stor8.field_112)
                          if Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112) / Mask(112, 0, stor8.field_112) != Mask(112, 0, stor8.field_0):
                              revert with 0, 'ds-math-mul-overflow'
                          kLast = Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112)
                  log Mint(
                        address minter=ext_call.return_data[0] - Mask(112, 0, stor8.field_0),
                        uint256 mintAmount=ext_call.return_data[0] - Mask(112, 0, stor8.field_112),
                        uint256 mintTokens=caller)
                  stor12 = 1
                  return ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112))
              if not Mask(112, 0, stor8.field_0):
                  Mask(112, 0, stor8.field_0) = Mask(112, 0, ext_call.return_data[0])
                  Mask(112, 0, stor8.field_112) = Mask(112, 0, ext_call.return_data[0])
                  uint32(stor8.field_224) = uint32(block.timestamp)
                  log Sync(
                        uint112 reserve0=ext_call.return_data[0] << 144,
                        uint112 reserve1=Mask(112, 0, ext_call.return_data[0]))
                  if address(ext_call.return_data[0]):
                      if not Mask(112, 0, stor8.field_112):
                          kLast = 0
                      else:
                          require Mask(112, 0, stor8.field_112)
                          if Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112) / Mask(112, 0, stor8.field_112) != Mask(112, 0, stor8.field_0):
                              revert with 0, 'ds-math-mul-overflow'
                          kLast = Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112)
                  log Mint(
                        address minter=ext_call.return_data[0] - Mask(112, 0, stor8.field_0),
                        uint256 mintAmount=ext_call.return_data[0] - Mask(112, 0, stor8.field_112),
                        uint256 mintTokens=caller)
                  stor12 = 1
                  return ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112))
              if Mask(112, 0, stor8.field_112):
                  require Mask(112, 0, stor8.field_0)
                  price0CumulativeLast += Mask(224, 0, Mask(112, 0, Mask(112, 0, stor8.field_112)) << 112 / Mask(112, 0, stor8.field_0)) * uint32(uint32(block.timestamp) - uint32(stor8.field_224))
                  require Mask(112, 0, stor8.field_112)
                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              Mask(112, 0, stor8.field_0) = Mask(112, 0, ext_call.return_data[0])
              Mask(112, 0, stor8.field_112) = Mask(112, 0, ext_call.return_data[0])
              uint32(stor8.field_224) = uint32(block.timestamp)
              log Sync(
                    uint112 reserve0=ext_call.return_data[0] << 144,
                    uint112 reserve1=Mask(112, 0, ext_call.return_data[0]))
              if not address(ext_call.return_data[0]):
                  log Mint(
                        address minter=ext_call.return_data[0] - Mask(112, 0, stor8.field_0),
                        uint256 mintAmount=ext_call.return_data[0] - Mask(112, 0, stor8.field_112),
                        uint256 mintTokens=caller)
                  stor12 = 1
                  return ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112))
              if not Mask(112, 0, stor8.field_112):
                  kLast = 0
                  log Mint(
                        address minter=ext_call.return_data[0] - Mask(112, 0, stor8.field_0),
                        uint256 mintAmount=ext_call.return_data[0] - Mask(112, 0, stor8.field_112),
                        uint256 mintTokens=caller)
                  stor12 = 1
                  return ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112))
          ('bool', ('type', 112, ('field', 112, ('stor', ('name', 'stor8', 8)))))
          require Mask(112, 0, stor8.field_112)
          if Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112) / Mask(112, 0, stor8.field_112) != Mask(112, 0, stor8.field_0):
              revert with 0, 'ds-math-mul-overflow'
          kLast = Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112)
          log Mint(
                address minter=ext_call.return_data[0] - Mask(112, 0, stor8.field_0),
                uint256 mintAmount=ext_call.return_data[0] - Mask(112, 0, stor8.field_112),
                uint256 mintTokens=caller)
          stor12 = 1
  else:
      if not kLast:
          if not totalSupply:
              if ext_call.return_data[0] - Mask(112, 0, stor8.field_112):
                  require ext_call.return_data[0] - Mask(112, 0, stor8.field_112)
                  if (ext_call.return_data[0] * ext_call.return_data[0]) - (Mask(112, 0, stor8.field_112) * ext_call.return_data[0]) - (ext_call.return_data[0] * Mask(112, 0, stor8.field_0)) + (Mask(112, 0, stor8.field_112) * Mask(112, 0, stor8.field_0)) / ext_call.return_data[0] - Mask(112, 0, stor8.field_112) != ext_call.return_data[0] - Mask(112, 0, stor8.field_0):
                      revert with 0, 'ds-math-mul-overflow'
                  if (ext_call.return_data[0] * ext_call.return_data[0]) - (Mask(112, 0, stor8.field_112) * ext_call.return_data[0]) - (ext_call.return_data[0] * Mask(112, 0, stor8.field_0)) + (Mask(112, 0, stor8.field_112) * Mask(112, 0, stor8.field_0)) > 3:
                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              revert with 0, 'ds-math-sub-underflow'
          require totalSupply
          if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / totalSupply != ext_call.return_data[0] - Mask(112, 0, stor8.field_0):
              revert with 0, 'ds-math-mul-overflow'
          require Mask(112, 0, stor8.field_0)
          if not totalSupply:
              require Mask(112, 0, stor8.field_112)
              if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0) < 0 / Mask(112, 0, stor8.field_112):
                  if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0) <= 0:
                      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                  32,
                                  40,
                                  0x44556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e5445,
                                  mem[204 len 24]
                  if totalSupply + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)) < totalSupply:
                      revert with 0, 'ds-math-add-overflow'
                  totalSupply += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)
                  if balanceOf[address(to)] + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)) < balanceOf[address(to)]:
                      revert with 0, 'ds-math-add-overflow'
                  balanceOf[address(to)] += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)
                  log Transfer(
                        address from=((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)),
                        address to=0,
                        uint256 value=to)
                  if ext_call.return_data[0] > LOCK8605463013():
                      revert with 0, 'UniswapV2: OVERFLOW'
                  if ext_call.return_data[0] > LOCK8605463013():
                      revert with 0, 'UniswapV2: OVERFLOW'
                  if uint32(uint32(block.timestamp) - uint32(stor8.field_224)):
                      if Mask(112, 0, stor8.field_0):
                          if Mask(112, 0, stor8.field_112):
                              require Mask(112, 0, stor8.field_0)
                              price0CumulativeLast += Mask(224, 0, Mask(112, 0, Mask(112, 0, stor8.field_112)) << 112 / Mask(112, 0, stor8.field_0)) * uint32(uint32(block.timestamp) - uint32(stor8.field_224))
                              require Mask(112, 0, stor8.field_112)
                              price1CumulativeLast += Mask(224, 0, Mask(112, 0, stor8.field_0) / Mask(112, 0, stor8.field_112)) * uint32(uint32(block.timestamp) - uint32(stor8.field_224))
                              Mask(112, 0, stor8.field_0) = Mask(112, 0, ext_call.return_data[0])
                              Mask(112, 0, stor8.field_112) = Mask(112, 0, ext_call.return_data[0])
                              uint32(stor8.field_224) = uint32(block.timestamp)
                              log Sync(
                                    uint112 reserve0=ext_call.return_data[0] << 144,
                                    uint112 reserve1=Mask(112, 0, ext_call.return_data[0]))
                              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
                  Mask(112, 0, stor8.field_0) = Mask(112, 0, ext_call.return_data[0])
                  Mask(112, 0, stor8.field_112) = Mask(112, 0, ext_call.return_data[0])
                  uint32(stor8.field_224) = uint32(block.timestamp)
                  log Sync(
                        uint112 reserve0=ext_call.return_data[0] << 144,
                        uint112 reserve1=Mask(112, 0, ext_call.return_data[0]))
                  if address(ext_call.return_data[0]):
                      if not Mask(112, 0, stor8.field_112):
                          kLast = 0
                      else:
                          require Mask(112, 0, stor8.field_112)
                          if Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112) / Mask(112, 0, stor8.field_112) != Mask(112, 0, stor8.field_0):
                              revert with 0, 'ds-math-mul-overflow'
                          kLast = Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112)
                  log Mint(
                        address minter=ext_call.return_data[0] - Mask(112, 0, stor8.field_0),
                        uint256 mintAmount=ext_call.return_data[0] - Mask(112, 0, stor8.field_112),
                        uint256 mintTokens=caller)
                  stor12 = 1
                  return ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0))
              if 0 / Mask(112, 0, stor8.field_112) <= 0:
                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                              32,
                              40,
                              0x44556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e5445,
                              mem[204 len 24]
              if totalSupply + (0 / Mask(112, 0, stor8.field_112)) < totalSupply:
                  revert with 0, 'ds-math-add-overflow'
              totalSupply += 0 / Mask(112, 0, stor8.field_112)
              if balanceOf[address(to)] + (0 / Mask(112, 0, stor8.field_112)) < balanceOf[address(to)]:
                  revert with 0, 'ds-math-add-overflow'
              balanceOf[address(to)] += 0 / Mask(112, 0, stor8.field_112)
              log Transfer(
                    address from=(0 / Mask(112, 0, stor8.field_112)),
                    address to=0,
                    uint256 value=to)
              if ext_call.return_data[0] > LOCK8605463013():
                  revert with 0, 'UniswapV2: OVERFLOW'
              if ext_call.return_data[0] > LOCK8605463013():
                  revert with 0, 'UniswapV2: OVERFLOW'
              if uint32(uint32(block.timestamp) - uint32(stor8.field_224)):
                  if Mask(112, 0, stor8.field_0):
                      if Mask(112, 0, stor8.field_112):
                          require Mask(112, 0, stor8.field_0)
                          price0CumulativeLast += Mask(224, 0, Mask(112, 0, Mask(112, 0, stor8.field_112)) << 112 / Mask(112, 0, stor8.field_0)) * uint32(uint32(block.timestamp) - uint32(stor8.field_224))
                          require Mask(112, 0, stor8.field_112)
                          price1CumulativeLast += Mask(224, 0, Mask(112, 0, stor8.field_0) / Mask(112, 0, stor8.field_112)) * uint32(uint32(block.timestamp) - uint32(stor8.field_224))
                          Mask(112, 0, stor8.field_0) = Mask(112, 0, ext_call.return_data[0])
                          Mask(112, 0, stor8.field_112) = Mask(112, 0, ext_call.return_data[0])
                          uint32(stor8.field_224) = uint32(block.timestamp)
                          log Sync(
                                uint112 reserve0=ext_call.return_data[0] << 144,
                                uint112 reserve1=Mask(112, 0, ext_call.return_data[0]))
                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              Mask(112, 0, stor8.field_0) = Mask(112, 0, ext_call.return_data[0])
              Mask(112, 0, stor8.field_112) = Mask(112, 0, ext_call.return_data[0])
              uint32(stor8.field_224) = uint32(block.timestamp)
              log Sync(
                    uint112 reserve0=ext_call.return_data[0] << 144,
                    uint112 reserve1=Mask(112, 0, ext_call.return_data[0]))
              if address(ext_call.return_data[0]):
                  if not Mask(112, 0, stor8.field_112):
                      kLast = 0
                  else:
                      require Mask(112, 0, stor8.field_112)
                      if Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112) / Mask(112, 0, stor8.field_112) != Mask(112, 0, stor8.field_0):
                          revert with 0, 'ds-math-mul-overflow'
                      kLast = Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112)
              log Mint(
                    address minter=ext_call.return_data[0] - Mask(112, 0, stor8.field_0),
                    uint256 mintAmount=ext_call.return_data[0] - Mask(112, 0, stor8.field_112),
                    uint256 mintTokens=caller)
              stor12 = 1
              return (0 / Mask(112, 0, stor8.field_112))
          require totalSupply
          if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / totalSupply != ext_call.return_data[0] - Mask(112, 0, stor8.field_112):
              revert with 0, 'ds-math-mul-overflow'
          require Mask(112, 0, stor8.field_112)
          if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0) < (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112):
              if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0) <= 0:
                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                              32,
                              40,
                              0x44556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e5445,
                              mem[204 len 24]
              if totalSupply + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)) < totalSupply:
                  revert with 0, 'ds-math-add-overflow'
              totalSupply += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)
              if balanceOf[address(to)] + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)) < balanceOf[address(to)]:
                  revert with 0, 'ds-math-add-overflow'
              balanceOf[address(to)] += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)
              log Transfer(
                    address from=((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)),
                    address to=0,
                    uint256 value=to)
              if ext_call.return_data[0] > LOCK8605463013():
                  revert with 0, 'UniswapV2: OVERFLOW'
              if ext_call.return_data[0] > LOCK8605463013():
                  revert with 0, 'UniswapV2: OVERFLOW'
              if uint32(uint32(block.timestamp) - uint32(stor8.field_224)):
                  if Mask(112, 0, stor8.field_0):
                      if Mask(112, 0, stor8.field_112):
                          require Mask(112, 0, stor8.field_0)
                          price0CumulativeLast += Mask(224, 0, Mask(112, 0, Mask(112, 0, stor8.field_112)) << 112 / Mask(112, 0, stor8.field_0)) * uint32(uint32(block.timestamp) - uint32(stor8.field_224))
                          require Mask(112, 0, stor8.field_112)
                          price1CumulativeLast += Mask(224, 0, Mask(112, 0, stor8.field_0) / Mask(112, 0, stor8.field_112)) * uint32(uint32(block.timestamp) - uint32(stor8.field_224))
                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              Mask(112, 0, stor8.field_0) = Mask(112, 0, ext_call.return_data[0])
              Mask(112, 0, stor8.field_112) = Mask(112, 0, ext_call.return_data[0])
              uint32(stor8.field_224) = uint32(block.timestamp)
              log Sync(
                    uint112 reserve0=ext_call.return_data[0] << 144,
                    uint112 reserve1=Mask(112, 0, ext_call.return_data[0]))
              if address(ext_call.return_data[0]):
                  if not Mask(112, 0, stor8.field_112):
                      kLast = 0
                  else:
                      require Mask(112, 0, stor8.field_112)
                      if Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112) / Mask(112, 0, stor8.field_112) != Mask(112, 0, stor8.field_0):
                          revert with 0, 'ds-math-mul-overflow'
                      kLast = Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112)
              log Mint(
                    address minter=ext_call.return_data[0] - Mask(112, 0, stor8.field_0),
                    uint256 mintAmount=ext_call.return_data[0] - Mask(112, 0, stor8.field_112),
                    uint256 mintTokens=caller)
              stor12 = 1
              return ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0))
          if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112) <= 0:
              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                          32,
                          40,
                          0x44556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e5445,
                          mem[204 len 24]
          if totalSupply + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)) < totalSupply:
              revert with 0, 'ds-math-add-overflow'
          totalSupply += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)
          if balanceOf[address(to)] + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)) < balanceOf[address(to)]:
              revert with 0, 'ds-math-add-overflow'
          balanceOf[address(to)] += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)
          log Transfer(
                address from=((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)),
                address to=0,
                uint256 value=to)
          if ext_call.return_data[0] > LOCK8605463013():
              revert with 0, 'UniswapV2: OVERFLOW'
          if ext_call.return_data[0] > LOCK8605463013():
              revert with 0, 'UniswapV2: OVERFLOW'
          if uint32(uint32(block.timestamp) - uint32(stor8.field_224)):
              if Mask(112, 0, stor8.field_0):
                  if Mask(112, 0, stor8.field_112):
                      require Mask(112, 0, stor8.field_0)
                      price0CumulativeLast += Mask(224, 0, Mask(112, 0, Mask(112, 0, stor8.field_112)) << 112 / Mask(112, 0, stor8.field_0)) * uint32(uint32(block.timestamp) - uint32(stor8.field_224))
                      require Mask(112, 0, stor8.field_112)
                      price1CumulativeLast += Mask(224, 0, Mask(112, 0, stor8.field_0) / Mask(112, 0, stor8.field_112)) * uint32(uint32(block.timestamp) - uint32(stor8.field_224))
                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
          Mask(112, 0, stor8.field_0) = Mask(112, 0, ext_call.return_data[0])
          Mask(112, 0, stor8.field_112) = Mask(112, 0, ext_call.return_data[0])
          uint32(stor8.field_224) = uint32(block.timestamp)
          log Sync(
                uint112 reserve0=ext_call.return_data[0] << 144,
                uint112 reserve1=Mask(112, 0, ext_call.return_data[0]))
          if address(ext_call.return_data[0]):
              if not Mask(112, 0, stor8.field_112):
                  kLast = 0
              else:
                  require Mask(112, 0, stor8.field_112)
                  if Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112) / Mask(112, 0, stor8.field_112) != Mask(112, 0, stor8.field_0):
                      revert with 0, 'ds-math-mul-overflow'
                  kLast = Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112)
          log Mint(
                address minter=ext_call.return_data[0] - Mask(112, 0, stor8.field_0),
                uint256 mintAmount=ext_call.return_data[0] - Mask(112, 0, stor8.field_112),
                uint256 mintTokens=caller)
          stor12 = 1
          return ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112))
      kLast = 0
      if not totalSupply:
          if ext_call.return_data[0] - Mask(112, 0, stor8.field_112):
              require ext_call.return_data[0] - Mask(112, 0, stor8.field_112)
              if (ext_call.return_data[0] * ext_call.return_data[0]) - (Mask(112, 0, stor8.field_112) * ext_call.return_data[0]) - (ext_call.return_data[0] * Mask(112, 0, stor8.field_0)) + (Mask(112, 0, stor8.field_112) * Mask(112, 0, stor8.field_0)) / ext_call.return_data[0] - Mask(112, 0, stor8.field_112) != ext_call.return_data[0] - Mask(112, 0, stor8.field_0):
                  revert with 0, 'ds-math-mul-overflow'
              if (ext_call.return_data[0] * ext_call.return_data[0]) - (Mask(112, 0, stor8.field_112) * ext_call.return_data[0]) - (ext_call.return_data[0] * Mask(112, 0, stor8.field_0)) + (Mask(112, 0, stor8.field_112) * Mask(112, 0, stor8.field_0)) > 3:
                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
          revert with 0, 'ds-math-sub-underflow'
      require totalSupply
      if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / totalSupply != ext_call.return_data[0] - Mask(112, 0, stor8.field_0):
          revert with 0, 'ds-math-mul-overflow'
      require Mask(112, 0, stor8.field_0)
      if not totalSupply:
          require Mask(112, 0, stor8.field_112)
          if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0) < 0 / Mask(112, 0, stor8.field_112):
              if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0) <= 0:
                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                              32,
                              40,
                              0x44556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e5445,
                              mem[204 len 24]
              if totalSupply + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)) < totalSupply:
                  revert with 0, 'ds-math-add-overflow'
              totalSupply += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)
              if balanceOf[address(to)] + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)) < balanceOf[address(to)]:
                  revert with 0, 'ds-math-add-overflow'
              balanceOf[address(to)] += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)
              log Transfer(
                    address from=((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)),
                    address to=0,
                    uint256 value=to)
              if ext_call.return_data[0] > LOCK8605463013():
                  revert with 0, 'UniswapV2: OVERFLOW'
              if ext_call.return_data[0] > LOCK8605463013():
                  revert with 0, 'UniswapV2: OVERFLOW'
              if uint32(uint32(block.timestamp) - uint32(stor8.field_224)):
                  if Mask(112, 0, stor8.field_0):
                      if Mask(112, 0, stor8.field_112):
                          require Mask(112, 0, stor8.field_0)
                          price0CumulativeLast += Mask(224, 0, Mask(112, 0, Mask(112, 0, stor8.field_112)) << 112 / Mask(112, 0, stor8.field_0)) * uint32(uint32(block.timestamp) - uint32(stor8.field_224))
                          require Mask(112, 0, stor8.field_112)
                          price1CumulativeLast += Mask(224, 0, Mask(112, 0, stor8.field_0) / Mask(112, 0, stor8.field_112)) * uint32(uint32(block.timestamp) - uint32(stor8.field_224))
                          Mask(112, 0, stor8.field_0) = Mask(112, 0, ext_call.return_data[0])
                          Mask(112, 0, stor8.field_112) = Mask(112, 0, ext_call.return_data[0])
                          uint32(stor8.field_224) = uint32(block.timestamp)
                          log Sync(
                                uint112 reserve0=ext_call.return_data[0] << 144,
                                uint112 reserve1=Mask(112, 0, ext_call.return_data[0]))
                          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              Mask(112, 0, stor8.field_0) = Mask(112, 0, ext_call.return_data[0])
              Mask(112, 0, stor8.field_112) = Mask(112, 0, ext_call.return_data[0])
              uint32(stor8.field_224) = uint32(block.timestamp)
              log Sync(
                    uint112 reserve0=ext_call.return_data[0] << 144,
                    uint112 reserve1=Mask(112, 0, ext_call.return_data[0]))
              if address(ext_call.return_data[0]):
                  if not Mask(112, 0, stor8.field_112):
                      kLast = 0
                  else:
                      require Mask(112, 0, stor8.field_112)
                      if Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112) / Mask(112, 0, stor8.field_112) != Mask(112, 0, stor8.field_0):
                          revert with 0, 'ds-math-mul-overflow'
                      kLast = Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112)
              log Mint(
                    address minter=ext_call.return_data[0] - Mask(112, 0, stor8.field_0),
                    uint256 mintAmount=ext_call.return_data[0] - Mask(112, 0, stor8.field_112),
                    uint256 mintTokens=caller)
              stor12 = 1
              return ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0))
          if 0 / Mask(112, 0, stor8.field_112) <= 0:
              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                          32,
                          40,
                          0x44556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e5445,
                          mem[204 len 24]
          if totalSupply + (0 / Mask(112, 0, stor8.field_112)) < totalSupply:
              revert with 0, 'ds-math-add-overflow'
          totalSupply += 0 / Mask(112, 0, stor8.field_112)
          if balanceOf[address(to)] + (0 / Mask(112, 0, stor8.field_112)) < balanceOf[address(to)]:
              revert with 0, 'ds-math-add-overflow'
          balanceOf[address(to)] += 0 / Mask(112, 0, stor8.field_112)
          log Transfer(
                address from=(0 / Mask(112, 0, stor8.field_112)),
                address to=0,
                uint256 value=to)
          if ext_call.return_data[0] > LOCK8605463013():
              revert with 0, 'UniswapV2: OVERFLOW'
          if ext_call.return_data[0] > LOCK8605463013():
              revert with 0, 'UniswapV2: OVERFLOW'
          if uint32(uint32(block.timestamp) - uint32(stor8.field_224)):
              if Mask(112, 0, stor8.field_0):
                  if Mask(112, 0, stor8.field_112):
                      require Mask(112, 0, stor8.field_0)
                      price0CumulativeLast += Mask(224, 0, Mask(112, 0, Mask(112, 0, stor8.field_112)) << 112 / Mask(112, 0, stor8.field_0)) * uint32(uint32(block.timestamp) - uint32(stor8.field_224))
                      require Mask(112, 0, stor8.field_112)
                      price1CumulativeLast += Mask(224, 0, Mask(112, 0, stor8.field_0) / Mask(112, 0, stor8.field_112)) * uint32(uint32(block.timestamp) - uint32(stor8.field_224))
                      Mask(112, 0, stor8.field_0) = Mask(112, 0, ext_call.return_data[0])
                      Mask(112, 0, stor8.field_112) = Mask(112, 0, ext_call.return_data[0])
                      uint32(stor8.field_224) = uint32(block.timestamp)
                      log Sync(
                            uint112 reserve0=ext_call.return_data[0] << 144,
                            uint112 reserve1=Mask(112, 0, ext_call.return_data[0]))
                      ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
          Mask(112, 0, stor8.field_0) = Mask(112, 0, ext_call.return_data[0])
          Mask(112, 0, stor8.field_112) = Mask(112, 0, ext_call.return_data[0])
          uint32(stor8.field_224) = uint32(block.timestamp)
          log Sync(
                uint112 reserve0=ext_call.return_data[0] << 144,
                uint112 reserve1=Mask(112, 0, ext_call.return_data[0]))
          if address(ext_call.return_data[0]):
              if not Mask(112, 0, stor8.field_112):
                  kLast = 0
              else:
                  require Mask(112, 0, stor8.field_112)
                  if Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112) / Mask(112, 0, stor8.field_112) != Mask(112, 0, stor8.field_0):
                      revert with 0, 'ds-math-mul-overflow'
                  kLast = Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112)
          log Mint(
                address minter=ext_call.return_data[0] - Mask(112, 0, stor8.field_0),
                uint256 mintAmount=ext_call.return_data[0] - Mask(112, 0, stor8.field_112),
                uint256 mintTokens=caller)
          stor12 = 1
          return (0 / Mask(112, 0, stor8.field_112))
      require totalSupply
      if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / totalSupply != ext_call.return_data[0] - Mask(112, 0, stor8.field_112):
          revert with 0, 'ds-math-mul-overflow'
      require Mask(112, 0, stor8.field_112)
      if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0) < (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112):
          if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0) <= 0:
              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                          32,
                          40,
                          0x44556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e5445,
                          mem[204 len 24]
          if totalSupply + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)) < totalSupply:
              revert with 0, 'ds-math-add-overflow'
          totalSupply += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)
          if balanceOf[address(to)] + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)) < balanceOf[address(to)]:
              revert with 0, 'ds-math-add-overflow'
          balanceOf[address(to)] += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)
          log Transfer(
                address from=((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0)),
                address to=0,
                uint256 value=to)
          if ext_call.return_data[0] > LOCK8605463013():
              revert with 0, 'UniswapV2: OVERFLOW'
          if ext_call.return_data[0] > LOCK8605463013():
              revert with 0, 'UniswapV2: OVERFLOW'
          if not uint32(uint32(block.timestamp) - uint32(stor8.field_224)):
              Mask(112, 0, stor8.field_0) = Mask(112, 0, ext_call.return_data[0])
              Mask(112, 0, stor8.field_112) = Mask(112, 0, ext_call.return_data[0])
              uint32(stor8.field_224) = uint32(block.timestamp)
              log Sync(
                    uint112 reserve0=ext_call.return_data[0] << 144,
                    uint112 reserve1=Mask(112, 0, ext_call.return_data[0]))
              if address(ext_call.return_data[0]):
                  if not Mask(112, 0, stor8.field_112):
                      kLast = 0
                  else:
                      require Mask(112, 0, stor8.field_112)
                      if Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112) / Mask(112, 0, stor8.field_112) != Mask(112, 0, stor8.field_0):
                          revert with 0, 'ds-math-mul-overflow'
                      kLast = Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112)
              log Mint(
                    address minter=ext_call.return_data[0] - Mask(112, 0, stor8.field_0),
                    uint256 mintAmount=ext_call.return_data[0] - Mask(112, 0, stor8.field_112),
                    uint256 mintTokens=caller)
              stor12 = 1
              return ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0))
          if not Mask(112, 0, stor8.field_0):
              Mask(112, 0, stor8.field_0) = Mask(112, 0, ext_call.return_data[0])
              Mask(112, 0, stor8.field_112) = Mask(112, 0, ext_call.return_data[0])
              uint32(stor8.field_224) = uint32(block.timestamp)
              log Sync(
                    uint112 reserve0=ext_call.return_data[0] << 144,
                    uint112 reserve1=Mask(112, 0, ext_call.return_data[0]))
              if address(ext_call.return_data[0]):
                  if not Mask(112, 0, stor8.field_112):
                      kLast = 0
                  else:
                      require Mask(112, 0, stor8.field_112)
                      if Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112) / Mask(112, 0, stor8.field_112) != Mask(112, 0, stor8.field_0):
                          revert with 0, 'ds-math-mul-overflow'
                      kLast = Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112)
              log Mint(
                    address minter=ext_call.return_data[0] - Mask(112, 0, stor8.field_0),
                    uint256 mintAmount=ext_call.return_data[0] - Mask(112, 0, stor8.field_112),
                    uint256 mintTokens=caller)
              stor12 = 1
              return ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0))
          if Mask(112, 0, stor8.field_112):
              require Mask(112, 0, stor8.field_0)
              price0CumulativeLast += Mask(224, 0, Mask(112, 0, Mask(112, 0, stor8.field_112)) << 112 / Mask(112, 0, stor8.field_0)) * uint32(uint32(block.timestamp) - uint32(stor8.field_224))
              require Mask(112, 0, stor8.field_112)
              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
          Mask(112, 0, stor8.field_0) = Mask(112, 0, ext_call.return_data[0])
          Mask(112, 0, stor8.field_112) = Mask(112, 0, ext_call.return_data[0])
          uint32(stor8.field_224) = uint32(block.timestamp)
          log Sync(
                uint112 reserve0=ext_call.return_data[0] << 144,
                uint112 reserve1=Mask(112, 0, ext_call.return_data[0]))
          if not address(ext_call.return_data[0]):
              log Mint(
                    address minter=ext_call.return_data[0] - Mask(112, 0, stor8.field_0),
                    uint256 mintAmount=ext_call.return_data[0] - Mask(112, 0, stor8.field_112),
                    uint256 mintTokens=caller)
              stor12 = 1
              return ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0))
          if not Mask(112, 0, stor8.field_112):
              kLast = 0
              log Mint(
                    address minter=ext_call.return_data[0] - Mask(112, 0, stor8.field_0),
                    uint256 mintAmount=ext_call.return_data[0] - Mask(112, 0, stor8.field_112),
                    uint256 mintTokens=caller)
              stor12 = 1
              return ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_0) * totalSupply) / Mask(112, 0, stor8.field_0))
      else:
          if (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112) <= 0:
              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                          32,
                          40,
                          0x44556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e5445,
                          mem[204 len 24]
          if totalSupply + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)) < totalSupply:
              revert with 0, 'ds-math-add-overflow'
          totalSupply += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)
          if balanceOf[address(to)] + ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)) < balanceOf[address(to)]:
              revert with 0, 'ds-math-add-overflow'
          balanceOf[address(to)] += (ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)
          log Transfer(
                address from=((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112)),
                address to=0,
                uint256 value=to)
          if ext_call.return_data[0] > LOCK8605463013():
              revert with 0, 'UniswapV2: OVERFLOW'
          if ext_call.return_data[0] > LOCK8605463013():
              revert with 0, 'UniswapV2: OVERFLOW'
          if not uint32(uint32(block.timestamp) - uint32(stor8.field_224)):
              Mask(112, 0, stor8.field_0) = Mask(112, 0, ext_call.return_data[0])
              Mask(112, 0, stor8.field_112) = Mask(112, 0, ext_call.return_data[0])
              uint32(stor8.field_224) = uint32(block.timestamp)
              log Sync(
                    uint112 reserve0=ext_call.return_data[0] << 144,
                    uint112 reserve1=Mask(112, 0, ext_call.return_data[0]))
              if address(ext_call.return_data[0]):
                  if not Mask(112, 0, stor8.field_112):
                      kLast = 0
                  else:
                      require Mask(112, 0, stor8.field_112)
                      if Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112) / Mask(112, 0, stor8.field_112) != Mask(112, 0, stor8.field_0):
                          revert with 0, 'ds-math-mul-overflow'
                      kLast = Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112)
              log Mint(
                    address minter=ext_call.return_data[0] - Mask(112, 0, stor8.field_0),
                    uint256 mintAmount=ext_call.return_data[0] - Mask(112, 0, stor8.field_112),
                    uint256 mintTokens=caller)
              stor12 = 1
              return ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112))
          if not Mask(112, 0, stor8.field_0):
              Mask(112, 0, stor8.field_0) = Mask(112, 0, ext_call.return_data[0])
              Mask(112, 0, stor8.field_112) = Mask(112, 0, ext_call.return_data[0])
              uint32(stor8.field_224) = uint32(block.timestamp)
              log Sync(
                    uint112 reserve0=ext_call.return_data[0] << 144,
                    uint112 reserve1=Mask(112, 0, ext_call.return_data[0]))
              if address(ext_call.return_data[0]):
                  if not Mask(112, 0, stor8.field_112):
                      kLast = 0
                  else:
                      require Mask(112, 0, stor8.field_112)
                      if Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112) / Mask(112, 0, stor8.field_112) != Mask(112, 0, stor8.field_0):
                          revert with 0, 'ds-math-mul-overflow'
                      kLast = Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112)
              log Mint(
                    address minter=ext_call.return_data[0] - Mask(112, 0, stor8.field_0),
                    uint256 mintAmount=ext_call.return_data[0] - Mask(112, 0, stor8.field_112),
                    uint256 mintTokens=caller)
              stor12 = 1
              return ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112))
          if Mask(112, 0, stor8.field_112):
              require Mask(112, 0, stor8.field_0)
              price0CumulativeLast += Mask(224, 0, Mask(112, 0, Mask(112, 0, stor8.field_112)) << 112 / Mask(112, 0, stor8.field_0)) * uint32(uint32(block.timestamp) - uint32(stor8.field_224))
              require Mask(112, 0, stor8.field_112)
              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
          Mask(112, 0, stor8.field_0) = Mask(112, 0, ext_call.return_data[0])
          Mask(112, 0, stor8.field_112) = Mask(112, 0, ext_call.return_data[0])
          uint32(stor8.field_224) = uint32(block.timestamp)
          log Sync(
                uint112 reserve0=ext_call.return_data[0] << 144,
                uint112 reserve1=Mask(112, 0, ext_call.return_data[0]))
          if not address(ext_call.return_data[0]):
              log Mint(
                    address minter=ext_call.return_data[0] - Mask(112, 0, stor8.field_0),
                    uint256 mintAmount=ext_call.return_data[0] - Mask(112, 0, stor8.field_112),
                    uint256 mintTokens=caller)
              stor12 = 1
              return ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112))
          if not Mask(112, 0, stor8.field_112):
              kLast = 0
              log Mint(
                    address minter=ext_call.return_data[0] - Mask(112, 0, stor8.field_0),
                    uint256 mintAmount=ext_call.return_data[0] - Mask(112, 0, stor8.field_112),
                    uint256 mintTokens=caller)
              stor12 = 1
              return ((ext_call.return_data[0] * totalSupply) - (Mask(112, 0, stor8.field_112) * totalSupply) / Mask(112, 0, stor8.field_112))
      ('bool', ('type', 112, ('field', 112, ('stor', ('name', 'stor8', 8)))))
      require Mask(112, 0, stor8.field_112)
      if Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112) / Mask(112, 0, stor8.field_112) != Mask(112, 0, stor8.field_0):
          revert with 0, 'ds-math-mul-overflow'
      kLast = Mask(112, 0, stor8.field_0) * Mask(112, 0, stor8.field_112)
      log Mint(
            address minter=ext_call.return_data[0] - Mask(112, 0, stor8.field_0),
            uint256 mintAmount=ext_call.return_data[0] - Mask(112, 0, stor8.field_112),
            uint256 mintTokens=caller)
      stor12 = 1
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)


