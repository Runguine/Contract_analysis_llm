# Palkeoramix decompiler. 

const factory = 0xbfbcf9fa4f9c56b0f40a671ad40e0805a091865
const deployer = 0x41ff9aa7e16b8b1a8a8dc4f0efacd93d02d071c9
const WETH9 = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2

def storage:
  stor0 is uint256 at storage 0

#
#  Regular functions
#

def _fallback(?) payable: # default function
  revert

def refundETH() payable: 
  if eth.balance(this.address):
      call caller with:
         value eth.balance(this.address) wei
           gas gas_remaining wei
      if not ext_call.success:
          revert with 0, 'STE'

def selfPermit(address token, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) payable: 
  require calldata.size - 4 >=′ 192
  require token == token
  require v == v
  require ext_code.size(token)
  call token.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
       gas gas_remaining wei
      args 0, uint32(caller), this.address, value, deadline, v << 248, r, s
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]

def selfPermitAllowed(address token, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) payable: 
  require calldata.size - 4 >=′ 192
  require token == token
  require v == v
  require ext_code.size(token)
  call token.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) with:
       gas gas_remaining wei
      args 0, uint32(caller), this.address, nonce, expiry, 1, v << 248, r, s
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]

def exactOutputSingle(tuple params) payable: 
  require calldata.size - 4 >=′ 256
  if block.timestamp > cd[132]:
      revert with 0, 'Transaction too old'
  require cd[100] == address(cd[100])
  require cd[228] == address(cd[228])
  require cd[36] == address(cd[36])
  require cd[68] == cd[68] % unknown01000000()
  require params == address(params)
  if address(params) <= address(cd[36]):
      require address(params) < uint64(cd[36]) << 96
  else:
      require address(cd[36]) < uint64(params) << 96
  require cd[164] < 0x8000000000000000000000000000000000000000000000000000000000000000
  if not address(cd[228]):
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def exactInput(tuple params) payable: 
  require calldata.size - 4 >=′ 32
  require params <= LOCK8605463013()
  require calldata.size + -params - 4 >=′ 160
  require params.length <= LOCK8605463013()
  require params + params.length + 35 <′ calldata.size
  require cd[(params + params.length + 4)] <= LOCK8605463013()
  require ceil32(cd[(params + params.length + 4)]) + 288 >= 256 and ceil32(cd[(params + params.length + 4)]) + 288 <= LOCK8605463013()
  require params + params.length + cd[(params + params.length + 4)] + 36 <= calldata.size
  require cd[(params + 36)] == address(cd[(params + 36)])
  if block.timestamp > cd[(params + 68)]:
      revert with 0, 'Transaction too old'
  if cd[(params + params.length + 4)] < 43:
      revert with 0, 'slice_outOfBounds'
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def unwrapWETH9(uint256 amountMinimum, address recipient) payable: 
  require calldata.size - 4 >=′ 64
  require recipient == recipient
  require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
  static call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.balanceOf(address account) with:
          gas gas_remaining wei
         args this.address
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  require return_data.size >= 32
  if ext_call.return_data[0] < amountMinimum:
      revert with 0, 'Insufficient WETH9'
  if ext_call.return_data[0]:
      require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.withdraw(uint256 amount) with:
           gas gas_remaining wei
          args ext_call.return_data[0]
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      call recipient with:
         value ext_call.return_data[0] wei
           gas gas_remaining wei
      if not ext_call.success:
          revert with 0, 'STE'

def selfPermitIfNecessary(address token, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) payable: 
  require calldata.size - 4 >=′ 192
  require token == token
  require v == v
  require ext_code.size(token)
  static call token.allowance(address owner, address spender) with:
          gas gas_remaining wei
         args caller, this.address
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  require return_data.size >= 32
  if ext_call.return_data[0] < value:
      require ext_code.size(token)
      call token.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) with:
           gas gas_remaining wei
          args 0, uint32(caller), this.address, value, deadline, v << 248, r, s
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]

def selfPermitAllowedIfNecessary(address token, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) payable: 
  require calldata.size - 4 >=′ 192
  require token == token
  require v == v
  require ext_code.size(token)
  static call token.allowance(address owner, address spender) with:
          gas gas_remaining wei
         args caller, this.address
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  require return_data.size >= 32
  if ext_call.return_data[0] < -1:
      require ext_code.size(token)
      call token.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) with:
           gas gas_remaining wei
          args 0, uint32(caller), this.address, nonce, expiry, 1, v << 248, r, s
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]

def sweepToken(address token, uint256 amountMinimum, address recipient) payable: 
  require calldata.size - 4 >=′ 96
  require token == token
  require recipient == recipient
  require ext_code.size(token)
  static call token.balanceOf(address account) with:
          gas gas_remaining wei
         args this.address
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  require return_data.size >= 32
  if ext_call.return_data[0] < amountMinimum:
      revert with 0, 'Insufficient token'
  if ext_call.return_data[0]:
      mem[196 len 64] = transfer(address recipient, uint256 amount), address(recipient) << 64, 0, ext_call.return_data[0 len 28]
      call token with:
           gas gas_remaining wei
          args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[260 len 4]
      if not return_data.size:
          if not ext_call.success:
              revert with 0, 'ST'
          if not transfer(address recipient, uint256 amount), address(recipient) << 64:
              revert with 0, 'ST'
      else:
          mem[228 len return_data.size] = ext_call.return_data[0 len return_data.size]
          if not ext_call.success:
              revert with 0, 'ST'
          if return_data.size:
              require return_data.size >= 32
              if not mem[228]:
                  revert with 0, 'ST'

def unwrapWETH9WithFee(uint256 amountMinimum, address recipient, uint256 feeBips, address feeRecipient) payable: 
  require calldata.size - 4 >=′ 128
  require recipient == recipient
  require feeRecipient == feeRecipient
  require feeBips > 0
  require feeBips <= 100
  require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
  static call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.balanceOf(address account) with:
          gas gas_remaining wei
         args this.address
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  require return_data.size >= 32
  if ext_call.return_data[0] < amountMinimum:
      revert with 0, 'Insufficient WETH9'
  if ext_call.return_data[0]:
      require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.withdraw(uint256 amount) with:
           gas gas_remaining wei
          args ext_call.return_data[0]
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      if not ext_call.return_data[0]:
          call recipient with:
             value ext_call.return_data[0] wei
               gas gas_remaining wei
          if not ext_call.success:
              revert with 0, 'STE'
      else:
          require ext_call.return_data[0]
          require feeBips * ext_call.return_data[0] / ext_call.return_data[0] == feeBips
          if not feeBips * ext_call.return_data[0] / 10000:
              call recipient with:
                 value ext_call.return_data[0] - (feeBips * ext_call.return_data[0] / 10000) wei
                   gas gas_remaining wei
              if not ext_call.success:
                  revert with 0, 'STE'
          else:
              call feeRecipient with:
                 value feeBips * ext_call.return_data[0] / 10000 wei
                   gas gas_remaining wei
              if not ext_call.success:
                  revert with 0, 'STE'
              call recipient with:
                 value ext_call.return_data[0] - (feeBips * ext_call.return_data[0] / 10000) wei
                   gas gas_remaining wei
              if not return_data.size:
                  if not ext_call.success:
                      revert with 0, 'STE'
              else:
                  if not return_data.size:
                      if not ext_call.success:
                          revert with 0, 'STE'
                  else:
                      if not ext_call.success:
                          revert with 0, 'STE', mem[(2 * ceil32(return_data.size)) + 262 len (2 * ceil32(return_data.size)) - (2 * ceil32(return_data.size))]
      ('bool', 'ext_call.success')

def sweepTokenWithFee(address token, uint256 amountMinimum, address recipient, uint256 feeBips, address feeRecipient) payable: 
  require calldata.size - 4 >=′ 160
  require token == token
  require recipient == recipient
  require feeRecipient == feeRecipient
  require feeBips > 0
  require feeBips <= 100
  require ext_code.size(token)
  static call token.balanceOf(address account) with:
          gas gas_remaining wei
         args this.address
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  require return_data.size >= 32
  if ext_call.return_data[0] < amountMinimum:
      revert with 0, 'Insufficient token'
  if ext_call.return_data[0]:
      require ext_call.return_data[0]
      require feeBips * ext_call.return_data[0] / ext_call.return_data[0] == feeBips
      if not feeBips * ext_call.return_data[0] / 10000:
          mem[196 len 64] = transfer(address recipient, uint256 amount), address(recipient) << 64, 0, Mask(224, 32, ext_call.return_data[0] - (feeBips * ext_call.return_data[0] / 10000)) >> 32
          call token with:
               gas gas_remaining wei
              args Mask(224, 32, ext_call.return_data[0] - (feeBips * ext_call.return_data[0] / 10000)) << 224, mem[260 len 4]
          if not return_data.size:
              if not ext_call.success:
                  revert with 0, 'ST'
              if not transfer(address recipient, uint256 amount), address(recipient) << 64:
                  revert with 0, 'ST'
          else:
              mem[228 len return_data.size] = ext_call.return_data[0 len return_data.size]
              if not ext_call.success:
                  revert with 0, 'ST'
              if return_data.size:
                  require return_data.size >= 32
                  if not mem[228]:
                      revert with 0, 'ST'
      else:
          mem[196 len 64] = transfer(address recipient, uint256 amount), address(feeRecipient) << 64, 0, Mask(224, 32, feeBips * ext_call.return_data[0] / 10000) >> 32
          call token with:
               gas gas_remaining wei
              args Mask(224, 32, feeBips * ext_call.return_data[0] / 10000) << 224, mem[260 len 4]
          if not return_data.size:
              if not ext_call.success:
                  revert with 0, 'ST'
              if not transfer(address recipient, uint256 amount), address(feeRecipient) << 64:
                  revert with 0, 'ST'
              mem[296 len 64] = transfer(address recipient, uint256 amount), address(recipient) << 64, 0, Mask(224, 32, ext_call.return_data[0] - (feeBips * ext_call.return_data[0] / 10000)) >> 32
              call token with:
                   gas gas_remaining wei
                  args Mask(224, 32, ext_call.return_data[0] - (feeBips * ext_call.return_data[0] / 10000)) << 224, mem[360 len 4]
              if not return_data.size:
                  if not ext_call.success:
                      revert with 0, 'ST'
                  if not transfer(address recipient, uint256 amount), address(feeRecipient) << 64:
                      revert with 0, 'ST'
              else:
                  mem[328 len return_data.size] = ext_call.return_data[0 len return_data.size]
                  if not ext_call.success:
                      revert with 0, 'ST'
                  if return_data.size:
                      require return_data.size >= 32
                      if not mem[328]:
                          revert with 0, 'ST'
          else:
              mem[228 len return_data.size] = ext_call.return_data[0 len return_data.size]
              if not ext_call.success:
                  revert with 0, 'ST'
              if return_data.size:
                  require return_data.size >= 32
                  if not mem[228]:
                      revert with 0, 'ST'
              mem[ceil32(return_data.size) + 297 len 64] = transfer(address recipient, uint256 amount), address(recipient) << 64, 0, Mask(224, 32, ext_call.return_data[0] - (feeBips * ext_call.return_data[0] / 10000)) >> 32
              call token with:
                   gas gas_remaining wei
                  args Mask(224, 32, ext_call.return_data[0] - (feeBips * ext_call.return_data[0] / 10000)) << 224, mem[ceil32(return_data.size) + 361 len 4]
              if not return_data.size:
                  if not ext_call.success:
                      revert with 0, 'ST'
                  if not transfer(address recipient, uint256 amount), address(feeRecipient) << 64:
                      revert with 0, 'ST'
              else:
                  mem[ceil32(return_data.size) + 329 len return_data.size] = ext_call.return_data[0 len return_data.size]
                  if not ext_call.success:
                      revert with 0, 'ST', mem[(2 * ceil32(return_data.size)) + 398 len (2 * ceil32(return_data.size)) - (2 * ceil32(return_data.size))]
                  if return_data.size:
                      require return_data.size >= 32
                      if not mem[ceil32(return_data.size) + 329]:
                          revert with 0, 'ST', mem[(2 * ceil32(return_data.size)) + 398 len (2 * ceil32(return_data.size)) - (2 * ceil32(return_data.size))]

def unknown23a69e75(): # not payable
  require calldata.size - 4 >=′ 96
  require cd[68] <= LOCK8605463013()
  require cd[68] + 35 <′ calldata.size
  require ('cd', 68).length <= LOCK8605463013()
  require cd[68] + ('cd', 68).length + 36 <= calldata.size
  if cd[4] <=′ 0:
      require cd[36] >′ 0
  require ('cd', 68).length >=′ 32
  require ('cd', 68)[0] <= LOCK8605463013()
  require ('cd', 68).length - ('cd', 68)[0] >=′ 64
  require cd[(cd[68] + ('cd', 68)[0] + 36)] <= LOCK8605463013()
  require cd[68] + ('cd', 68)[0] + cd[(cd[68] + ('cd', 68)[0] + 36)] + 67 <′ cd[68] + ('cd', 68).length + 36
  require cd[(cd[68] + ('cd', 68)[0] + cd[(cd[68] + ('cd', 68)[0] + 36)] + 36)] <= LOCK8605463013()
  require ceil32(cd[(cd[68] + ('cd', 68)[0] + cd[(cd[68] + ('cd', 68)[0] + 36)] + 36)]) + 192 >= 160 and ceil32(cd[(cd[68] + ('cd', 68)[0] + cd[(cd[68] + ('cd', 68)[0] + 36)] + 36)]) + 192 <= LOCK8605463013()
  require ('cd', 68)[0] + cd[(cd[68] + ('cd', 68)[0] + 36)] + cd[(cd[68] + ('cd', 68)[0] + cd[(cd[68] + ('cd', 68)[0] + 36)] + 36)] + 68 <= ('cd', 68).length + 36
  mem[192 len cd[(cd[68] + ('cd', 68)[0] + cd[(cd[68] + ('cd', 68)[0] + 36)] + 36)]] = call.data[cd[68] + ('cd', 68)[0] + cd[(cd[68] + ('cd', 68)[0] + 36)] + 68 len cd[(cd[68] + ('cd', 68)[0] + cd[(cd[68] + ('cd', 68)[0] + 36)] + 36)]]
  mem[cd[(cd[68] + ('cd', 68)[0] + cd[(cd[68] + ('cd', 68)[0] + 36)] + 36)] + 192] = 0
  require cd[(cd[68] + ('cd', 68)[0] + 68)] == address(cd[(cd[68] + ('cd', 68)[0] + 68)])
  if cd[(cd[68] + ('cd', 68)[0] + cd[(cd[68] + ('cd', 68)[0] + 36)] + 36)] < 20:
      revert with 0, 'toAddress_outOfBounds'
  if cd[(cd[68] + ('cd', 68)[0] + cd[(cd[68] + ('cd', 68)[0] + 36)] + 36)] < 23:
      revert with 0, 'toUint24_outOfBounds'
  if cd[(cd[68] + ('cd', 68)[0] + cd[(cd[68] + ('cd', 68)[0] + 36)] + 36)] < 43:
      revert with 0, 'toAddress_outOfBounds'
  if mem[192 len 20] <= mem[215 len 20]:
      require mem[192 len 20] < Mask(64, 96, mem[215])
      mem[ceil32(cd[(cd[68] + ('cd', 68)[0] + cd[(cd[68] + ('cd', 68)[0] + 36)] + 36)]) + 448] = mem[215 len 20]
      mem[ceil32(cd[(cd[68] + ('cd', 68)[0] + cd[(cd[68] + ('cd', 68)[0] + 36)] + 36)]) + 480] = mem[212 len 3]
      require address(sha3(0, 4755689777358670618, sha3(Mask(64, 96, mem[192]) << 96, mem[ceil32(cd[(cd[68] + ('cd', 68)[0] + cd[(cd[68] + ('cd', 68)[0] + 36)] + 36)]) + 448 len 64]), 0x6ce8eb472fa82df5469c6ab6d485f17c3ad13c8cd7af59b3d4a8026c5ce0f7e2)) == caller
  else:
      require mem[215 len 20] < Mask(64, 96, mem[192])
      mem[ceil32(cd[(cd[68] + ('cd', 68)[0] + cd[(cd[68] + ('cd', 68)[0] + 36)] + 36)]) + 448] = mem[192 len 20]
      mem[ceil32(cd[(cd[68] + ('cd', 68)[0] + cd[(cd[68] + ('cd', 68)[0] + 36)] + 36)]) + 480] = mem[212 len 3]
      require address(sha3(0, 4755689777358670618, sha3(Mask(64, 96, mem[215]) << 96, mem[ceil32(cd[(cd[68] + ('cd', 68)[0] + cd[(cd[68] + ('cd', 68)[0] + 36)] + 36)]) + 448 len 64]), 0x6ce8eb472fa82df5469c6ab6d485f17c3ad13c8cd7af59b3d4a8026c5ce0f7e2)) == caller
  if cd[4] >′ 0:
      if mem[192 len 20] < mem[215 len 20]:
          if mem[192 len 20] != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
      else:
          if 66 <= cd[(cd[68] + ('cd', 68)[0] + cd[(cd[68] + ('cd', 68)[0] + 36)] + 36)]:
              if cd[(cd[68] + ('cd', 68)[0] + cd[(cd[68] + ('cd', 68)[0] + 36)] + 36)] < 23:
                  revert with 0, 'slice_overflow'
              if cd[(cd[68] + ('cd', 68)[0] + cd[(cd[68] + ('cd', 68)[0] + 36)] + 36)] < cd[(cd[68] + ('cd', 68)[0] + cd[(cd[68] + ('cd', 68)[0] + 36)] + 36)]:
                  revert with 0, 'slice_outOfBounds'
              if cd[(cd[68] + ('cd', 68)[0] + cd[(cd[68] + ('cd', 68)[0] + 36)] + 36)] - 23:
                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              revert with 0, 'toAddress_outOfBounds'
          stor0 = cd[4]
          if mem[215 len 20] != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
      if eth.balance(this.address) < cd[4]:
          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
      require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
         value cd[4] wei
           gas gas_remaining wei
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transfer(address recipient, uint256 amount) with:
           gas gas_remaining wei
          args caller, cd[4]
  else:
      if mem[215 len 20] < mem[192 len 20]:
          if mem[192 len 20] != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
      else:
          if 66 <= cd[(cd[68] + ('cd', 68)[0] + cd[(cd[68] + ('cd', 68)[0] + 36)] + 36)]:
              if cd[(cd[68] + ('cd', 68)[0] + cd[(cd[68] + ('cd', 68)[0] + 36)] + 36)] < 23:
                  revert with 0, 'slice_overflow'
              if cd[(cd[68] + ('cd', 68)[0] + cd[(cd[68] + ('cd', 68)[0] + 36)] + 36)] < cd[(cd[68] + ('cd', 68)[0] + cd[(cd[68] + ('cd', 68)[0] + 36)] + 36)]:
                  revert with 0, 'slice_outOfBounds'
              if cd[(cd[68] + ('cd', 68)[0] + cd[(cd[68] + ('cd', 68)[0] + 36)] + 36)] - 23:
                  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
              revert with 0, 'toAddress_outOfBounds'
          stor0 = cd[36]
          if mem[215 len 20] != 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:
              ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
      if eth.balance(this.address) < cd[36]:
          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
      require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit() with:
         value cd[36] wei
           gas gas_remaining wei
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      require ext_code.size(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
      call 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.transfer(address recipient, uint256 amount) with:
           gas gas_remaining wei
          args caller, cd[36]
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  require return_data.size >= 32

def exactInputSingle(tuple params) payable: 
  require calldata.size - 4 >=′ 256
  if block.timestamp > cd[132]:
      revert with 0, 'Transaction too old'
  require cd[100] == address(cd[100])
  require cd[228] == address(cd[228])
  require params == address(params)
  require cd[68] == cd[68] % unknown01000000()
  require cd[36] == address(cd[36])
  if address(cd[100]):
      if address(params) <= address(cd[36]):
          require address(params) < uint64(cd[36]) << 96
          require cd[164] < 0x8000000000000000000000000000000000000000000000000000000000000000
          require ext_code.size(address(sha3(0, 4755689777358670618, sha3(params << 192, address(cd[36]), cd[68] % unknown01000000()), 0x6ce8eb472fa82df5469c6ab6d485f17c3ad13c8cd7af59b3d4a8026c5ce0f7e2)))
          if address(cd[228]):
              call address(sha3(0, 4755689777358670618, sha3(params << 192, address(cd[36]), cd[68] % unknown01000000()), 0x6ce8eb472fa82df5469c6ab6d485f17c3ad13c8cd7af59b3d4a8026c5ce0f7e2)).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                   gas gas_remaining wei
                  args address(cd[100]), address(params) < address(cd[36]), cd[164], address(cd[228]), 160, 192, 'alle+', address(params), cd[68] % unknown01000000(), address(cd[36]), 0 >> 88, 0
          else:
              if address(params) < address(cd[36]):
                  call address(sha3(0, 4755689777358670618, sha3(params << 192, address(cd[36]), cd[68] % unknown01000000()), 0x6ce8eb472fa82df5469c6ab6d485f17c3ad13c8cd7af59b3d4a8026c5ce0f7e2)).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                       gas gas_remaining wei
                      args address(cd[100]), address(params) < address(cd[36]), cd[164], 4295128740, 160, 192, 'alle+', address(params), cd[68] % unknown01000000(), address(cd[36]), 0 >> 88, 0
              else:
                  call address(sha3(0, 4755689777358670618, sha3(params << 192, address(cd[36]), cd[68] % unknown01000000()), 0x6ce8eb472fa82df5469c6ab6d485f17c3ad13c8cd7af59b3d4a8026c5ce0f7e2)).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                       gas gas_remaining wei
                      args address(cd[100]), address(params) < address(cd[36]), cd[164], 0xfffd8963efd1fc6a506488495d951d5263988d25, 160, 192, 'alle+', address(params), cd[68] % unknown01000000(), address(cd[36]), 0 >> 88, 0
      else:
          require address(cd[36]) < uint64(params) << 96
          require cd[164] < 0x8000000000000000000000000000000000000000000000000000000000000000
          require ext_code.size(address(sha3(0, 4755689777358670618, sha3(cd[36] << 192, address(params), cd[68] % unknown01000000()), 0x6ce8eb472fa82df5469c6ab6d485f17c3ad13c8cd7af59b3d4a8026c5ce0f7e2)))
          if address(cd[228]):
              call address(sha3(0, 4755689777358670618, sha3(cd[36] << 192, address(params), cd[68] % unknown01000000()), 0x6ce8eb472fa82df5469c6ab6d485f17c3ad13c8cd7af59b3d4a8026c5ce0f7e2)).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                   gas gas_remaining wei
                  args address(cd[100]), address(params) < address(cd[36]), cd[164], address(cd[228]), 160, 192, 'alle+', address(params), cd[68] % unknown01000000(), address(cd[36]), 0 >> 88, 0
          else:
              if address(params) < address(cd[36]):
                  call address(sha3(0, 4755689777358670618, sha3(cd[36] << 192, address(params), cd[68] % unknown01000000()), 0x6ce8eb472fa82df5469c6ab6d485f17c3ad13c8cd7af59b3d4a8026c5ce0f7e2)).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                       gas gas_remaining wei
                      args address(cd[100]), address(params) < address(cd[36]), cd[164], 4295128740, 160, 192, 'alle+', address(params), cd[68] % unknown01000000(), address(cd[36]), 0 >> 88, 0
              else:
                  call address(sha3(0, 4755689777358670618, sha3(cd[36] << 192, address(params), cd[68] % unknown01000000()), 0x6ce8eb472fa82df5469c6ab6d485f17c3ad13c8cd7af59b3d4a8026c5ce0f7e2)).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                       gas gas_remaining wei
                      args address(cd[100]), address(params) < address(cd[36]), cd[164], 0xfffd8963efd1fc6a506488495d951d5263988d25, 160, 192, 'alle+', address(params), cd[68] % unknown01000000(), address(cd[36]), 0 >> 88, 0
  else:
      if address(params) <= address(cd[36]):
          require address(params) < uint64(cd[36]) << 96
          require cd[164] < 0x8000000000000000000000000000000000000000000000000000000000000000
          require ext_code.size(address(sha3(0, 4755689777358670618, sha3(params << 192, address(cd[36]), cd[68] % unknown01000000()), 0x6ce8eb472fa82df5469c6ab6d485f17c3ad13c8cd7af59b3d4a8026c5ce0f7e2)))
          if address(cd[228]):
              call address(sha3(0, 4755689777358670618, sha3(params << 192, address(cd[36]), cd[68] % unknown01000000()), 0x6ce8eb472fa82df5469c6ab6d485f17c3ad13c8cd7af59b3d4a8026c5ce0f7e2)).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                   gas gas_remaining wei
                  args address(this.address), address(params) < address(cd[36]), cd[164], address(cd[228]), 160, 192, 'alle+', address(params), cd[68] % unknown01000000(), address(cd[36]), 0 >> 88, 0
          else:
              if address(params) < address(cd[36]):
                  call address(sha3(0, 4755689777358670618, sha3(params << 192, address(cd[36]), cd[68] % unknown01000000()), 0x6ce8eb472fa82df5469c6ab6d485f17c3ad13c8cd7af59b3d4a8026c5ce0f7e2)).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                       gas gas_remaining wei
                      args address(this.address), address(params) < address(cd[36]), cd[164], 4295128740, 160, 192, 'alle+', address(params), cd[68] % unknown01000000(), address(cd[36]), 0 >> 88, 0
              else:
                  call address(sha3(0, 4755689777358670618, sha3(params << 192, address(cd[36]), cd[68] % unknown01000000()), 0x6ce8eb472fa82df5469c6ab6d485f17c3ad13c8cd7af59b3d4a8026c5ce0f7e2)).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                       gas gas_remaining wei
                      args address(this.address), address(params) < address(cd[36]), cd[164], 0xfffd8963efd1fc6a506488495d951d5263988d25, 160, 192, 'alle+', address(params), cd[68] % unknown01000000(), address(cd[36]), 0 >> 88, 0
      else:
          require address(cd[36]) < uint64(params) << 96
          require cd[164] < 0x8000000000000000000000000000000000000000000000000000000000000000
          require ext_code.size(address(sha3(0, 4755689777358670618, sha3(cd[36] << 192, address(params), cd[68] % unknown01000000()), 0x6ce8eb472fa82df5469c6ab6d485f17c3ad13c8cd7af59b3d4a8026c5ce0f7e2)))
          if address(cd[228]):
              call address(sha3(0, 4755689777358670618, sha3(cd[36] << 192, address(params), cd[68] % unknown01000000()), 0x6ce8eb472fa82df5469c6ab6d485f17c3ad13c8cd7af59b3d4a8026c5ce0f7e2)).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                   gas gas_remaining wei
                  args address(this.address), address(params) < address(cd[36]), cd[164], address(cd[228]), 160, 192, 'alle+', address(params), cd[68] % unknown01000000(), address(cd[36]), 0 >> 88, 0
          else:
              if address(params) < address(cd[36]):
                  call address(sha3(0, 4755689777358670618, sha3(cd[36] << 192, address(params), cd[68] % unknown01000000()), 0x6ce8eb472fa82df5469c6ab6d485f17c3ad13c8cd7af59b3d4a8026c5ce0f7e2)).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                       gas gas_remaining wei
                      args address(this.address), address(params) < address(cd[36]), cd[164], 4295128740, 160, 192, 'alle+', address(params), cd[68] % unknown01000000(), address(cd[36]), 0 >> 88, 0
              else:
                  call address(sha3(0, 4755689777358670618, sha3(cd[36] << 192, address(params), cd[68] % unknown01000000()), 0x6ce8eb472fa82df5469c6ab6d485f17c3ad13c8cd7af59b3d4a8026c5ce0f7e2)).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
                       gas gas_remaining wei
                      args address(this.address), address(params) < address(cd[36]), cd[164], 0xfffd8963efd1fc6a506488495d951d5263988d25, 160, 192, 'alle+', address(params), cd[68] % unknown01000000(), address(cd[36]), 0 >> 88, 0
  if not ext_call.success:
      revert with ext_call.return_data[0 len return_data.size]
  require return_data.size >=′ 64
  if address(params) >= address(cd[36]):
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def exactOutput(tuple params) payable: 
  require calldata.size - 4 >=′ 32
  require params <= LOCK8605463013()
  require calldata.size + -params - 4 >=′ 160
  if block.timestamp > cd[(params + 68)]:
      revert with 0, 'Transaction too old'
  require cd[(params + 36)] == address(cd[(params + 36)])
  require params.length <′ calldata.size + -params - 35
  require cd[(params + params.length + 4)] <= LOCK8605463013()
  require params + params.length + 36 <=′ calldata.size - cd[(params + params.length + 4)]
  mem[192 len cd[(params + params.length + 4)]] = call.data[params + params.length + 36 len cd[(params + params.length + 4)]]
  mem[cd[(params + params.length + 4)] + 192] = 0
  if cd[(params + params.length + 4)] < 20:
      revert with 0, 'toAddress_outOfBounds'
  if address(cd[(params + 36)]):
      _8 = mem[192]
      if cd[(params + params.length + 4)] < 23:
          revert with 0, 'toUint24_outOfBounds'
      _16 = Mask(72, 0, cd[(params + params.length + 4)]), mem[192 len 23]
      if cd[(params + params.length + 4)] < 43:
          revert with 0, 'toAddress_outOfBounds'
      _24 = mem[215]
      mem[ceil32(cd[(params + params.length + 4)]) + 192] = 0
      if Mask(160, 96, _24) >> 96 <= Mask(160, 96, _8) >> 96:
          require Mask(160, 96, _24) >> 96 < Mask(64, 96, _8)
          require cd[(params + 100)] < 0x8000000000000000000000000000000000000000000000000000000000000000
          mem[ceil32(cd[(params + params.length + 4)]) + 661] = 32
          mem[ceil32(cd[(params + params.length + 4)]) + 693] = 64
          mem[ceil32(cd[(params + params.length + 4)]) + 757] = cd[(params + params.length + 4)]
          mem[ceil32(cd[(params + params.length + 4)]) + 789 len ceil32(cd[(params + params.length + 4)])] = call.data[params + params.length + 36 len cd[(params + params.length + 4)]], mem[cd[(params + params.length + 4)] + 192 len ceil32(cd[(params + params.length + 4)]) - cd[(params + params.length + 4)]]
          if ceil32(cd[(params + params.length + 4)]) > cd[(params + params.length + 4)]:
              mem[cd[(params + params.length + 4)] + ceil32(cd[(params + params.length + 4)]) + 789] = 0
          mem[ceil32(cd[(params + params.length + 4)]) + 725] = caller
          mem[(2 * ceil32(cd[(params + params.length + 4)])) + 789] = 0x128acb0800000000000000000000000000000000000000000000000000000000
          mem[(2 * ceil32(cd[(params + params.length + 4)])) + 793] = address(cd[(params + 36)])
          mem[(2 * ceil32(cd[(params + params.length + 4)])) + 825] = Mask(160, 96, _24) >> 96 < Mask(160, 96, _8) >> 96
          mem[(2 * ceil32(cd[(params + params.length + 4)])) + 857] = -cd[(params + 100)]
          if Mask(160, 96, _24) >> 96 < Mask(160, 96, _8) >> 96:
              mem[(2 * ceil32(cd[(params + params.length + 4)])) + 889] = 4295128740
          else:
              mem[(2 * ceil32(cd[(params + params.length + 4)])) + 889] = 0xfffd8963efd1fc6a506488495d951d5263988d25
          mem[(2 * ceil32(cd[(params + params.length + 4)])) + 921] = 160
          mem[(2 * ceil32(cd[(params + params.length + 4)])) + 953] = ceil32(cd[(params + params.length + 4)]) + 128
          mem[(2 * ceil32(cd[(params + params.length + 4)])) + 985 len ceil32(ceil32(cd[(params + params.length + 4)])) + 4] = mem[ceil32(cd[(params + params.length + 4)]) + 661 len ceil32(ceil32(cd[(params + params.length + 4)])) + 4]
          if ceil32(ceil32(cd[(params + params.length + 4)])) + 4 > ceil32(cd[(params + params.length + 4)]) + 128:
              mem[(4 * ceil32(cd[(params + params.length + 4)])) + 1113] = 0
          require ext_code.size(address(sha3(0, 4755689777358670618, sha3(Mask(64, 96, _24) << 96, Mask(160, 96, _8), _16 % unknown01000000()), 0x6ce8eb472fa82df5469c6ab6d485f17c3ad13c8cd7af59b3d4a8026c5ce0f7e2)))
          call address(sha3(0, 4755689777358670618, sha3(Mask(64, 96, _24) << 96, Mask(160, 96, _8), _16 % unknown01000000()), 0x6ce8eb472fa82df5469c6ab6d485f17c3ad13c8cd7af59b3d4a8026c5ce0f7e2)).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
               gas gas_remaining wei
              args mem[(2 * ceil32(cd[(params + params.length + 4)])) + 793 len ceil32(ceil32(cd[(params + params.length + 4)])) + ceil32(cd[(params + params.length + 4)]) + 196]
      else:
          require Mask(160, 96, _8) >> 96 < Mask(64, 96, _24)
          require cd[(params + 100)] < 0x8000000000000000000000000000000000000000000000000000000000000000
          mem[ceil32(cd[(params + params.length + 4)]) + 661] = 32
          mem[ceil32(cd[(params + params.length + 4)]) + 693] = 64
          mem[ceil32(cd[(params + params.length + 4)]) + 757] = cd[(params + params.length + 4)]
          mem[ceil32(cd[(params + params.length + 4)]) + 789 len ceil32(cd[(params + params.length + 4)])] = call.data[params + params.length + 36 len cd[(params + params.length + 4)]], mem[cd[(params + params.length + 4)] + 192 len ceil32(cd[(params + params.length + 4)]) - cd[(params + params.length + 4)]]
          if ceil32(cd[(params + params.length + 4)]) > cd[(params + params.length + 4)]:
              mem[cd[(params + params.length + 4)] + ceil32(cd[(params + params.length + 4)]) + 789] = 0
          mem[ceil32(cd[(params + params.length + 4)]) + 725] = caller
          mem[(2 * ceil32(cd[(params + params.length + 4)])) + 789] = 0x128acb0800000000000000000000000000000000000000000000000000000000
          mem[(2 * ceil32(cd[(params + params.length + 4)])) + 793] = address(cd[(params + 36)])
          mem[(2 * ceil32(cd[(params + params.length + 4)])) + 825] = Mask(160, 96, _24) >> 96 < Mask(160, 96, _8) >> 96
          mem[(2 * ceil32(cd[(params + params.length + 4)])) + 857] = -cd[(params + 100)]
          if Mask(160, 96, _24) >> 96 < Mask(160, 96, _8) >> 96:
              mem[(2 * ceil32(cd[(params + params.length + 4)])) + 889] = 4295128740
          else:
              mem[(2 * ceil32(cd[(params + params.length + 4)])) + 889] = 0xfffd8963efd1fc6a506488495d951d5263988d25
          mem[(2 * ceil32(cd[(params + params.length + 4)])) + 921] = 160
          mem[(2 * ceil32(cd[(params + params.length + 4)])) + 953] = ceil32(cd[(params + params.length + 4)]) + 128
          mem[(2 * ceil32(cd[(params + params.length + 4)])) + 985 len ceil32(ceil32(cd[(params + params.length + 4)])) + 4] = mem[ceil32(cd[(params + params.length + 4)]) + 661 len ceil32(ceil32(cd[(params + params.length + 4)])) + 4]
          if ceil32(ceil32(cd[(params + params.length + 4)])) + 4 > ceil32(cd[(params + params.length + 4)]) + 128:
              mem[(4 * ceil32(cd[(params + params.length + 4)])) + 1113] = 0
          require ext_code.size(address(sha3(0, 4755689777358670618, sha3(Mask(64, 96, _8) << 96, Mask(160, 96, _24), _16 % unknown01000000()), 0x6ce8eb472fa82df5469c6ab6d485f17c3ad13c8cd7af59b3d4a8026c5ce0f7e2)))
          call address(sha3(0, 4755689777358670618, sha3(Mask(64, 96, _8) << 96, Mask(160, 96, _24), _16 % unknown01000000()), 0x6ce8eb472fa82df5469c6ab6d485f17c3ad13c8cd7af59b3d4a8026c5ce0f7e2)).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
               gas gas_remaining wei
              args mem[(2 * ceil32(cd[(params + params.length + 4)])) + 793 len ceil32(ceil32(cd[(params + params.length + 4)])) + ceil32(cd[(params + params.length + 4)]) + 196]
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      require return_data.size >=′ 64
      if Mask(160, 96, _24) >> 96 < Mask(160, 96, _8) >> 96:
          require -ext_call.return_data[32] == cd[(params + 100)]
      else:
          require -ext_call.return_data[0] == cd[(params + 100)]
  else:
      _12 = mem[192]
      if cd[(params + params.length + 4)] < 23:
          revert with 0, 'toUint24_outOfBounds'
      _20 = Mask(72, 0, cd[(params + params.length + 4)]), mem[192 len 23]
      if cd[(params + params.length + 4)] < 43:
          revert with 0, 'toAddress_outOfBounds'
      _28 = mem[215]
      mem[ceil32(cd[(params + params.length + 4)]) + 192] = 0
      if Mask(160, 96, _28) >> 96 <= Mask(160, 96, _12) >> 96:
          require Mask(160, 96, _28) >> 96 < Mask(64, 96, _12)
          require cd[(params + 100)] < 0x8000000000000000000000000000000000000000000000000000000000000000
          mem[ceil32(cd[(params + params.length + 4)]) + 661] = 32
          mem[ceil32(cd[(params + params.length + 4)]) + 693] = 64
          mem[ceil32(cd[(params + params.length + 4)]) + 757] = cd[(params + params.length + 4)]
          mem[ceil32(cd[(params + params.length + 4)]) + 789 len ceil32(cd[(params + params.length + 4)])] = call.data[params + params.length + 36 len cd[(params + params.length + 4)]], mem[cd[(params + params.length + 4)] + 192 len ceil32(cd[(params + params.length + 4)]) - cd[(params + params.length + 4)]]
          if ceil32(cd[(params + params.length + 4)]) > cd[(params + params.length + 4)]:
              mem[cd[(params + params.length + 4)] + ceil32(cd[(params + params.length + 4)]) + 789] = 0
          mem[ceil32(cd[(params + params.length + 4)]) + 725] = caller
          mem[(2 * ceil32(cd[(params + params.length + 4)])) + 789] = 0x128acb0800000000000000000000000000000000000000000000000000000000
          mem[(2 * ceil32(cd[(params + params.length + 4)])) + 793] = this.address
          mem[(2 * ceil32(cd[(params + params.length + 4)])) + 825] = Mask(160, 96, _28) >> 96 < Mask(160, 96, _12) >> 96
          mem[(2 * ceil32(cd[(params + params.length + 4)])) + 857] = -cd[(params + 100)]
          if Mask(160, 96, _28) >> 96 < Mask(160, 96, _12) >> 96:
              mem[(2 * ceil32(cd[(params + params.length + 4)])) + 889] = 4295128740
          else:
              mem[(2 * ceil32(cd[(params + params.length + 4)])) + 889] = 0xfffd8963efd1fc6a506488495d951d5263988d25
          mem[(2 * ceil32(cd[(params + params.length + 4)])) + 921] = 160
          mem[(2 * ceil32(cd[(params + params.length + 4)])) + 953] = ceil32(cd[(params + params.length + 4)]) + 128
          mem[(2 * ceil32(cd[(params + params.length + 4)])) + 985 len ceil32(ceil32(cd[(params + params.length + 4)])) + 4] = mem[ceil32(cd[(params + params.length + 4)]) + 661 len ceil32(ceil32(cd[(params + params.length + 4)])) + 4]
          if ceil32(ceil32(cd[(params + params.length + 4)])) + 4 > ceil32(cd[(params + params.length + 4)]) + 128:
              mem[(4 * ceil32(cd[(params + params.length + 4)])) + 1113] = 0
          require ext_code.size(address(sha3(0, 4755689777358670618, sha3(Mask(64, 96, _28) << 96, Mask(160, 96, _12), _20 % unknown01000000()), 0x6ce8eb472fa82df5469c6ab6d485f17c3ad13c8cd7af59b3d4a8026c5ce0f7e2)))
          call address(sha3(0, 4755689777358670618, sha3(Mask(64, 96, _28) << 96, Mask(160, 96, _12), _20 % unknown01000000()), 0x6ce8eb472fa82df5469c6ab6d485f17c3ad13c8cd7af59b3d4a8026c5ce0f7e2)).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
               gas gas_remaining wei
              args mem[(2 * ceil32(cd[(params + params.length + 4)])) + 793 len ceil32(ceil32(cd[(params + params.length + 4)])) + ceil32(cd[(params + params.length + 4)]) + 196]
      else:
          require Mask(160, 96, _12) >> 96 < Mask(64, 96, _28)
          require cd[(params + 100)] < 0x8000000000000000000000000000000000000000000000000000000000000000
          mem[ceil32(cd[(params + params.length + 4)]) + 661] = 32
          mem[ceil32(cd[(params + params.length + 4)]) + 693] = 64
          mem[ceil32(cd[(params + params.length + 4)]) + 757] = cd[(params + params.length + 4)]
          mem[ceil32(cd[(params + params.length + 4)]) + 789 len ceil32(cd[(params + params.length + 4)])] = call.data[params + params.length + 36 len cd[(params + params.length + 4)]], mem[cd[(params + params.length + 4)] + 192 len ceil32(cd[(params + params.length + 4)]) - cd[(params + params.length + 4)]]
          if ceil32(cd[(params + params.length + 4)]) > cd[(params + params.length + 4)]:
              mem[cd[(params + params.length + 4)] + ceil32(cd[(params + params.length + 4)]) + 789] = 0
          mem[ceil32(cd[(params + params.length + 4)]) + 725] = caller
          mem[(2 * ceil32(cd[(params + params.length + 4)])) + 789] = 0x128acb0800000000000000000000000000000000000000000000000000000000
          mem[(2 * ceil32(cd[(params + params.length + 4)])) + 793] = this.address
          mem[(2 * ceil32(cd[(params + params.length + 4)])) + 825] = Mask(160, 96, _28) >> 96 < Mask(160, 96, _12) >> 96
          mem[(2 * ceil32(cd[(params + params.length + 4)])) + 857] = -cd[(params + 100)]
          if Mask(160, 96, _28) >> 96 < Mask(160, 96, _12) >> 96:
              mem[(2 * ceil32(cd[(params + params.length + 4)])) + 889] = 4295128740
          else:
              mem[(2 * ceil32(cd[(params + params.length + 4)])) + 889] = 0xfffd8963efd1fc6a506488495d951d5263988d25
          mem[(2 * ceil32(cd[(params + params.length + 4)])) + 921] = 160
          mem[(2 * ceil32(cd[(params + params.length + 4)])) + 953] = ceil32(cd[(params + params.length + 4)]) + 128
          mem[(2 * ceil32(cd[(params + params.length + 4)])) + 985 len ceil32(ceil32(cd[(params + params.length + 4)])) + 4] = mem[ceil32(cd[(params + params.length + 4)]) + 661 len ceil32(ceil32(cd[(params + params.length + 4)])) + 4]
          if ceil32(ceil32(cd[(params + params.length + 4)])) + 4 > ceil32(cd[(params + params.length + 4)]) + 128:
              mem[(4 * ceil32(cd[(params + params.length + 4)])) + 1113] = 0
          require ext_code.size(address(sha3(0, 4755689777358670618, sha3(Mask(64, 96, _12) << 96, Mask(160, 96, _28), _20 % unknown01000000()), 0x6ce8eb472fa82df5469c6ab6d485f17c3ad13c8cd7af59b3d4a8026c5ce0f7e2)))
          call address(sha3(0, 4755689777358670618, sha3(Mask(64, 96, _12) << 96, Mask(160, 96, _28), _20 % unknown01000000()), 0x6ce8eb472fa82df5469c6ab6d485f17c3ad13c8cd7af59b3d4a8026c5ce0f7e2)).swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data) with:
               gas gas_remaining wei
              args mem[(2 * ceil32(cd[(params + params.length + 4)])) + 793 len ceil32(ceil32(cd[(params + params.length + 4)])) + ceil32(cd[(params + params.length + 4)]) + 196]
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]
      require return_data.size >=′ 64
      if Mask(160, 96, _28) >> 96 < Mask(160, 96, _12) >> 96:
          require -ext_call.return_data[32] == cd[(params + 100)]
      else:
          require -ext_call.return_data[0] == cd[(params + 100)]
  if stor0 > cd[(params + 132)]:
      revert with 0, 'Too much requested'
  stor0 = -1
  return stor0

def multicall(bytes[] data) payable: 
  require calldata.size - 4 >=′ 32
  require data <= LOCK8605463013()
  require data + 35 <′ calldata.size
  require data.length <= LOCK8605463013()
  require data + (32 * data.length) + 36 <= calldata.size
  require data.length <= LOCK8605463013()
  mem[96] = data.length
  mem[64] = (32 * data.length) + 128
  if not data.length:
      idx = 0
      while idx < data.length:
          require cd[(data + (32 * idx) + 36)] <′ calldata.size + -data - 67
          require cd[(data + cd[(data + (32 * idx) + 36)] + 36)] <= LOCK8605463013()
          require data + cd[(data + (32 * idx) + 36)] + 68 <=′ calldata.size - cd[(data + cd[(data + (32 * idx) + 36)] + 36)]
          _95 = mem[64]
          mem[mem[64] len cd[(data + cd[(data + (32 * idx) + 36)] + 36)]] = call.data[data + cd[(data + (32 * idx) + 36)] + 68 len cd[(data + cd[(data + (32 * idx) + 36)] + 36)]]
          mem[cd[(data + cd[(data + (32 * idx) + 36)] + 36)] + mem[64]] = 0
          delegate this.address.mem[mem[64] len 4] with:
               gas gas_remaining wei
              args mem[mem[64] + 4 len cd[(data + cd[(data + (32 * idx) + 36)] + 36)] + _95 + -mem[64] - 4]
          if not return_data.size:
              if delegate.return_code:
                  require idx < mem[96]
                  mem[(32 * idx) + 128] = 96
                  idx = idx + 1
                  continue 
              require mem[96] >= 68
              _109 = mem[100]
              require mem[100] >=′ 32
              _112 = mem[132]
              require mem[132] <= LOCK8605463013()
              require mem[100] + 132 >′ mem[132] + 163
              _120 = mem[mem[132] + 132]
              require mem[mem[132] + 132] <= LOCK8605463013()
              _126 = mem[64]
              require mem[64] + ceil32(mem[mem[132] + 132]) + 32 >= mem[64] and mem[64] + ceil32(mem[mem[132] + 132]) + 32 <= LOCK8605463013()
              mem[64] = mem[64] + ceil32(mem[mem[132] + 132]) + 32
              mem[_126] = mem[mem[132] + 132]
              require _112 + _120 + 164 <= _109 + 132
              idx = 0
              while idx < _120:
                  mem[idx + _126 + 32] = mem[idx + _112 + 164]
                  idx = idx + 32
                  continue 
              if ceil32(_120) <= _120:
                  _181 = mem[64]
                  mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                  mem[mem[64] + 4] = 32
                  _187 = mem[_126]
                  mem[mem[64] + 36] = mem[_126]
                  idx = 0
                  while idx < _187:
                      mem[idx + _181 + 68] = mem[idx + _126 + 32]
                      idx = idx + 32
                      continue 
                  if ceil32(_187) > _187:
                      mem[_187 + _181 + 68] = 0
                  revert with memory
                    from mem[64]
                     len ceil32(_187) + _181 + -mem[64] + 68
              mem[_120 + _126 + 32] = 0
              _182 = mem[64]
              mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
              mem[mem[64] + 4] = 32
              _188 = mem[_126]
              mem[mem[64] + 36] = mem[_126]
              idx = 0
              while idx < _188:
                  mem[idx + _182 + 68] = mem[idx + _126 + 32]
                  idx = idx + 32
                  continue 
              if ceil32(_188) > _188:
                  mem[_188 + _182 + 68] = 0
              revert with memory
                from mem[64]
                 len ceil32(_188) + _182 + -mem[64] + 68
          _101 = mem[64]
          mem[64] = mem[64] + ceil32(return_data.size) + 1
          mem[_101] = return_data.size
          mem[_101 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
          if delegate.return_code:
              require idx < mem[96]
              mem[(32 * idx) + 128] = _101
              idx = idx + 1
              continue 
          require return_data.size >= 68
          _110 = Mask(224, 0, return_data.size), mem[_101 + 32 len 4]
          require Mask(224, 0, return_data.size), mem[_101 + 32 len 4] >=′ 32
          _113 = mem[_101 + 36]
          require mem[_101 + 36] <= LOCK8605463013()
          require _101 + Mask(224, 0, return_data.size), mem[_101 + 32 len 4] + 36 >′ _101 + mem[_101 + 36] + 67
          _121 = mem[_101 + mem[_101 + 36] + 36]
          require mem[_101 + mem[_101 + 36] + 36] <= LOCK8605463013()
          _127 = mem[64]
          require mem[64] + ceil32(mem[_101 + mem[_101 + 36] + 36]) + 32 >= mem[64] and mem[64] + ceil32(mem[_101 + mem[_101 + 36] + 36]) + 32 <= LOCK8605463013()
          mem[64] = mem[64] + ceil32(mem[_101 + mem[_101 + 36] + 36]) + 32
          mem[_127] = _121
          require _113 + _121 + 68 <= _110 + 36
          idx = 0
          while idx < _121:
              mem[idx + _127 + 32] = mem[idx + _101 + _113 + 68]
              idx = idx + 32
              continue 
          if ceil32(_121) <= _121:
              _183 = mem[64]
              mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
              mem[mem[64] + 4] = 32
              mem[mem[64] + 36] = _121
              idx = 0
              while idx < _121:
                  mem[idx + _183 + 68] = mem[idx + _127 + 32]
                  idx = idx + 32
                  continue 
              if ceil32(_121) > _121:
                  mem[_121 + _183 + 68] = 0
              revert with memory
                from mem[64]
                 len ceil32(_121) + _183 + -mem[64] + 68
          mem[_121 + _127 + 32] = 0
          _184 = mem[64]
          mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
          mem[mem[64] + 4] = 32
          mem[mem[64] + 36] = _121
          idx = 0
          while idx < _121:
              mem[idx + _184 + 68] = mem[idx + _127 + 32]
              idx = idx + 32
              continue 
          if ceil32(_121) > _121:
              mem[_121 + _184 + 68] = 0
          revert with memory
            from mem[64]
             len ceil32(_121) + _184 + -mem[64] + 68
      _88 = mem[64]
      mem[mem[64]] = 32
      _89 = mem[96]
      mem[mem[64] + 32] = mem[96]
      s = 0
      t = 128
      u = mem[64] + 64
      v = mem[64] + (32 * mem[96]) + 64
      while s < _89:
          mem[u] = v + -_88 - 64
          _174 = mem[t]
          _178 = mem[mem[t]]
          mem[v] = mem[mem[t]]
          idx = 0
          while idx < _178:
              mem[idx + v + 32] = mem[idx + _174 + 32]
              idx = idx + 32
              continue 
          if ceil32(_178) > _178:
              mem[_178 + v + 32] = 0
          s = s + 1
          t = t + 32
          u = u + 32
          v = ceil32(_178) + v + 32
          continue 
  else:
      mem[128] = 96
      s = 128
      idx = data.length
      while idx - 1:
          mem[s + 32] = 96
          s = s + 32
          idx = idx - 1
          continue 
      idx = 0
      while idx < data.length:
          require cd[(data + (32 * idx) + 36)] <′ calldata.size + -data - 67
          require cd[(data + cd[(data + (32 * idx) + 36)] + 36)] <= LOCK8605463013()
          require data + cd[(data + (32 * idx) + 36)] + 68 <=′ calldata.size - cd[(data + cd[(data + (32 * idx) + 36)] + 36)]
          mem[mem[64] len cd[(data + cd[(data + (32 * idx) + 36)] + 36)]] = call.data[data + cd[(data + (32 * idx) + 36)] + 68 len cd[(data + cd[(data + (32 * idx) + 36)] + 36)]]
          mem[cd[(data + cd[(data + (32 * idx) + 36)] + 36)] + mem[64]] = 0
          delegate this.address with:
               gas gas_remaining wei
              args call.data[data + cd[(data + (32 * idx) + 36)] + 68 len cd[(data + cd[(data + (32 * idx) + 36)] + 36)]]
          if not return_data.size:
              if delegate.return_code:
                  require idx < mem[96]
                  mem[(32 * idx) + 128] = 96
                  idx = idx + 1
                  continue 
              require mem[96] >= 68
              _213 = mem[100]
              require mem[100] >=′ 32
              _215 = mem[132]
              require mem[132] <= LOCK8605463013()
              require mem[100] + 132 >′ mem[132] + 163
              _217 = mem[mem[132] + 132]
              require mem[mem[132] + 132] <= LOCK8605463013()
              _219 = mem[64]
              require mem[64] + ceil32(mem[mem[132] + 132]) + 32 >= mem[64] and mem[64] + ceil32(mem[mem[132] + 132]) + 32 <= LOCK8605463013()
              mem[64] = mem[64] + ceil32(mem[mem[132] + 132]) + 32
              mem[_219] = mem[mem[132] + 132]
              require _215 + _217 + 164 <= _213 + 132
              idx = 0
              while idx < _217:
                  mem[idx + _219 + 32] = mem[idx + _215 + 164]
                  idx = idx + 32
                  continue 
              if ceil32(_217) <= _217:
                  _253 = mem[64]
                  mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                  mem[mem[64] + 4] = 32
                  _266 = mem[_219]
                  mem[mem[64] + 36] = mem[_219]
                  idx = 0
                  while idx < _266:
                      mem[idx + _253 + 68] = mem[idx + _219 + 32]
                      idx = idx + 32
                      continue 
                  if ceil32(_266) > _266:
                      mem[_266 + _253 + 68] = 0
                  revert with memory
                    from mem[64]
                     len ceil32(_266) + _253 + -mem[64] + 68
              mem[_217 + _219 + 32] = 0
              _254 = mem[64]
              mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
              mem[mem[64] + 4] = 32
              _267 = mem[_219]
              mem[mem[64] + 36] = mem[_219]
              idx = 0
              while idx < _267:
                  mem[idx + _254 + 68] = mem[idx + _219 + 32]
                  idx = idx + 32
                  continue 
              if ceil32(_267) > _267:
                  mem[_267 + _254 + 68] = 0
              revert with memory
                from mem[64]
                 len ceil32(_267) + _254 + -mem[64] + 68
          _200 = mem[64]
          mem[64] = mem[64] + ceil32(return_data.size) + 1
          mem[_200] = return_data.size
          mem[_200 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
          if delegate.return_code:
              require idx < mem[96]
              mem[(32 * idx) + 128] = _200
              idx = idx + 1
              continue 
          require return_data.size >= 68
          _214 = Mask(224, 0, return_data.size), mem[_200 + 32 len 4]
          require Mask(224, 0, return_data.size), mem[_200 + 32 len 4] >=′ 32
          _216 = mem[_200 + 36]
          require mem[_200 + 36] <= LOCK8605463013()
          require _200 + Mask(224, 0, return_data.size), mem[_200 + 32 len 4] + 36 >′ _200 + mem[_200 + 36] + 67
          _218 = mem[_200 + mem[_200 + 36] + 36]
          require mem[_200 + mem[_200 + 36] + 36] <= LOCK8605463013()
          _220 = mem[64]
          require mem[64] + ceil32(mem[_200 + mem[_200 + 36] + 36]) + 32 >= mem[64] and mem[64] + ceil32(mem[_200 + mem[_200 + 36] + 36]) + 32 <= LOCK8605463013()
          mem[64] = mem[64] + ceil32(mem[_200 + mem[_200 + 36] + 36]) + 32
          mem[_220] = _218
          require _216 + _218 + 68 <= _214 + 36
          idx = 0
          while idx < _218:
              mem[idx + _220 + 32] = mem[idx + _200 + _216 + 68]
              idx = idx + 32
              continue 
          if ceil32(_218) <= _218:
              _255 = mem[64]
              mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
              mem[mem[64] + 4] = 32
              mem[mem[64] + 36] = _218
              idx = 0
              while idx < _218:
                  mem[idx + _255 + 68] = mem[idx + _220 + 32]
                  idx = idx + 32
                  continue 
              if ceil32(_218) > _218:
                  mem[_218 + _255 + 68] = 0
              revert with memory
                from mem[64]
                 len ceil32(_218) + _255 + -mem[64] + 68
          mem[_218 + _220 + 32] = 0
          _256 = mem[64]
          mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
          mem[mem[64] + 4] = 32
          mem[mem[64] + 36] = _218
          idx = 0
          while idx < _218:
              mem[idx + _256 + 68] = mem[idx + _220 + 32]
              idx = idx + 32
              continue 
          if ceil32(_218) > _218:
              mem[_218 + _256 + 68] = 0
          revert with memory
            from mem[64]
             len ceil32(_218) + _256 + -mem[64] + 68
      _179 = mem[64]
      mem[mem[64]] = 32
      _180 = mem[96]
      mem[mem[64] + 32] = mem[96]
      s = 0
      t = 128
      u = mem[64] + 64
      v = mem[64] + (32 * mem[96]) + 64
      while s < _180:
          mem[u] = v + -_179 - 64
          _248 = mem[t]
          _252 = mem[mem[t]]
          mem[v] = mem[mem[t]]
          idx = 0
          while idx < _252:
              mem[idx + v + 32] = mem[idx + _248 + 32]
              idx = idx + 32
              continue 
          if ceil32(_252) > _252:
              mem[_252 + v + 32] = 0
          s = s + 1
          t = t + 32
          u = u + 32
          v = ceil32(_252) + v + 32
          continue 
  return memory
    from mem[64]
     len v - mem[64]


