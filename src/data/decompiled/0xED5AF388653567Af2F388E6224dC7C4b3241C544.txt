# Palkeoramix decompiler. 

const amountForAuctionAndDev = 8900
const maxPerAddressDuringMint = 5
const amountForDevs = 200
const AUCTION_DROP_PER_STEP = 5 * 10^16
const AUCTION_DROP_INTERVAL = 1200
const AUCTION_START_PRICE = 10^18
const AUCTION_END_PRICE = 15 * 10^16
const AUCTION_PRICE_CURVE_LENGTH = 20400

def storage:
  owner is address at storage 0
  totalSupply is uint256 at storage 1
  stor2 is array of struct at storage 2
  stor3 is array of struct at storage 3
  stor4 is mapping of struct at storage 4
  balanceOf is mapping of struct at storage 5
  approved is mapping of address at storage 6
  stor7 is mapping of uint8 at storage 7
  nextOwnerToExplicitlySet is uint256 at storage 8
  stor9 is uint256 at storage 9
  stor10 is uint32 at storage 10
  stor10 is uint32 at storage 10 offset 32
  stor10 is uint32 at storage 10 offset 192
  stor10 is uint64 at storage 10
  stor10 is uint64 at storage 10 offset 64
  stor10 is uint64 at storage 10 offset 128
  stor10 is uint64 at storage 10 offset 192
  allowlist is mapping of uint256 at storage 11
  stor12 is array of struct at storage 12

def getApproved(uint256 tokenId): # not payable
  require calldata.size - 4 >=′ 32
  if totalSupply <= tokenId:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721A: approved query for nonexistent token'
  return approved[tokenId]

def totalSupply(): # not payable
  return totalSupply

def balanceOf(address account): # not payable
  require calldata.size - 4 >=′ 32
  require account == account
  if not account:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721A: balance query for the zero address'
  return balanceOf[address(account)].field_0

def owner(): # not payable
  return owner

def allowlist(address _param1): # not payable
  require calldata.size - 4 >=′ 32
  require _param1 == _param1
  return allowlist[_param1]

def nextOwnerToExplicitlySet(): # not payable
  return nextOwnerToExplicitlySet

def numberMinted(address owner): # not payable
  require calldata.size - 4 >=′ 32
  require owner == owner
  if not owner:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721A: number minted query for the zero address'
  return balanceOf[address(owner)].field_128

def isApprovedForAll(address owner, address operator): # not payable
  require calldata.size - 4 >=′ 64
  require owner == owner
  require operator == operator
  return bool(stor7[address(owner)][address(operator)])

#
#  Regular functions
#

def _fallback(?) payable: # default function
  revert

def tokenByIndex(uint256 index): # not payable
  require calldata.size - 4 >=′ 32
  if index >= totalSupply:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721A: global index out of bounds'
  return index

def renounceOwnership(): # not payable
  if owner != caller:
      revert with 0, 32, 32, 0xfe4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65
  owner = 0
  log OwnershipTransferred(
        address previousOwner=owner,
        address newOwner=0)

def setPublicSaleKey(uint32 key): # not payable
  require calldata.size - 4 >=′ 32
  require key == key
  if owner != caller:
      revert with 0, 32, 32, 0xfe4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65
  uint32(stor10.field_192) = key

def isPublicSaleOn(uint256 publicPriceWei, uint256 publicSaleKey, uint256 publicSaleStartTime): # not payable
  require calldata.size - 4 >=′ 96
  if not publicPriceWei:
      return bool(publicPriceWei)
  if not publicSaleKey:
      return bool(publicSaleKey)
  return block.timestamp >= publicSaleStartTime

def setAuctionSaleStartTime(uint32 timestamp): # not payable
  require calldata.size - 4 >=′ 32
  require timestamp == timestamp
  if owner != caller:
      revert with 0, 32, 32, 0xfe4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65
  uint32(stor10.field_0) = timestamp

def saleConfig(): # not payable
  return uint32(stor10.field_0), 
         uint32(stor10.field_0),
         uint64(stor10.field_0),
         uint64(stor10.field_0),
         uint32(stor10.field_192)

def withdrawMoney(): # not payable
  if owner != caller:
      revert with 0, 32, 32, 0xfe4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65
  if stor9 == 2:
      revert with 0, 'ReentrancyGuard: reentrant call'
  stor9 = 2
  call caller with:
     value eth.balance(this.address) wei
       gas gas_remaining wei
  if not ext_call.success:
      revert with 0, 'Transfer failed.'
  stor9 = 1

def transferOwnership(address newOwner): # not payable
  require calldata.size - 4 >=′ 32
  require newOwner == newOwner
  if owner != caller:
      revert with 0, 32, 32, 0xfe4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65
  if not newOwner:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
  owner = newOwner
  log OwnershipTransferred(
        address previousOwner=owner,
        address newOwner=newOwner)

def setApprovalForAll(address operator, bool approved): # not payable
  require calldata.size - 4 >=′ 64
  require operator == operator
  require approved == approved
  if caller == operator:
      revert with 0, 'ERC721A: approve to caller'
  stor7[caller][address(operator)] = uint8(approved)
  log ApprovalForAll(
        address owner=approved,
        address operator=caller,
        bool approved=operator)

def supportsInterface(bytes4 interfaceId): # not payable
  require calldata.size - 4 >=′ 32
  require interfaceId == Mask(32, 224, interfaceId)
  if 0x80ac58cd00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, interfaceId):
      return True
  if 0x5b5e139f00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, interfaceId):
      return True
  if 0x780e9d6300000000000000000000000000000000000000000000000000000000 == Mask(32, 224, interfaceId):
      return True
  return (Mask(32, 224, interfaceId) == 0x1ffc9a700000000000000000000000000000000000000000000000000000000)

def getAuctionPrice(uint256 _saleStartTime): # not payable
  require calldata.size - 4 >=′ 32
  if block.timestamp < _saleStartTime:
      return 10^18
  if block.timestamp - _saleStartTime >= 20400:
      return 15 * 10^16
  if block.timestamp < _saleStartTime:
      revert with 0, 17
  if block.timestamp - _saleStartTime / 1200 and 5 * 10^16 > -1 / block.timestamp - _saleStartTime / 1200:
      revert with 0, 17
  if 10^18 < 5 * 10^16 * block.timestamp - _saleStartTime / 1200:
      revert with 0, 17
  return ((-5 * 10^16 * block.timestamp - _saleStartTime / 1200) + 10^18)

def endAuctionAndSetupNonAuctionSaleInfo(uint64 mintlistPriceWei, uint64 publicPriceWei, uint32 publicSaleStartTime): # not payable
  require calldata.size - 4 >=′ 96
  require mintlistPriceWei == mintlistPriceWei
  require publicPriceWei == publicPriceWei
  require publicSaleStartTime == publicSaleStartTime
  if owner != caller:
      revert with 0, 32, 32, 0xfe4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65
  uint32(stor10.field_0) = 0
  uint32(stor10.field_32) = publicSaleStartTime
  uint64(stor10.field_64) = mintlistPriceWei
  uint64(stor10.field_128) = publicPriceWei
  uint64(stor10.field_192) = uint32(stor10.field_192)

def ownerOf(uint256 tokenId): # not payable
  require calldata.size - 4 >=′ 32
  mem[64] = 160
  if totalSupply <= tokenId:
      revert with 0, 'ERC721A: owner query for nonexistent token'
  if tokenId < 5:
      idx = tokenId
      while idx >= 0:
          mem[0] = idx
          mem[32] = 4
          _20 = mem[64]
          mem[64] = mem[64] + 64
          mem[_20] = stor4[idx].field_0
          mem[_20 + 32] = stor4[idx].field_160
          if stor4[idx].field_0:
              return stor4[idx].field_0
          if not idx:
              revert with 0, 17
          idx = idx - 1
          continue 
  else:
      if 1 > !(tokenId - 5):
          revert with 0, 17
      idx = tokenId
      while idx >= tokenId - 4:
          mem[0] = idx
          mem[32] = 4
          _23 = mem[64]
          mem[64] = mem[64] + 64
          mem[_23] = stor4[idx].field_0
          mem[_23 + 32] = stor4[idx].field_160
          if stor4[idx].field_0:
              return stor4[idx].field_0
          if not idx:
              revert with 0, 17
          idx = idx - 1
          continue 
  revert with 0, 'ERC721A: unable to determine the owner of token'

def getOwnershipData(uint256 tokenId): # not payable
  require calldata.size - 4 >=′ 32
  mem[64] = 224
  if totalSupply <= tokenId:
      revert with 0, 'ERC721A: owner query for nonexistent token'
  if tokenId < 5:
      idx = tokenId
      while idx >= 0:
          mem[0] = idx
          mem[32] = 4
          _23 = mem[64]
          mem[64] = mem[64] + 64
          mem[_23] = stor4[idx].field_0
          mem[_23 + 32] = stor4[idx].field_160
          if stor4[idx].field_0:
              return stor4[idx].field_0, stor4[idx].field_160
          if not idx:
              revert with 0, 17
          idx = idx - 1
          continue 
  else:
      if 1 > !(tokenId - 5):
          revert with 0, 17
      idx = tokenId
      while idx >= tokenId - 4:
          mem[0] = idx
          mem[32] = 4
          _26 = mem[64]
          mem[64] = mem[64] + 64
          mem[_26] = stor4[idx].field_0
          mem[_26 + 32] = stor4[idx].field_160
          if stor4[idx].field_0:
              return stor4[idx].field_0, stor4[idx].field_160
          if not idx:
              revert with 0, 17
          idx = idx - 1
          continue 
  revert with 0, 'ERC721A: unable to determine the owner of token'

def tokenOfOwnerByIndex(address owner, uint256 index) payable: 
  mem[64] = 96
  require not call.value
  require calldata.size - 4 >=′ 64
  require owner == owner
  if not owner:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721A: balance query for the zero address'
  if index >= balanceOf[address(owner)].field_0:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721A: owner index out of bounds'
  idx = 0
  s = 0
  t = 0
  while idx < totalSupply:
      mem[0] = idx
      mem[32] = 4
      _17 = mem[64]
      mem[64] = mem[64] + 64
      mem[_17] = stor4[idx].field_0
      mem[_17 + 32] = stor4[idx].field_160
      if not stor4[idx].field_0:
          if address(s) != owner:
              if idx == -1:
                  revert with 0, 17
              idx = idx + 1
              s = s
              t = t
              continue 
          if t == index:
              return idx
          if t == -1:
              revert with 0, 17
          if idx == -1:
              revert with 0, 17
          idx = idx + 1
          s = s
          t = t + 1
          continue 
      if stor4[idx].field_0 != owner:
          if idx == -1:
              revert with 0, 17
          idx = idx + 1
          s = stor4[idx].field_0
          t = t
          continue 
      if t == index:
          return idx
      if t == -1:
          revert with 0, 17
      if idx == -1:
          revert with 0, 17
      idx = idx + 1
      s = stor4[idx].field_0
      t = t + 1
      continue 
  revert with 0, 'ERC721A: unable to get token of owner by index'

def seedAllowlist(address[] addresses, uint256[] numSlots): # not payable
  require calldata.size - 4 >=′ 64
  require addresses <= LOCK8605463013()
  require addresses + 35 <′ calldata.size
  if addresses.length > LOCK8605463013():
      revert with 0, 65
  if ceil32(32 * addresses.length) + 97 < 96 or ceil32(32 * addresses.length) + 97 > LOCK8605463013():
      revert with 0, 65
  mem[96] = addresses.length
  require addresses + (32 * addresses.length) + 36 <= calldata.size
  s = addresses + 36
  t = 128
  idx = 0
  while idx < addresses.length:
      require cd[s] == address(cd[s])
      mem[t] = cd[s]
      s = s + 32
      t = t + 32
      idx = idx + 1
      continue 
  require numSlots <= LOCK8605463013()
  require numSlots + 35 <′ calldata.size
  if numSlots.length > LOCK8605463013():
      revert with 0, 65
  if ceil32(32 * numSlots.length) + 98 < 97 or ceil32(32 * addresses.length) + ceil32(32 * numSlots.length) + 98 > LOCK8605463013():
      revert with 0, 65
  mem[ceil32(32 * addresses.length) + 97] = numSlots.length
  require numSlots + (32 * numSlots.length) + 36 <= calldata.size
  idx = 0
  s = numSlots + 36
  t = ceil32(32 * addresses.length) + 129
  while idx < numSlots.length:
      mem[t] = cd[s]
      idx = idx + 1
      s = s + 32
      t = t + 32
      continue 
  if owner != caller:
      revert with 0, 32, 32, 0xfe4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65
  if addresses.length != numSlots.length:
      revert with 0, 'addresses does not match numSlots length'
  idx = 0
  while idx < addresses.length:
      if idx >= numSlots.length:
          revert with 0, 50
      if idx >= addresses.length:
          revert with 0, 50
      mem[0] = mem[(32 * idx) + 140 len 20]
      mem[32] = 11
      allowlist[mem[(32 * idx) + 140 len 20]] = mem[(32 * idx) + ceil32(32 * addresses.length) + 129]
      if idx == -1:
          revert with 0, 17
      idx = idx + 1
      continue 

def setBaseURI(string baseURI): # not payable
  require calldata.size - 4 >=′ 32
  require baseURI <= LOCK8605463013()
  require baseURI + 35 <′ calldata.size
  require baseURI.length <= LOCK8605463013()
  require baseURI + baseURI.length + 36 <= calldata.size
  if owner != caller:
      revert with 0, 32, 32, 0xfe4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65
  if bool(stor12.length):
      if bool(stor12.length) == uint255(stor12.length) * 0.5 < 32:
          revert with 0, 34
      if not baseURI.length:
          stor12.length = 0
          idx = 0
          while (uint255(stor12.length) * 0.5) + 31 / 32 > idx:
              stor12[idx].field_0 = 0
              idx = idx + 1
              continue 
      else:
          stor12.length = (2 * baseURI.length) + 1
          s = 0
          idx = baseURI + 36
          while baseURI + baseURI.length + 36 > idx:
              stor12[s].field_0 = cd[idx]
              s = s + 1
              idx = idx + 32
              continue 
          idx = Mask(251, 0, baseURI.length + 31) >> 5
          while (uint255(stor12.length) * 0.5) + 31 / 32 > idx:
              stor12[idx].field_0 = 0
              idx = idx + 1
              continue 
  else:
      if bool(stor12.length) == stor12.length.field_1 < 32:
          revert with 0, 34
      if not baseURI.length:
          stor12.length = 0
          idx = 0
          while stor12.length.field_1 + 31 / 32 > idx:
              stor12[idx].field_0 = 0
              idx = idx + 1
              continue 
      else:
          stor12.length = (2 * baseURI.length) + 1
          s = 0
          idx = baseURI + 36
          while baseURI + baseURI.length + 36 > idx:
              stor12[s].field_0 = cd[idx]
              s = s + 1
              idx = idx + 32
              continue 
          idx = Mask(251, 0, baseURI.length + 31) >> 5
          while stor12.length.field_1 + 31 / 32 > idx:
              stor12[idx].field_0 = 0
              idx = idx + 1
              continue 

def approve(address spender, uint256 amount): # not payable
  require calldata.size - 4 >=′ 64
  require spender == spender
  mem[64] = 160
  if totalSupply <= amount:
      revert with 0, 'ERC721A: owner query for nonexistent token'
  if amount < 5:
      idx = amount
      while idx >= 0:
          mem[0] = idx
          mem[32] = 4
          _36 = mem[64]
          mem[64] = mem[64] + 64
          mem[_36] = stor4[idx].field_0
          mem[_36 + 32] = stor4[idx].field_160
          if not stor4[idx].field_0:
              if not idx:
                  revert with 0, 17
              idx = idx - 1
              continue 
          if spender == stor4[idx].field_0:
              revert with 0, 'ERC721A: approval to current owner'
          if stor4[idx].field_0 != caller:
              if not stor7[stor4[idx].field_0][caller]:
                  revert with 0, 'ERC721A: approve caller is not owner nor approved for all'
          approved[amount] = spender
          log Approval(
                address owner=stor4[idx].field_0,
                address spender=spender,
                uint256 value=amount)
          stop
  else:
      if 1 > !(amount - 5):
          revert with 0, 17
      idx = amount
      while idx >= amount - 4:
          mem[0] = idx
          mem[32] = 4
          _39 = mem[64]
          mem[64] = mem[64] + 64
          mem[_39] = stor4[idx].field_0
          mem[_39 + 32] = stor4[idx].field_160
          if not stor4[idx].field_0:
              if not idx:
                  revert with 0, 17
              idx = idx - 1
              continue 
          if spender == stor4[idx].field_0:
              revert with 0, 'ERC721A: approval to current owner'
          if stor4[idx].field_0 != caller:
              if not stor7[stor4[idx].field_0][caller]:
                  revert with 0, 'ERC721A: approve caller is not owner nor approved for all'
          approved[amount] = spender
          log Approval(
                address owner=stor4[idx].field_0,
                address spender=spender,
                uint256 value=amount)
          stop
  revert with 0, 'ERC721A: unable to determine the owner of token'

def allowlistMint() payable: 
  if tx.origin != caller:
      revert with 0, 'The caller is another contract'
  if not uint64(stor10.field_64):
      revert with 0, 'allowlist sale has not begun yet'
  if not allowlist[caller]:
      revert with 0, 'not eligible for allowlist mint'
  if 1 > !totalSupply:
      revert with 0, 17
  if totalSupply + 1 > 10000:
      revert with 0, 'reached max supply'
  if not allowlist[caller]:
      revert with 0, 17
  allowlist[caller]--
  mem[96] = 0
  if not caller:
      revert with 0, 'ERC721A: mint to the zero address'
  if totalSupply > totalSupply:
      revert with 0, 'ERC721A: token already minted'
  mem[128] = balanceOf[caller].field_0
  mem[160] = balanceOf[caller].field_128
  if balanceOf[caller].field_0 > LOCK8605463013():
      revert with 0, 17
  mem[192] = uint128(balanceOf[caller].field_0 + 1)
  if balanceOf[caller].field_128 > LOCK8605463013():
      revert with 0, 17
  mem[224] = uint128(balanceOf[caller].field_128 + 1)
  balanceOf[caller].field_0 = uint128(balanceOf[caller].field_0 + 1)
  balanceOf[caller].field_128 = uint128(balanceOf[caller].field_128 + 1)
  mem[64] = 320
  mem[256] = caller
  mem[288] = uint64(block.timestamp)
  mem[0] = totalSupply
  mem[32] = 4
  stor4[stor1].field_0 = caller
  stor4[stor1].field_160 = uint64(block.timestamp)
  idx = 0
  s = totalSupply
  while idx < 1:
      log Transfer(
            address from=0,
            address to=caller,
            uint256 value=s)
      if ext_code.size(caller):
          mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
          mem[mem[64] + 4] = caller
          mem[mem[64] + 36] = 0
          mem[mem[64] + 68] = s
          mem[mem[64] + 100] = 128
          mem[mem[64] + 132] = mem[96]
          t = 0
          while t < mem[96]:
              mem[t + mem[64] + 164] = mem[t + 128]
              t = t + 32
              continue 
          if ceil32(mem[96]) <= mem[96]:
              require ext_code.size(caller)
              call caller.onERC721Received(address , address , uint256 , bytes ) with:
                   gas gas_remaining wei
                  args caller, 0, s, 128, mem[96], mem[mem[64] + 164 len ceil32(mem[96])]
              mem[mem[64]] = ext_call.return_data[0]
              if not ext_call.success:
                  if not return_data.size:
                      if not mem[96]:
                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                      revert with memory
                        from 128
                         len mem[96]
                  if not return_data.size:
                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                  revert with ext_call.return_data[0 len return_data.size]
              _98 = mem[64]
              mem[64] = mem[64] + ceil32(return_data.size)
              require return_data.size >=′ 32
              require mem[_98] == Mask(32, 224, mem[_98])
              if Mask(32, 224, mem[_98]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
          else:
              mem[mem[96] + mem[64] + 164] = 0
              require ext_code.size(caller)
              call caller.onERC721Received(address , address , uint256 , bytes ) with:
                   gas gas_remaining wei
                  args caller, 0, s, 128, mem[96], mem[mem[64] + 164 len ceil32(mem[96])]
              mem[mem[64]] = ext_call.return_data[0]
              if not ext_call.success:
                  if not return_data.size:
                      if not mem[96]:
                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                      revert with memory
                        from 128
                         len mem[96]
                  if not return_data.size:
                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                  revert with ext_call.return_data[0 len return_data.size]
              _99 = mem[64]
              mem[64] = mem[64] + ceil32(return_data.size)
              require return_data.size >=′ 32
              require mem[_99] == Mask(32, 224, mem[_99])
              if Mask(32, 224, mem[_99]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
      if s == -1:
          revert with 0, 17
      if idx == -1:
          revert with 0, 17
      idx = idx + 1
      s = s + 1
      continue 
  totalSupply = s
  if call.value < uint64(stor10.field_64):
      revert with 0, 'Need to send more ETH.'
  if call.value > uint64(stor10.field_64):
      if call.value < uint64(stor10.field_64):
          revert with 0, 17
      call caller with:
         value call.value - uint64(stor10.field_64) wei
           gas 2300 * is_zero(value) wei
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]

def name(): # not payable
  if bool(stor2.length):
      if bool(stor2.length) == uint255(stor2.length) * 0.5 < 32:
          revert with 0, 34
      if bool(stor2.length):
          if bool(stor2.length) == uint255(stor2.length) * 0.5 < 32:
              revert with 0, 34
          if Mask(256, -1, stor2.length):
              if 31 < uint255(stor2.length) * 0.5:
                  mem[128] = uint256(stor2.field_0)
                  idx = 128
                  s = 0
                  while (uint255(stor2.length) * 0.5) + 96 > idx:
                      mem[idx + 32] = stor2[s].field_256
                      idx = idx + 32
                      s = s + 1
                      continue 
                  return Array(len=2 * Mask(256, -1, stor2.length), data=mem[128 len ceil32(uint255(stor2.length) * 0.5)])
              mem[128] = 256 * stor2.length.field_8
      else:
          if bool(stor2.length) == stor2.length.field_1 < 32:
              revert with 0, 34
          if stor2.length.field_1:
              if 31 < stor2.length.field_1:
                  mem[128] = uint256(stor2.field_0)
                  idx = 128
                  s = 0
                  while stor2.length.field_1 + 96 > idx:
                      mem[idx + 32] = stor2[s].field_256
                      idx = idx + 32
                      s = s + 1
                      continue 
                  return Array(len=2 * Mask(256, -1, stor2.length), data=mem[128 len ceil32(uint255(stor2.length) * 0.5)])
              mem[128] = 256 * stor2.length.field_8
      mem[ceil32(uint255(stor2.length) * 0.5) + 192 len ceil32(uint255(stor2.length) * 0.5)] = mem[128 len ceil32(uint255(stor2.length) * 0.5)]
      if ceil32(uint255(stor2.length) * 0.5) > uint255(stor2.length) * 0.5:
          mem[(uint255(stor2.length) * 0.5) + ceil32(uint255(stor2.length) * 0.5) + 192] = 0
      return Array(len=2 * Mask(256, -1, stor2.length), data=mem[128 len ceil32(uint255(stor2.length) * 0.5)], mem[(2 * ceil32(uint255(stor2.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor2.length) * 0.5)]), 
  if bool(stor2.length) == stor2.length.field_1 < 32:
      revert with 0, 34
  if bool(stor2.length):
      if bool(stor2.length) == uint255(stor2.length) * 0.5 < 32:
          revert with 0, 34
      if Mask(256, -1, stor2.length):
          if 31 < uint255(stor2.length) * 0.5:
              mem[128] = uint256(stor2.field_0)
              idx = 128
              s = 0
              while (uint255(stor2.length) * 0.5) + 96 > idx:
                  mem[idx + 32] = stor2[s].field_256
                  idx = idx + 32
                  s = s + 1
                  continue 
              return Array(len=stor2.length % 128, data=mem[128 len ceil32(stor2.length.field_1)])
          mem[128] = 256 * stor2.length.field_8
  else:
      if bool(stor2.length) == stor2.length.field_1 < 32:
          revert with 0, 34
      if stor2.length.field_1:
          if 31 < stor2.length.field_1:
              mem[128] = uint256(stor2.field_0)
              idx = 128
              s = 0
              while stor2.length.field_1 + 96 > idx:
                  mem[idx + 32] = stor2[s].field_256
                  idx = idx + 32
                  s = s + 1
                  continue 
              return Array(len=stor2.length % 128, data=mem[128 len ceil32(stor2.length.field_1)])
          mem[128] = 256 * stor2.length.field_8
  mem[ceil32(stor2.length.field_1) + 192 len ceil32(stor2.length.field_1)] = mem[128 len ceil32(stor2.length.field_1)]
  if ceil32(stor2.length.field_1) > stor2.length.field_1:
      mem[stor2.length.field_1 + ceil32(stor2.length.field_1) + 192] = 0
  return Array(len=stor2.length % 128, data=mem[128 len ceil32(stor2.length.field_1)], mem[(2 * ceil32(stor2.length.field_1)) + 192 len 2 * ceil32(stor2.length.field_1)]), 

def symbol(): # not payable
  if bool(stor3.length):
      if bool(stor3.length) == uint255(stor3.length) * 0.5 < 32:
          revert with 0, 34
      if bool(stor3.length):
          if bool(stor3.length) == uint255(stor3.length) * 0.5 < 32:
              revert with 0, 34
          if Mask(256, -1, stor3.length):
              if 31 < uint255(stor3.length) * 0.5:
                  mem[128] = uint256(stor3.field_0)
                  idx = 128
                  s = 0
                  while (uint255(stor3.length) * 0.5) + 96 > idx:
                      mem[idx + 32] = stor3[s].field_256
                      idx = idx + 32
                      s = s + 1
                      continue 
                  return Array(len=2 * Mask(256, -1, stor3.length), data=mem[128 len ceil32(uint255(stor3.length) * 0.5)])
              mem[128] = 256 * stor3.length.field_8
      else:
          if bool(stor3.length) == stor3.length.field_1 < 32:
              revert with 0, 34
          if stor3.length.field_1:
              if 31 < stor3.length.field_1:
                  mem[128] = uint256(stor3.field_0)
                  idx = 128
                  s = 0
                  while stor3.length.field_1 + 96 > idx:
                      mem[idx + 32] = stor3[s].field_256
                      idx = idx + 32
                      s = s + 1
                      continue 
                  return Array(len=2 * Mask(256, -1, stor3.length), data=mem[128 len ceil32(uint255(stor3.length) * 0.5)])
              mem[128] = 256 * stor3.length.field_8
      mem[ceil32(uint255(stor3.length) * 0.5) + 192 len ceil32(uint255(stor3.length) * 0.5)] = mem[128 len ceil32(uint255(stor3.length) * 0.5)]
      if ceil32(uint255(stor3.length) * 0.5) > uint255(stor3.length) * 0.5:
          mem[(uint255(stor3.length) * 0.5) + ceil32(uint255(stor3.length) * 0.5) + 192] = 0
      return Array(len=2 * Mask(256, -1, stor3.length), data=mem[128 len ceil32(uint255(stor3.length) * 0.5)], mem[(2 * ceil32(uint255(stor3.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor3.length) * 0.5)]), 
  if bool(stor3.length) == stor3.length.field_1 < 32:
      revert with 0, 34
  if bool(stor3.length):
      if bool(stor3.length) == uint255(stor3.length) * 0.5 < 32:
          revert with 0, 34
      if Mask(256, -1, stor3.length):
          if 31 < uint255(stor3.length) * 0.5:
              mem[128] = uint256(stor3.field_0)
              idx = 128
              s = 0
              while (uint255(stor3.length) * 0.5) + 96 > idx:
                  mem[idx + 32] = stor3[s].field_256
                  idx = idx + 32
                  s = s + 1
                  continue 
              return Array(len=stor3.length % 128, data=mem[128 len ceil32(stor3.length.field_1)])
          mem[128] = 256 * stor3.length.field_8
  else:
      if bool(stor3.length) == stor3.length.field_1 < 32:
          revert with 0, 34
      if stor3.length.field_1:
          if 31 < stor3.length.field_1:
              mem[128] = uint256(stor3.field_0)
              idx = 128
              s = 0
              while stor3.length.field_1 + 96 > idx:
                  mem[idx + 32] = stor3[s].field_256
                  idx = idx + 32
                  s = s + 1
                  continue 
              return Array(len=stor3.length % 128, data=mem[128 len ceil32(stor3.length.field_1)])
          mem[128] = 256 * stor3.length.field_8
  mem[ceil32(stor3.length.field_1) + 192 len ceil32(stor3.length.field_1)] = mem[128 len ceil32(stor3.length.field_1)]
  if ceil32(stor3.length.field_1) > stor3.length.field_1:
      mem[stor3.length.field_1 + ceil32(stor3.length.field_1) + 192] = 0
  return Array(len=stor3.length % 128, data=mem[128 len ceil32(stor3.length.field_1)], mem[(2 * ceil32(stor3.length.field_1)) + 192 len 2 * ceil32(stor3.length.field_1)]), 

def transferFrom(address sender, address recipient, uint256 amount): # not payable
  require calldata.size - 4 >=′ 96
  require sender == sender
  require recipient == recipient
  mem[64] = 160
  if totalSupply <= amount:
      revert with 0, 'ERC721A: owner query for nonexistent token'
  if amount < 5:
      idx = amount
      while idx >= 0:
          mem[0] = idx
          mem[32] = 4
          _194 = mem[64]
          mem[64] = mem[64] + 64
          mem[_194] = stor4[idx].field_0
          mem[_194 + 32] = stor4[idx].field_160
          if not stor4[idx].field_0:
              if not idx:
                  revert with 0, 17
              idx = idx - 1
              continue 
          if stor4[idx].field_0 != caller:
              if totalSupply <= amount:
                  revert with 0, 'ERC721A: approved query for nonexistent token'
              if approved[amount] != caller:
                  if not stor7[stor4[idx].field_0][caller]:
                      revert with 0, 'ERC721A: transfer caller is not owner nor approved'
          if stor4[idx].field_0 != sender:
              revert with 0, 'ERC721A: transfer from incorrect owner'
          if not recipient:
              revert with 0, 'ERC721A: transfer to the zero address'
          approved[amount] = 0
          log Approval(
                address owner=stor4[idx].field_0,
                address spender=0,
                uint256 value=amount)
          if balanceOf[address(sender)].field_0 < 1:
              revert with 0, 17
          balanceOf[address(sender)].field_0 = uint128(balanceOf[address(sender)].field_0 - 1)
          if balanceOf[address(recipient)].field_0 > LOCK8605463013():
              revert with 0, 17
          balanceOf[address(recipient)].field_0 = uint128(balanceOf[address(recipient)].field_0 + 1)
          stor4[amount].field_0 = recipient
          stor4[amount].field_160 = uint64(block.timestamp)
          if 1 > !amount:
              revert with 0, 17
          if not stor4[amount + 1].field_0:
              if totalSupply > amount + 1:
                  stor4[amount + 1].field_0 = stor4[idx].field_0
                  stor4[amount + 1].field_160 = stor4[idx].field_160
          log Transfer(
                address from=sender,
                address to=recipient,
                uint256 value=amount)
          stop
  else:
      if 1 > !(amount - 5):
          revert with 0, 17
      idx = amount
      while idx >= amount - 4:
          mem[0] = idx
          mem[32] = 4
          _197 = mem[64]
          mem[64] = mem[64] + 64
          mem[_197] = stor4[idx].field_0
          mem[_197 + 32] = stor4[idx].field_160
          if not stor4[idx].field_0:
              if not idx:
                  revert with 0, 17
              idx = idx - 1
              continue 
          if stor4[idx].field_0 != caller:
              if totalSupply <= amount:
                  revert with 0, 'ERC721A: approved query for nonexistent token'
              if approved[amount] != caller:
                  if not stor7[stor4[idx].field_0][caller]:
                      revert with 0, 'ERC721A: transfer caller is not owner nor approved'
          if stor4[idx].field_0 != sender:
              revert with 0, 'ERC721A: transfer from incorrect owner'
          if not recipient:
              revert with 0, 'ERC721A: transfer to the zero address'
          approved[amount] = 0
          log Approval(
                address owner=stor4[idx].field_0,
                address spender=0,
                uint256 value=amount)
          if balanceOf[address(sender)].field_0 < 1:
              revert with 0, 17
          balanceOf[address(sender)].field_0 = uint128(balanceOf[address(sender)].field_0 - 1)
          if balanceOf[address(recipient)].field_0 > LOCK8605463013():
              revert with 0, 17
          balanceOf[address(recipient)].field_0 = uint128(balanceOf[address(recipient)].field_0 + 1)
          stor4[amount].field_0 = recipient
          stor4[amount].field_160 = uint64(block.timestamp)
          if 1 > !amount:
              revert with 0, 17
          if not stor4[amount + 1].field_0:
              if totalSupply > amount + 1:
                  stor4[amount + 1].field_0 = stor4[idx].field_0
                  stor4[amount + 1].field_160 = stor4[idx].field_160
          log Transfer(
                address from=sender,
                address to=recipient,
                uint256 value=amount)
          stop
  revert with 0, 'ERC721A: unable to determine the owner of token'

def devMint(uint256 quantity) payable: 
  mem[64] = 96
  require not call.value
  require calldata.size - 4 >=′ 32
  if owner != caller:
      revert with 0, 32, 32, 0xfe4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65
  if totalSupply > !quantity:
      revert with 0, 17
  if totalSupply + quantity > 200:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'too many already minted before dev mint'
  if quantity % 5:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'can only mint a multiple of the maxBatchSize'
  idx = 0
  while idx < quantity / 5:
      _90 = mem[64]
      mem[64] = mem[64] + 32
      mem[_90] = 0
      if not caller:
          revert with 0, 'ERC721A: mint to the zero address'
      if totalSupply > totalSupply:
          revert with 0, 'ERC721A: token already minted'
      mem[0] = caller
      mem[32] = 5
      _95 = mem[64]
      mem[64] = mem[64] + 64
      mem[_95] = balanceOf[caller].field_0
      mem[_95 + 32] = balanceOf[caller].field_128
      _96 = mem[64]
      mem[64] = mem[64] + 64
      if balanceOf[caller].field_0 > LOCK8605463013():
          revert with 0, 17
      mem[_96] = uint128(balanceOf[caller].field_0 + 5)
      if balanceOf[caller].field_128 > LOCK8605463013():
          revert with 0, 17
      mem[_96 + 32] = uint128(balanceOf[caller].field_128 + 5)
      mem[0] = caller
      mem[32] = 5
      balanceOf[caller].field_0 = uint128(balanceOf[caller].field_0 + 5)
      balanceOf[caller].field_128 = uint128(balanceOf[caller].field_128 + 5)
      _103 = mem[64]
      mem[64] = mem[64] + 64
      mem[_103] = caller
      mem[_103 + 32] = uint64(block.timestamp)
      mem[0] = totalSupply
      mem[32] = 4
      stor4[stor1].field_0 = caller
      stor4[stor1].field_160 = uint64(block.timestamp)
      s = 0
      t = totalSupply
      while s < 5:
          log Transfer(
                address from=0,
                address to=caller,
                uint256 value=t)
          if ext_code.size(caller):
              mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
              mem[mem[64] + 4] = caller
              mem[mem[64] + 36] = 0
              mem[mem[64] + 68] = t
              mem[mem[64] + 100] = 128
              _141 = mem[_90]
              mem[mem[64] + 132] = mem[_90]
              idx = 0
              while idx < _141:
                  mem[idx + mem[64] + 164] = mem[idx + _90 + 32]
                  idx = idx + 32
                  continue 
              if ceil32(_141) <= _141:
                  require ext_code.size(caller)
                  call caller.onERC721Received(address , address , uint256 , bytes ) with:
                       gas gas_remaining wei
                      args caller, 0, t, 128, mem[mem[64] + 132 len ceil32(_141) + 32]
                  mem[mem[64]] = ext_call.return_data[0]
                  if not ext_call.success:
                      if not return_data.size:
                          if not mem[96]:
                              revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                          revert with memory
                            from 128
                             len mem[96]
                      if not return_data.size:
                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                      revert with ext_call.return_data[0 len return_data.size]
                  _174 = mem[64]
                  mem[64] = mem[64] + ceil32(return_data.size)
                  require return_data.size >=′ 32
                  require mem[_174] == Mask(32, 224, mem[_174])
                  if Mask(32, 224, mem[_174]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
              else:
                  mem[_141 + mem[64] + 164] = 0
                  require ext_code.size(caller)
                  call caller.onERC721Received(address , address , uint256 , bytes ) with:
                       gas gas_remaining wei
                      args caller, 0, t, 128, mem[mem[64] + 132 len ceil32(_141) + 32]
                  mem[mem[64]] = ext_call.return_data[0]
                  if not ext_call.success:
                      if not return_data.size:
                          if not mem[96]:
                              revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                          revert with memory
                            from 128
                             len mem[96]
                      if not return_data.size:
                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                      revert with ext_call.return_data[0 len return_data.size]
                  _175 = mem[64]
                  mem[64] = mem[64] + ceil32(return_data.size)
                  require return_data.size >=′ 32
                  require mem[_175] == Mask(32, 224, mem[_175])
                  if Mask(32, 224, mem[_175]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
          if t == -1:
              revert with 0, 17
          if s == -1:
              revert with 0, 17
          s = s + 1
          t = t + 1
          continue 
      totalSupply = t
      if idx == -1:
          revert with 0, 17
      idx = idx + 1
      continue 

def publicSaleMint(uint256 quantity, uint256 callerPublicSaleKey) payable: 
  require calldata.size - 4 >=′ 64
  if tx.origin != caller:
      revert with 0, 'The caller is another contract'
  mem[96] = uint32(stor10.field_0)
  mem[128] = uint32(stor10.field_32)
  mem[160] = uint64(stor10.field_64)
  mem[192] = uint64(stor10.field_128)
  mem[224] = uint32(stor10.field_192)
  if uint32(stor10.field_192) != callerPublicSaleKey:
      revert with 0, 'called with incorrect public sale key'
  if not uint64(stor10.field_128):
      revert with 0, 'public sale has not begun yet'
  if not uint32(stor10.field_192):
      revert with 0, 'public sale has not begun yet'
  if block.timestamp < uint32(stor10.field_32):
      revert with 0, 'public sale has not begun yet'
  if totalSupply > !quantity:
      revert with 0, 17
  if totalSupply + quantity > 10000:
      revert with 0, 'reached max supply'
  if not caller:
      revert with 0, 'ERC721A: number minted query for the zero address'
  if balanceOf[caller].field_128 > !quantity:
      revert with 0, 17
  if balanceOf[caller].field_128 + quantity > 5:
      revert with 0, 'can not mint this many'
  mem[256] = 0
  if not caller:
      revert with 0, 'ERC721A: mint to the zero address'
  if totalSupply > totalSupply:
      revert with 0, 'ERC721A: token already minted'
  if quantity > 5:
      revert with 0, 'ERC721A: quantity to mint too high'
  mem[288] = balanceOf[caller].field_0
  mem[320] = balanceOf[caller].field_128
  if balanceOf[caller].field_0 > -uint128(quantity) + LOCK8605463013():
      revert with 0, 17
  mem[352] = uint128(uint128(quantity) + balanceOf[caller].field_0)
  if balanceOf[caller].field_128 > -uint128(quantity) + LOCK8605463013():
      revert with 0, 17
  mem[384] = uint128(uint128(quantity) + balanceOf[caller].field_128)
  balanceOf[caller].field_0 = uint128(uint128(quantity) + balanceOf[caller].field_0)
  balanceOf[caller].field_128 = uint128(uint128(quantity) + balanceOf[caller].field_128)
  mem[64] = 480
  mem[416] = caller
  mem[448] = uint64(block.timestamp)
  mem[0] = totalSupply
  mem[32] = 4
  stor4[stor1].field_0 = caller
  stor4[stor1].field_160 = uint64(block.timestamp)
  idx = 0
  s = totalSupply
  while idx < quantity:
      log Transfer(
            address from=0,
            address to=caller,
            uint256 value=s)
      if ext_code.size(caller):
          mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
          mem[mem[64] + 4] = caller
          mem[mem[64] + 36] = 0
          mem[mem[64] + 68] = s
          mem[mem[64] + 100] = 128
          _75 = mem[256]
          mem[mem[64] + 132] = mem[256]
          t = 0
          while t < _75:
              mem[t + mem[64] + 164] = mem[t + 288]
              t = t + 32
              continue 
          if ceil32(_75) <= _75:
              require ext_code.size(caller)
              call caller.onERC721Received(address , address , uint256 , bytes ) with:
                   gas gas_remaining wei
                  args caller, 0, s, 128, mem[mem[64] + 132 len ceil32(_75) + 32]
              mem[mem[64]] = ext_call.return_data[0]
              if not ext_call.success:
                  if not return_data.size:
                      if not mem[96]:
                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                      revert with memory
                        from 128
                         len mem[96]
                  if not return_data.size:
                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                  revert with ext_call.return_data[0 len return_data.size]
              _111 = mem[64]
              mem[64] = mem[64] + ceil32(return_data.size)
              require return_data.size >=′ 32
              require mem[_111] == Mask(32, 224, mem[_111])
              if Mask(32, 224, mem[_111]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
          else:
              mem[_75 + mem[64] + 164] = 0
              require ext_code.size(caller)
              call caller.onERC721Received(address , address , uint256 , bytes ) with:
                   gas gas_remaining wei
                  args caller, 0, s, 128, mem[mem[64] + 132 len ceil32(_75) + 32]
              mem[mem[64]] = ext_call.return_data[0]
              if not ext_call.success:
                  if not return_data.size:
                      if not mem[96]:
                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                      revert with memory
                        from 128
                         len mem[96]
                  if not return_data.size:
                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                  revert with ext_call.return_data[0 len return_data.size]
              _112 = mem[64]
              mem[64] = mem[64] + ceil32(return_data.size)
              require return_data.size >=′ 32
              require mem[_112] == Mask(32, 224, mem[_112])
              if Mask(32, 224, mem[_112]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
      if s == -1:
          revert with 0, 17
      if idx == -1:
          revert with 0, 17
      idx = idx + 1
      s = s + 1
      continue 
  totalSupply = s
  if uint64(stor10.field_128) and quantity > -1 / uint64(stor10.field_128):
      revert with 0, 17
  if call.value < uint64(stor10.field_128) * quantity:
      revert with 0, 'Need to send more ETH.'
  if call.value > uint64(stor10.field_128) * quantity:
      if call.value < uint64(stor10.field_128) * quantity:
          revert with 0, 17
      call caller with:
         value call.value - (uint64(stor10.field_128) * quantity) wei
           gas 2300 * is_zero(value) wei
      if not ext_call.success:
          revert with ext_call.return_data[0 len return_data.size]

def tokenURI(uint256 tokenId): # not payable
  require calldata.size - 4 >=′ 32
  if totalSupply <= tokenId:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721Metadata: URI query for nonexistent token'
  if bool(stor12.length):
      if bool(stor12.length) == uint255(stor12.length) * 0.5 < 32:
          revert with 0, 34
      if bool(stor12.length):
          if bool(stor12.length) == uint255(stor12.length) * 0.5 < 32:
              revert with 0, 34
          if not Mask(256, -1, stor12.length):
              if uint255(stor12.length) * 0.5 <= 0:
                  return ''
              if tokenId:
                  s = 0
                  idx = tokenId
                  while idx:
                      if s == -1:
                          revert with 0, 17
                      s = s + 1
                      idx = idx / 10
                      continue 
                  if s > LOCK8605463013():
                      revert with 0, 65
          else:
              if 31 < uint255(stor12.length) * 0.5:
                  idx = 128
                  s = 0
                  while (uint255(stor12.length) * 0.5) + 96 > idx:
                      mem[idx + 32] = stor12[s].field_256
                      idx = idx + 32
                      s = s + 1
                      continue 
                  if uint255(stor12.length) * 0.5 > 0:
              else:
                  if uint255(stor12.length) * 0.5 <= 0:
                      return ''
                  if tokenId:
                      s = 0
                      idx = tokenId
                      while idx:
                          if s == -1:
                              revert with 0, 17
                          s = s + 1
                          idx = idx / 10
                          continue 
                      if s > LOCK8605463013():
                          revert with 0, 65
      else:
          if bool(stor12.length) == stor12.length.field_1 < 32:
              revert with 0, 34
          if not stor12.length.field_1:
              if uint255(stor12.length) * 0.5 <= 0:
                  return ''
              if tokenId:
                  s = 0
                  idx = tokenId
                  while idx:
                      if s == -1:
                          revert with 0, 17
                      s = s + 1
                      idx = idx / 10
                      continue 
                  if s > LOCK8605463013():
                      revert with 0, 65
          else:
              if 31 < stor12.length.field_1:
                  idx = 128
                  s = 0
                  while stor12.length.field_1 + 96 > idx:
                      mem[idx + 32] = stor12[s].field_256
                      idx = idx + 32
                      s = s + 1
                      continue 
                  if uint255(stor12.length) * 0.5 > 0:
              else:
                  if uint255(stor12.length) * 0.5 <= 0:
                      return ''
                  if tokenId:
                      s = 0
                      idx = tokenId
                      while idx:
                          if s == -1:
                              revert with 0, 17
                          s = s + 1
                          idx = idx / 10
                          continue 
                      if s > LOCK8605463013():
                          revert with 0, 65
  else:
      if bool(stor12.length) == stor12.length.field_1 < 32:
          revert with 0, 34
      if bool(stor12.length):
          if bool(stor12.length) == uint255(stor12.length) * 0.5 < 32:
              revert with 0, 34
          if not Mask(256, -1, stor12.length):
              if stor12.length.field_1 <= 0:
                  return ''
              if tokenId:
                  s = 0
                  idx = tokenId
                  while idx:
                      if s == -1:
                          revert with 0, 17
                      s = s + 1
                      idx = idx / 10
                      continue 
                  if s > LOCK8605463013():
                      revert with 0, 65
          else:
              if 31 < uint255(stor12.length) * 0.5:
                  idx = 128
                  s = 0
                  while (uint255(stor12.length) * 0.5) + 96 > idx:
                      mem[idx + 32] = stor12[s].field_256
                      idx = idx + 32
                      s = s + 1
                      continue 
                  if stor12.length.field_1 > 0:
              else:
                  if stor12.length.field_1 <= 0:
                      return ''
                  if tokenId:
                      s = 0
                      idx = tokenId
                      while idx:
                          if s == -1:
                              revert with 0, 17
                          s = s + 1
                          idx = idx / 10
                          continue 
                      if s > LOCK8605463013():
                          revert with 0, 65
      else:
          if bool(stor12.length) == stor12.length.field_1 < 32:
              revert with 0, 34
          if not stor12.length.field_1:
              if stor12.length.field_1 <= 0:
                  return ''
              if tokenId:
                  s = 0
                  idx = tokenId
                  while idx:
                      if s == -1:
                          revert with 0, 17
                      s = s + 1
                      idx = idx / 10
                      continue 
                  if s > LOCK8605463013():
                      revert with 0, 65
          else:
              if 31 < stor12.length.field_1:
                  idx = 128
                  s = 0
                  while stor12.length.field_1 + 96 > idx:
                      mem[idx + 32] = stor12[s].field_256
                      idx = idx + 32
                      s = s + 1
                      continue 
                  if stor12.length.field_1 > 0:
              else:
                  if stor12.length.field_1 <= 0:
                      return ''
                  if tokenId:
                      s = 0
                      idx = tokenId
                      while idx:
                          if s == -1:
                              revert with 0, 17
                          s = s + 1
                          idx = idx / 10
                          continue 
                      if s > LOCK8605463013():
                          revert with 0, 65
  ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)

def setOwnersExplicit(uint256 quantity) payable: 
  mem[64] = 96
  require not call.value
  require calldata.size - 4 >=′ 32
  if owner != caller:
      revert with 0, 32, 32, 0xfe4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65
  if stor9 == 2:
      revert with 0, 'ReentrancyGuard: reentrant call'
  stor9 = 2
  if not quantity:
      revert with 0, 'quantity must be nonzero'
  if nextOwnerToExplicitlySet > !quantity:
      revert with 0, 17
  if nextOwnerToExplicitlySet + quantity < 1:
      revert with 0, 17
  if nextOwnerToExplicitlySet + quantity - 1 > 9999:
      if totalSupply <= 9999:
          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'not enough minted yet for this cleanup'
      idx = nextOwnerToExplicitlySet
      while idx <= 9999:
          mem[0] = idx
          mem[32] = 4
          if stor4[idx].field_0:
              if idx == -1:
                  revert with 0, 17
              idx = idx + 1
              continue 
          mem[64] = 160
          if totalSupply <= idx:
              revert with 0, 'ERC721A: owner query for nonexistent token'
          if idx < 5:
              s = idx
              while s >= 0:
                  mem[0] = s
                  mem[32] = 4
                  _117 = mem[64]
                  mem[64] = mem[64] + 64
                  mem[_117] = stor4[s].field_0
                  mem[_117 + 32] = stor4[s].field_160
                  if not stor4[s].field_0:
                      if not s:
                          revert with 0, 17
                      s = s - 1
                      continue 
                  _137 = mem[64]
                  mem[64] = mem[64] + 64
                  mem[_137] = stor4[s].field_0
                  mem[_137 + 32] = stor4[s].field_160
                  mem[0] = idx
                  mem[32] = 4
                  stor4[idx].field_0 = stor4[s].field_0
                  stor4[idx].field_160 = stor4[s].field_160
                  if idx == -1:
                      revert with 0, 17
                  idx = idx + 1
                  continue 
          else:
              if 1 > !(idx - 5):
                  revert with 0, 17
              s = idx
              while s >= idx - 4:
                  mem[0] = s
                  mem[32] = 4
                  _120 = mem[64]
                  mem[64] = mem[64] + 64
                  mem[_120] = stor4[s].field_0
                  mem[_120 + 32] = stor4[s].field_160
                  if not stor4[s].field_0:
                      if not s:
                          revert with 0, 17
                      s = s - 1
                      continue 
                  _143 = mem[64]
                  mem[64] = mem[64] + 64
                  mem[_143] = stor4[s].field_0
                  mem[_143 + 32] = stor4[s].field_160
                  mem[0] = idx
                  mem[32] = 4
                  stor4[idx].field_0 = stor4[s].field_0
                  stor4[idx].field_160 = stor4[s].field_160
                  if idx == -1:
                      revert with 0, 17
                  idx = idx + 1
                  continue 
          revert with 0, 'ERC721A: unable to determine the owner of token'
      nextOwnerToExplicitlySet = 10000
  else:
      if totalSupply <= nextOwnerToExplicitlySet + quantity - 1:
          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'not enough minted yet for this cleanup'
      idx = nextOwnerToExplicitlySet
      while idx <= nextOwnerToExplicitlySet + quantity - 1:
          mem[0] = idx
          mem[32] = 4
          if stor4[idx].field_0:
              if idx == -1:
                  revert with 0, 17
              idx = idx + 1
              continue 
          mem[64] = 160
          if totalSupply <= idx:
              revert with 0, 'ERC721A: owner query for nonexistent token'
          if idx < 5:
              s = idx
              while s >= 0:
                  mem[0] = s
                  mem[32] = 4
                  _111 = mem[64]
                  mem[64] = mem[64] + 64
                  mem[_111] = stor4[s].field_0
                  mem[_111 + 32] = stor4[s].field_160
                  if not stor4[s].field_0:
                      if not s:
                          revert with 0, 17
                      s = s - 1
                      continue 
                  _125 = mem[64]
                  mem[64] = mem[64] + 64
                  mem[_125] = stor4[s].field_0
                  mem[_125 + 32] = stor4[s].field_160
                  mem[0] = idx
                  mem[32] = 4
                  stor4[idx].field_0 = stor4[s].field_0
                  stor4[idx].field_160 = stor4[s].field_160
                  if idx == -1:
                      revert with 0, 17
                  idx = idx + 1
                  continue 
          else:
              if 1 > !(idx - 5):
                  revert with 0, 17
              s = idx
              while s >= idx - 4:
                  mem[0] = s
                  mem[32] = 4
                  _114 = mem[64]
                  mem[64] = mem[64] + 64
                  mem[_114] = stor4[s].field_0
                  mem[_114 + 32] = stor4[s].field_160
                  if not stor4[s].field_0:
                      if not s:
                          revert with 0, 17
                      s = s - 1
                      continue 
                  _131 = mem[64]
                  mem[64] = mem[64] + 64
                  mem[_131] = stor4[s].field_0
                  mem[_131 + 32] = stor4[s].field_160
                  mem[0] = idx
                  mem[32] = 4
                  stor4[idx].field_0 = stor4[s].field_0
                  stor4[idx].field_160 = stor4[s].field_160
                  if idx == -1:
                      revert with 0, 17
                  idx = idx + 1
                  continue 
          revert with 0, 'ERC721A: unable to determine the owner of token'
      if 1 > !(nextOwnerToExplicitlySet + quantity - 1):
          revert with 0, 17
      nextOwnerToExplicitlySet += quantity
  stor9 = 1

def auctionMint(uint256 quantity) payable: 
  require calldata.size - 4 >=′ 32
  if tx.origin != caller:
      revert with 0, 'The caller is another contract'
  if not uint32(stor10.field_0):
      revert with 0, 'sale has not started yet'
  if block.timestamp < uint32(stor10.field_0):
      revert with 0, 'sale has not started yet'
  if totalSupply > !quantity:
      revert with 0, 17
  if totalSupply + quantity > 8900:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                  'not enough remaining reserved for auction to support desired mint amount'
  if not caller:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721A: number minted query for the zero address'
  if balanceOf[caller].field_128 > !quantity:
      revert with 0, 17
  if balanceOf[caller].field_128 + quantity > 5:
      revert with 0, 'can not mint this many'
  if block.timestamp < uint32(stor10.field_0):
      if quantity > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
          revert with 0, 17
      mem[96] = 0
      if not caller:
          revert with 0, 'ERC721A: mint to the zero address'
      if totalSupply > totalSupply:
          revert with 0, 'ERC721A: token already minted'
      if quantity > 5:
          revert with 0, 'ERC721A: quantity to mint too high'
      mem[128] = balanceOf[caller].field_0
      mem[160] = balanceOf[caller].field_128
      if balanceOf[caller].field_0 > -uint128(quantity) + LOCK8605463013():
          revert with 0, 17
      mem[192] = uint128(uint128(quantity) + balanceOf[caller].field_0)
      if balanceOf[caller].field_128 > -uint128(quantity) + LOCK8605463013():
          revert with 0, 17
      mem[224] = uint128(uint128(quantity) + balanceOf[caller].field_128)
      balanceOf[caller].field_0 = uint128(uint128(quantity) + balanceOf[caller].field_0)
      balanceOf[caller].field_128 = uint128(uint128(quantity) + balanceOf[caller].field_128)
      mem[64] = 320
      mem[256] = caller
      mem[288] = uint64(block.timestamp)
      mem[0] = totalSupply
      mem[32] = 4
      stor4[stor1].field_0 = caller
      stor4[stor1].field_160 = uint64(block.timestamp)
      idx = 0
      s = totalSupply
      while idx < quantity:
          log Transfer(
                address from=0,
                address to=caller,
                uint256 value=s)
          if ext_code.size(caller):
              mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
              mem[mem[64] + 4] = caller
              mem[mem[64] + 36] = 0
              mem[mem[64] + 68] = s
              mem[mem[64] + 100] = 128
              mem[mem[64] + 132] = mem[96]
              t = 0
              while t < mem[96]:
                  mem[t + mem[64] + 164] = mem[t + 128]
                  t = t + 32
                  continue 
              if ceil32(mem[96]) <= mem[96]:
                  require ext_code.size(caller)
                  call caller.onERC721Received(address , address , uint256 , bytes ) with:
                       gas gas_remaining wei
                      args caller, 0, s, 128, mem[96], mem[mem[64] + 164 len ceil32(mem[96])]
                  mem[mem[64]] = ext_call.return_data[0]
                  if not ext_call.success:
                      if not return_data.size:
                          if not mem[96]:
                              revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                          revert with memory
                            from 128
                             len mem[96]
                      if not return_data.size:
                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                      revert with ext_call.return_data[0 len return_data.size]
                  _294 = mem[64]
                  mem[64] = mem[64] + ceil32(return_data.size)
                  require return_data.size >=′ 32
                  require mem[_294] == Mask(32, 224, mem[_294])
                  if Mask(32, 224, mem[_294]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
              else:
                  mem[mem[96] + mem[64] + 164] = 0
                  require ext_code.size(caller)
                  call caller.onERC721Received(address , address , uint256 , bytes ) with:
                       gas gas_remaining wei
                      args caller, 0, s, 128, mem[96], mem[mem[64] + 164 len ceil32(mem[96])]
                  mem[mem[64]] = ext_call.return_data[0]
                  if not ext_call.success:
                      if not return_data.size:
                          if not mem[96]:
                              revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                          revert with memory
                            from 128
                             len mem[96]
                      if not return_data.size:
                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                      revert with ext_call.return_data[0 len return_data.size]
                  _295 = mem[64]
                  mem[64] = mem[64] + ceil32(return_data.size)
                  require return_data.size >=′ 32
                  require mem[_295] == Mask(32, 224, mem[_295])
                  if Mask(32, 224, mem[_295]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
          if s == -1:
              revert with 0, 17
          if idx == -1:
              revert with 0, 17
          idx = idx + 1
          s = s + 1
          continue 
      totalSupply = s
      if call.value < 10^18 * quantity:
          revert with 0, 'Need to send more ETH.'
      if call.value > 10^18 * quantity:
          if call.value < 10^18 * quantity:
              revert with 0, 17
          call caller with:
             value call.value - (10^18 * quantity) wei
               gas 2300 * is_zero(value) wei
          if not ext_call.success:
              revert with ext_call.return_data[0 len return_data.size]
  else:
      if block.timestamp - uint32(stor10.field_0) >= 20400:
          if quantity > 0x7afa7176cf187830b129ff26a7385a81ffb3f563a9265e24df:
              revert with 0, 17
          mem[96] = 0
          if not caller:
              revert with 0, 'ERC721A: mint to the zero address'
          if totalSupply > totalSupply:
              revert with 0, 'ERC721A: token already minted'
          if quantity > 5:
              revert with 0, 'ERC721A: quantity to mint too high'
          mem[128] = balanceOf[caller].field_0
          mem[160] = balanceOf[caller].field_128
          if balanceOf[caller].field_0 > -uint128(quantity) + LOCK8605463013():
              revert with 0, 17
          mem[192] = uint128(uint128(quantity) + balanceOf[caller].field_0)
          if balanceOf[caller].field_128 > -uint128(quantity) + LOCK8605463013():
              revert with 0, 17
          mem[224] = uint128(uint128(quantity) + balanceOf[caller].field_128)
          balanceOf[caller].field_0 = uint128(uint128(quantity) + balanceOf[caller].field_0)
          balanceOf[caller].field_128 = uint128(uint128(quantity) + balanceOf[caller].field_128)
          mem[64] = 320
          mem[256] = caller
          mem[288] = uint64(block.timestamp)
          mem[0] = totalSupply
          mem[32] = 4
          stor4[stor1].field_0 = caller
          stor4[stor1].field_160 = uint64(block.timestamp)
          idx = 0
          s = totalSupply
          while idx < quantity:
              log Transfer(
                    address from=0,
                    address to=caller,
                    uint256 value=s)
              if ext_code.size(caller):
                  mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                  mem[mem[64] + 4] = caller
                  mem[mem[64] + 36] = 0
                  mem[mem[64] + 68] = s
                  mem[mem[64] + 100] = 128
                  mem[mem[64] + 132] = mem[96]
                  t = 0
                  while t < mem[96]:
                      mem[t + mem[64] + 164] = mem[t + 128]
                      t = t + 32
                      continue 
                  if ceil32(mem[96]) <= mem[96]:
                      require ext_code.size(caller)
                      call caller.onERC721Received(address , address , uint256 , bytes ) with:
                           gas gas_remaining wei
                          args caller, 0, s, 128, mem[96], mem[mem[64] + 164 len ceil32(mem[96])]
                      mem[mem[64]] = ext_call.return_data[0]
                      if not ext_call.success:
                          if not return_data.size:
                              if not mem[96]:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with memory
                                from 128
                                 len mem[96]
                          if not return_data.size:
                              revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                          revert with ext_call.return_data[0 len return_data.size]
                      _292 = mem[64]
                      mem[64] = mem[64] + ceil32(return_data.size)
                      require return_data.size >=′ 32
                      require mem[_292] == Mask(32, 224, mem[_292])
                      if Mask(32, 224, mem[_292]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                  else:
                      mem[mem[96] + mem[64] + 164] = 0
                      require ext_code.size(caller)
                      call caller.onERC721Received(address , address , uint256 , bytes ) with:
                           gas gas_remaining wei
                          args caller, 0, s, 128, mem[96], mem[mem[64] + 164 len ceil32(mem[96])]
                      mem[mem[64]] = ext_call.return_data[0]
                      if not ext_call.success:
                          if not return_data.size:
                              if not mem[96]:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with memory
                                from 128
                                 len mem[96]
                          if not return_data.size:
                              revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                          revert with ext_call.return_data[0 len return_data.size]
                      _293 = mem[64]
                      mem[64] = mem[64] + ceil32(return_data.size)
                      require return_data.size >=′ 32
                      require mem[_293] == Mask(32, 224, mem[_293])
                      if Mask(32, 224, mem[_293]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
              if s == -1:
                  revert with 0, 17
              if idx == -1:
                  revert with 0, 17
              idx = idx + 1
              s = s + 1
              continue 
          totalSupply = s
          if call.value < 15 * 10^16 * quantity:
              revert with 0, 'Need to send more ETH.'
          if call.value > 15 * 10^16 * quantity:
              if call.value < 15 * 10^16 * quantity:
                  revert with 0, 17
              call caller with:
                 value call.value - (15 * 10^16 * quantity) wei
                   gas 2300 * is_zero(value) wei
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]
      else:
          if block.timestamp < uint32(stor10.field_0):
              revert with 0, 17
          if block.timestamp - uint32(stor10.field_0) / 1200 and 5 * 10^16 > -1 / block.timestamp - uint32(stor10.field_0) / 1200:
              revert with 0, 17
          if 10^18 < 5 * 10^16 * block.timestamp - uint32(stor10.field_0) / 1200:
              revert with 0, 17
          if (-5 * 10^16 * block.timestamp - uint32(stor10.field_0) / 1200) + 10^18 and quantity > -1 / (-5 * 10^16 * block.timestamp - uint32(stor10.field_0) / 1200) + 10^18:
              revert with 0, 17
          mem[96] = 0
          if not caller:
              revert with 0, 'ERC721A: mint to the zero address'
          if totalSupply > totalSupply:
              revert with 0, 'ERC721A: token already minted'
          if quantity > 5:
              revert with 0, 'ERC721A: quantity to mint too high'
          mem[128] = balanceOf[caller].field_0
          mem[160] = balanceOf[caller].field_128
          if balanceOf[caller].field_0 > -uint128(quantity) + LOCK8605463013():
              revert with 0, 17
          mem[192] = uint128(uint128(quantity) + balanceOf[caller].field_0)
          if balanceOf[caller].field_128 > -uint128(quantity) + LOCK8605463013():
              revert with 0, 17
          mem[224] = uint128(uint128(quantity) + balanceOf[caller].field_128)
          balanceOf[caller].field_0 = uint128(uint128(quantity) + balanceOf[caller].field_0)
          balanceOf[caller].field_128 = uint128(uint128(quantity) + balanceOf[caller].field_128)
          mem[64] = 320
          mem[256] = caller
          mem[288] = uint64(block.timestamp)
          mem[0] = totalSupply
          mem[32] = 4
          stor4[stor1].field_0 = caller
          stor4[stor1].field_160 = uint64(block.timestamp)
          idx = 0
          s = totalSupply
          while idx < quantity:
              log Transfer(
                    address from=0,
                    address to=caller,
                    uint256 value=s)
              if ext_code.size(caller):
                  mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                  mem[mem[64] + 4] = caller
                  mem[mem[64] + 36] = 0
                  mem[mem[64] + 68] = s
                  mem[mem[64] + 100] = 128
                  mem[mem[64] + 132] = mem[96]
                  t = 0
                  while t < mem[96]:
                      mem[t + mem[64] + 164] = mem[t + 128]
                      t = t + 32
                      continue 
                  if ceil32(mem[96]) <= mem[96]:
                      require ext_code.size(caller)
                      call caller.onERC721Received(address , address , uint256 , bytes ) with:
                           gas gas_remaining wei
                          args caller, 0, s, 128, mem[96], mem[mem[64] + 164 len ceil32(mem[96])]
                      mem[mem[64]] = ext_call.return_data[0]
                      if not ext_call.success:
                          if not return_data.size:
                              if not mem[96]:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with memory
                                from 128
                                 len mem[96]
                          if not return_data.size:
                              revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                          revert with ext_call.return_data[0 len return_data.size]
                      _290 = mem[64]
                      mem[64] = mem[64] + ceil32(return_data.size)
                      require return_data.size >=′ 32
                      require mem[_290] == Mask(32, 224, mem[_290])
                      if Mask(32, 224, mem[_290]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                  else:
                      mem[mem[96] + mem[64] + 164] = 0
                      require ext_code.size(caller)
                      call caller.onERC721Received(address , address , uint256 , bytes ) with:
                           gas gas_remaining wei
                          args caller, 0, s, 128, mem[96], mem[mem[64] + 164 len ceil32(mem[96])]
                      mem[mem[64]] = ext_call.return_data[0]
                      if not ext_call.success:
                          if not return_data.size:
                              if not mem[96]:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with memory
                                from 128
                                 len mem[96]
                          if not return_data.size:
                              revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                          revert with ext_call.return_data[0 len return_data.size]
                      _291 = mem[64]
                      mem[64] = mem[64] + ceil32(return_data.size)
                      require return_data.size >=′ 32
                      require mem[_291] == Mask(32, 224, mem[_291])
                      if Mask(32, 224, mem[_291]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
              if s == -1:
                  revert with 0, 17
              if idx == -1:
                  revert with 0, 17
              idx = idx + 1
              s = s + 1
              continue 
          totalSupply = s
          if call.value < (10^18 * quantity) - (5 * 10^16 * block.timestamp - uint32(stor10.field_0) / 1200 * quantity):
              revert with 0, 'Need to send more ETH.'
          if call.value > (10^18 * quantity) - (5 * 10^16 * block.timestamp - uint32(stor10.field_0) / 1200 * quantity):
              if call.value < (10^18 * quantity) - (5 * 10^16 * block.timestamp - uint32(stor10.field_0) / 1200 * quantity):
                  revert with 0, 17
              call caller with:
                 value call.value - (10^18 * quantity) + (5 * 10^16 * block.timestamp - uint32(stor10.field_0) / 1200 * quantity) wei
                   gas 2300 * is_zero(value) wei
              if not ext_call.success:
                  revert with ext_call.return_data[0 len return_data.size]

def safeTransferFrom(address from, address to, uint256 tokenId): # not payable
  require calldata.size - 4 >=′ 96
  require from == from
  require to == to
  mem[96] = 0
  mem[64] = 192
  mem[128] = 0
  mem[160] = 0
  if totalSupply <= tokenId:
      revert with 0, 'ERC721A: owner query for nonexistent token'
  if tokenId < 5:
      idx = tokenId
      while idx >= 0:
          mem[0] = idx
          mem[32] = 4
          _753 = mem[64]
          mem[64] = mem[64] + 64
          mem[_753] = stor4[idx].field_0
          mem[_753 + 32] = stor4[idx].field_160
          if not stor4[idx].field_0:
              if not idx:
                  revert with 0, 17
              idx = idx - 1
              continue 
          if caller == stor4[idx].field_0:
              if stor4[idx].field_0 != from:
                  revert with 0, 'ERC721A: transfer from incorrect owner'
              if not to:
                  revert with 0, 'ERC721A: transfer to the zero address'
              approved[tokenId] = 0
              log Approval(
                    address owner=stor4[idx].field_0,
                    address spender=0,
                    uint256 value=tokenId)
              if balanceOf[address(from)].field_0 < 1:
                  revert with 0, 17
              balanceOf[address(from)].field_0 = uint128(balanceOf[address(from)].field_0 - 1)
              mem[0] = to
              mem[32] = 5
              if balanceOf[address(to)].field_0 > LOCK8605463013():
                  revert with 0, 17
              balanceOf[address(to)].field_0 = uint128(balanceOf[address(to)].field_0 + 1)
              _825 = mem[64]
              mem[64] = mem[64] + 64
              mem[_825] = to
              mem[_825 + 32] = uint64(block.timestamp)
              stor4[tokenId].field_0 = to
              stor4[tokenId].field_160 = uint64(block.timestamp)
              if 1 > !tokenId:
                  revert with 0, 17
              mem[0] = tokenId + 1
              mem[32] = 4
              if stor4[tokenId + 1].field_0:
                  log Transfer(
                        address from=from,
                        address to=to,
                        uint256 value=tokenId)
                  if not ext_code.size(to):
                      stop
                  mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                  mem[mem[64] + 4] = caller
                  mem[mem[64] + 36] = from
                  mem[mem[64] + 68] = tokenId
                  mem[mem[64] + 100] = 128
                  mem[mem[64] + 132] = mem[96]
                  idx = 0
                  while idx < mem[96]:
                      mem[idx + mem[64] + 164] = mem[idx + 128]
                      idx = idx + 32
                      continue 
                  if ceil32(mem[96]) <= mem[96]:
                      require ext_code.size(to)
                      call to.onERC721Received(address , address , uint256 , bytes ) with:
                           gas gas_remaining wei
                          args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                      mem[mem[64]] = ext_call.return_data[0]
                      if not ext_call.success:
                          if not return_data.size:
                              if not mem[96]:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with memory
                                from 128
                                 len mem[96]
                          if not return_data.size:
                              revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                          revert with ext_call.return_data[0 len return_data.size]
                      _1551 = mem[64]
                      mem[64] = mem[64] + ceil32(return_data.size)
                      require return_data.size >=′ 32
                      require mem[_1551] == Mask(32, 224, mem[_1551])
                  else:
                      mem[mem[96] + mem[64] + 164] = 0
                      require ext_code.size(to)
                      call to.onERC721Received(address , address , uint256 , bytes ) with:
                           gas gas_remaining wei
                          args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                      mem[mem[64]] = ext_call.return_data[0]
                      if not ext_call.success:
                          if not return_data.size:
                              if not mem[96]:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with memory
                                from 128
                                 len mem[96]
                          if not return_data.size:
                              revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                          revert with ext_call.return_data[0 len return_data.size]
                      _1552 = mem[64]
                      mem[64] = mem[64] + ceil32(return_data.size)
                      require return_data.size >=′ 32
                      require mem[_1552] == Mask(32, 224, mem[_1552])
              else:
                  if totalSupply <= tokenId + 1:
                      log Transfer(
                            address from=from,
                            address to=to,
                            uint256 value=tokenId)
                      if not ext_code.size(to):
                          stop
                      mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                      mem[mem[64] + 4] = caller
                      mem[mem[64] + 36] = from
                      mem[mem[64] + 68] = tokenId
                      mem[mem[64] + 100] = 128
                      mem[mem[64] + 132] = mem[96]
                      idx = 0
                      while idx < mem[96]:
                          mem[idx + mem[64] + 164] = mem[idx + 128]
                          idx = idx + 32
                          continue 
                      if ceil32(mem[96]) <= mem[96]:
                          require ext_code.size(to)
                          call to.onERC721Received(address , address , uint256 , bytes ) with:
                               gas gas_remaining wei
                              args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              if not return_data.size:
                                  if not mem[96]:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with memory
                                    from 128
                                     len mem[96]
                              if not return_data.size:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with ext_call.return_data[0 len return_data.size]
                          _1553 = mem[64]
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          require mem[_1553] == Mask(32, 224, mem[_1553])
                      else:
                          mem[mem[96] + mem[64] + 164] = 0
                          require ext_code.size(to)
                          call to.onERC721Received(address , address , uint256 , bytes ) with:
                               gas gas_remaining wei
                              args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              if not return_data.size:
                                  if not mem[96]:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with memory
                                    from 128
                                     len mem[96]
                              if not return_data.size:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with ext_call.return_data[0 len return_data.size]
                          _1554 = mem[64]
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          require mem[_1554] == Mask(32, 224, mem[_1554])
                  else:
                      _861 = mem[64]
                      mem[64] = mem[64] + 64
                      mem[_861] = stor4[idx].field_0
                      mem[_861 + 32] = stor4[idx].field_160
                      mem[0] = tokenId + 1
                      mem[32] = 4
                      stor4[tokenId + 1].field_0 = stor4[idx].field_0
                      stor4[tokenId + 1].field_160 = stor4[idx].field_160
                      log Transfer(
                            address from=from,
                            address to=to,
                            uint256 value=tokenId)
                      if not ext_code.size(to):
                          stop
                      mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                      mem[mem[64] + 4] = caller
                      mem[mem[64] + 36] = from
                      mem[mem[64] + 68] = tokenId
                      mem[mem[64] + 100] = 128
                      mem[mem[64] + 132] = mem[96]
                      idx = 0
                      while idx < mem[96]:
                          mem[idx + mem[64] + 164] = mem[idx + 128]
                          idx = idx + 32
                          continue 
                      if ceil32(mem[96]) <= mem[96]:
                          require ext_code.size(to)
                          call to.onERC721Received(address , address , uint256 , bytes ) with:
                               gas gas_remaining wei
                              args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              if not return_data.size:
                                  if not mem[96]:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with memory
                                    from 128
                                     len mem[96]
                              if not return_data.size:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with ext_call.return_data[0 len return_data.size]
                          _1555 = mem[64]
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          require mem[_1555] == Mask(32, 224, mem[_1555])
                      else:
                          mem[mem[96] + mem[64] + 164] = 0
                          require ext_code.size(to)
                          call to.onERC721Received(address , address , uint256 , bytes ) with:
                               gas gas_remaining wei
                              args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              if not return_data.size:
                                  if not mem[96]:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with memory
                                    from 128
                                     len mem[96]
                              if not return_data.size:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with ext_call.return_data[0 len return_data.size]
                          _1556 = mem[64]
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          require mem[_1556] == Mask(32, 224, mem[_1556])
          else:
              if totalSupply <= tokenId:
                  revert with 0, 'ERC721A: approved query for nonexistent token'
              if approved[tokenId] == caller:
                  if stor4[idx].field_0 != from:
                      revert with 0, 'ERC721A: transfer from incorrect owner'
                  if not to:
                      revert with 0, 'ERC721A: transfer to the zero address'
                  approved[tokenId] = 0
                  log Approval(
                        address owner=stor4[idx].field_0,
                        address spender=0,
                        uint256 value=tokenId)
                  if balanceOf[address(from)].field_0 < 1:
                      revert with 0, 17
                  balanceOf[address(from)].field_0 = uint128(balanceOf[address(from)].field_0 - 1)
                  mem[0] = to
                  mem[32] = 5
                  if balanceOf[address(to)].field_0 > LOCK8605463013():
                      revert with 0, 17
                  balanceOf[address(to)].field_0 = uint128(balanceOf[address(to)].field_0 + 1)
                  _851 = mem[64]
                  mem[64] = mem[64] + 64
                  mem[_851] = to
                  mem[_851 + 32] = uint64(block.timestamp)
                  stor4[tokenId].field_0 = to
                  stor4[tokenId].field_160 = uint64(block.timestamp)
                  if 1 > !tokenId:
                      revert with 0, 17
                  mem[0] = tokenId + 1
                  mem[32] = 4
                  if stor4[tokenId + 1].field_0:
                      log Transfer(
                            address from=from,
                            address to=to,
                            uint256 value=tokenId)
                      if not ext_code.size(to):
                          stop
                      mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                      mem[mem[64] + 4] = caller
                      mem[mem[64] + 36] = from
                      mem[mem[64] + 68] = tokenId
                      mem[mem[64] + 100] = 128
                      mem[mem[64] + 132] = mem[96]
                      idx = 0
                      while idx < mem[96]:
                          mem[idx + mem[64] + 164] = mem[idx + 128]
                          idx = idx + 32
                          continue 
                      if ceil32(mem[96]) <= mem[96]:
                          require ext_code.size(to)
                          call to.onERC721Received(address , address , uint256 , bytes ) with:
                               gas gas_remaining wei
                              args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              if not return_data.size:
                                  if not mem[96]:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with memory
                                    from 128
                                     len mem[96]
                              if not return_data.size:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with ext_call.return_data[0 len return_data.size]
                          _1557 = mem[64]
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          require mem[_1557] == Mask(32, 224, mem[_1557])
                      else:
                          mem[mem[96] + mem[64] + 164] = 0
                          require ext_code.size(to)
                          call to.onERC721Received(address , address , uint256 , bytes ) with:
                               gas gas_remaining wei
                              args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              if not return_data.size:
                                  if not mem[96]:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with memory
                                    from 128
                                     len mem[96]
                              if not return_data.size:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with ext_call.return_data[0 len return_data.size]
                          _1558 = mem[64]
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          require mem[_1558] == Mask(32, 224, mem[_1558])
                  else:
                      if totalSupply <= tokenId + 1:
                          log Transfer(
                                address from=from,
                                address to=to,
                                uint256 value=tokenId)
                          if not ext_code.size(to):
                              stop
                          mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                          mem[mem[64] + 4] = caller
                          mem[mem[64] + 36] = from
                          mem[mem[64] + 68] = tokenId
                          mem[mem[64] + 100] = 128
                          mem[mem[64] + 132] = mem[96]
                          idx = 0
                          while idx < mem[96]:
                              mem[idx + mem[64] + 164] = mem[idx + 128]
                              idx = idx + 32
                              continue 
                          if ceil32(mem[96]) <= mem[96]:
                              require ext_code.size(to)
                              call to.onERC721Received(address , address , uint256 , bytes ) with:
                                   gas gas_remaining wei
                                  args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                              mem[mem[64]] = ext_call.return_data[0]
                              if not ext_call.success:
                                  if not return_data.size:
                                      if not mem[96]:
                                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                      revert with memory
                                        from 128
                                         len mem[96]
                                  if not return_data.size:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with ext_call.return_data[0 len return_data.size]
                              _1559 = mem[64]
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              require mem[_1559] == Mask(32, 224, mem[_1559])
                          else:
                              mem[mem[96] + mem[64] + 164] = 0
                              require ext_code.size(to)
                              call to.onERC721Received(address , address , uint256 , bytes ) with:
                                   gas gas_remaining wei
                                  args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                              mem[mem[64]] = ext_call.return_data[0]
                              if not ext_call.success:
                                  if not return_data.size:
                                      if not mem[96]:
                                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                      revert with memory
                                        from 128
                                         len mem[96]
                                  if not return_data.size:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with ext_call.return_data[0 len return_data.size]
                              _1560 = mem[64]
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              require mem[_1560] == Mask(32, 224, mem[_1560])
                      else:
                          _904 = mem[64]
                          mem[64] = mem[64] + 64
                          mem[_904] = stor4[idx].field_0
                          mem[_904 + 32] = stor4[idx].field_160
                          mem[0] = tokenId + 1
                          mem[32] = 4
                          stor4[tokenId + 1].field_0 = stor4[idx].field_0
                          stor4[tokenId + 1].field_160 = stor4[idx].field_160
                          log Transfer(
                                address from=from,
                                address to=to,
                                uint256 value=tokenId)
                          if not ext_code.size(to):
                              stop
                          mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                          mem[mem[64] + 4] = caller
                          mem[mem[64] + 36] = from
                          mem[mem[64] + 68] = tokenId
                          mem[mem[64] + 100] = 128
                          mem[mem[64] + 132] = mem[96]
                          idx = 0
                          while idx < mem[96]:
                              mem[idx + mem[64] + 164] = mem[idx + 128]
                              idx = idx + 32
                              continue 
                          if ceil32(mem[96]) <= mem[96]:
                              require ext_code.size(to)
                              call to.onERC721Received(address , address , uint256 , bytes ) with:
                                   gas gas_remaining wei
                                  args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                              mem[mem[64]] = ext_call.return_data[0]
                              if not ext_call.success:
                                  if not return_data.size:
                                      if not mem[96]:
                                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                      revert with memory
                                        from 128
                                         len mem[96]
                                  if not return_data.size:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with ext_call.return_data[0 len return_data.size]
                              _1561 = mem[64]
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              require mem[_1561] == Mask(32, 224, mem[_1561])
                          else:
                              mem[mem[96] + mem[64] + 164] = 0
                              require ext_code.size(to)
                              call to.onERC721Received(address , address , uint256 , bytes ) with:
                                   gas gas_remaining wei
                                  args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                              mem[mem[64]] = ext_call.return_data[0]
                              if not ext_call.success:
                                  if not return_data.size:
                                      if not mem[96]:
                                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                      revert with memory
                                        from 128
                                         len mem[96]
                                  if not return_data.size:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with ext_call.return_data[0 len return_data.size]
                              _1562 = mem[64]
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              require mem[_1562] == Mask(32, 224, mem[_1562])
              else:
                  if not stor7[stor4[idx].field_0][caller]:
                      revert with 0, 'ERC721A: transfer caller is not owner nor approved'
                  if stor4[idx].field_0 != from:
                      revert with 0, 'ERC721A: transfer from incorrect owner'
                  if not to:
                      revert with 0, 'ERC721A: transfer to the zero address'
                  approved[tokenId] = 0
                  log Approval(
                        address owner=stor4[idx].field_0,
                        address spender=0,
                        uint256 value=tokenId)
                  if balanceOf[address(from)].field_0 < 1:
                      revert with 0, 17
                  balanceOf[address(from)].field_0 = uint128(balanceOf[address(from)].field_0 - 1)
                  mem[0] = to
                  mem[32] = 5
                  if balanceOf[address(to)].field_0 > LOCK8605463013():
                      revert with 0, 17
                  balanceOf[address(to)].field_0 = uint128(balanceOf[address(to)].field_0 + 1)
                  _877 = mem[64]
                  mem[64] = mem[64] + 64
                  mem[_877] = to
                  mem[_877 + 32] = uint64(block.timestamp)
                  stor4[tokenId].field_0 = to
                  stor4[tokenId].field_160 = uint64(block.timestamp)
                  if 1 > !tokenId:
                      revert with 0, 17
                  mem[0] = tokenId + 1
                  mem[32] = 4
                  if stor4[tokenId + 1].field_0:
                      log Transfer(
                            address from=from,
                            address to=to,
                            uint256 value=tokenId)
                      if not ext_code.size(to):
                          stop
                      mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                      mem[mem[64] + 4] = caller
                      mem[mem[64] + 36] = from
                      mem[mem[64] + 68] = tokenId
                      mem[mem[64] + 100] = 128
                      mem[mem[64] + 132] = mem[96]
                      idx = 0
                      while idx < mem[96]:
                          mem[idx + mem[64] + 164] = mem[idx + 128]
                          idx = idx + 32
                          continue 
                      if ceil32(mem[96]) <= mem[96]:
                          require ext_code.size(to)
                          call to.onERC721Received(address , address , uint256 , bytes ) with:
                               gas gas_remaining wei
                              args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              if not return_data.size:
                                  if not mem[96]:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with memory
                                    from 128
                                     len mem[96]
                              if not return_data.size:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with ext_call.return_data[0 len return_data.size]
                          _1563 = mem[64]
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          require mem[_1563] == Mask(32, 224, mem[_1563])
                      else:
                          mem[mem[96] + mem[64] + 164] = 0
                          require ext_code.size(to)
                          call to.onERC721Received(address , address , uint256 , bytes ) with:
                               gas gas_remaining wei
                              args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              if not return_data.size:
                                  if not mem[96]:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with memory
                                    from 128
                                     len mem[96]
                              if not return_data.size:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with ext_call.return_data[0 len return_data.size]
                          _1564 = mem[64]
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          require mem[_1564] == Mask(32, 224, mem[_1564])
                  else:
                      if totalSupply <= tokenId + 1:
                          log Transfer(
                                address from=from,
                                address to=to,
                                uint256 value=tokenId)
                          if not ext_code.size(to):
                              stop
                          mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                          mem[mem[64] + 4] = caller
                          mem[mem[64] + 36] = from
                          mem[mem[64] + 68] = tokenId
                          mem[mem[64] + 100] = 128
                          mem[mem[64] + 132] = mem[96]
                          idx = 0
                          while idx < mem[96]:
                              mem[idx + mem[64] + 164] = mem[idx + 128]
                              idx = idx + 32
                              continue 
                          if ceil32(mem[96]) <= mem[96]:
                              require ext_code.size(to)
                              call to.onERC721Received(address , address , uint256 , bytes ) with:
                                   gas gas_remaining wei
                                  args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                              mem[mem[64]] = ext_call.return_data[0]
                              if not ext_call.success:
                                  if not return_data.size:
                                      if not mem[96]:
                                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                      revert with memory
                                        from 128
                                         len mem[96]
                                  if not return_data.size:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with ext_call.return_data[0 len return_data.size]
                              _1565 = mem[64]
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              require mem[_1565] == Mask(32, 224, mem[_1565])
                          else:
                              mem[mem[96] + mem[64] + 164] = 0
                              require ext_code.size(to)
                              call to.onERC721Received(address , address , uint256 , bytes ) with:
                                   gas gas_remaining wei
                                  args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                              mem[mem[64]] = ext_call.return_data[0]
                              if not ext_call.success:
                                  if not return_data.size:
                                      if not mem[96]:
                                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                      revert with memory
                                        from 128
                                         len mem[96]
                                  if not return_data.size:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with ext_call.return_data[0 len return_data.size]
                              _1566 = mem[64]
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              require mem[_1566] == Mask(32, 224, mem[_1566])
                      else:
                          _934 = mem[64]
                          mem[64] = mem[64] + 64
                          mem[_934] = stor4[idx].field_0
                          mem[_934 + 32] = stor4[idx].field_160
                          mem[0] = tokenId + 1
                          mem[32] = 4
                          stor4[tokenId + 1].field_0 = stor4[idx].field_0
                          stor4[tokenId + 1].field_160 = stor4[idx].field_160
                          log Transfer(
                                address from=from,
                                address to=to,
                                uint256 value=tokenId)
                          if not ext_code.size(to):
                              stop
                          mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                          mem[mem[64] + 4] = caller
                          mem[mem[64] + 36] = from
                          mem[mem[64] + 68] = tokenId
                          mem[mem[64] + 100] = 128
                          mem[mem[64] + 132] = mem[96]
                          idx = 0
                          while idx < mem[96]:
                              mem[idx + mem[64] + 164] = mem[idx + 128]
                              idx = idx + 32
                              continue 
                          if ceil32(mem[96]) <= mem[96]:
                              require ext_code.size(to)
                              call to.onERC721Received(address , address , uint256 , bytes ) with:
                                   gas gas_remaining wei
                                  args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                              mem[mem[64]] = ext_call.return_data[0]
                              if not ext_call.success:
                                  if not return_data.size:
                                      if not mem[96]:
                                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                      revert with memory
                                        from 128
                                         len mem[96]
                                  if not return_data.size:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with ext_call.return_data[0 len return_data.size]
                              _1567 = mem[64]
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              require mem[_1567] == Mask(32, 224, mem[_1567])
                          else:
                              mem[mem[96] + mem[64] + 164] = 0
                              require ext_code.size(to)
                              call to.onERC721Received(address , address , uint256 , bytes ) with:
                                   gas gas_remaining wei
                                  args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                              mem[mem[64]] = ext_call.return_data[0]
                              if not ext_call.success:
                                  if not return_data.size:
                                      if not mem[96]:
                                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                      revert with memory
                                        from 128
                                         len mem[96]
                                  if not return_data.size:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with ext_call.return_data[0 len return_data.size]
                              _1568 = mem[64]
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              require mem[_1568] == Mask(32, 224, mem[_1568])
          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
  else:
      if 1 > !(tokenId - 5):
          revert with 0, 17
      idx = tokenId
      while idx >= tokenId - 4:
          mem[0] = idx
          mem[32] = 4
          _756 = mem[64]
          mem[64] = mem[64] + 64
          mem[_756] = stor4[idx].field_0
          mem[_756 + 32] = stor4[idx].field_160
          if not stor4[idx].field_0:
              if not idx:
                  revert with 0, 17
              idx = idx - 1
              continue 
          if caller == stor4[idx].field_0:
              if stor4[idx].field_0 != from:
                  revert with 0, 'ERC721A: transfer from incorrect owner'
              if not to:
                  revert with 0, 'ERC721A: transfer to the zero address'
              approved[tokenId] = 0
              log Approval(
                    address owner=stor4[idx].field_0,
                    address spender=0,
                    uint256 value=tokenId)
              if balanceOf[address(from)].field_0 < 1:
                  revert with 0, 17
              balanceOf[address(from)].field_0 = uint128(balanceOf[address(from)].field_0 - 1)
              mem[0] = to
              mem[32] = 5
              if balanceOf[address(to)].field_0 > LOCK8605463013():
                  revert with 0, 17
              balanceOf[address(to)].field_0 = uint128(balanceOf[address(to)].field_0 + 1)
              _832 = mem[64]
              mem[64] = mem[64] + 64
              mem[_832] = to
              mem[_832 + 32] = uint64(block.timestamp)
              stor4[tokenId].field_0 = to
              stor4[tokenId].field_160 = uint64(block.timestamp)
              if 1 > !tokenId:
                  revert with 0, 17
              mem[0] = tokenId + 1
              mem[32] = 4
              if stor4[tokenId + 1].field_0:
                  log Transfer(
                        address from=from,
                        address to=to,
                        uint256 value=tokenId)
                  if not ext_code.size(to):
                      stop
                  mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                  mem[mem[64] + 4] = caller
                  mem[mem[64] + 36] = from
                  mem[mem[64] + 68] = tokenId
                  mem[mem[64] + 100] = 128
                  mem[mem[64] + 132] = mem[96]
                  idx = 0
                  while idx < mem[96]:
                      mem[idx + mem[64] + 164] = mem[idx + 128]
                      idx = idx + 32
                      continue 
                  if ceil32(mem[96]) <= mem[96]:
                      require ext_code.size(to)
                      call to.onERC721Received(address , address , uint256 , bytes ) with:
                           gas gas_remaining wei
                          args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                      mem[mem[64]] = ext_call.return_data[0]
                      if not ext_call.success:
                          if not return_data.size:
                              if not mem[96]:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with memory
                                from 128
                                 len mem[96]
                          if not return_data.size:
                              revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                          revert with ext_call.return_data[0 len return_data.size]
                      _1569 = mem[64]
                      mem[64] = mem[64] + ceil32(return_data.size)
                      require return_data.size >=′ 32
                      require mem[_1569] == Mask(32, 224, mem[_1569])
                  else:
                      mem[mem[96] + mem[64] + 164] = 0
                      require ext_code.size(to)
                      call to.onERC721Received(address , address , uint256 , bytes ) with:
                           gas gas_remaining wei
                          args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                      mem[mem[64]] = ext_call.return_data[0]
                      if not ext_call.success:
                          if not return_data.size:
                              if not mem[96]:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with memory
                                from 128
                                 len mem[96]
                          if not return_data.size:
                              revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                          revert with ext_call.return_data[0 len return_data.size]
                      _1570 = mem[64]
                      mem[64] = mem[64] + ceil32(return_data.size)
                      require return_data.size >=′ 32
                      require mem[_1570] == Mask(32, 224, mem[_1570])
              else:
                  if totalSupply <= tokenId + 1:
                      log Transfer(
                            address from=from,
                            address to=to,
                            uint256 value=tokenId)
                      if not ext_code.size(to):
                          stop
                      mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                      mem[mem[64] + 4] = caller
                      mem[mem[64] + 36] = from
                      mem[mem[64] + 68] = tokenId
                      mem[mem[64] + 100] = 128
                      mem[mem[64] + 132] = mem[96]
                      idx = 0
                      while idx < mem[96]:
                          mem[idx + mem[64] + 164] = mem[idx + 128]
                          idx = idx + 32
                          continue 
                      if ceil32(mem[96]) <= mem[96]:
                          require ext_code.size(to)
                          call to.onERC721Received(address , address , uint256 , bytes ) with:
                               gas gas_remaining wei
                              args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              if not return_data.size:
                                  if not mem[96]:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with memory
                                    from 128
                                     len mem[96]
                              if not return_data.size:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with ext_call.return_data[0 len return_data.size]
                          _1571 = mem[64]
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          require mem[_1571] == Mask(32, 224, mem[_1571])
                      else:
                          mem[mem[96] + mem[64] + 164] = 0
                          require ext_code.size(to)
                          call to.onERC721Received(address , address , uint256 , bytes ) with:
                               gas gas_remaining wei
                              args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              if not return_data.size:
                                  if not mem[96]:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with memory
                                    from 128
                                     len mem[96]
                              if not return_data.size:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with ext_call.return_data[0 len return_data.size]
                          _1572 = mem[64]
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          require mem[_1572] == Mask(32, 224, mem[_1572])
                  else:
                      _869 = mem[64]
                      mem[64] = mem[64] + 64
                      mem[_869] = stor4[idx].field_0
                      mem[_869 + 32] = stor4[idx].field_160
                      mem[0] = tokenId + 1
                      mem[32] = 4
                      stor4[tokenId + 1].field_0 = stor4[idx].field_0
                      stor4[tokenId + 1].field_160 = stor4[idx].field_160
                      log Transfer(
                            address from=from,
                            address to=to,
                            uint256 value=tokenId)
                      if not ext_code.size(to):
                          stop
                      mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                      mem[mem[64] + 4] = caller
                      mem[mem[64] + 36] = from
                      mem[mem[64] + 68] = tokenId
                      mem[mem[64] + 100] = 128
                      mem[mem[64] + 132] = mem[96]
                      idx = 0
                      while idx < mem[96]:
                          mem[idx + mem[64] + 164] = mem[idx + 128]
                          idx = idx + 32
                          continue 
                      if ceil32(mem[96]) <= mem[96]:
                          require ext_code.size(to)
                          call to.onERC721Received(address , address , uint256 , bytes ) with:
                               gas gas_remaining wei
                              args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              if not return_data.size:
                                  if not mem[96]:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with memory
                                    from 128
                                     len mem[96]
                              if not return_data.size:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with ext_call.return_data[0 len return_data.size]
                          _1573 = mem[64]
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          require mem[_1573] == Mask(32, 224, mem[_1573])
                      else:
                          mem[mem[96] + mem[64] + 164] = 0
                          require ext_code.size(to)
                          call to.onERC721Received(address , address , uint256 , bytes ) with:
                               gas gas_remaining wei
                              args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              if not return_data.size:
                                  if not mem[96]:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with memory
                                    from 128
                                     len mem[96]
                              if not return_data.size:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with ext_call.return_data[0 len return_data.size]
                          _1574 = mem[64]
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          require mem[_1574] == Mask(32, 224, mem[_1574])
          else:
              if totalSupply <= tokenId:
                  revert with 0, 'ERC721A: approved query for nonexistent token'
              if approved[tokenId] == caller:
                  if stor4[idx].field_0 != from:
                      revert with 0, 'ERC721A: transfer from incorrect owner'
                  if not to:
                      revert with 0, 'ERC721A: transfer to the zero address'
                  approved[tokenId] = 0
                  log Approval(
                        address owner=stor4[idx].field_0,
                        address spender=0,
                        uint256 value=tokenId)
                  if balanceOf[address(from)].field_0 < 1:
                      revert with 0, 17
                  balanceOf[address(from)].field_0 = uint128(balanceOf[address(from)].field_0 - 1)
                  mem[0] = to
                  mem[32] = 5
                  if balanceOf[address(to)].field_0 > LOCK8605463013():
                      revert with 0, 17
                  balanceOf[address(to)].field_0 = uint128(balanceOf[address(to)].field_0 + 1)
                  _855 = mem[64]
                  mem[64] = mem[64] + 64
                  mem[_855] = to
                  mem[_855 + 32] = uint64(block.timestamp)
                  stor4[tokenId].field_0 = to
                  stor4[tokenId].field_160 = uint64(block.timestamp)
                  if 1 > !tokenId:
                      revert with 0, 17
                  mem[0] = tokenId + 1
                  mem[32] = 4
                  if stor4[tokenId + 1].field_0:
                      log Transfer(
                            address from=from,
                            address to=to,
                            uint256 value=tokenId)
                      if not ext_code.size(to):
                          stop
                      mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                      mem[mem[64] + 4] = caller
                      mem[mem[64] + 36] = from
                      mem[mem[64] + 68] = tokenId
                      mem[mem[64] + 100] = 128
                      mem[mem[64] + 132] = mem[96]
                      idx = 0
                      while idx < mem[96]:
                          mem[idx + mem[64] + 164] = mem[idx + 128]
                          idx = idx + 32
                          continue 
                      if ceil32(mem[96]) <= mem[96]:
                          require ext_code.size(to)
                          call to.onERC721Received(address , address , uint256 , bytes ) with:
                               gas gas_remaining wei
                              args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              if not return_data.size:
                                  if not mem[96]:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with memory
                                    from 128
                                     len mem[96]
                              if not return_data.size:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with ext_call.return_data[0 len return_data.size]
                          _1575 = mem[64]
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          require mem[_1575] == Mask(32, 224, mem[_1575])
                      else:
                          mem[mem[96] + mem[64] + 164] = 0
                          require ext_code.size(to)
                          call to.onERC721Received(address , address , uint256 , bytes ) with:
                               gas gas_remaining wei
                              args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              if not return_data.size:
                                  if not mem[96]:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with memory
                                    from 128
                                     len mem[96]
                              if not return_data.size:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with ext_call.return_data[0 len return_data.size]
                          _1576 = mem[64]
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          require mem[_1576] == Mask(32, 224, mem[_1576])
                  else:
                      if totalSupply <= tokenId + 1:
                          log Transfer(
                                address from=from,
                                address to=to,
                                uint256 value=tokenId)
                          if not ext_code.size(to):
                              stop
                          mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                          mem[mem[64] + 4] = caller
                          mem[mem[64] + 36] = from
                          mem[mem[64] + 68] = tokenId
                          mem[mem[64] + 100] = 128
                          mem[mem[64] + 132] = mem[96]
                          idx = 0
                          while idx < mem[96]:
                              mem[idx + mem[64] + 164] = mem[idx + 128]
                              idx = idx + 32
                              continue 
                          if ceil32(mem[96]) <= mem[96]:
                              require ext_code.size(to)
                              call to.onERC721Received(address , address , uint256 , bytes ) with:
                                   gas gas_remaining wei
                                  args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                              mem[mem[64]] = ext_call.return_data[0]
                              if not ext_call.success:
                                  if not return_data.size:
                                      if not mem[96]:
                                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                      revert with memory
                                        from 128
                                         len mem[96]
                                  if not return_data.size:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with ext_call.return_data[0 len return_data.size]
                              _1577 = mem[64]
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              require mem[_1577] == Mask(32, 224, mem[_1577])
                          else:
                              mem[mem[96] + mem[64] + 164] = 0
                              require ext_code.size(to)
                              call to.onERC721Received(address , address , uint256 , bytes ) with:
                                   gas gas_remaining wei
                                  args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                              mem[mem[64]] = ext_call.return_data[0]
                              if not ext_call.success:
                                  if not return_data.size:
                                      if not mem[96]:
                                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                      revert with memory
                                        from 128
                                         len mem[96]
                                  if not return_data.size:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with ext_call.return_data[0 len return_data.size]
                              _1578 = mem[64]
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              require mem[_1578] == Mask(32, 224, mem[_1578])
                      else:
                          _915 = mem[64]
                          mem[64] = mem[64] + 64
                          mem[_915] = stor4[idx].field_0
                          mem[_915 + 32] = stor4[idx].field_160
                          mem[0] = tokenId + 1
                          mem[32] = 4
                          stor4[tokenId + 1].field_0 = stor4[idx].field_0
                          stor4[tokenId + 1].field_160 = stor4[idx].field_160
                          log Transfer(
                                address from=from,
                                address to=to,
                                uint256 value=tokenId)
                          if not ext_code.size(to):
                              stop
                          mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                          mem[mem[64] + 4] = caller
                          mem[mem[64] + 36] = from
                          mem[mem[64] + 68] = tokenId
                          mem[mem[64] + 100] = 128
                          mem[mem[64] + 132] = mem[96]
                          idx = 0
                          while idx < mem[96]:
                              mem[idx + mem[64] + 164] = mem[idx + 128]
                              idx = idx + 32
                              continue 
                          if ceil32(mem[96]) <= mem[96]:
                              require ext_code.size(to)
                              call to.onERC721Received(address , address , uint256 , bytes ) with:
                                   gas gas_remaining wei
                                  args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                              mem[mem[64]] = ext_call.return_data[0]
                              if not ext_call.success:
                                  if not return_data.size:
                                      if not mem[96]:
                                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                      revert with memory
                                        from 128
                                         len mem[96]
                                  if not return_data.size:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with ext_call.return_data[0 len return_data.size]
                              _1579 = mem[64]
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              require mem[_1579] == Mask(32, 224, mem[_1579])
                          else:
                              mem[mem[96] + mem[64] + 164] = 0
                              require ext_code.size(to)
                              call to.onERC721Received(address , address , uint256 , bytes ) with:
                                   gas gas_remaining wei
                                  args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                              mem[mem[64]] = ext_call.return_data[0]
                              if not ext_call.success:
                                  if not return_data.size:
                                      if not mem[96]:
                                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                      revert with memory
                                        from 128
                                         len mem[96]
                                  if not return_data.size:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with ext_call.return_data[0 len return_data.size]
                              _1580 = mem[64]
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              require mem[_1580] == Mask(32, 224, mem[_1580])
              else:
                  if not stor7[stor4[idx].field_0][caller]:
                      revert with 0, 'ERC721A: transfer caller is not owner nor approved'
                  if stor4[idx].field_0 != from:
                      revert with 0, 'ERC721A: transfer from incorrect owner'
                  if not to:
                      revert with 0, 'ERC721A: transfer to the zero address'
                  approved[tokenId] = 0
                  log Approval(
                        address owner=stor4[idx].field_0,
                        address spender=0,
                        uint256 value=tokenId)
                  if balanceOf[address(from)].field_0 < 1:
                      revert with 0, 17
                  balanceOf[address(from)].field_0 = uint128(balanceOf[address(from)].field_0 - 1)
                  mem[0] = to
                  mem[32] = 5
                  if balanceOf[address(to)].field_0 > LOCK8605463013():
                      revert with 0, 17
                  balanceOf[address(to)].field_0 = uint128(balanceOf[address(to)].field_0 + 1)
                  _883 = mem[64]
                  mem[64] = mem[64] + 64
                  mem[_883] = to
                  mem[_883 + 32] = uint64(block.timestamp)
                  stor4[tokenId].field_0 = to
                  stor4[tokenId].field_160 = uint64(block.timestamp)
                  if 1 > !tokenId:
                      revert with 0, 17
                  mem[0] = tokenId + 1
                  mem[32] = 4
                  if stor4[tokenId + 1].field_0:
                      log Transfer(
                            address from=from,
                            address to=to,
                            uint256 value=tokenId)
                      if not ext_code.size(to):
                          stop
                      mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                      mem[mem[64] + 4] = caller
                      mem[mem[64] + 36] = from
                      mem[mem[64] + 68] = tokenId
                      mem[mem[64] + 100] = 128
                      mem[mem[64] + 132] = mem[96]
                      idx = 0
                      while idx < mem[96]:
                          mem[idx + mem[64] + 164] = mem[idx + 128]
                          idx = idx + 32
                          continue 
                      if ceil32(mem[96]) <= mem[96]:
                          require ext_code.size(to)
                          call to.onERC721Received(address , address , uint256 , bytes ) with:
                               gas gas_remaining wei
                              args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              if not return_data.size:
                                  if not mem[96]:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with memory
                                    from 128
                                     len mem[96]
                              if not return_data.size:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with ext_call.return_data[0 len return_data.size]
                          _1581 = mem[64]
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          require mem[_1581] == Mask(32, 224, mem[_1581])
                      else:
                          mem[mem[96] + mem[64] + 164] = 0
                          require ext_code.size(to)
                          call to.onERC721Received(address , address , uint256 , bytes ) with:
                               gas gas_remaining wei
                              args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              if not return_data.size:
                                  if not mem[96]:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with memory
                                    from 128
                                     len mem[96]
                              if not return_data.size:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with ext_call.return_data[0 len return_data.size]
                          _1582 = mem[64]
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          require mem[_1582] == Mask(32, 224, mem[_1582])
                  else:
                      if totalSupply <= tokenId + 1:
                          log Transfer(
                                address from=from,
                                address to=to,
                                uint256 value=tokenId)
                          if not ext_code.size(to):
                              stop
                          mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                          mem[mem[64] + 4] = caller
                          mem[mem[64] + 36] = from
                          mem[mem[64] + 68] = tokenId
                          mem[mem[64] + 100] = 128
                          mem[mem[64] + 132] = mem[96]
                          idx = 0
                          while idx < mem[96]:
                              mem[idx + mem[64] + 164] = mem[idx + 128]
                              idx = idx + 32
                              continue 
                          if ceil32(mem[96]) <= mem[96]:
                              require ext_code.size(to)
                              call to.onERC721Received(address , address , uint256 , bytes ) with:
                                   gas gas_remaining wei
                                  args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                              mem[mem[64]] = ext_call.return_data[0]
                              if not ext_call.success:
                                  if not return_data.size:
                                      if not mem[96]:
                                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                      revert with memory
                                        from 128
                                         len mem[96]
                                  if not return_data.size:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with ext_call.return_data[0 len return_data.size]
                              _1583 = mem[64]
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              require mem[_1583] == Mask(32, 224, mem[_1583])
                          else:
                              mem[mem[96] + mem[64] + 164] = 0
                              require ext_code.size(to)
                              call to.onERC721Received(address , address , uint256 , bytes ) with:
                                   gas gas_remaining wei
                                  args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                              mem[mem[64]] = ext_call.return_data[0]
                              if not ext_call.success:
                                  if not return_data.size:
                                      if not mem[96]:
                                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                      revert with memory
                                        from 128
                                         len mem[96]
                                  if not return_data.size:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with ext_call.return_data[0 len return_data.size]
                              _1584 = mem[64]
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              require mem[_1584] == Mask(32, 224, mem[_1584])
                      else:
                          _945 = mem[64]
                          mem[64] = mem[64] + 64
                          mem[_945] = stor4[idx].field_0
                          mem[_945 + 32] = stor4[idx].field_160
                          mem[0] = tokenId + 1
                          mem[32] = 4
                          stor4[tokenId + 1].field_0 = stor4[idx].field_0
                          stor4[tokenId + 1].field_160 = stor4[idx].field_160
                          log Transfer(
                                address from=from,
                                address to=to,
                                uint256 value=tokenId)
                          if not ext_code.size(to):
                              stop
                          mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                          mem[mem[64] + 4] = caller
                          mem[mem[64] + 36] = from
                          mem[mem[64] + 68] = tokenId
                          mem[mem[64] + 100] = 128
                          mem[mem[64] + 132] = mem[96]
                          idx = 0
                          while idx < mem[96]:
                              mem[idx + mem[64] + 164] = mem[idx + 128]
                              idx = idx + 32
                              continue 
                          if ceil32(mem[96]) <= mem[96]:
                              require ext_code.size(to)
                              call to.onERC721Received(address , address , uint256 , bytes ) with:
                                   gas gas_remaining wei
                                  args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                              mem[mem[64]] = ext_call.return_data[0]
                              if not ext_call.success:
                                  if not return_data.size:
                                      if not mem[96]:
                                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                      revert with memory
                                        from 128
                                         len mem[96]
                                  if not return_data.size:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with ext_call.return_data[0 len return_data.size]
                              _1585 = mem[64]
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              require mem[_1585] == Mask(32, 224, mem[_1585])
                          else:
                              mem[mem[96] + mem[64] + 164] = 0
                              require ext_code.size(to)
                              call to.onERC721Received(address , address , uint256 , bytes ) with:
                                   gas gas_remaining wei
                                  args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                              mem[mem[64]] = ext_call.return_data[0]
                              if not ext_call.success:
                                  if not return_data.size:
                                      if not mem[96]:
                                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                      revert with memory
                                        from 128
                                         len mem[96]
                                  if not return_data.size:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with ext_call.return_data[0 len return_data.size]
                              _1586 = mem[64]
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              require mem[_1586] == Mask(32, 224, mem[_1586])
          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
  revert with 0, 'ERC721A: unable to determine the owner of token'

def safeTransferFrom(address from, address to, uint256 tokenId, bytes _data): # not payable
  require calldata.size - 4 >=′ 128
  require from == from
  require to == to
  require _data <= LOCK8605463013()
  require _data + 35 <′ calldata.size
  if _data.length > LOCK8605463013():
      revert with 0, 65
  if ceil32(ceil32(_data.length)) + 97 < 96 or ceil32(ceil32(_data.length)) + 97 > LOCK8605463013():
      revert with 0, 65
  mem[96] = _data.length
  require _data + _data.length + 36 <= calldata.size
  mem[128 len _data.length] = _data[all]
  mem[64] = ceil32(ceil32(_data.length)) + 161
  mem[ceil32(ceil32(_data.length)) + 97] = 0
  mem[ceil32(ceil32(_data.length)) + 129] = 0
  if totalSupply <= tokenId:
      revert with 0, 'ERC721A: owner query for nonexistent token'
  if tokenId < 5:
      idx = tokenId
      while idx >= 0:
          mem[0] = idx
          mem[32] = 4
          _753 = mem[64]
          mem[64] = mem[64] + 64
          mem[_753] = stor4[idx].field_0
          mem[_753 + 32] = stor4[idx].field_160
          if not stor4[idx].field_0:
              if not idx:
                  revert with 0, 17
              idx = idx - 1
              continue 
          if caller == stor4[idx].field_0:
              if stor4[idx].field_0 != from:
                  revert with 0, 'ERC721A: transfer from incorrect owner'
              if not to:
                  revert with 0, 'ERC721A: transfer to the zero address'
              approved[tokenId] = 0
              log Approval(
                    address owner=stor4[idx].field_0,
                    address spender=0,
                    uint256 value=tokenId)
              if balanceOf[address(from)].field_0 < 1:
                  revert with 0, 17
              balanceOf[address(from)].field_0 = uint128(balanceOf[address(from)].field_0 - 1)
              mem[0] = to
              mem[32] = 5
              if balanceOf[address(to)].field_0 > LOCK8605463013():
                  revert with 0, 17
              balanceOf[address(to)].field_0 = uint128(balanceOf[address(to)].field_0 + 1)
              _825 = mem[64]
              mem[64] = mem[64] + 64
              mem[_825] = to
              mem[_825 + 32] = uint64(block.timestamp)
              stor4[tokenId].field_0 = to
              stor4[tokenId].field_160 = uint64(block.timestamp)
              if 1 > !tokenId:
                  revert with 0, 17
              mem[0] = tokenId + 1
              mem[32] = 4
              if stor4[tokenId + 1].field_0:
                  log Transfer(
                        address from=from,
                        address to=to,
                        uint256 value=tokenId)
                  if not ext_code.size(to):
                      stop
                  mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                  mem[mem[64] + 4] = caller
                  mem[mem[64] + 36] = from
                  mem[mem[64] + 68] = tokenId
                  mem[mem[64] + 100] = 128
                  mem[mem[64] + 132] = mem[96]
                  idx = 0
                  while idx < mem[96]:
                      mem[idx + mem[64] + 164] = mem[idx + 128]
                      idx = idx + 32
                      continue 
                  if ceil32(mem[96]) <= mem[96]:
                      require ext_code.size(to)
                      call to.onERC721Received(address , address , uint256 , bytes ) with:
                           gas gas_remaining wei
                          args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                      mem[mem[64]] = ext_call.return_data[0]
                      if not ext_call.success:
                          if not return_data.size:
                              if not mem[96]:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with memory
                                from 128
                                 len mem[96]
                          if not return_data.size:
                              revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                          revert with ext_call.return_data[0 len return_data.size]
                      _1551 = mem[64]
                      mem[64] = mem[64] + ceil32(return_data.size)
                      require return_data.size >=′ 32
                      require mem[_1551] == Mask(32, 224, mem[_1551])
                  else:
                      mem[mem[96] + mem[64] + 164] = 0
                      require ext_code.size(to)
                      call to.onERC721Received(address , address , uint256 , bytes ) with:
                           gas gas_remaining wei
                          args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                      mem[mem[64]] = ext_call.return_data[0]
                      if not ext_call.success:
                          if not return_data.size:
                              if not mem[96]:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with memory
                                from 128
                                 len mem[96]
                          if not return_data.size:
                              revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                          revert with ext_call.return_data[0 len return_data.size]
                      _1552 = mem[64]
                      mem[64] = mem[64] + ceil32(return_data.size)
                      require return_data.size >=′ 32
                      require mem[_1552] == Mask(32, 224, mem[_1552])
              else:
                  if totalSupply <= tokenId + 1:
                      log Transfer(
                            address from=from,
                            address to=to,
                            uint256 value=tokenId)
                      if not ext_code.size(to):
                          stop
                      mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                      mem[mem[64] + 4] = caller
                      mem[mem[64] + 36] = from
                      mem[mem[64] + 68] = tokenId
                      mem[mem[64] + 100] = 128
                      mem[mem[64] + 132] = mem[96]
                      idx = 0
                      while idx < mem[96]:
                          mem[idx + mem[64] + 164] = mem[idx + 128]
                          idx = idx + 32
                          continue 
                      if ceil32(mem[96]) <= mem[96]:
                          require ext_code.size(to)
                          call to.onERC721Received(address , address , uint256 , bytes ) with:
                               gas gas_remaining wei
                              args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              if not return_data.size:
                                  if not mem[96]:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with memory
                                    from 128
                                     len mem[96]
                              if not return_data.size:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with ext_call.return_data[0 len return_data.size]
                          _1553 = mem[64]
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          require mem[_1553] == Mask(32, 224, mem[_1553])
                      else:
                          mem[mem[96] + mem[64] + 164] = 0
                          require ext_code.size(to)
                          call to.onERC721Received(address , address , uint256 , bytes ) with:
                               gas gas_remaining wei
                              args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              if not return_data.size:
                                  if not mem[96]:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with memory
                                    from 128
                                     len mem[96]
                              if not return_data.size:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with ext_call.return_data[0 len return_data.size]
                          _1554 = mem[64]
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          require mem[_1554] == Mask(32, 224, mem[_1554])
                  else:
                      _861 = mem[64]
                      mem[64] = mem[64] + 64
                      mem[_861] = stor4[idx].field_0
                      mem[_861 + 32] = stor4[idx].field_160
                      mem[0] = tokenId + 1
                      mem[32] = 4
                      stor4[tokenId + 1].field_0 = stor4[idx].field_0
                      stor4[tokenId + 1].field_160 = stor4[idx].field_160
                      log Transfer(
                            address from=from,
                            address to=to,
                            uint256 value=tokenId)
                      if not ext_code.size(to):
                          stop
                      mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                      mem[mem[64] + 4] = caller
                      mem[mem[64] + 36] = from
                      mem[mem[64] + 68] = tokenId
                      mem[mem[64] + 100] = 128
                      mem[mem[64] + 132] = mem[96]
                      idx = 0
                      while idx < mem[96]:
                          mem[idx + mem[64] + 164] = mem[idx + 128]
                          idx = idx + 32
                          continue 
                      if ceil32(mem[96]) <= mem[96]:
                          require ext_code.size(to)
                          call to.onERC721Received(address , address , uint256 , bytes ) with:
                               gas gas_remaining wei
                              args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              if not return_data.size:
                                  if not mem[96]:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with memory
                                    from 128
                                     len mem[96]
                              if not return_data.size:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with ext_call.return_data[0 len return_data.size]
                          _1555 = mem[64]
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          require mem[_1555] == Mask(32, 224, mem[_1555])
                      else:
                          mem[mem[96] + mem[64] + 164] = 0
                          require ext_code.size(to)
                          call to.onERC721Received(address , address , uint256 , bytes ) with:
                               gas gas_remaining wei
                              args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              if not return_data.size:
                                  if not mem[96]:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with memory
                                    from 128
                                     len mem[96]
                              if not return_data.size:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with ext_call.return_data[0 len return_data.size]
                          _1556 = mem[64]
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          require mem[_1556] == Mask(32, 224, mem[_1556])
          else:
              if totalSupply <= tokenId:
                  revert with 0, 'ERC721A: approved query for nonexistent token'
              if approved[tokenId] == caller:
                  if stor4[idx].field_0 != from:
                      revert with 0, 'ERC721A: transfer from incorrect owner'
                  if not to:
                      revert with 0, 'ERC721A: transfer to the zero address'
                  approved[tokenId] = 0
                  log Approval(
                        address owner=stor4[idx].field_0,
                        address spender=0,
                        uint256 value=tokenId)
                  if balanceOf[address(from)].field_0 < 1:
                      revert with 0, 17
                  balanceOf[address(from)].field_0 = uint128(balanceOf[address(from)].field_0 - 1)
                  mem[0] = to
                  mem[32] = 5
                  if balanceOf[address(to)].field_0 > LOCK8605463013():
                      revert with 0, 17
                  balanceOf[address(to)].field_0 = uint128(balanceOf[address(to)].field_0 + 1)
                  _851 = mem[64]
                  mem[64] = mem[64] + 64
                  mem[_851] = to
                  mem[_851 + 32] = uint64(block.timestamp)
                  stor4[tokenId].field_0 = to
                  stor4[tokenId].field_160 = uint64(block.timestamp)
                  if 1 > !tokenId:
                      revert with 0, 17
                  mem[0] = tokenId + 1
                  mem[32] = 4
                  if stor4[tokenId + 1].field_0:
                      log Transfer(
                            address from=from,
                            address to=to,
                            uint256 value=tokenId)
                      if not ext_code.size(to):
                          stop
                      mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                      mem[mem[64] + 4] = caller
                      mem[mem[64] + 36] = from
                      mem[mem[64] + 68] = tokenId
                      mem[mem[64] + 100] = 128
                      mem[mem[64] + 132] = mem[96]
                      idx = 0
                      while idx < mem[96]:
                          mem[idx + mem[64] + 164] = mem[idx + 128]
                          idx = idx + 32
                          continue 
                      if ceil32(mem[96]) <= mem[96]:
                          require ext_code.size(to)
                          call to.onERC721Received(address , address , uint256 , bytes ) with:
                               gas gas_remaining wei
                              args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              if not return_data.size:
                                  if not mem[96]:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with memory
                                    from 128
                                     len mem[96]
                              if not return_data.size:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with ext_call.return_data[0 len return_data.size]
                          _1557 = mem[64]
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          require mem[_1557] == Mask(32, 224, mem[_1557])
                      else:
                          mem[mem[96] + mem[64] + 164] = 0
                          require ext_code.size(to)
                          call to.onERC721Received(address , address , uint256 , bytes ) with:
                               gas gas_remaining wei
                              args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              if not return_data.size:
                                  if not mem[96]:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with memory
                                    from 128
                                     len mem[96]
                              if not return_data.size:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with ext_call.return_data[0 len return_data.size]
                          _1558 = mem[64]
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          require mem[_1558] == Mask(32, 224, mem[_1558])
                  else:
                      if totalSupply <= tokenId + 1:
                          log Transfer(
                                address from=from,
                                address to=to,
                                uint256 value=tokenId)
                          if not ext_code.size(to):
                              stop
                          mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                          mem[mem[64] + 4] = caller
                          mem[mem[64] + 36] = from
                          mem[mem[64] + 68] = tokenId
                          mem[mem[64] + 100] = 128
                          mem[mem[64] + 132] = mem[96]
                          idx = 0
                          while idx < mem[96]:
                              mem[idx + mem[64] + 164] = mem[idx + 128]
                              idx = idx + 32
                              continue 
                          if ceil32(mem[96]) <= mem[96]:
                              require ext_code.size(to)
                              call to.onERC721Received(address , address , uint256 , bytes ) with:
                                   gas gas_remaining wei
                                  args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                              mem[mem[64]] = ext_call.return_data[0]
                              if not ext_call.success:
                                  if not return_data.size:
                                      if not mem[96]:
                                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                      revert with memory
                                        from 128
                                         len mem[96]
                                  if not return_data.size:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with ext_call.return_data[0 len return_data.size]
                              _1559 = mem[64]
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              require mem[_1559] == Mask(32, 224, mem[_1559])
                          else:
                              mem[mem[96] + mem[64] + 164] = 0
                              require ext_code.size(to)
                              call to.onERC721Received(address , address , uint256 , bytes ) with:
                                   gas gas_remaining wei
                                  args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                              mem[mem[64]] = ext_call.return_data[0]
                              if not ext_call.success:
                                  if not return_data.size:
                                      if not mem[96]:
                                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                      revert with memory
                                        from 128
                                         len mem[96]
                                  if not return_data.size:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with ext_call.return_data[0 len return_data.size]
                              _1560 = mem[64]
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              require mem[_1560] == Mask(32, 224, mem[_1560])
                      else:
                          _904 = mem[64]
                          mem[64] = mem[64] + 64
                          mem[_904] = stor4[idx].field_0
                          mem[_904 + 32] = stor4[idx].field_160
                          mem[0] = tokenId + 1
                          mem[32] = 4
                          stor4[tokenId + 1].field_0 = stor4[idx].field_0
                          stor4[tokenId + 1].field_160 = stor4[idx].field_160
                          log Transfer(
                                address from=from,
                                address to=to,
                                uint256 value=tokenId)
                          if not ext_code.size(to):
                              stop
                          mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                          mem[mem[64] + 4] = caller
                          mem[mem[64] + 36] = from
                          mem[mem[64] + 68] = tokenId
                          mem[mem[64] + 100] = 128
                          mem[mem[64] + 132] = mem[96]
                          idx = 0
                          while idx < mem[96]:
                              mem[idx + mem[64] + 164] = mem[idx + 128]
                              idx = idx + 32
                              continue 
                          if ceil32(mem[96]) <= mem[96]:
                              require ext_code.size(to)
                              call to.onERC721Received(address , address , uint256 , bytes ) with:
                                   gas gas_remaining wei
                                  args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                              mem[mem[64]] = ext_call.return_data[0]
                              if not ext_call.success:
                                  if not return_data.size:
                                      if not mem[96]:
                                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                      revert with memory
                                        from 128
                                         len mem[96]
                                  if not return_data.size:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with ext_call.return_data[0 len return_data.size]
                              _1561 = mem[64]
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              require mem[_1561] == Mask(32, 224, mem[_1561])
                          else:
                              mem[mem[96] + mem[64] + 164] = 0
                              require ext_code.size(to)
                              call to.onERC721Received(address , address , uint256 , bytes ) with:
                                   gas gas_remaining wei
                                  args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                              mem[mem[64]] = ext_call.return_data[0]
                              if not ext_call.success:
                                  if not return_data.size:
                                      if not mem[96]:
                                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                      revert with memory
                                        from 128
                                         len mem[96]
                                  if not return_data.size:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with ext_call.return_data[0 len return_data.size]
                              _1562 = mem[64]
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              require mem[_1562] == Mask(32, 224, mem[_1562])
              else:
                  if not stor7[stor4[idx].field_0][caller]:
                      revert with 0, 'ERC721A: transfer caller is not owner nor approved'
                  if stor4[idx].field_0 != from:
                      revert with 0, 'ERC721A: transfer from incorrect owner'
                  if not to:
                      revert with 0, 'ERC721A: transfer to the zero address'
                  approved[tokenId] = 0
                  log Approval(
                        address owner=stor4[idx].field_0,
                        address spender=0,
                        uint256 value=tokenId)
                  if balanceOf[address(from)].field_0 < 1:
                      revert with 0, 17
                  balanceOf[address(from)].field_0 = uint128(balanceOf[address(from)].field_0 - 1)
                  mem[0] = to
                  mem[32] = 5
                  if balanceOf[address(to)].field_0 > LOCK8605463013():
                      revert with 0, 17
                  balanceOf[address(to)].field_0 = uint128(balanceOf[address(to)].field_0 + 1)
                  _877 = mem[64]
                  mem[64] = mem[64] + 64
                  mem[_877] = to
                  mem[_877 + 32] = uint64(block.timestamp)
                  stor4[tokenId].field_0 = to
                  stor4[tokenId].field_160 = uint64(block.timestamp)
                  if 1 > !tokenId:
                      revert with 0, 17
                  mem[0] = tokenId + 1
                  mem[32] = 4
                  if stor4[tokenId + 1].field_0:
                      log Transfer(
                            address from=from,
                            address to=to,
                            uint256 value=tokenId)
                      if not ext_code.size(to):
                          stop
                      mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                      mem[mem[64] + 4] = caller
                      mem[mem[64] + 36] = from
                      mem[mem[64] + 68] = tokenId
                      mem[mem[64] + 100] = 128
                      mem[mem[64] + 132] = mem[96]
                      idx = 0
                      while idx < mem[96]:
                          mem[idx + mem[64] + 164] = mem[idx + 128]
                          idx = idx + 32
                          continue 
                      if ceil32(mem[96]) <= mem[96]:
                          require ext_code.size(to)
                          call to.onERC721Received(address , address , uint256 , bytes ) with:
                               gas gas_remaining wei
                              args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              if not return_data.size:
                                  if not mem[96]:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with memory
                                    from 128
                                     len mem[96]
                              if not return_data.size:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with ext_call.return_data[0 len return_data.size]
                          _1563 = mem[64]
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          require mem[_1563] == Mask(32, 224, mem[_1563])
                      else:
                          mem[mem[96] + mem[64] + 164] = 0
                          require ext_code.size(to)
                          call to.onERC721Received(address , address , uint256 , bytes ) with:
                               gas gas_remaining wei
                              args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              if not return_data.size:
                                  if not mem[96]:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with memory
                                    from 128
                                     len mem[96]
                              if not return_data.size:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with ext_call.return_data[0 len return_data.size]
                          _1564 = mem[64]
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          require mem[_1564] == Mask(32, 224, mem[_1564])
                  else:
                      if totalSupply <= tokenId + 1:
                          log Transfer(
                                address from=from,
                                address to=to,
                                uint256 value=tokenId)
                          if not ext_code.size(to):
                              stop
                          mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                          mem[mem[64] + 4] = caller
                          mem[mem[64] + 36] = from
                          mem[mem[64] + 68] = tokenId
                          mem[mem[64] + 100] = 128
                          mem[mem[64] + 132] = mem[96]
                          idx = 0
                          while idx < mem[96]:
                              mem[idx + mem[64] + 164] = mem[idx + 128]
                              idx = idx + 32
                              continue 
                          if ceil32(mem[96]) <= mem[96]:
                              require ext_code.size(to)
                              call to.onERC721Received(address , address , uint256 , bytes ) with:
                                   gas gas_remaining wei
                                  args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                              mem[mem[64]] = ext_call.return_data[0]
                              if not ext_call.success:
                                  if not return_data.size:
                                      if not mem[96]:
                                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                      revert with memory
                                        from 128
                                         len mem[96]
                                  if not return_data.size:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with ext_call.return_data[0 len return_data.size]
                              _1565 = mem[64]
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              require mem[_1565] == Mask(32, 224, mem[_1565])
                          else:
                              mem[mem[96] + mem[64] + 164] = 0
                              require ext_code.size(to)
                              call to.onERC721Received(address , address , uint256 , bytes ) with:
                                   gas gas_remaining wei
                                  args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                              mem[mem[64]] = ext_call.return_data[0]
                              if not ext_call.success:
                                  if not return_data.size:
                                      if not mem[96]:
                                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                      revert with memory
                                        from 128
                                         len mem[96]
                                  if not return_data.size:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with ext_call.return_data[0 len return_data.size]
                              _1566 = mem[64]
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              require mem[_1566] == Mask(32, 224, mem[_1566])
                      else:
                          _934 = mem[64]
                          mem[64] = mem[64] + 64
                          mem[_934] = stor4[idx].field_0
                          mem[_934 + 32] = stor4[idx].field_160
                          mem[0] = tokenId + 1
                          mem[32] = 4
                          stor4[tokenId + 1].field_0 = stor4[idx].field_0
                          stor4[tokenId + 1].field_160 = stor4[idx].field_160
                          log Transfer(
                                address from=from,
                                address to=to,
                                uint256 value=tokenId)
                          if not ext_code.size(to):
                              stop
                          mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                          mem[mem[64] + 4] = caller
                          mem[mem[64] + 36] = from
                          mem[mem[64] + 68] = tokenId
                          mem[mem[64] + 100] = 128
                          mem[mem[64] + 132] = mem[96]
                          idx = 0
                          while idx < mem[96]:
                              mem[idx + mem[64] + 164] = mem[idx + 128]
                              idx = idx + 32
                              continue 
                          if ceil32(mem[96]) <= mem[96]:
                              require ext_code.size(to)
                              call to.onERC721Received(address , address , uint256 , bytes ) with:
                                   gas gas_remaining wei
                                  args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                              mem[mem[64]] = ext_call.return_data[0]
                              if not ext_call.success:
                                  if not return_data.size:
                                      if not mem[96]:
                                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                      revert with memory
                                        from 128
                                         len mem[96]
                                  if not return_data.size:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with ext_call.return_data[0 len return_data.size]
                              _1567 = mem[64]
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              require mem[_1567] == Mask(32, 224, mem[_1567])
                          else:
                              mem[mem[96] + mem[64] + 164] = 0
                              require ext_code.size(to)
                              call to.onERC721Received(address , address , uint256 , bytes ) with:
                                   gas gas_remaining wei
                                  args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                              mem[mem[64]] = ext_call.return_data[0]
                              if not ext_call.success:
                                  if not return_data.size:
                                      if not mem[96]:
                                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                      revert with memory
                                        from 128
                                         len mem[96]
                                  if not return_data.size:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with ext_call.return_data[0 len return_data.size]
                              _1568 = mem[64]
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              require mem[_1568] == Mask(32, 224, mem[_1568])
          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
  else:
      if 1 > !(tokenId - 5):
          revert with 0, 17
      idx = tokenId
      while idx >= tokenId - 4:
          mem[0] = idx
          mem[32] = 4
          _756 = mem[64]
          mem[64] = mem[64] + 64
          mem[_756] = stor4[idx].field_0
          mem[_756 + 32] = stor4[idx].field_160
          if not stor4[idx].field_0:
              if not idx:
                  revert with 0, 17
              idx = idx - 1
              continue 
          if caller == stor4[idx].field_0:
              if stor4[idx].field_0 != from:
                  revert with 0, 'ERC721A: transfer from incorrect owner'
              if not to:
                  revert with 0, 'ERC721A: transfer to the zero address'
              approved[tokenId] = 0
              log Approval(
                    address owner=stor4[idx].field_0,
                    address spender=0,
                    uint256 value=tokenId)
              if balanceOf[address(from)].field_0 < 1:
                  revert with 0, 17
              balanceOf[address(from)].field_0 = uint128(balanceOf[address(from)].field_0 - 1)
              mem[0] = to
              mem[32] = 5
              if balanceOf[address(to)].field_0 > LOCK8605463013():
                  revert with 0, 17
              balanceOf[address(to)].field_0 = uint128(balanceOf[address(to)].field_0 + 1)
              _832 = mem[64]
              mem[64] = mem[64] + 64
              mem[_832] = to
              mem[_832 + 32] = uint64(block.timestamp)
              stor4[tokenId].field_0 = to
              stor4[tokenId].field_160 = uint64(block.timestamp)
              if 1 > !tokenId:
                  revert with 0, 17
              mem[0] = tokenId + 1
              mem[32] = 4
              if stor4[tokenId + 1].field_0:
                  log Transfer(
                        address from=from,
                        address to=to,
                        uint256 value=tokenId)
                  if not ext_code.size(to):
                      stop
                  mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                  mem[mem[64] + 4] = caller
                  mem[mem[64] + 36] = from
                  mem[mem[64] + 68] = tokenId
                  mem[mem[64] + 100] = 128
                  mem[mem[64] + 132] = mem[96]
                  idx = 0
                  while idx < mem[96]:
                      mem[idx + mem[64] + 164] = mem[idx + 128]
                      idx = idx + 32
                      continue 
                  if ceil32(mem[96]) <= mem[96]:
                      require ext_code.size(to)
                      call to.onERC721Received(address , address , uint256 , bytes ) with:
                           gas gas_remaining wei
                          args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                      mem[mem[64]] = ext_call.return_data[0]
                      if not ext_call.success:
                          if not return_data.size:
                              if not mem[96]:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with memory
                                from 128
                                 len mem[96]
                          if not return_data.size:
                              revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                          revert with ext_call.return_data[0 len return_data.size]
                      _1569 = mem[64]
                      mem[64] = mem[64] + ceil32(return_data.size)
                      require return_data.size >=′ 32
                      require mem[_1569] == Mask(32, 224, mem[_1569])
                  else:
                      mem[mem[96] + mem[64] + 164] = 0
                      require ext_code.size(to)
                      call to.onERC721Received(address , address , uint256 , bytes ) with:
                           gas gas_remaining wei
                          args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                      mem[mem[64]] = ext_call.return_data[0]
                      if not ext_call.success:
                          if not return_data.size:
                              if not mem[96]:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with memory
                                from 128
                                 len mem[96]
                          if not return_data.size:
                              revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                          revert with ext_call.return_data[0 len return_data.size]
                      _1570 = mem[64]
                      mem[64] = mem[64] + ceil32(return_data.size)
                      require return_data.size >=′ 32
                      require mem[_1570] == Mask(32, 224, mem[_1570])
              else:
                  if totalSupply <= tokenId + 1:
                      log Transfer(
                            address from=from,
                            address to=to,
                            uint256 value=tokenId)
                      if not ext_code.size(to):
                          stop
                      mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                      mem[mem[64] + 4] = caller
                      mem[mem[64] + 36] = from
                      mem[mem[64] + 68] = tokenId
                      mem[mem[64] + 100] = 128
                      mem[mem[64] + 132] = mem[96]
                      idx = 0
                      while idx < mem[96]:
                          mem[idx + mem[64] + 164] = mem[idx + 128]
                          idx = idx + 32
                          continue 
                      if ceil32(mem[96]) <= mem[96]:
                          require ext_code.size(to)
                          call to.onERC721Received(address , address , uint256 , bytes ) with:
                               gas gas_remaining wei
                              args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              if not return_data.size:
                                  if not mem[96]:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with memory
                                    from 128
                                     len mem[96]
                              if not return_data.size:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with ext_call.return_data[0 len return_data.size]
                          _1571 = mem[64]
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          require mem[_1571] == Mask(32, 224, mem[_1571])
                      else:
                          mem[mem[96] + mem[64] + 164] = 0
                          require ext_code.size(to)
                          call to.onERC721Received(address , address , uint256 , bytes ) with:
                               gas gas_remaining wei
                              args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              if not return_data.size:
                                  if not mem[96]:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with memory
                                    from 128
                                     len mem[96]
                              if not return_data.size:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with ext_call.return_data[0 len return_data.size]
                          _1572 = mem[64]
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          require mem[_1572] == Mask(32, 224, mem[_1572])
                  else:
                      _869 = mem[64]
                      mem[64] = mem[64] + 64
                      mem[_869] = stor4[idx].field_0
                      mem[_869 + 32] = stor4[idx].field_160
                      mem[0] = tokenId + 1
                      mem[32] = 4
                      stor4[tokenId + 1].field_0 = stor4[idx].field_0
                      stor4[tokenId + 1].field_160 = stor4[idx].field_160
                      log Transfer(
                            address from=from,
                            address to=to,
                            uint256 value=tokenId)
                      if not ext_code.size(to):
                          stop
                      mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                      mem[mem[64] + 4] = caller
                      mem[mem[64] + 36] = from
                      mem[mem[64] + 68] = tokenId
                      mem[mem[64] + 100] = 128
                      mem[mem[64] + 132] = mem[96]
                      idx = 0
                      while idx < mem[96]:
                          mem[idx + mem[64] + 164] = mem[idx + 128]
                          idx = idx + 32
                          continue 
                      if ceil32(mem[96]) <= mem[96]:
                          require ext_code.size(to)
                          call to.onERC721Received(address , address , uint256 , bytes ) with:
                               gas gas_remaining wei
                              args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              if not return_data.size:
                                  if not mem[96]:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with memory
                                    from 128
                                     len mem[96]
                              if not return_data.size:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with ext_call.return_data[0 len return_data.size]
                          _1573 = mem[64]
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          require mem[_1573] == Mask(32, 224, mem[_1573])
                      else:
                          mem[mem[96] + mem[64] + 164] = 0
                          require ext_code.size(to)
                          call to.onERC721Received(address , address , uint256 , bytes ) with:
                               gas gas_remaining wei
                              args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              if not return_data.size:
                                  if not mem[96]:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with memory
                                    from 128
                                     len mem[96]
                              if not return_data.size:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with ext_call.return_data[0 len return_data.size]
                          _1574 = mem[64]
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          require mem[_1574] == Mask(32, 224, mem[_1574])
          else:
              if totalSupply <= tokenId:
                  revert with 0, 'ERC721A: approved query for nonexistent token'
              if approved[tokenId] == caller:
                  if stor4[idx].field_0 != from:
                      revert with 0, 'ERC721A: transfer from incorrect owner'
                  if not to:
                      revert with 0, 'ERC721A: transfer to the zero address'
                  approved[tokenId] = 0
                  log Approval(
                        address owner=stor4[idx].field_0,
                        address spender=0,
                        uint256 value=tokenId)
                  if balanceOf[address(from)].field_0 < 1:
                      revert with 0, 17
                  balanceOf[address(from)].field_0 = uint128(balanceOf[address(from)].field_0 - 1)
                  mem[0] = to
                  mem[32] = 5
                  if balanceOf[address(to)].field_0 > LOCK8605463013():
                      revert with 0, 17
                  balanceOf[address(to)].field_0 = uint128(balanceOf[address(to)].field_0 + 1)
                  _855 = mem[64]
                  mem[64] = mem[64] + 64
                  mem[_855] = to
                  mem[_855 + 32] = uint64(block.timestamp)
                  stor4[tokenId].field_0 = to
                  stor4[tokenId].field_160 = uint64(block.timestamp)
                  if 1 > !tokenId:
                      revert with 0, 17
                  mem[0] = tokenId + 1
                  mem[32] = 4
                  if stor4[tokenId + 1].field_0:
                      log Transfer(
                            address from=from,
                            address to=to,
                            uint256 value=tokenId)
                      if not ext_code.size(to):
                          stop
                      mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                      mem[mem[64] + 4] = caller
                      mem[mem[64] + 36] = from
                      mem[mem[64] + 68] = tokenId
                      mem[mem[64] + 100] = 128
                      mem[mem[64] + 132] = mem[96]
                      idx = 0
                      while idx < mem[96]:
                          mem[idx + mem[64] + 164] = mem[idx + 128]
                          idx = idx + 32
                          continue 
                      if ceil32(mem[96]) <= mem[96]:
                          require ext_code.size(to)
                          call to.onERC721Received(address , address , uint256 , bytes ) with:
                               gas gas_remaining wei
                              args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              if not return_data.size:
                                  if not mem[96]:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with memory
                                    from 128
                                     len mem[96]
                              if not return_data.size:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with ext_call.return_data[0 len return_data.size]
                          _1575 = mem[64]
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          require mem[_1575] == Mask(32, 224, mem[_1575])
                      else:
                          mem[mem[96] + mem[64] + 164] = 0
                          require ext_code.size(to)
                          call to.onERC721Received(address , address , uint256 , bytes ) with:
                               gas gas_remaining wei
                              args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              if not return_data.size:
                                  if not mem[96]:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with memory
                                    from 128
                                     len mem[96]
                              if not return_data.size:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with ext_call.return_data[0 len return_data.size]
                          _1576 = mem[64]
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          require mem[_1576] == Mask(32, 224, mem[_1576])
                  else:
                      if totalSupply <= tokenId + 1:
                          log Transfer(
                                address from=from,
                                address to=to,
                                uint256 value=tokenId)
                          if not ext_code.size(to):
                              stop
                          mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                          mem[mem[64] + 4] = caller
                          mem[mem[64] + 36] = from
                          mem[mem[64] + 68] = tokenId
                          mem[mem[64] + 100] = 128
                          mem[mem[64] + 132] = mem[96]
                          idx = 0
                          while idx < mem[96]:
                              mem[idx + mem[64] + 164] = mem[idx + 128]
                              idx = idx + 32
                              continue 
                          if ceil32(mem[96]) <= mem[96]:
                              require ext_code.size(to)
                              call to.onERC721Received(address , address , uint256 , bytes ) with:
                                   gas gas_remaining wei
                                  args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                              mem[mem[64]] = ext_call.return_data[0]
                              if not ext_call.success:
                                  if not return_data.size:
                                      if not mem[96]:
                                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                      revert with memory
                                        from 128
                                         len mem[96]
                                  if not return_data.size:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with ext_call.return_data[0 len return_data.size]
                              _1577 = mem[64]
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              require mem[_1577] == Mask(32, 224, mem[_1577])
                          else:
                              mem[mem[96] + mem[64] + 164] = 0
                              require ext_code.size(to)
                              call to.onERC721Received(address , address , uint256 , bytes ) with:
                                   gas gas_remaining wei
                                  args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                              mem[mem[64]] = ext_call.return_data[0]
                              if not ext_call.success:
                                  if not return_data.size:
                                      if not mem[96]:
                                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                      revert with memory
                                        from 128
                                         len mem[96]
                                  if not return_data.size:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with ext_call.return_data[0 len return_data.size]
                              _1578 = mem[64]
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              require mem[_1578] == Mask(32, 224, mem[_1578])
                      else:
                          _915 = mem[64]
                          mem[64] = mem[64] + 64
                          mem[_915] = stor4[idx].field_0
                          mem[_915 + 32] = stor4[idx].field_160
                          mem[0] = tokenId + 1
                          mem[32] = 4
                          stor4[tokenId + 1].field_0 = stor4[idx].field_0
                          stor4[tokenId + 1].field_160 = stor4[idx].field_160
                          log Transfer(
                                address from=from,
                                address to=to,
                                uint256 value=tokenId)
                          if not ext_code.size(to):
                              stop
                          mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                          mem[mem[64] + 4] = caller
                          mem[mem[64] + 36] = from
                          mem[mem[64] + 68] = tokenId
                          mem[mem[64] + 100] = 128
                          mem[mem[64] + 132] = mem[96]
                          idx = 0
                          while idx < mem[96]:
                              mem[idx + mem[64] + 164] = mem[idx + 128]
                              idx = idx + 32
                              continue 
                          if ceil32(mem[96]) <= mem[96]:
                              require ext_code.size(to)
                              call to.onERC721Received(address , address , uint256 , bytes ) with:
                                   gas gas_remaining wei
                                  args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                              mem[mem[64]] = ext_call.return_data[0]
                              if not ext_call.success:
                                  if not return_data.size:
                                      if not mem[96]:
                                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                      revert with memory
                                        from 128
                                         len mem[96]
                                  if not return_data.size:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with ext_call.return_data[0 len return_data.size]
                              _1579 = mem[64]
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              require mem[_1579] == Mask(32, 224, mem[_1579])
                          else:
                              mem[mem[96] + mem[64] + 164] = 0
                              require ext_code.size(to)
                              call to.onERC721Received(address , address , uint256 , bytes ) with:
                                   gas gas_remaining wei
                                  args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                              mem[mem[64]] = ext_call.return_data[0]
                              if not ext_call.success:
                                  if not return_data.size:
                                      if not mem[96]:
                                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                      revert with memory
                                        from 128
                                         len mem[96]
                                  if not return_data.size:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with ext_call.return_data[0 len return_data.size]
                              _1580 = mem[64]
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              require mem[_1580] == Mask(32, 224, mem[_1580])
              else:
                  if not stor7[stor4[idx].field_0][caller]:
                      revert with 0, 'ERC721A: transfer caller is not owner nor approved'
                  if stor4[idx].field_0 != from:
                      revert with 0, 'ERC721A: transfer from incorrect owner'
                  if not to:
                      revert with 0, 'ERC721A: transfer to the zero address'
                  approved[tokenId] = 0
                  log Approval(
                        address owner=stor4[idx].field_0,
                        address spender=0,
                        uint256 value=tokenId)
                  if balanceOf[address(from)].field_0 < 1:
                      revert with 0, 17
                  balanceOf[address(from)].field_0 = uint128(balanceOf[address(from)].field_0 - 1)
                  mem[0] = to
                  mem[32] = 5
                  if balanceOf[address(to)].field_0 > LOCK8605463013():
                      revert with 0, 17
                  balanceOf[address(to)].field_0 = uint128(balanceOf[address(to)].field_0 + 1)
                  _883 = mem[64]
                  mem[64] = mem[64] + 64
                  mem[_883] = to
                  mem[_883 + 32] = uint64(block.timestamp)
                  stor4[tokenId].field_0 = to
                  stor4[tokenId].field_160 = uint64(block.timestamp)
                  if 1 > !tokenId:
                      revert with 0, 17
                  mem[0] = tokenId + 1
                  mem[32] = 4
                  if stor4[tokenId + 1].field_0:
                      log Transfer(
                            address from=from,
                            address to=to,
                            uint256 value=tokenId)
                      if not ext_code.size(to):
                          stop
                      mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                      mem[mem[64] + 4] = caller
                      mem[mem[64] + 36] = from
                      mem[mem[64] + 68] = tokenId
                      mem[mem[64] + 100] = 128
                      mem[mem[64] + 132] = mem[96]
                      idx = 0
                      while idx < mem[96]:
                          mem[idx + mem[64] + 164] = mem[idx + 128]
                          idx = idx + 32
                          continue 
                      if ceil32(mem[96]) <= mem[96]:
                          require ext_code.size(to)
                          call to.onERC721Received(address , address , uint256 , bytes ) with:
                               gas gas_remaining wei
                              args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              if not return_data.size:
                                  if not mem[96]:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with memory
                                    from 128
                                     len mem[96]
                              if not return_data.size:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with ext_call.return_data[0 len return_data.size]
                          _1581 = mem[64]
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          require mem[_1581] == Mask(32, 224, mem[_1581])
                      else:
                          mem[mem[96] + mem[64] + 164] = 0
                          require ext_code.size(to)
                          call to.onERC721Received(address , address , uint256 , bytes ) with:
                               gas gas_remaining wei
                              args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                          mem[mem[64]] = ext_call.return_data[0]
                          if not ext_call.success:
                              if not return_data.size:
                                  if not mem[96]:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with memory
                                    from 128
                                     len mem[96]
                              if not return_data.size:
                                  revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                              revert with ext_call.return_data[0 len return_data.size]
                          _1582 = mem[64]
                          mem[64] = mem[64] + ceil32(return_data.size)
                          require return_data.size >=′ 32
                          require mem[_1582] == Mask(32, 224, mem[_1582])
                  else:
                      if totalSupply <= tokenId + 1:
                          log Transfer(
                                address from=from,
                                address to=to,
                                uint256 value=tokenId)
                          if not ext_code.size(to):
                              stop
                          mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                          mem[mem[64] + 4] = caller
                          mem[mem[64] + 36] = from
                          mem[mem[64] + 68] = tokenId
                          mem[mem[64] + 100] = 128
                          mem[mem[64] + 132] = mem[96]
                          idx = 0
                          while idx < mem[96]:
                              mem[idx + mem[64] + 164] = mem[idx + 128]
                              idx = idx + 32
                              continue 
                          if ceil32(mem[96]) <= mem[96]:
                              require ext_code.size(to)
                              call to.onERC721Received(address , address , uint256 , bytes ) with:
                                   gas gas_remaining wei
                                  args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                              mem[mem[64]] = ext_call.return_data[0]
                              if not ext_call.success:
                                  if not return_data.size:
                                      if not mem[96]:
                                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                      revert with memory
                                        from 128
                                         len mem[96]
                                  if not return_data.size:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with ext_call.return_data[0 len return_data.size]
                              _1583 = mem[64]
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              require mem[_1583] == Mask(32, 224, mem[_1583])
                          else:
                              mem[mem[96] + mem[64] + 164] = 0
                              require ext_code.size(to)
                              call to.onERC721Received(address , address , uint256 , bytes ) with:
                                   gas gas_remaining wei
                                  args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                              mem[mem[64]] = ext_call.return_data[0]
                              if not ext_call.success:
                                  if not return_data.size:
                                      if not mem[96]:
                                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                      revert with memory
                                        from 128
                                         len mem[96]
                                  if not return_data.size:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with ext_call.return_data[0 len return_data.size]
                              _1584 = mem[64]
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              require mem[_1584] == Mask(32, 224, mem[_1584])
                      else:
                          _945 = mem[64]
                          mem[64] = mem[64] + 64
                          mem[_945] = stor4[idx].field_0
                          mem[_945 + 32] = stor4[idx].field_160
                          mem[0] = tokenId + 1
                          mem[32] = 4
                          stor4[tokenId + 1].field_0 = stor4[idx].field_0
                          stor4[tokenId + 1].field_160 = stor4[idx].field_160
                          log Transfer(
                                address from=from,
                                address to=to,
                                uint256 value=tokenId)
                          if not ext_code.size(to):
                              stop
                          mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                          mem[mem[64] + 4] = caller
                          mem[mem[64] + 36] = from
                          mem[mem[64] + 68] = tokenId
                          mem[mem[64] + 100] = 128
                          mem[mem[64] + 132] = mem[96]
                          idx = 0
                          while idx < mem[96]:
                              mem[idx + mem[64] + 164] = mem[idx + 128]
                              idx = idx + 32
                              continue 
                          if ceil32(mem[96]) <= mem[96]:
                              require ext_code.size(to)
                              call to.onERC721Received(address , address , uint256 , bytes ) with:
                                   gas gas_remaining wei
                                  args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                              mem[mem[64]] = ext_call.return_data[0]
                              if not ext_call.success:
                                  if not return_data.size:
                                      if not mem[96]:
                                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                      revert with memory
                                        from 128
                                         len mem[96]
                                  if not return_data.size:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with ext_call.return_data[0 len return_data.size]
                              _1585 = mem[64]
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              require mem[_1585] == Mask(32, 224, mem[_1585])
                          else:
                              mem[mem[96] + mem[64] + 164] = 0
                              require ext_code.size(to)
                              call to.onERC721Received(address , address , uint256 , bytes ) with:
                                   gas gas_remaining wei
                                  args caller, address(from), tokenId, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                              mem[mem[64]] = ext_call.return_data[0]
                              if not ext_call.success:
                                  if not return_data.size:
                                      if not mem[96]:
                                          revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                      revert with memory
                                        from 128
                                         len mem[96]
                                  if not return_data.size:
                                      revert with 0, 'ERC721A: transfer to non ERC721Receiver implementer'
                                  revert with ext_call.return_data[0 len return_data.size]
                              _1586 = mem[64]
                              mem[64] = mem[64] + ceil32(return_data.size)
                              require return_data.size >=′ 32
                              require mem[_1586] == Mask(32, 224, mem[_1586])
          ...  # Decompilation aborted, sorry: ("decompilation didn't finish",)
  revert with 0, 'ERC721A: unable to determine the owner of token'


