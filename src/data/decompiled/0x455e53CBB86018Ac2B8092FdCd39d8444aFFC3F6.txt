# Palkeoramix decompiler. 

def storage:
  balanceOf is mapping of uint256 at storage 0
  stor1 is mapping of uint256 at storage 1
  totalSupply is uint256 at storage 2
  stor3 is bool at storage 3
  stor3 is uint8 at storage 3
  stor3 is uint8 at storage 3 offset 1
  stor3 is uint256 at storage 3
  stor4 is bool at storage 4
  stor4 is uint8 at storage 4
  stor4 is uint8 at storage 4 offset 1
  stor4 is uint256 at storage 4
  nonces is mapping of uint256 at storage 7
  roleAdmin is mapping of struct at storage 9
  roleMember is array of struct at storage 10
  unknown8eb66d6a is uint256 at storage 11
  lastMint is uint256 at storage 12
  unknown407c48b4 is uint8 at storage 13

def totalSupply(): # not payable
  require calldata.size - 4 >=′ 0
  return totalSupply

def getRoleAdmin(bytes32 role): # not payable
  require calldata.size - 4 >=′ 32
  return roleAdmin[role].field_256

def unknown407c48b4(): # not payable
  require calldata.size - 4 >=′ 0
  return bool(unknown407c48b4)

def lastMint(): # not payable
  require calldata.size - 4 >=′ 0
  return lastMint

def balanceOf(address account): # not payable
  require calldata.size - 4 >=′ 32
  require not Mask(96, 160, account)
  return balanceOf[address(account)]

def nonces(address _param1): # not payable
  require calldata.size - 4 >=′ 32
  require not Mask(96, 160, _param1)
  return nonces[address(_param1)]

def unknown8eb66d6a(): # not payable
  require calldata.size - 4 >=′ 0
  return unknown8eb66d6a

def getRoleMember(bytes32 role, uint256 index): # not payable
  require calldata.size - 4 >=′ 64
  if index >= roleMember[role].field_0:
      revert with 0, 50
  return address(roleMember[role][index].field_0)

def hasRole(bytes32 role, address account): # not payable
  require calldata.size - 4 >=′ 64
  require not Mask(96, 160, account)
  return bool(uint8(roleAdmin[role][address(account)].field_0))

def getRoleMemberCount(bytes32 role): # not payable
  require calldata.size - 4 >=′ 32
  return roleMember[role].field_0

#
#  Regular functions
#

def decimals(): # not payable
  require calldata.size - 4 >=′ 0
  return 18

def version(): # not payable
  require calldata.size - 4 >=′ 0
  return '', 0

def DEFAULT_ADMIN_ROLE(): # not payable
  require calldata.size - 4 >=′ 0
  return 0

def unknown6afdd850(): # not payable
  require calldata.size - 4 >=′ 0
  return 0x22d473030f116ddee9f6b43ac78ba3

def unknown2e285051(): # not payable
  require calldata.size - 4 >=′ 0
  return 0x573321b8a13c75b2702bc4b0ad9afaae98bf6985285411964a564e68bf6da1c9

def CAP_MANAGER_ROLE(): # not payable
  require calldata.size - 4 >=′ 0
  return 0x27f9f680a0c6704fd9796b55c67fe885252243966ecb05a88f3e7873c845d9a

def unknownfadd1a1b(): # not payable
  require calldata.size - 4 >=′ 0
  return 0xbd4c1461ef59750b24719a44d7e2a7948c57fd12c98e333541b7ea7b61f07cb7

def unknown84b0196e(): # not payable
  require calldata.size - 4 >=′ 0
  return 0xf00000000000000000000000000000000000000000000000000000000000000, 
         224,
         288,
         chainid,
         this.address,
         0,
         352,
         23,
         0x506f6c79676f6e2045636f737973,
         0,
         1,
         49,
         0,
         0

def allowance(address owner, address spender): # not payable
  require calldata.size - 4 >=′ 64
  require not Mask(96, 160, owner)
  require not Mask(96, 160, spender)
  if spender == 0x22d473030f116ddee9f6b43ac78ba3:
      if unknown407c48b4:
          return -1
  return stor1[address(owner)][address(spender)]

def supportsInterface(bytes4 interfaceId): # not payable
  require calldata.size - 4 >=′ 32
  require not interfaceId - Mask(32, 224, interfaceId)
  if Mask(32, 224, interfaceId) == 0x5a05180f00000000000000000000000000000000000000000000000000000000:
      return True
  if Mask(32, 224, interfaceId) != 0x7965db0b00000000000000000000000000000000000000000000000000000000:
      return (0x1ffc9a700000000000000000000000000000000000000000000000000000000 == Mask(32, 224, interfaceId))
  return (Mask(32, 224, interfaceId) == 0x7965db0b00000000000000000000000000000000000000000000000000000000)

def approve(address spender, uint256 amount): # not payable
  require calldata.size - 4 >=′ 64
  require not Mask(96, 160, spender)
  if not caller:
      revert with Error(string reason), 'ERC20: approve from the zero address'
  if not spender:
      revert with Error(string reason), 'ERC20: approve to the zero address'
  stor1[caller][address(spender)] = amount
  log Approval(
        address owner=amount,
        address spender=caller,
        uint256 value=spender)
  return 1

def DOMAIN_SEPARATOR(): # not payable
  require calldata.size - 4 >=′ 0
  if this.address != 0x455e53cbb86018ac2b8092fdcd39d8444affc3f6:
      return sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0xafdc6b3596f2bc7878c706fa55d5aabb82790c51a37e088a158406cea4025910, 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6, chainid, this.address)
  if 1 != chainid:
      return sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0xafdc6b3596f2bc7878c706fa55d5aabb82790c51a37e088a158406cea4025910, 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6, chainid, this.address)
  return 0xb229387d8db422d84103ea5884522a783e8f8b570d17cc1e9bb39959983346f8

def transfer(address recipient, uint256 amount): # not payable
  require calldata.size - 4 >=′ 64
  require not Mask(96, 160, recipient)
  if not caller:
      revert with Error(string reason), 'ERC20: transfer from the zero address'
  if not recipient:
      revert with Error(string reason), 'ERC20: transfer to the zero address'
  if balanceOf[caller] < amount:
      revert with Error(string reason), 'ERC20: transfer amount exceeds balance'
  balanceOf[caller] -= amount
  balanceOf[recipient] += amount
  log Transfer(
        address from=amount,
        address to=caller,
        uint256 value=recipient)
  return 1

def unknownff740c31(uint256 _param1): # not payable
  require calldata.size - 4 >=′ 32
  if uint8(roleAdmin[0x27f9f680a0c6704fd9796b55c67fe885252243966ecb05a88f3e7873c845d9a][caller].field_0):
      log 0xed4079ad: unknown8eb66d6a, _param1
      unknown8eb66d6a = _param1
      return 0
  idx = 41
  s = caller
  while idx > 1:
      if s % 16 >= 16:
          revert with 0, 50
      if idx >= 42:
          revert with 0, 50
      mem[idx + 128 len 8] = 0
      if not idx:
          revert with 0, 17
      idx = idx - 1
      s = Mask(252, 0, s) * 0.0625
      continue 
  if not caller + 10240:
      idx = 65
      s = 0x27f9f680a0c6704fd9796b55c67fe885252243966ecb05a88f3e7873c845d9a
      while idx > 1:
          if s % 16 >= 16:
              revert with 0, 50
          if idx >= 66:
              revert with 0, 50
          mem[idx + 224 len 8] = 0
          if not idx:
              revert with 0, 17
          idx = idx - 1
          s = Mask(252, 0, s) * 0.0625
          continue 
  revert with Error(string reason), 32, 32, 0xfe537472696e67733a20686578206c656e67746820696e73756666696369656e

def unknown705e6a5b(uint256 _param1): # not payable
  require calldata.size - 4 >=′ 32
  require not _param1 - bool(_param1)
  if uint8(roleAdmin[0xbd4c1461ef59750b24719a44d7e2a7948c57fd12c98e333541b7ea7b61f07cb7][caller].field_0):
      log 0x383d8f27: bool(_param1)
      unknown407c48b4 = uint8(bool(_param1))
      return 0
  mem[128 len 64] = call.data[calldata.size len 64]
  idx = 41
  s = caller
  while idx > 1:
      if s % 16 >= 16:
          revert with 0, 50
      if idx >= 42:
          revert with 0, 50
      mem[idx + 128 len 8] = 0
      if not idx:
          revert with 0, 17
      idx = idx - 1
      s = Mask(252, 0, s) * 0.0625
      continue 
  if caller + 10240:
      revert with Error(string reason), 32, 32, 0xfe537472696e67733a20686578206c656e67746820696e73756666696369656e
  mem[224 len 96] = call.data[calldata.size len 96]
  idx = 65
  s = 0xbd4c1461ef59750b24719a44d7e2a7948c57fd12c98e333541b7ea7b61f07cb7
  while idx > 1:
      if s % 16 >= 16:
          revert with 0, 50
      if idx >= 66:
          revert with 0, 50
      mem[idx + 224 len 8] = 0
      if not idx:
          revert with 0, 17
      idx = idx - 1
      s = Mask(252, 0, s) * 0.0625
      continue 
  revert with Error(string reason), 
              32,
              148,
              0x416363657373436f6e74726f6c3a, mem[160 len 42], 8297, mem[288 len 66], 0, None >> 928,
              0

def increaseAllowance(address spender, uint256 addedValue): # not payable
  require calldata.size - 4 >=′ 64
  require not Mask(96, 160, spender)
  if spender != 0x22d473030f116ddee9f6b43ac78ba3:
      if stor1[caller][address(spender)] > stor1[caller][address(spender)] + addedValue:
          revert with 0, 17
      if not caller:
          revert with Error(string reason), 'ERC20: approve from the zero address'
      if not spender:
          revert with Error(string reason), 'ERC20: approve to the zero address'
      stor1[caller][address(spender)] += addedValue
      log Approval(
            address owner=(stor1[caller][address(spender)] + addedValue),
            address spender=caller,
            uint256 value=spender)
  else:
      if unknown407c48b4:
          if -1 > addedValue - 1:
              revert with 0, 17
          if not caller:
              revert with Error(string reason), 'ERC20: approve from the zero address'
          if not spender:
              revert with Error(string reason), 'ERC20: approve to the zero address'
          stor1[caller][address(spender)] = addedValue - 1
          log Approval(
                address owner=(addedValue - 1),
                address spender=caller,
                uint256 value=spender)
      else:
          if stor1[caller][address(spender)] > stor1[caller][address(spender)] + addedValue:
              revert with 0, 17
          if not caller:
              revert with Error(string reason), 'ERC20: approve from the zero address'
          if not spender:
              revert with Error(string reason), 'ERC20: approve to the zero address'
          stor1[caller][address(spender)] += addedValue
          log Approval(
                address owner=(stor1[caller][address(spender)] + addedValue),
                address spender=caller,
                uint256 value=spender)
  return 1

def decreaseAllowance(address spender, uint256 subtractedValue): # not payable
  require calldata.size - 4 >=′ 64
  require not Mask(96, 160, spender)
  if spender != 0x22d473030f116ddee9f6b43ac78ba3:
      if stor1[caller][address(spender)] < subtractedValue:
          revert with Error(string reason), 'ERC20: decreased allowance below zero'
      if not caller:
          revert with Error(string reason), 'ERC20: approve from the zero address'
      if not spender:
          revert with Error(string reason), 'ERC20: approve to the zero address'
      stor1[caller][address(spender)] -= subtractedValue
      log Approval(
            address owner=(stor1[caller][address(spender)] - subtractedValue),
            address spender=caller,
            uint256 value=spender)
  else:
      if unknown407c48b4:
          if -1 < subtractedValue:
              revert with Error(string reason), 'ERC20: decreased allowance below zero'
          if not caller:
              revert with Error(string reason), 'ERC20: approve from the zero address'
          if not spender:
              revert with Error(string reason), 'ERC20: approve to the zero address'
          stor1[caller][address(spender)] = -subtractedValue - 1
          log Approval(
                address owner=(-subtractedValue - 1),
                address spender=caller,
                uint256 value=spender)
      else:
          if stor1[caller][address(spender)] < subtractedValue:
              revert with Error(string reason), 'ERC20: decreased allowance below zero'
          if not caller:
              revert with Error(string reason), 'ERC20: approve from the zero address'
          if not spender:
              revert with Error(string reason), 'ERC20: approve to the zero address'
          stor1[caller][address(spender)] -= subtractedValue
          log Approval(
                address owner=(stor1[caller][address(spender)] - subtractedValue),
                address spender=caller,
                uint256 value=spender)
  return 1

def mint(address _to, uint256 _amount): # not payable
  require calldata.size - 4 >=′ 64
  require not Mask(96, 160, _to)
  if not uint8(roleAdmin[0x573321b8a13c75b2702bc4b0ad9afaae98bf6985285411964a564e68bf6da1c9][caller].field_0):
      idx = 41
      s = caller
      while idx > 1:
          if s % 16 >= 16:
              revert with 0, 50
          if idx >= 42:
              revert with 0, 50
          mem[idx + 128 len 8] = 0
          if not idx:
              revert with 0, 17
          idx = idx - 1
          s = Mask(252, 0, s) * 0.0625
          continue 
      if not caller + 10240:
          idx = 65
          s = 0x573321b8a13c75b2702bc4b0ad9afaae98bf6985285411964a564e68bf6da1c9
          while idx > 1:
              if s % 16 >= 16:
                  revert with 0, 50
              if idx >= 66:
                  revert with 0, 50
              mem[idx + 224 len 8] = 0
              if not idx:
                  revert with 0, 17
              idx = idx - 1
              s = Mask(252, 0, s) * 0.0625
              continue 
      revert with Error(string reason), 32, 32, 0xfe537472696e67733a20686578206c656e67746820696e73756666696369656e
  if block.timestamp - lastMint > block.timestamp:
      revert with 0, 17
  if lastMint != block.timestamp and (block.timestamp * unknown8eb66d6a) - (lastMint * unknown8eb66d6a) / block.timestamp - lastMint != unknown8eb66d6a:
      revert with 0, 17
  if _amount > (block.timestamp * unknown8eb66d6a) - (lastMint * unknown8eb66d6a):
      revert with 1541212405, (block.timestamp * unknown8eb66d6a) - (lastMint * unknown8eb66d6a), _amount
  lastMint = block.timestamp
  if not _to:
      revert with Error(string reason), 'ERC20: mint to the zero address'
  if totalSupply > totalSupply + _amount:
      revert with 0, 17
  totalSupply += _amount
  balanceOf[address(_to)] += _amount
  log Transfer(
        address from=_amount,
        address to=0,
        uint256 value=_to)
  return 0

def transferFrom(address sender, address recipient, uint256 amount): # not payable
  require calldata.size - 4 >=′ 96
  require not Mask(96, 160, sender)
  require not Mask(96, 160, recipient)
  if 0x22d473030f116ddee9f6b43ac78ba3 != caller:
      if stor1[address(sender)][caller] + 1:
          if stor1[address(sender)][caller] < amount:
              revert with Error(string reason), 'ERC20: insufficient allowance'
          if not sender:
              revert with Error(string reason), 'ERC20: approve from the zero address'
          if not caller:
              revert with Error(string reason), 'ERC20: approve to the zero address'
          stor1[address(sender)][caller] -= amount
          log Approval(
                address owner=(stor1[address(sender)][caller] - amount),
                address spender=sender,
                uint256 value=caller)
  else:
      if not unknown407c48b4:
          if stor1[address(sender)][caller] + 1:
              if stor1[address(sender)][caller] < amount:
                  revert with Error(string reason), 'ERC20: insufficient allowance'
              if not sender:
                  revert with Error(string reason), 'ERC20: approve from the zero address'
              if not caller:
                  revert with Error(string reason), 'ERC20: approve to the zero address'
              stor1[address(sender)][caller] -= amount
              log Approval(
                    address owner=(stor1[address(sender)][caller] - amount),
                    address spender=sender,
                    uint256 value=caller)
  if not sender:
      revert with Error(string reason), 'ERC20: transfer from the zero address'
  if not recipient:
      revert with Error(string reason), 'ERC20: transfer to the zero address'
  if balanceOf[address(sender)] < amount:
      revert with Error(string reason), 'ERC20: transfer amount exceeds balance'
  balanceOf[address(sender)] -= amount
  balanceOf[recipient] += amount
  log Transfer(
        address from=amount,
        address to=sender,
        uint256 value=recipient)
  return 1

def permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s): # not payable
  require calldata.size - 4 >=′ 224
  require not Mask(96, 160, owner)
  require not Mask(96, 160, spender)
  require not Mask(248, 8, v)
  if block.timestamp > deadline:
      revert with Error(string reason), 'ERC20Permit: expired deadline'
  nonces[address(owner)]++
  if s > 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0:
      revert with Error(string reason), 'ECDSA: invalid signature 's' value'
  if this.address != 0x455e53cbb86018ac2b8092fdcd39d8444affc3f6:
      signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0xafdc6b3596f2bc7878c706fa55d5aabb82790c51a37e088a158406cea4025910, 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6, chainid, this.address), sha3(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9, address(owner), address(spender), value, nonces[address(owner)], deadline)), v << 248, r, s) # precompiled
  else:
      if 1 != chainid:
          signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0xafdc6b3596f2bc7878c706fa55d5aabb82790c51a37e088a158406cea4025910, 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6, chainid, this.address), sha3(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9, address(owner), address(spender), value, nonces[address(owner)], deadline)), v << 248, r, s) # precompiled
      else:
          signer = erecover(sha3(6401, 0xb229387d8db422d84103ea5884522a783e8f8b570d17cc1e9bb39959983346f8, sha3(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9, address(owner), address(spender), value, nonces[address(owner)], deadline)), v << 248, r, s) # precompiled
  if not erecover.result:
      revert with ext_call.return_data[0 len return_data.size]
  if not address(signer):
      revert with Error(string reason), 'ECDSA: invalid signature'
  if address(signer) - owner:
      revert with Error(string reason), 'ERC20Permit: invalid signature'
  if not owner:
      revert with Error(string reason), 'ERC20: approve from the zero address'
  if not spender:
      revert with Error(string reason), 'ERC20: approve to the zero address'
  stor1[address(owner)][address(spender)] = value
  log Approval(
        address owner=value,
        address spender=owner,
        uint256 value=spender)
  return 0

def renounceRole(bytes32 role, address account): # not payable
  require calldata.size - 4 >=′ 64
  require not Mask(96, 160, account)
  if account - caller:
      revert with Error(string reason), 'AccessControl: can only renounce roles for self'
  if uint8(roleAdmin[role][address(account)].field_0):
      uint8(roleAdmin[role][address(account)].field_0) = 0
      log RoleRevoked(
            bytes32 role=role,
            address account=account,
            address sender=caller)
  if roleMember[role][1][address(account)].field_0:
      if roleMember[role][1][address(account)].field_0 - 1 > roleMember[role][1][address(account)].field_0:
          revert with 0, 17
      if roleMember[role].field_0 - 1 > roleMember[role].field_0:
          revert with 0, 17
      if roleMember[role].field_0 - roleMember[role][1][address(account)].field_0:
          if roleMember[role].field_0 - 1 >= roleMember[role].field_0:
              revert with 0, 50
          if roleMember[role][1][address(account)].field_0 - 1 >= roleMember[role].field_0:
              revert with 0, 50
          roleMember[role][roleMember[role][1][address(account)].field_0].field_0 = roleMember[role][roleMember[role].field_0].field_0
          roleMember[role][1][roleMember[role][roleMember[role].field_0].field_0].field_0 = roleMember[role][1][address(account)].field_0
      if not roleMember[role].field_0:
          revert with 0, 49
      if roleMember[role].field_0 - 1 >= roleMember[role].field_0:
          revert with 0, 50
      roleMember[role][roleMember[role].field_0].field_0 = 0
      roleMember[role].field_0--
      roleMember[role][1][address(account)].field_0 = 0
      return 0
  else:
      return 0

def grantRole(bytes32 role, address account): # not payable
  require calldata.size - 4 >=′ 64
  require not Mask(96, 160, account)
  if not uint8(roleAdmin[roleAdmin[role].field_256][caller].field_0):
      mem[128 len 64] = call.data[calldata.size len 64]
      idx = 41
      s = caller
      while idx > 1:
          if s % 16 >= 16:
              revert with 0, 50
          if idx >= 42:
              revert with 0, 50
          mem[idx + 128 len 8] = 0
          if not idx:
              revert with 0, 17
          idx = idx - 1
          s = Mask(252, 0, s) * 0.0625
          continue 
      if not caller + 10240:
          mem[224 len 96] = call.data[calldata.size len 96]
          idx = 65
          s = roleAdmin[role].field_256
          while idx > 1:
              if s % 16 >= 16:
                  revert with 0, 50
              if idx >= 66:
                  revert with 0, 50
              mem[idx + 224 len 8] = 0
              if not idx:
                  revert with 0, 17
              idx = idx - 1
              s = Mask(252, 0, s) * 0.0625
              continue 
          if not roleAdmin[role].field_256 + 16384:
              revert with Error(string reason), 
                          32,
                          148,
                          0x416363657373436f6e74726f6c3a, mem[160 len 42], 8297, mem[288 len 66], 0, None >> 928,
                          0
      revert with Error(string reason), 32, 32, 0xfe537472696e67733a20686578206c656e67746820696e73756666696369656e
  if not uint8(roleAdmin[role][address(account)].field_0):
      uint8(roleAdmin[role][address(account)].field_0) = 1
      log RoleGranted(
            bytes32 role=role,
            address account=account,
            address sender=caller)
  if not roleMember[role][1][address(account)].field_0:
      if roleMember[role].field_0 >= unknown10000000():
          revert with 0, 65
      roleMember[role].field_0++
      if roleMember[role].field_0 >= roleMember[role].field_0:
          revert with 0, 50
      address(roleMember[role][roleMember[role].field_0].field_0) = account
      Mask(96, 0, roleMember[role][roleMember[role].field_0].field_160) = 0
      roleMember[role][1][address(account)].field_0 = roleMember[role].field_0
      return 0
  else:
      return 0

def revokeRole(bytes32 role, address account): # not payable
  require calldata.size - 4 >=′ 64
  require not Mask(96, 160, account)
  if not uint8(roleAdmin[roleAdmin[role].field_256][caller].field_0):
      mem[128 len 64] = call.data[calldata.size len 64]
      idx = 41
      s = caller
      while idx > 1:
          if s % 16 >= 16:
              revert with 0, 50
          if idx >= 42:
              revert with 0, 50
          mem[idx + 128 len 8] = 0
          if not idx:
              revert with 0, 17
          idx = idx - 1
          s = Mask(252, 0, s) * 0.0625
          continue 
      if not caller + 10240:
          mem[224 len 96] = call.data[calldata.size len 96]
          idx = 65
          s = roleAdmin[role].field_256
          while idx > 1:
              if s % 16 >= 16:
                  revert with 0, 50
              if idx >= 66:
                  revert with 0, 50
              mem[idx + 224 len 8] = 0
              if not idx:
                  revert with 0, 17
              idx = idx - 1
              s = Mask(252, 0, s) * 0.0625
              continue 
          if not roleAdmin[role].field_256 + 16384:
              revert with Error(string reason), 
                          32,
                          148,
                          0x416363657373436f6e74726f6c3a, mem[160 len 42], 8297, mem[288 len 66], 0, None >> 928,
                          0
      revert with Error(string reason), 32, 32, 0xfe537472696e67733a20686578206c656e67746820696e73756666696369656e
  if uint8(roleAdmin[role][address(account)].field_0):
      uint8(roleAdmin[role][address(account)].field_0) = 0
      log RoleRevoked(
            bytes32 role=role,
            address account=account,
            address sender=caller)
  if roleMember[role][1][address(account)].field_0:
      if roleMember[role][1][address(account)].field_0 - 1 > roleMember[role][1][address(account)].field_0:
          revert with 0, 17
      if roleMember[role].field_0 - 1 > roleMember[role].field_0:
          revert with 0, 17
      if roleMember[role].field_0 - roleMember[role][1][address(account)].field_0:
          if roleMember[role].field_0 - 1 >= roleMember[role].field_0:
              revert with 0, 50
          if roleMember[role][1][address(account)].field_0 - 1 >= roleMember[role].field_0:
              revert with 0, 50
          roleMember[role][roleMember[role][1][address(account)].field_0].field_0 = roleMember[role][roleMember[role].field_0].field_0
          roleMember[role][1][roleMember[role][roleMember[role].field_0].field_0].field_0 = roleMember[role][1][address(account)].field_0
      if not roleMember[role].field_0:
          revert with 0, 49
      if roleMember[role].field_0 - 1 >= roleMember[role].field_0:
          revert with 0, 50
      roleMember[role][roleMember[role].field_0].field_0 = 0
      roleMember[role].field_0--
      roleMember[role][1][address(account)].field_0 = 0
      return 0
  else:
      return 0

def name(): # not payable
  require calldata.size - 4 >=′ 0
  if not bool(stor3.field_0):
      if stor3.field_1 % 128 < 32 == bool(stor3.field_0):
          revert with 0, 34
      mem[96] = stor3.field_1 % 128
      if bool(stor3.field_0):
          if bool(stor3.field_0) != 1:
              revert with 0, 65
          s = 0xc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b
          idx = 0
          while idx < stor3.field_1 % 128:
              mem[idx + 128] = stor[s]
              s = s + 1
              idx = idx + 32
              continue 
          if ceil32(ceil32(stor3.field_1 % 128)) + 97 > LOCK8605463013() or ceil32(ceil32(stor3.field_1 % 128)) + 97 < 96:
              revert with 0, 65
          mem[ceil32(ceil32(stor3.field_1 % 128)) + 97] = 32
          return Array(len=stor3.field_0 % 128, data=mem[128 len ceil32(stor3.field_1 % 128)])
      mem[128] = Mask(248, 8, uint256(stor3.field_0))
      if ceil32(32 * bool(stor3.field_1 % 128)) + 97 > LOCK8605463013() or ceil32(32 * bool(stor3.field_1 % 128)) + 97 < 96:
          revert with 0, 65
      mem[64] = ceil32(32 * bool(stor3.field_1 % 128)) + 97
      mem[ceil32(32 * bool(stor3.field_1 % 128)) + 97] = 32
      mem[ceil32(32 * bool(stor3.field_1 % 128)) + 129] = stor3.field_1 % 128
      mem[ceil32(32 * bool(stor3.field_1 % 128)) + 161 len ceil32(stor3.field_1 % 128)] = mem[128 len ceil32(stor3.field_1 % 128)]
      mem[stor3.field_1 % 128 + ceil32(32 * bool(stor3.field_1 % 128)) + 161] = 0
      return Array(len=stor3.field_0 % 128, data=mem[ceil32(32 * bool(stor3.field_1 % 128)) + 161 len ceil32(stor3.field_1 % 128)])
  if uint255(uint256(stor3.field_0)) * 0.5 < 32 == bool(stor3.field_0):
      revert with 0, 34
  mem[96] = uint255(uint256(stor3.field_0)) * 0.5
  if bool(stor3.field_0):
      if bool(stor3.field_0) != 1:
          revert with 0, 65
      s = 0xc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b
      idx = 0
      while idx < uint255(uint256(stor3.field_0)) * 0.5:
          mem[idx + 128] = stor[s]
          s = s + 1
          idx = idx + 32
          continue 
      if ceil32(ceil32(uint255(uint256(stor3.field_0)) * 0.5)) + 97 > LOCK8605463013() or ceil32(ceil32(uint255(uint256(stor3.field_0)) * 0.5)) + 97 < 96:
          revert with 0, 65
      mem[ceil32(ceil32(uint255(uint256(stor3.field_0)) * 0.5)) + 97] = 32
      return Array(len=2 * Mask(256, -1, uint256(stor3.field_0)), data=mem[128 len ceil32(uint255(uint256(stor3.field_0)) * 0.5)])
  mem[128] = Mask(248, 8, uint256(stor3.field_0))
  if ceil32(32 * bool(uint255(uint256(stor3.field_0)) * 0.5)) + 97 > LOCK8605463013() or ceil32(32 * bool(uint255(uint256(stor3.field_0)) * 0.5)) + 97 < 96:
      revert with 0, 65
  mem[64] = ceil32(32 * bool(uint255(uint256(stor3.field_0)) * 0.5)) + 97
  mem[ceil32(32 * bool(uint255(uint256(stor3.field_0)) * 0.5)) + 97] = 32
  mem[ceil32(32 * bool(uint255(uint256(stor3.field_0)) * 0.5)) + 129] = uint255(uint256(stor3.field_0)) * 0.5
  mem[ceil32(32 * bool(uint255(uint256(stor3.field_0)) * 0.5)) + 161 len ceil32(uint255(uint256(stor3.field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor3.field_0)) * 0.5)]
  mem[(uint255(uint256(stor3.field_0)) * 0.5) + ceil32(32 * bool(uint255(uint256(stor3.field_0)) * 0.5)) + 161] = 0
  return Array(len=2 * Mask(256, -1, uint256(stor3.field_0)), data=mem[ceil32(32 * bool(uint255(uint256(stor3.field_0)) * 0.5)) + 161 len ceil32(uint255(uint256(stor3.field_0)) * 0.5)]), 

def symbol(): # not payable
  require calldata.size - 4 >=′ 0
  if not bool(stor4.field_0):
      if stor4.field_1 % 128 < 32 == bool(stor4.field_0):
          revert with 0, 34
      mem[96] = stor4.field_1 % 128
      if bool(stor4.field_0):
          if bool(stor4.field_0) != 1:
              revert with 0, 65
          s = 0x8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b
          idx = 0
          while idx < stor4.field_1 % 128:
              mem[idx + 128] = stor[s]
              s = s + 1
              idx = idx + 32
              continue 
          if ceil32(ceil32(stor4.field_1 % 128)) + 97 > LOCK8605463013() or ceil32(ceil32(stor4.field_1 % 128)) + 97 < 96:
              revert with 0, 65
          mem[ceil32(ceil32(stor4.field_1 % 128)) + 97] = 32
          return Array(len=stor4.field_0 % 128, data=mem[128 len ceil32(stor4.field_1 % 128)])
      mem[128] = Mask(248, 8, uint256(stor4.field_0))
      if ceil32(32 * bool(stor4.field_1 % 128)) + 97 > LOCK8605463013() or ceil32(32 * bool(stor4.field_1 % 128)) + 97 < 96:
          revert with 0, 65
      mem[64] = ceil32(32 * bool(stor4.field_1 % 128)) + 97
      mem[ceil32(32 * bool(stor4.field_1 % 128)) + 97] = 32
      mem[ceil32(32 * bool(stor4.field_1 % 128)) + 129] = stor4.field_1 % 128
      mem[ceil32(32 * bool(stor4.field_1 % 128)) + 161 len ceil32(stor4.field_1 % 128)] = mem[128 len ceil32(stor4.field_1 % 128)]
      mem[stor4.field_1 % 128 + ceil32(32 * bool(stor4.field_1 % 128)) + 161] = 0
      return Array(len=stor4.field_0 % 128, data=mem[ceil32(32 * bool(stor4.field_1 % 128)) + 161 len ceil32(stor4.field_1 % 128)])
  if uint255(uint256(stor4.field_0)) * 0.5 < 32 == bool(stor4.field_0):
      revert with 0, 34
  mem[96] = uint255(uint256(stor4.field_0)) * 0.5
  if bool(stor4.field_0):
      if bool(stor4.field_0) != 1:
          revert with 0, 65
      s = 0x8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b
      idx = 0
      while idx < uint255(uint256(stor4.field_0)) * 0.5:
          mem[idx + 128] = stor[s]
          s = s + 1
          idx = idx + 32
          continue 
      if ceil32(ceil32(uint255(uint256(stor4.field_0)) * 0.5)) + 97 > LOCK8605463013() or ceil32(ceil32(uint255(uint256(stor4.field_0)) * 0.5)) + 97 < 96:
          revert with 0, 65
      mem[ceil32(ceil32(uint255(uint256(stor4.field_0)) * 0.5)) + 97] = 32
      return Array(len=2 * Mask(256, -1, uint256(stor4.field_0)), data=mem[128 len ceil32(uint255(uint256(stor4.field_0)) * 0.5)])
  mem[128] = Mask(248, 8, uint256(stor4.field_0))
  if ceil32(32 * bool(uint255(uint256(stor4.field_0)) * 0.5)) + 97 > LOCK8605463013() or ceil32(32 * bool(uint255(uint256(stor4.field_0)) * 0.5)) + 97 < 96:
      revert with 0, 65
  mem[64] = ceil32(32 * bool(uint255(uint256(stor4.field_0)) * 0.5)) + 97
  mem[ceil32(32 * bool(uint255(uint256(stor4.field_0)) * 0.5)) + 97] = 32
  mem[ceil32(32 * bool(uint255(uint256(stor4.field_0)) * 0.5)) + 129] = uint255(uint256(stor4.field_0)) * 0.5
  mem[ceil32(32 * bool(uint255(uint256(stor4.field_0)) * 0.5)) + 161 len ceil32(uint255(uint256(stor4.field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor4.field_0)) * 0.5)]
  mem[(uint255(uint256(stor4.field_0)) * 0.5) + ceil32(32 * bool(uint255(uint256(stor4.field_0)) * 0.5)) + 161] = 0
  return Array(len=2 * Mask(256, -1, uint256(stor4.field_0)), data=mem[ceil32(32 * bool(uint255(uint256(stor4.field_0)) * 0.5)) + 161 len ceil32(uint255(uint256(stor4.field_0)) * 0.5)]), 

def _fallback(?) payable: # default function
  require calldata.size >= 4
  if supportsInterface(bytes4 interfaceId) == uint32(call.func_hash) >> 224:
      require not call.value
      require calldata.size - 4 >=′ 32
      require not _param1 - Mask(32, 224, _param1)
      if Mask(32, 224, _param1) == 0x5a05180f00000000000000000000000000000000000000000000000000000000:
          return True
      if Mask(32, 224, _param1) != 0x7965db0b00000000000000000000000000000000000000000000000000000000:
          return (0x1ffc9a700000000000000000000000000000000000000000000000000000000 == Mask(32, 224, _param1))
      return (Mask(32, 224, _param1) == 0x7965db0b00000000000000000000000000000000000000000000000000000000)
  if name() == uint32(call.func_hash) >> 224:
      require not call.value
      require calldata.size - 4 >=′ 0
      if not bool(stor3.field_0):
          if stor3.field_1 % 128 < 32 == bool(stor3.field_0):
              revert with 0, 34
          mem[128] = stor3.field_1 % 128
          if bool(stor3.field_0):
              if bool(stor3.field_0) != 1:
                  revert with 0, 65
              s = 0xc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b
              idx = 0
              while idx < stor3.field_1 % 128:
                  mem[idx + 160] = stor[s]
                  s = s + 1
                  idx = idx + 32
                  continue 
              if ceil32(ceil32(stor3.field_1 % 128)) + 129 > LOCK8605463013() or ceil32(ceil32(stor3.field_1 % 128)) + 129 < 128:
                  revert with 0, 65
              mem[ceil32(ceil32(stor3.field_1 % 128)) + 129] = 32
              return Array(len=stor3.field_0 % 128, data=mem[160 len ceil32(stor3.field_1 % 128)])
          mem[160] = Mask(248, 8, uint256(stor3.field_0))
          if ceil32(32 * bool(stor3.field_1 % 128)) + 129 > LOCK8605463013() or ceil32(32 * bool(stor3.field_1 % 128)) + 129 < 128:
              revert with 0, 65
          mem[64] = ceil32(32 * bool(stor3.field_1 % 128)) + 129
          mem[ceil32(32 * bool(stor3.field_1 % 128)) + 129] = 32
          mem[ceil32(32 * bool(stor3.field_1 % 128)) + 161] = stor3.field_1 % 128
          mem[ceil32(32 * bool(stor3.field_1 % 128)) + 193 len ceil32(stor3.field_1 % 128)] = mem[160 len ceil32(stor3.field_1 % 128)]
          mem[stor3.field_1 % 128 + ceil32(32 * bool(stor3.field_1 % 128)) + 193] = 0
          return Array(len=stor3.field_0 % 128, data=mem[ceil32(32 * bool(stor3.field_1 % 128)) + 193 len ceil32(stor3.field_1 % 128)])
      if uint255(uint256(stor3.field_0)) * 0.5 < 32 == bool(stor3.field_0):
          revert with 0, 34
      mem[128] = uint255(uint256(stor3.field_0)) * 0.5
      if bool(stor3.field_0):
          if bool(stor3.field_0) != 1:
              revert with 0, 65
          s = 0xc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b
          idx = 0
          while idx < uint255(uint256(stor3.field_0)) * 0.5:
              mem[idx + 160] = stor[s]
              s = s + 1
              idx = idx + 32
              continue 
          if ceil32(ceil32(uint255(uint256(stor3.field_0)) * 0.5)) + 129 > LOCK8605463013() or ceil32(ceil32(uint255(uint256(stor3.field_0)) * 0.5)) + 129 < 128:
              revert with 0, 65
          mem[ceil32(ceil32(uint255(uint256(stor3.field_0)) * 0.5)) + 129] = 32
          return Array(len=2 * Mask(256, -1, uint256(stor3.field_0)), data=mem[160 len ceil32(uint255(uint256(stor3.field_0)) * 0.5)])
      mem[160] = Mask(248, 8, uint256(stor3.field_0))
      if ceil32(32 * bool(uint255(uint256(stor3.field_0)) * 0.5)) + 129 > LOCK8605463013() or ceil32(32 * bool(uint255(uint256(stor3.field_0)) * 0.5)) + 129 < 128:
          revert with 0, 65
      mem[64] = ceil32(32 * bool(uint255(uint256(stor3.field_0)) * 0.5)) + 129
      mem[ceil32(32 * bool(uint255(uint256(stor3.field_0)) * 0.5)) + 129] = 32
      mem[ceil32(32 * bool(uint255(uint256(stor3.field_0)) * 0.5)) + 161] = uint255(uint256(stor3.field_0)) * 0.5
      mem[ceil32(32 * bool(uint255(uint256(stor3.field_0)) * 0.5)) + 193 len ceil32(uint255(uint256(stor3.field_0)) * 0.5)] = mem[160 len ceil32(uint255(uint256(stor3.field_0)) * 0.5)]
      mem[(uint255(uint256(stor3.field_0)) * 0.5) + ceil32(32 * bool(uint255(uint256(stor3.field_0)) * 0.5)) + 193] = 0
      return Array(len=2 * Mask(256, -1, uint256(stor3.field_0)), data=mem[ceil32(32 * bool(uint255(uint256(stor3.field_0)) * 0.5)) + 193 len ceil32(uint255(uint256(stor3.field_0)) * 0.5)]), 
  if approve(address spender, uint256 amount) == uint32(call.func_hash) >> 224:
      require not call.value
      require calldata.size - 4 >=′ 64
      require not Mask(96, 160, _param1)
      if not caller:
          revert with Error(string reason), 'ERC20: approve from the zero address'
      if not address(_param1):
          revert with Error(string reason), 'ERC20: approve to the zero address'
      stor1[caller][address(_param1)] = _param2
      log Approval(
            address owner=_param2,
            address spender=caller,
            uint256 value=address(_param1))
      return 1
  if totalSupply() == uint32(call.func_hash) >> 224:
      require not call.value
      require calldata.size - 4 >=′ 0
      return totalSupply
  if transferFrom(address sender, address recipient, uint256 amount) == uint32(call.func_hash) >> 224:
      require not call.value
      require calldata.size - 4 >=′ 96
      require not Mask(96, 160, _param1)
      require not Mask(96, 160, _param2)
      if 0x22d473030f116ddee9f6b43ac78ba3 != caller:
          if stor1[address(_param1)][caller] + 1:
              if stor1[address(_param1)][caller] < _param3:
                  revert with Error(string reason), 'ERC20: insufficient allowance'
              if not address(_param1):
                  revert with Error(string reason), 'ERC20: approve from the zero address'
              if not caller:
                  revert with Error(string reason), 'ERC20: approve to the zero address'
              stor1[address(_param1)][caller] -= _param3
              log Approval(
                    address owner=(stor1[address(_param1)][caller] - _param3),
                    address spender=address(_param1),
                    uint256 value=caller)
      else:
          if not unknown407c48b4:
              if stor1[address(_param1)][caller] + 1:
                  if stor1[address(_param1)][caller] < _param3:
                      revert with Error(string reason), 'ERC20: insufficient allowance'
                  if not address(_param1):
                      revert with Error(string reason), 'ERC20: approve from the zero address'
                  if not caller:
                      revert with Error(string reason), 'ERC20: approve to the zero address'
                  stor1[address(_param1)][caller] -= _param3
                  log Approval(
                        address owner=(stor1[address(_param1)][caller] - _param3),
                        address spender=address(_param1),
                        uint256 value=caller)
      if not address(_param1):
          revert with Error(string reason), 'ERC20: transfer from the zero address'
      if not address(_param2):
          revert with Error(string reason), 'ERC20: transfer to the zero address'
      if balanceOf[address(_param1)] < _param3:
          revert with Error(string reason), 'ERC20: transfer amount exceeds balance'
      balanceOf[address(_param1)] -= _param3
      balanceOf[address(_param2)] += _param3
      log Transfer(
            address from=_param3,
            address to=address(_param1),
            uint256 value=address(_param2))
      return 1
  if getRoleAdmin(bytes32 role) == uint32(call.func_hash) >> 224:
      require not call.value
      require calldata.size - 4 >=′ 32
      return roleAdmin[_param1].field_256
  if 774393937 == uint32(call.func_hash) >> 224:
      require not call.value
      require calldata.size - 4 >=′ 0
      return 0x573321b8a13c75b2702bc4b0ad9afaae98bf6985285411964a564e68bf6da1c9
  if grantRole(bytes32 role, address account) == uint32(call.func_hash) >> 224:
      require not call.value
      require calldata.size - 4 >=′ 64
      require not Mask(96, 160, _param2)
      if not uint8(roleAdmin[roleAdmin[_param1].field_256][caller].field_0):
          idx = 41
          s = caller
          while idx > 1:
              if s % 16 >= 16:
                  revert with 0, 50
              if idx >= 42:
                  revert with 0, 50
              mem[idx + 160 len 8] = 0
              if not idx:
                  revert with 0, 17
              idx = idx - 1
              s = Mask(252, 0, s) * 0.0625
              continue 
          if not caller + 10240:
              mem[256 len 96] = call.data[calldata.size len 96]
              idx = 65
              s = roleAdmin[_param1].field_256
              while idx > 1:
                  if s % 16 >= 16:
                      revert with 0, 50
                  if idx >= 66:
                      revert with 0, 50
                  mem[idx + 256 len 8] = 0
                  if not idx:
                      revert with 0, 17
                  idx = idx - 1
                  s = Mask(252, 0, s) * 0.0625
                  continue 
              if not roleAdmin[_param1].field_256 + 16384:
                  revert with Error(string reason), 32, 148, mem[320 len 66], 0 >> 928, 0
          revert with Error(string reason), 32, 32, 0xfe537472696e67733a20686578206c656e67746820696e73756666696369656e
      if not uint8(roleAdmin[_param1][address(_param2)].field_0):
          uint8(roleAdmin[_param1][address(_param2)].field_0) = 1
          log RoleGranted(
                bytes32 role=_param1,
                address account=address(_param2),
                address sender=caller)
      if not roleMember[_param1][1][address(_param2)].field_0:
          if roleMember[_param1].field_0 >= unknown10000000():
              revert with 0, 65
          roleMember[_param1].field_0++
          if roleMember[_param1].field_0 >= roleMember[_param1].field_0:
              revert with 0, 50
          address(roleMember[_param1][roleMember[_param1].field_0].field_0) = address(_param2)
          Mask(96, 0, roleMember[_param1][roleMember[_param1].field_0].field_160) = 0
          roleMember[_param1][1][address(_param2)].field_0 = roleMember[_param1].field_0
  else:
      if decimals() == uint32(call.func_hash) >> 224:
          require not call.value
          require calldata.size - 4 >=′ 0
          return 18
      if DOMAIN_SEPARATOR() == uint32(call.func_hash) >> 224:
          require not call.value
          require calldata.size - 4 >=′ 0
          if this.address != 0x455e53cbb86018ac2b8092fdcd39d8444affc3f6:
              return sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0xafdc6b3596f2bc7878c706fa55d5aabb82790c51a37e088a158406cea4025910, 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6, chainid, this.address)
          if 1 != chainid:
              return sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0xafdc6b3596f2bc7878c706fa55d5aabb82790c51a37e088a158406cea4025910, 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6, chainid, this.address)
          return 0xb229387d8db422d84103ea5884522a783e8f8b570d17cc1e9bb39959983346f8
      if renounceRole(bytes32 role, address account) == uint32(call.func_hash) >> 224:
          require not call.value
          require calldata.size - 4 >=′ 64
          require not Mask(96, 160, _param2)
          if address(_param2) - caller:
              revert with Error(string reason), 'AccessControl: can only renounce roles for self'
          if uint8(roleAdmin[_param1][address(_param2)].field_0):
              uint8(roleAdmin[_param1][address(_param2)].field_0) = 0
              log RoleRevoked(
                    bytes32 role=_param1,
                    address account=address(_param2),
                    address sender=caller)
          if roleMember[_param1][1][address(_param2)].field_0:
              if roleMember[_param1][1][address(_param2)].field_0 - 1 > roleMember[_param1][1][address(_param2)].field_0:
                  revert with 0, 17
              if roleMember[_param1].field_0 - 1 > roleMember[_param1].field_0:
                  revert with 0, 17
              if roleMember[_param1].field_0 - roleMember[_param1][1][address(_param2)].field_0:
                  if roleMember[_param1].field_0 - 1 >= roleMember[_param1].field_0:
                      revert with 0, 50
                  if roleMember[_param1][1][address(_param2)].field_0 - 1 >= roleMember[_param1].field_0:
                      revert with 0, 50
                  roleMember[_param1][roleMember[_param1][1][address(_param2)].field_0].field_0 = roleMember[_param1][roleMember[_param1].field_0].field_0
                  roleMember[_param1][1][roleMember[_param1][roleMember[_param1].field_0].field_0].field_0 = roleMember[_param1][1][address(_param2)].field_0
              if not roleMember[_param1].field_0:
                  revert with 0, 49
              if roleMember[_param1].field_0 - 1 >= roleMember[_param1].field_0:
                  revert with 0, 50
              roleMember[_param1][roleMember[_param1].field_0].field_0 = 0
              roleMember[_param1].field_0--
              roleMember[_param1][1][address(_param2)].field_0 = 0
      else:
          if increaseAllowance(address spender, uint256 addedValue) == uint32(call.func_hash) >> 224:
              require not call.value
              require calldata.size - 4 >=′ 64
              require not Mask(96, 160, _param1)
              if address(_param1) != 0x22d473030f116ddee9f6b43ac78ba3:
                  if stor1[caller][address(_param1)] > stor1[caller][address(_param1)] + _param2:
                      revert with 0, 17
                  if not caller:
                      revert with Error(string reason), 'ERC20: approve from the zero address'
                  if not address(_param1):
                      revert with Error(string reason), 'ERC20: approve to the zero address'
                  stor1[caller][address(_param1)] += _param2
                  log Approval(
                        address owner=(stor1[caller][address(_param1)] + _param2),
                        address spender=caller,
                        uint256 value=address(_param1))
              else:
                  if unknown407c48b4:
                      if -1 > _param2 - 1:
                          revert with 0, 17
                      if not caller:
                          revert with Error(string reason), 'ERC20: approve from the zero address'
                      if not address(_param1):
                          revert with Error(string reason), 'ERC20: approve to the zero address'
                      stor1[caller][address(_param1)] = _param2 - 1
                      log Approval(
                            address owner=(_param2 - 1),
                            address spender=caller,
                            uint256 value=address(_param1))
                  else:
                      if stor1[caller][address(_param1)] > stor1[caller][address(_param1)] + _param2:
                          revert with 0, 17
                      if not caller:
                          revert with Error(string reason), 'ERC20: approve from the zero address'
                      if not address(_param1):
                          revert with Error(string reason), 'ERC20: approve to the zero address'
                      stor1[caller][address(_param1)] += _param2
                      log Approval(
                            address owner=(stor1[caller][address(_param1)] + _param2),
                            address spender=caller,
                            uint256 value=address(_param1))
              return 1
          if 1081886900 == uint32(call.func_hash) >> 224:
              require not call.value
              require calldata.size - 4 >=′ 0
              return bool(unknown407c48b4)
          if mint(address _to, uint256 _amount) == uint32(call.func_hash) >> 224:
              require not call.value
              require calldata.size - 4 >=′ 64
              require not Mask(96, 160, _param1)
              if not uint8(roleAdmin[0x573321b8a13c75b2702bc4b0ad9afaae98bf6985285411964a564e68bf6da1c9][caller].field_0):
                  idx = 41
                  s = caller
                  while idx > 1:
                      if s % 16 >= 16:
                          revert with 0, 50
                      if idx >= 42:
                          revert with 0, 50
                      mem[idx + 160 len 8] = 0
                      if not idx:
                          revert with 0, 17
                      idx = idx - 1
                      s = Mask(252, 0, s) * 0.0625
                      continue 
                  if not caller + 10240:
                      idx = 65
                      s = 0x573321b8a13c75b2702bc4b0ad9afaae98bf6985285411964a564e68bf6da1c9
                      while idx > 1:
                          if s % 16 >= 16:
                              revert with 0, 50
                          if idx >= 66:
                              revert with 0, 50
                          mem[idx + 256 len 8] = 0
                          if not idx:
                              revert with 0, 17
                          idx = idx - 1
                          s = Mask(252, 0, s) * 0.0625
                          continue 
                  revert with Error(string reason), 32, 32, 0xfe537472696e67733a20686578206c656e67746820696e73756666696369656e
              if block.timestamp - lastMint > block.timestamp:
                  revert with 0, 17
              if lastMint != block.timestamp and (block.timestamp * unknown8eb66d6a) - (lastMint * unknown8eb66d6a) / block.timestamp - lastMint != unknown8eb66d6a:
                  revert with 0, 17
              if _param2 > (block.timestamp * unknown8eb66d6a) - (lastMint * unknown8eb66d6a):
                  revert with 1541212405, (block.timestamp * unknown8eb66d6a) - (lastMint * unknown8eb66d6a), _param2
              lastMint = block.timestamp
              if not address(_param1):
                  revert with Error(string reason), 'ERC20: mint to the zero address'
              if totalSupply > totalSupply + _param2:
                  revert with 0, 17
              totalSupply += _param2
              balanceOf[address(_param1)] += _param2
              log Transfer(
                    address from=_param2,
                    address to=0,
                    uint256 value=address(_param1))
          else:
              if version() == uint32(call.func_hash) >> 224:
                  require not call.value
                  require calldata.size - 4 >=′ 0
                  return '', 0
              if lastMint() == uint32(call.func_hash) >> 224:
                  require not call.value
                  require calldata.size - 4 >=′ 0
                  return lastMint
              if unknown6afdd850() == uint32(call.func_hash) >> 224:
                  require not call.value
                  require calldata.size - 4 >=′ 0
                  return 0x22d473030f116ddee9f6b43ac78ba3
              if 1885235803 == uint32(call.func_hash) >> 224:
                  require not call.value
                  require calldata.size - 4 >=′ 32
                  require not _param1 - bool(_param1)
                  if uint8(roleAdmin[0xbd4c1461ef59750b24719a44d7e2a7948c57fd12c98e333541b7ea7b61f07cb7][caller].field_0):
                      log 0x383d8f27: bool(_param1)
                      unknown407c48b4 = uint8(bool(_param1))
                      return 0
                  idx = 41
                  s = caller
                  while idx > 1:
                      if s % 16 >= 16:
                          revert with 0, 50
                      if idx >= 42:
                          revert with 0, 50
                      mem[idx + 160 len 8] = 0
                      if not idx:
                          revert with 0, 17
                      idx = idx - 1
                      s = Mask(252, 0, s) * 0.0625
                      continue 
                  if caller + 10240:
                      revert with Error(string reason), 32, 32, 0xfe537472696e67733a20686578206c656e67746820696e73756666696369656e
                  mem[256 len 96] = call.data[calldata.size len 96]
                  idx = 65
                  s = 0xbd4c1461ef59750b24719a44d7e2a7948c57fd12c98e333541b7ea7b61f07cb7
                  while idx > 1:
                      if s % 16 >= 16:
                          revert with 0, 50
                      if idx >= 66:
                          revert with 0, 50
                      mem[idx + 256 len 8] = 0
                      if not idx:
                          revert with 0, 17
                      idx = idx - 1
                      s = Mask(252, 0, s) * 0.0625
                      continue 
                  revert with Error(string reason), 32, 148, mem[320 len 66], 0 >> 928, 0
              if balanceOf(address account) == uint32(call.func_hash) >> 224:
                  require not call.value
                  require calldata.size - 4 >=′ 32
                  require not Mask(96, 160, _param1)
                  return balanceOf[address(_param1)]
              if nonces(address _param1) == uint32(call.func_hash) >> 224:
                  require not call.value
                  require calldata.size - 4 >=′ 32
                  require not Mask(96, 160, _param1)
                  return nonces[address(_param1)]
              if unknown84b0196e() == uint32(call.func_hash) >> 224:
                  require not call.value
                  require calldata.size - 4 >=′ 0
                  return 0xf00000000000000000000000000000000000000000000000000000000000000, 
                         224,
                         288,
                         chainid,
                         this.address,
                         0,
                         352,
                         23,
                         0x506f6c79676f6e2045636f737973,
                         0,
                         1,
                         49,
                         0,
                         0
              if CAP_MANAGER_ROLE() == uint32(call.func_hash) >> 224:
                  require not call.value
                  require calldata.size - 4 >=′ 0
                  return 0x27f9f680a0c6704fd9796b55c67fe885252243966ecb05a88f3e7873c845d9a
              if 2394320234 == uint32(call.func_hash) >> 224:
                  require not call.value
                  require calldata.size - 4 >=′ 0
                  return unknown8eb66d6a
              if getRoleMember(bytes32 role, uint256 index) == uint32(call.func_hash) >> 224:
                  require not call.value
                  require calldata.size - 4 >=′ 64
                  if _param2 >= roleMember[_param1].field_0:
                      revert with 0, 50
                  return address(roleMember[_param1][_param2].field_0)
              if hasRole(bytes32 role, address account) == uint32(call.func_hash) >> 224:
                  require not call.value
                  require calldata.size - 4 >=′ 64
                  require not Mask(96, 160, _param2)
                  return bool(uint8(roleAdmin[_param1][address(_param2)].field_0))
              if symbol() == uint32(call.func_hash) >> 224:
                  require not call.value
                  require calldata.size - 4 >=′ 0
                  if not bool(stor4.field_0):
                      if stor4.field_1 % 128 < 32 == bool(stor4.field_0):
                          revert with 0, 34
                      mem[128] = stor4.field_1 % 128
                      if bool(stor4.field_0):
                          if bool(stor4.field_0) != 1:
                              revert with 0, 65
                          s = 0x8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b
                          idx = 0
                          while idx < stor4.field_1 % 128:
                              mem[idx + 160] = stor[s]
                              s = s + 1
                              idx = idx + 32
                              continue 
                          if ceil32(ceil32(stor4.field_1 % 128)) + 129 > LOCK8605463013() or ceil32(ceil32(stor4.field_1 % 128)) + 129 < 128:
                              revert with 0, 65
                          mem[ceil32(ceil32(stor4.field_1 % 128)) + 129] = 32
                          return Array(len=stor4.field_0 % 128, data=mem[160 len ceil32(stor4.field_1 % 128)])
                      mem[160] = Mask(248, 8, uint256(stor4.field_0))
                      if ceil32(32 * bool(stor4.field_1 % 128)) + 129 > LOCK8605463013() or ceil32(32 * bool(stor4.field_1 % 128)) + 129 < 128:
                          revert with 0, 65
                      mem[64] = ceil32(32 * bool(stor4.field_1 % 128)) + 129
                      mem[ceil32(32 * bool(stor4.field_1 % 128)) + 129] = 32
                      mem[ceil32(32 * bool(stor4.field_1 % 128)) + 161] = stor4.field_1 % 128
                      mem[ceil32(32 * bool(stor4.field_1 % 128)) + 193 len ceil32(stor4.field_1 % 128)] = mem[160 len ceil32(stor4.field_1 % 128)]
                      mem[stor4.field_1 % 128 + ceil32(32 * bool(stor4.field_1 % 128)) + 193] = 0
                      return Array(len=stor4.field_0 % 128, data=mem[ceil32(32 * bool(stor4.field_1 % 128)) + 193 len ceil32(stor4.field_1 % 128)])
                  if uint255(uint256(stor4.field_0)) * 0.5 < 32 == bool(stor4.field_0):
                      revert with 0, 34
                  mem[128] = uint255(uint256(stor4.field_0)) * 0.5
                  if bool(stor4.field_0):
                      if bool(stor4.field_0) != 1:
                          revert with 0, 65
                      s = 0x8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b
                      idx = 0
                      while idx < uint255(uint256(stor4.field_0)) * 0.5:
                          mem[idx + 160] = stor[s]
                          s = s + 1
                          idx = idx + 32
                          continue 
                      if ceil32(ceil32(uint255(uint256(stor4.field_0)) * 0.5)) + 129 > LOCK8605463013() or ceil32(ceil32(uint255(uint256(stor4.field_0)) * 0.5)) + 129 < 128:
                          revert with 0, 65
                      mem[ceil32(ceil32(uint255(uint256(stor4.field_0)) * 0.5)) + 129] = 32
                      return Array(len=2 * Mask(256, -1, uint256(stor4.field_0)), data=mem[160 len ceil32(uint255(uint256(stor4.field_0)) * 0.5)])
                  mem[160] = Mask(248, 8, uint256(stor4.field_0))
                  if ceil32(32 * bool(uint255(uint256(stor4.field_0)) * 0.5)) + 129 > LOCK8605463013() or ceil32(32 * bool(uint255(uint256(stor4.field_0)) * 0.5)) + 129 < 128:
                      revert with 0, 65
                  mem[64] = ceil32(32 * bool(uint255(uint256(stor4.field_0)) * 0.5)) + 129
                  mem[ceil32(32 * bool(uint255(uint256(stor4.field_0)) * 0.5)) + 129] = 32
                  mem[ceil32(32 * bool(uint255(uint256(stor4.field_0)) * 0.5)) + 161] = uint255(uint256(stor4.field_0)) * 0.5
                  mem[ceil32(32 * bool(uint255(uint256(stor4.field_0)) * 0.5)) + 193 len ceil32(uint255(uint256(stor4.field_0)) * 0.5)] = mem[160 len ceil32(uint255(uint256(stor4.field_0)) * 0.5)]
                  mem[(uint255(uint256(stor4.field_0)) * 0.5) + ceil32(32 * bool(uint255(uint256(stor4.field_0)) * 0.5)) + 193] = 0
                  return Array(len=2 * Mask(256, -1, uint256(stor4.field_0)), data=mem[ceil32(32 * bool(uint255(uint256(stor4.field_0)) * 0.5)) + 193 len ceil32(uint255(uint256(stor4.field_0)) * 0.5)]), 
              if DEFAULT_ADMIN_ROLE() == uint32(call.func_hash) >> 224:
                  require not call.value
                  require calldata.size - 4 >=′ 0
              else:
                  if decreaseAllowance(address spender, uint256 subtractedValue) == uint32(call.func_hash) >> 224:
                      require not call.value
                      require calldata.size - 4 >=′ 64
                      require not Mask(96, 160, _param1)
                      if address(_param1) != 0x22d473030f116ddee9f6b43ac78ba3:
                          if stor1[caller][address(_param1)] < _param2:
                              revert with Error(string reason), 'ERC20: decreased allowance below zero'
                          if not caller:
                              revert with Error(string reason), 'ERC20: approve from the zero address'
                          if not address(_param1):
                              revert with Error(string reason), 'ERC20: approve to the zero address'
                          stor1[caller][address(_param1)] -= _param2
                          log Approval(
                                address owner=(stor1[caller][address(_param1)] - _param2),
                                address spender=caller,
                                uint256 value=address(_param1))
                      else:
                          if unknown407c48b4:
                              if -1 < _param2:
                                  revert with Error(string reason), 'ERC20: decreased allowance below zero'
                              if not caller:
                                  revert with Error(string reason), 'ERC20: approve from the zero address'
                              if not address(_param1):
                                  revert with Error(string reason), 'ERC20: approve to the zero address'
                              stor1[caller][address(_param1)] = -_param2 - 1
                              log Approval(
                                    address owner=(-_param2 - 1),
                                    address spender=caller,
                                    uint256 value=address(_param1))
                          else:
                              if stor1[caller][address(_param1)] < _param2:
                                  revert with Error(string reason), 'ERC20: decreased allowance below zero'
                              if not caller:
                                  revert with Error(string reason), 'ERC20: approve from the zero address'
                              if not address(_param1):
                                  revert with Error(string reason), 'ERC20: approve to the zero address'
                              stor1[caller][address(_param1)] -= _param2
                              log Approval(
                                    address owner=(stor1[caller][address(_param1)] - _param2),
                                    address spender=caller,
                                    uint256 value=address(_param1))
                      return 1
                  if transfer(address recipient, uint256 amount) == uint32(call.func_hash) >> 224:
                      require not call.value
                      require calldata.size - 4 >=′ 64
                      require not Mask(96, 160, _param1)
                      if not caller:
                          revert with Error(string reason), 'ERC20: transfer from the zero address'
                      if not address(_param1):
                          revert with Error(string reason), 'ERC20: transfer to the zero address'
                      if balanceOf[caller] < _param2:
                          revert with Error(string reason), 'ERC20: transfer amount exceeds balance'
                      balanceOf[caller] -= _param2
                      balanceOf[address(_param1)] += _param2
                      log Transfer(
                            address from=_param2,
                            address to=caller,
                            uint256 value=address(_param1))
                      return 1
                  if getRoleMemberCount(bytes32 role) == uint32(call.func_hash) >> 224:
                      require not call.value
                      require calldata.size - 4 >=′ 32
                      return roleMember[_param1].field_0
                  if permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) == uint32(call.func_hash) >> 224:
                      require not call.value
                      require calldata.size - 4 >=′ 224
                      require not Mask(96, 160, _param1)
                      require not Mask(96, 160, _param2)
                      require not Mask(248, 8, _param5)
                      if block.timestamp > _param4:
                          revert with Error(string reason), 'ERC20Permit: expired deadline'
                      nonces[address(_param1)]++
                      if _param7 > 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0:
                          revert with Error(string reason), 'ECDSA: invalid signature 's' value'
                      if this.address != 0x455e53cbb86018ac2b8092fdcd39d8444affc3f6:
                          signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0xafdc6b3596f2bc7878c706fa55d5aabb82790c51a37e088a158406cea4025910, 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6, chainid, this.address), sha3(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9, address(_param1), address(_param2), _param3, nonces[address(_param1)], _param4)), _param5 << 248, _param6, _param7) # precompiled
                      else:
                          if 1 != chainid:
                              signer = erecover(sha3(6401, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, 0xafdc6b3596f2bc7878c706fa55d5aabb82790c51a37e088a158406cea4025910, 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6, chainid, this.address), sha3(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9, address(_param1), address(_param2), _param3, nonces[address(_param1)], _param4)), _param5 << 248, _param6, _param7) # precompiled
                          else:
                              signer = erecover(sha3(6401, 0xb229387d8db422d84103ea5884522a783e8f8b570d17cc1e9bb39959983346f8, sha3(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9, address(_param1), address(_param2), _param3, nonces[address(_param1)], _param4)), _param5 << 248, _param6, _param7) # precompiled
                      if not erecover.result:
                          revert with ext_call.return_data[0 len return_data.size]
                      if not address(signer):
                          revert with Error(string reason), 'ECDSA: invalid signature'
                      if address(signer) - address(_param1):
                          revert with Error(string reason), 'ERC20Permit: invalid signature'
                      if not address(_param1):
                          revert with Error(string reason), 'ERC20: approve from the zero address'
                      if not address(_param2):
                          revert with Error(string reason), 'ERC20: approve to the zero address'
                      stor1[address(_param1)][address(_param2)] = _param3
                      log Approval(
                            address owner=_param3,
                            address spender=address(_param1),
                            uint256 value=address(_param2))
                  else:
                      if uint32(call.func_hash) >> 224 != revokeRole(bytes32 role, address account):
                          if allowance(address owner, address spender) == uint32(call.func_hash) >> 224:
                              require not call.value
                              require calldata.size - 4 >=′ 64
                              require not Mask(96, 160, _param1)
                              require not Mask(96, 160, _param2)
                              if address(_param2) == 0x22d473030f116ddee9f6b43ac78ba3:
                                  if unknown407c48b4:
                                      return -1
                              return stor1[address(_param1)][address(_param2)]
                          if 4208794139 == uint32(call.func_hash) >> 224:
                              require not call.value
                              require calldata.size - 4 >=′ 0
                              return 0xbd4c1461ef59750b24719a44d7e2a7948c57fd12c98e333541b7ea7b61f07cb7
                          require 4285795377 == uint32(call.func_hash) >> 224
                          require not call.value
                          require calldata.size - 4 >=′ 32
                          if uint8(roleAdmin[0x27f9f680a0c6704fd9796b55c67fe885252243966ecb05a88f3e7873c845d9a][caller].field_0):
                              log 0xed4079ad: unknown8eb66d6a, _param1
                              unknown8eb66d6a = _param1
                              return 0
                          idx = 41
                          s = caller
                          while idx > 1:
                              if s % 16 >= 16:
                                  revert with 0, 50
                              if idx >= 42:
                                  revert with 0, 50
                              mem[idx + 160 len 8] = 0
                              if not idx:
                                  revert with 0, 17
                              idx = idx - 1
                              s = Mask(252, 0, s) * 0.0625
                              continue 
                          if not caller + 10240:
                              idx = 65
                              s = 0x27f9f680a0c6704fd9796b55c67fe885252243966ecb05a88f3e7873c845d9a
                              while idx > 1:
                                  if s % 16 >= 16:
                                      revert with 0, 50
                                  if idx >= 66:
                                      revert with 0, 50
                                  mem[idx + 256 len 8] = 0
                                  if not idx:
                                      revert with 0, 17
                                  idx = idx - 1
                                  s = Mask(252, 0, s) * 0.0625
                                  continue 
                          revert with Error(string reason), 32, 32, 0xfe537472696e67733a20686578206c656e67746820696e73756666696369656e
                      require not call.value
                      require calldata.size - 4 >=′ 64
                      require not Mask(96, 160, _param2)
                      if not uint8(roleAdmin[roleAdmin[_param1].field_256][caller].field_0):
                          idx = 41
                          s = caller
                          while idx > 1:
                              if s % 16 >= 16:
                                  revert with 0, 50
                              if idx >= 42:
                                  revert with 0, 50
                              mem[idx + 160 len 8] = 0
                              if not idx:
                                  revert with 0, 17
                              idx = idx - 1
                              s = Mask(252, 0, s) * 0.0625
                              continue 
                          if not caller + 10240:
                              mem[256 len 96] = call.data[calldata.size len 96]
                              idx = 65
                              s = roleAdmin[_param1].field_256
                              while idx > 1:
                                  if s % 16 >= 16:
                                      revert with 0, 50
                                  if idx >= 66:
                                      revert with 0, 50
                                  mem[idx + 256 len 8] = 0
                                  if not idx:
                                      revert with 0, 17
                                  idx = idx - 1
                                  s = Mask(252, 0, s) * 0.0625
                                  continue 
                              if not roleAdmin[_param1].field_256 + 16384:
                                  revert with Error(string reason), 32, 148, mem[320 len 66], 0 >> 928, 0
                          revert with Error(string reason), 32, 32, 0xfe537472696e67733a20686578206c656e67746820696e73756666696369656e
                      if uint8(roleAdmin[_param1][address(_param2)].field_0):
                          uint8(roleAdmin[_param1][address(_param2)].field_0) = 0
                          log RoleRevoked(
                                bytes32 role=_param1,
                                address account=address(_param2),
                                address sender=caller)
                      if roleMember[_param1][1][address(_param2)].field_0:
                          if roleMember[_param1][1][address(_param2)].field_0 - 1 > roleMember[_param1][1][address(_param2)].field_0:
                              revert with 0, 17
                          if roleMember[_param1].field_0 - 1 > roleMember[_param1].field_0:
                              revert with 0, 17
                          if roleMember[_param1].field_0 - roleMember[_param1][1][address(_param2)].field_0:
                              if roleMember[_param1].field_0 - 1 >= roleMember[_param1].field_0:
                                  revert with 0, 50
                              if roleMember[_param1][1][address(_param2)].field_0 - 1 >= roleMember[_param1].field_0:
                                  revert with 0, 50
                              roleMember[_param1][roleMember[_param1][1][address(_param2)].field_0].field_0 = roleMember[_param1][roleMember[_param1].field_0].field_0
                              roleMember[_param1][1][roleMember[_param1][roleMember[_param1].field_0].field_0].field_0 = roleMember[_param1][1][address(_param2)].field_0
                          if not roleMember[_param1].field_0:
                              revert with 0, 49
                          if roleMember[_param1].field_0 - 1 >= roleMember[_param1].field_0:
                              revert with 0, 50
                          roleMember[_param1][roleMember[_param1].field_0].field_0 = 0
                          roleMember[_param1].field_0--
                          roleMember[_param1][1][address(_param2)].field_0 = 0
  return 0


