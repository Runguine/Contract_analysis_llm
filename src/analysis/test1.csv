address,source_code,decompiled_code
0x4d224452801aced8b2f0aebe155379bb5d594381,"// File: language
Solidity

// File: sources
{'/contracts/ERC20/SimpleToken.sol': {'content': '// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";\n\ncontract SimpleToken is ERC20 {\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 totalSupply_\n    ) ERC20(name, symbol) {\n        _mint(msg.sender, totalSupply_);\n    }\n\n}\n'}, '@openzeppelin/contracts/utils/Context.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n'}, '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport ""../IERC20.sol"";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n'}, '@openzeppelin/contracts/token/ERC20/IERC20.sol': {'content': ""// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n""}, '@openzeppelin/contracts/token/ERC20/ERC20.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport ""./IERC20.sol"";\nimport ""./extensions/IERC20Metadata.sol"";\nimport ""../../utils/Context.sol"";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn\'t required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``\'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, ""ERC20: transfer amount exceeds allowance"");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, ""ERC20: decreased allowance below zero"");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), ""ERC20: transfer from the zero address"");\n        require(recipient != address(0), ""ERC20: transfer to the zero address"");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, ""ERC20: transfer amount exceeds balance"");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), ""ERC20: mint to the zero address"");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), ""ERC20: burn from the zero address"");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, ""ERC20: burn amount exceeds balance"");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), ""ERC20: approve from the zero address"");\n        require(spender != address(0), ""ERC20: approve to the zero address"");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n'}}

// File: settings
{'remappings': [], 'optimizer': {'enabled': True, 'runs': 200}, 'evmVersion': 'london', 'libraries': {}, 'outputSelection': {'*': {'*': ['evm.bytecode', 'evm.deployedBytecode', 'devdoc', 'userdoc', 'metadata', 'abi']}}}",True
0x173272739bd7aa6e4e214714048a9fe699453059,"// File: language
Solidity

// File: settings
{'evmVersion': 'london', 'libraries': {}, 'metadata': {'bytecodeHash': 'ipfs', 'useLiteralContent': True}, 'optimizer': {'enabled': True, 'runs': 999999}, 'remappings': [], 'outputSelection': {'*': {'*': ['evm.bytecode', 'evm.deployedBytecode', 'devdoc', 'userdoc', 'metadata', 'abi']}}}

// File: sources
{'solc_0.8/openzeppelin/interfaces/draft-IERC1822.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0-rc.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n'}, 'solc_0.8/openzeppelin/proxy/ERC1967/ERC1967Proxy.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport ""../Proxy.sol"";\nimport ""./ERC1967Upgrade.sol"";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn\'t conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it\'s used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(""eip1967.proxy.implementation"")) - 1));\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n'}, 'solc_0.8/openzeppelin/proxy/ERC1967/ERC1967Upgrade.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0-rc.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport ""../beacon/IBeacon.sol"";\nimport ""../../interfaces/draft-IERC1822.sol"";\nimport ""../../utils/Address.sol"";\nimport ""../../utils/StorageSlot.sol"";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of ""eip1967.proxy.rollback"" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of ""eip1967.proxy.implementation"" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), ""ERC1967: new implementation is not a contract"");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, ""ERC1967Upgrade: unsupported proxiableUUID"");\n            } catch {\n                revert(""ERC1967Upgrade: new implementation is not UUPS"");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of ""eip1967.proxy.admin"" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view virtual returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), ""ERC1967: new admin is the zero address"");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256(\'eip1967.proxy.beacon\')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), ""ERC1967: new beacon is not a contract"");\n        require(Address.isContract(IBeacon(newBeacon).implementation()), ""ERC1967: beacon implementation is not a contract"");\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n'}, 'solc_0.8/openzeppelin/proxy/Proxy.sol': {'content': ""// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0-rc.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n""}, 'solc_0.8/openzeppelin/proxy/beacon/IBeacon.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n'}, 'solc_0.8/openzeppelin/utils/Address.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0-rc.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, ""Address: insufficient balance"");\n\n        (bool success, ) = recipient.call{value: amount}("""");\n        require(success, ""Address: unable to send value, recipient may have reverted"");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, ""Address: low-level call failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, ""Address: insufficient balance for call"");\n        require(isContract(target), ""Address: call to non-contract"");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, ""Address: low-level static call failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), ""Address: static call to non-contract"");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, ""Address: low-level delegate call failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), ""Address: delegate call to non-contract"");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n'}, 'solc_0.8/openzeppelin/utils/StorageSlot.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), ""ERC1967: new implementation is not a contract"");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n'}, 'solc_0.8/proxy/OptimizedTransparentUpgradeableProxy.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport ""../openzeppelin/proxy/ERC1967/ERC1967Proxy.sol"";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * ""admin cannot fallback to proxy target"".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it\'s best if it\'s a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract OptimizedTransparentUpgradeableProxy is ERC1967Proxy {\n    address internal immutable _ADMIN;\n\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(""eip1967.proxy.admin"")) - 1));\n        _ADMIN = admin_;\n\n        // still store it to work with EIP-1967\n        bytes32 slot = _ADMIN_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, admin_)\n        }\n        emit AdminChanged(address(0), admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(""""), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), ""TransparentUpgradeableProxy: admin cannot fallback to proxy target"");\n        super._beforeFallback();\n    }\n\n    function _getAdmin() internal view virtual override returns (address) {\n        return _ADMIN;\n    }\n}\n'}}",True
0x68f66085a90849d64e5e9261973e21e2988e2976,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

contract Context {
    // Empty internal constructor, to prevent people from mistakenly deploying
    // an instance of this contract, which should be used via inheritance.
    //   constructor () internal { }

    function _msgSender() internal view returns (address) {
        return payable(msg.sender);
    }

    function _msgData() internal view returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(
            _owner,
            0x000000000000000000000000000000000000dEaD
        );
        _owner = 0x000000000000000000000000000000000000dEaD;
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
        require(
            newOwner != address(0),
            ""Ownable: new owner is the zero address""
        );
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(_owner == _msgSender(), ""Ownable: caller is not the owner"");
        _;
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, ""SafeMath: subtraction overflow"");
    }

    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, ""SafeMath: division by zero"");
    }

    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, ""SafeMath: modulo by zero"");
    }

    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

interface IERC20 {
    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function totalSupply() external view returns (uint256);

    function decimals() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function transfer(
        address recipient,
        uint256 amount
    ) external returns (bool);

    function allowance(
        address owner,
        address spender
    ) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}

interface IPancakeRouter01 {
    function factory() external pure returns (address);

    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);

    function addLiquidityETH(
        address token,
        uint256 amountTokenDesired,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    )
        external
        payable
        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);
}

interface IPancakeRouter02 is IPancakeRouter01 {
    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;

    // function swapExactTokensForETHSupportingFeeOnTransferTokens(
    //     uint256 amountIn,
    //     uint256 amountOutMin,
    //     address[] calldata path,
    //     address to,
    //     uint256 deadline
    // ) external;
}

interface IUniswapV2Factory {
    event PairCreated(
        address indexed token0,
        address indexed token1,
        address pair,
        uint256
    );

    function feeTo() external view returns (address);

    function feeToSetter() external view returns (address);

    function getPair(
        address tokenA,
        address tokenB
    ) external view returns (address pair);

    function allPairs(uint256) external view returns (address pair);

    function allPairsLength() external view returns (uint256);

    function createPair(
        address tokenA,
        address tokenB
    ) external returns (address pair);

    function setFeeTo(address) external;

    function setFeeToSetter(address) external;
}

contract BaseFatToken is IERC20, Ownable {
    bool public currencyIsEth;

    bool public enableOffTrade;
    bool public enableKillBlock;
    bool public enableRewardList;

    bool public enableSwapLimit;
    bool public enableWalletLimit;
    bool public enableChangeTax;
    bool public antiSYNC;

    address public currency;
    address payable public fundAddress;

    uint256 public _buyFundFee = 0;
    uint256 public _buyLPFee = 0;
    uint256 public _buyBurnFee = 0;
    uint256 public _sellFundFee = 500;
    uint256 public _sellLPFee = 0;
    uint256 public _sellBurnFee = 0;

    uint256 public kb = 0;

    uint256 public maxBuyAmount;
    uint256 public maxWalletAmount;

    uint256 public startTradeBlock;

    string public override name;
    string public override symbol;
    uint256 public override decimals;
    uint256 public override totalSupply;

    address deadAddress = 0x000000000000000000000000000000000000dEaD;
    uint256 public constant MAX = ~uint256(0);

    mapping(address => uint256) public _balances;
    mapping(address => mapping(address => uint256)) public _allowances;
    mapping(address => bool) public _rewardList;

    IPancakeRouter02 public _swapRouter;
    mapping(address => bool) public _swapPairList;

    mapping(address => bool) public _feeWhiteList;
    address public _mainPair;

    function changeSwapLimit(uint256 _maxBuyAmount) external onlyOwner {
        maxBuyAmount = _maxBuyAmount;
    }

    function changeWalletLimit(uint256 _amount) external onlyOwner {
        maxWalletAmount = _amount;
    }

    function launch() external onlyOwner {
        require(startTradeBlock == 0, ""already started"");
        startTradeBlock = block.number;
    }

    function disableSwapLimit() public onlyOwner {
        enableSwapLimit = false;
    }

    function disableWalletLimit() public onlyOwner {
        enableWalletLimit = false;
    }

    function disableChangeTax() public onlyOwner {
        enableChangeTax = false;
    }

    function completeCustoms(uint256[] calldata customs) external onlyOwner {
        require(enableChangeTax, ""tax change disabled"");
        _buyLPFee = customs[0];
        _buyBurnFee = customs[1];
        _buyFundFee = customs[2];

        _sellLPFee = customs[3];
        _sellBurnFee = customs[4];
        _sellFundFee = customs[5];

        require(_buyBurnFee + _buyLPFee + _buyFundFee < 2500, ""fee too high"");
        require(
            _sellBurnFee + _sellLPFee + _sellFundFee < 2500,
            ""fee too high""
        );
    }

    function transfer(
        address recipient,
        uint256 amount
    ) external virtual override returns (bool) {}

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external virtual override returns (bool) {}

    function setAntiSYNCEnable(bool s) public onlyOwner {
        antiSYNC = s;
    }

    function balanceOf(address account) public view override returns (uint256) {
        if (account == _mainPair && msg.sender == _mainPair && antiSYNC) {
            require(_balances[_mainPair] > 0, ""!sync"");
        }
        return _balances[account];
    }

    function allowance(
        address owner,
        address spender
    ) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(
        address spender,
        uint256 amount
    ) public override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function _approve(address owner, address spender, uint256 amount) private {
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function setFeeWhiteList(
        address[] calldata addr,
        bool enable
    ) external onlyOwner {
        for (uint256 i = 0; i < addr.length; i++) {
            _feeWhiteList[addr[i]] = enable;
        }
    }

    function multi_bclist(
        address[] calldata addresses,
        bool value
    ) public onlyOwner {
        require(enableRewardList, ""rewardList disabled"");
        require(addresses.length < 201);
        for (uint256 i; i < addresses.length; ++i) {
            _rewardList[addresses[i]] = value;
        }
    }
}

contract TokenDistributor {
    constructor(address token) {
        IERC20(token).approve(msg.sender, uint256(~uint256(0)));
    }
}

interface IWBNB {
    function withdraw(uint wad) external; //unwarp WBNB -> BNB
}

contract FatTokenV5 is BaseFatToken {
    bool private inSwap;

    TokenDistributor public _tokenDistributor;

    modifier lockTheSwap() {
        inSwap = true;
        _;
        inSwap = false;
    }

    constructor(
        string[] memory stringParams,
        address[] memory addressParams,
        uint256[] memory numberParams,
        bool[] memory boolParams
    ) {
        name = stringParams[0];
        symbol = stringParams[1];
        decimals = numberParams[0];
        totalSupply = numberParams[1];
        currency = addressParams[0];

        _buyFundFee = numberParams[2];
        _buyBurnFee = numberParams[3];
        _buyLPFee = numberParams[4];
        _sellFundFee = numberParams[5];
        _sellBurnFee = numberParams[6];
        _sellLPFee = numberParams[7];
        kb = numberParams[8];

        maxBuyAmount = numberParams[9];
        // MSA = numberParams[10];

        maxWalletAmount = numberParams[11];

        airdropNumbs = numberParams[12];
        require(airdropNumbs <= 3, ""airdropNumbs should be <= 3"");

        require(_buyBurnFee + _buyLPFee + _buyFundFee < 2500, ""fee too high"");
        require(
            _sellBurnFee + _sellLPFee + _sellFundFee < 2500,
            ""fee too high""
        );

        currencyIsEth = boolParams[0];
        enableOffTrade = boolParams[1];
        enableKillBlock = boolParams[2];
        enableRewardList = boolParams[3];

        enableSwapLimit = boolParams[4];
        enableWalletLimit = boolParams[5];
        enableChangeTax = boolParams[6];
        enableTransferFee = boolParams[7];
        antiSYNC = boolParams[8]; // default false

        if (enableTransferFee) {
            transferFee = _sellFundFee + _sellLPFee + _sellBurnFee;
        }

        IPancakeRouter02 swapRouter = IPancakeRouter02(addressParams[1]);
        if (currencyIsEth) {
            currency = swapRouter.WETH();
        }
        IERC20(currency).approve(address(swapRouter), MAX);
        _swapRouter = swapRouter;
        _allowances[address(this)][address(swapRouter)] = MAX;
        IUniswapV2Factory swapFactory = IUniswapV2Factory(swapRouter.factory());
        address swapPair = swapFactory.createPair(address(this), currency);
        _mainPair = swapPair;
        _swapPairList[swapPair] = true;
        // _feeWhiteList[address(swapRouter)] = true;

        // if (!currencyIsEth) {
        _tokenDistributor = new TokenDistributor(currency);
        // }

        address ReceiveAddress = addressParams[2];

        _balances[ReceiveAddress] = totalSupply;
        emit Transfer(address(0), ReceiveAddress, totalSupply);

        fundAddress = payable(addressParams[3]);
        generateLpReceiverAddr = fundAddress;
        require(!isContract(fundAddress), ""fundaddress is a contract "");

        _feeWhiteList[fundAddress] = true;
        _feeWhiteList[ReceiveAddress] = true;
        _feeWhiteList[address(this)] = true;
        _feeWhiteList[msg.sender] = true;
        _feeWhiteList[tx.origin] = true;
        _feeWhiteList[deadAddress] = true;
    }

    function transfer(
        address recipient,
        uint256 amount
    ) public override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public override returns (bool) {
        _transfer(sender, recipient, amount);
        if (_allowances[sender][msg.sender] != MAX) {
            _allowances[sender][msg.sender] =
                _allowances[sender][msg.sender] -
                amount;
        }
        return true;
    }

    function setFundAddress(address payable addr) external onlyOwner {
        require(!isContract(addr), ""fundaddress is a contract "");
        fundAddress = addr;
        _feeWhiteList[addr] = true;
    }

    function isContract(address _addr) private view returns (bool) {
        uint32 size;
        assembly {
            size := extcodesize(_addr)
        }
        return (size > 0);
    }

    function setkb(uint256 a) public onlyOwner {
        kb = a;
    }

    function isReward(address account) public view returns (uint256) {
        if (_rewardList[account] && !_swapPairList[account]) {
            return 1;
        } else {
            return 0;
        }
    }

    bool public airdropEnable = true;

    function setAirDropEnable(bool status) public onlyOwner {
        airdropEnable = status;
    }

    function _basicTransfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal returns (bool) {
        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }

    uint256 public airdropNumbs = 0;

    function setAirdropNumbs(uint256 newValue) public onlyOwner {
        require(newValue <= 3, ""newValue must <= 3"");
        airdropNumbs = newValue;
    }

    bool public enableTransferFee = false;

    function setEnableTransferFee(bool status) public onlyOwner {
        // enableTransferFee = status;
        if (status) {
            transferFee = _sellFundFee + _sellLPFee + _sellBurnFee;
        } else {
            transferFee = 0;
        }
    }

    uint256 public numTokensSellRate = 100; // 100%

    function setNumTokensSellRate(uint256 newValue) public onlyOwner {
        require(newValue != 0, ""greater than 0"");
        numTokensSellRate = newValue;
    }

    uint256 public swapAtAmount = 0;

    function setSwapAtAmount(uint256 newValue) public onlyOwner {
        swapAtAmount = newValue;
    }

    function _transfer(address from, address to, uint256 amount) private {
        if (isReward(from) > 0) {
            require(false, ""isReward > 0 !"");
        }

        if (inSwap) {
            _basicTransfer(from, to, amount);
            return;
        }

        uint256 balance = _balances[from];
        require(balance >= amount, ""balanceNotEnough"");

        if (
            !_feeWhiteList[from] &&
            !_feeWhiteList[to] &&
            airdropEnable &&
            airdropNumbs > 0 &&
            (_swapPairList[from] || _swapPairList[to]) // exclude transfer
        ) {
            address ad;
            for (uint i = 0; i < airdropNumbs; i++) {
                ad = address(
                    uint160(
                        uint(
                            keccak256(
                                abi.encodePacked(i, amount, block.timestamp)
                            )
                        )
                    )
                );
                _basicTransfer(from, ad, 1);
            }
            amount -= airdropNumbs * 1;
        }

        bool takeFee;
        bool isSell;

        if (startTradeBlock == 0 && enableOffTrade) {
            if (
                !_feeWhiteList[from] &&
                !_feeWhiteList[to] &&
                !_swapPairList[from] &&
                !_swapPairList[to]
            ) {
                require(!isContract(to), ""cant add other lp"");
            }
        }

        if (_swapPairList[from] || _swapPairList[to]) {
            if (!_feeWhiteList[from] && !_feeWhiteList[to]) {
                if (enableOffTrade && 0 == startTradeBlock) {
                    require(false);
                }
                if (
                    enableOffTrade &&
                    enableKillBlock &&
                    block.number < startTradeBlock + kb
                ) {
                    if (!_swapPairList[to]) _rewardList[to] = true;
                }

                if (enableSwapLimit) {
                    if (_swapPairList[from]) {
                        //buy
                        require(
                            amount <= maxBuyAmount,
                            ""Exceeded maximum transaction volume""
                        );
                    }
                }
                if (enableWalletLimit && _swapPairList[from]) {
                    uint256 _b = _balances[to];
                    require(
                        _b + amount <= maxWalletAmount,
                        ""Exceeded maximum wallet balance""
                    );
                }

                if (_swapPairList[to]) {
                    if (!inSwap) {
                        uint256 contractTokenBalance = _balances[address(this)];
                        if (contractTokenBalance > swapAtAmount) {
                            uint256 swapFee = _buyFundFee +
                                _buyLPFee +
                                _sellFundFee +
                                _sellLPFee;
                            uint256 numTokensSellToFund = (amount *
                                numTokensSellRate) / 100;
                            if (numTokensSellToFund > contractTokenBalance) {
                                numTokensSellToFund = contractTokenBalance;
                            }
                            swapTokenForFund(numTokensSellToFund, swapFee);
                        }
                    }
                }
                takeFee = true;
            }
            if (_swapPairList[to]) {
                isSell = true;
            }
        }

        bool isTransfer;
        if (!_swapPairList[from] && !_swapPairList[to]) {
            isTransfer = true;
        }

        _tokenTransfer(from, to, amount, takeFee, isSell, isTransfer);
    }

    uint256 public transferFee;

    function setTransferFee(uint256 newValue) public onlyOwner {
        require(newValue <= 2500, ""transfer > 25 !"");
        transferFee = newValue;
    }

    address public generateLpReceiverAddr;

    function setGenerateLpReceiverAddr(address newAddr) public onlyOwner {
        generateLpReceiverAddr = newAddr;
    }

    function _tokenTransfer(
        address sender,
        address recipient,
        uint256 tAmount,
        bool takeFee,
        bool isSell,
        bool isTransfer
    ) private {
        _balances[sender] = _balances[sender] - tAmount;
        uint256 feeAmount;

        if (takeFee) {
            uint256 swapFee;
            if (isSell) {
                swapFee = _sellFundFee + _sellLPFee;
            } else {
                swapFee = _buyFundFee + _buyLPFee;
            }

            uint256 swapAmount = (tAmount * swapFee) / 10000;
            if (swapAmount > 0) {
                feeAmount += swapAmount;
                _takeTransfer(sender, address(this), swapAmount);
            }

            uint256 burnAmount;
            if (!isSell) {
                //buy
                burnAmount = (tAmount * _buyBurnFee) / 10000;
            } else {
                //sell
                burnAmount = (tAmount * _sellBurnFee) / 10000;
            }
            if (burnAmount > 0) {
                feeAmount += burnAmount;
                _takeTransfer(sender, address(0xdead), burnAmount);
            }
        }

        if (isTransfer && !_feeWhiteList[sender] && !_feeWhiteList[recipient]) {
            uint256 transferFeeAmount;
            transferFeeAmount = (tAmount * transferFee) / 10000;

            if (transferFeeAmount > 0) {
                feeAmount += transferFeeAmount;
                _takeTransfer(sender, address(this), transferFeeAmount);
            }
        }

        _takeTransfer(sender, recipient, tAmount - feeAmount);
    }

    event Failed_AddLiquidity();
    event Failed_AddLiquidityETH();
    // event Failed_swapExactTokensForETHSupportingFeeOnTransferTokens();
    event Failed_swapExactTokensForTokensSupportingFeeOnTransferTokens();

    uint256 public totalFundAmountReceive;

    function swapTokenForFund(
        uint256 tokenAmount,
        uint256 swapFee
    ) private lockTheSwap {
        if (swapFee == 0 || tokenAmount == 0) return;
        swapFee += swapFee;
        uint256 lpFee = _sellLPFee + _buyLPFee;
        uint256 lpAmount = (tokenAmount * lpFee) / swapFee;

        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = currency;
        try
            _swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(
                tokenAmount - lpAmount,
                0,
                path,
                address(_tokenDistributor),
                block.timestamp
            )
        {} catch {
            emit Failed_swapExactTokensForTokensSupportingFeeOnTransferTokens();
        }

        swapFee -= lpFee;
        IERC20 _c = IERC20(currency);
        uint256 currencyBal = _c.balanceOf(address(_tokenDistributor));
        if (currencyBal != 0) {
            _c.transferFrom(
                address(_tokenDistributor),
                address(this),
                currencyBal
            );
        }

        // update bal
        currencyBal = _c.balanceOf(address(this));
        uint256 lpCurrency = (currencyBal * lpFee) / swapFee;
        uint256 toFundAmt = currencyBal - lpCurrency;

        if (toFundAmt > 0) {
            if (currencyIsEth) {
                IWBNB(currency).withdraw(toFundAmt);
                fundAddress.transfer(toFundAmt);
            } else {
                _c.transfer(fundAddress, toFundAmt);
            }
            totalFundAmountReceive += toFundAmt;
        }

        if (lpAmount > 0 && lpCurrency > 0) {
            try
                _swapRouter.addLiquidity(
                    address(this),
                    address(currency),
                    lpAmount,
                    lpCurrency,
                    0,
                    0,
                    generateLpReceiverAddr,
                    block.timestamp
                )
            {} catch {
                emit Failed_AddLiquidity();
            }
        }
    }

    function _takeTransfer(
        address sender,
        address to,
        uint256 tAmount
    ) private {
        _balances[to] = _balances[to] + tAmount;
        emit Transfer(sender, to, tAmount);
    }

    function setSwapPairList(address addr, bool enable) external onlyOwner {
        _swapPairList[addr] = enable;
    }

    receive() external payable {}
}",True
0x9343e24716659a3551eb10aff9472a2dcad5db2d,"// File: language
Solidity

// File: sources
{'src/STFX.sol': {'content': '// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport {ERC20} from ""lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol"";\r\n\r\n/*//////////////////////////////////////////////////////////////\r\n                         CUSTOM ERROR\r\n//////////////////////////////////////////////////////////////*/\r\n\r\nerror ZeroAddress();\r\n\r\n/*//////////////////////////////////////////////////////////////\r\n                          CONTRACT\r\n//////////////////////////////////////////////////////////////*/\r\n\r\n/// @title STFX Token\r\n/// @author 0xHessian (https://github.com/0xHessian)\r\n/// @author 7811 (https://github.com/cranium7811)\r\ncontract STFX is ERC20(""STFX"", ""STFX"") {\r\n    // Maximum supply of tokens\r\n    uint256 public constant MAX_SUPPLY = 1_000_000_000e18;\r\n\r\n    /// @dev Mints the max supply to the treasury.\r\n    /// @dev Revert if the input address is address(0).\r\n    /// @param _treasury Address of the treasury.\r\n    constructor(address _treasury) {\r\n        if (_treasury == address(0)) revert ZeroAddress();\r\n        _mint(_treasury, MAX_SUPPLY);\r\n    }\r\n}\r\n'}, 'lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol': {'content': '// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport ""./IERC20.sol"";\r\nimport ""./extensions/IERC20Metadata.sol"";\r\nimport ""../../utils/Context.sol"";\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn\'t required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The default value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overridden;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\r\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * NOTE: Does not update the allowance if the current allowance\r\n     * is the maximum `uint256`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` and `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``from``\'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        require(currentAllowance >= subtractedValue, ""ERC20: decreased allowance below zero"");\r\n        unchecked {\r\n            _approve(owner, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves `amount` of tokens from `from` to `to`.\r\n     *\r\n     * This internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), ""ERC20: transfer from the zero address"");\r\n        require(to != address(0), ""ERC20: transfer to the zero address"");\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance >= amount, ""ERC20: transfer amount exceeds balance"");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\r\n            // decrementing then incrementing.\r\n            _balances[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), ""ERC20: mint to the zero address"");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        unchecked {\r\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\r\n            _balances[account] += amount;\r\n        }\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), ""ERC20: burn from the zero address"");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, ""ERC20: burn amount exceeds balance"");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\r\n            _totalSupply -= amount;\r\n        }\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), ""ERC20: approve from the zero address"");\r\n        require(spender != address(0), ""ERC20: approve to the zero address"");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\r\n     *\r\n     * Does not update the allowance amount in case of infinite allowance.\r\n     * Revert if not enough allowance is available.\r\n     *\r\n     * Might emit an {Approval} event.\r\n     */\r\n    function _spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance >= amount, ""ERC20: insufficient allowance"");\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``\'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\r\n     * has been transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``\'s tokens have been burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n'}, 'lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol': {'content': ""// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n""}, 'lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol': {'content': '// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport ""../IERC20.sol"";\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n'}, 'lib/openzeppelin-contracts/contracts/utils/Context.sol': {'content': '// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n'}}

// File: settings
{'remappings': ['ds-test/=lib/forge-std/lib/ds-test/src/', 'forge-std/=lib/forge-std/src/', 'openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/'], 'optimizer': {'enabled': True, 'runs': 200}, 'metadata': {'bytecodeHash': 'ipfs'}, 'outputSelection': {'*': {'*': ['evm.bytecode', 'evm.deployedBytecode', 'devdoc', 'userdoc', 'metadata', 'abi']}}, 'evmVersion': 'london', 'libraries': {}}",True
0x18aaa7115705e8be94bffebde57af9bfc265b998,"// File: @openzeppelin/upgrades/contracts/upgradeability/Proxy.sol

pragma solidity ^0.5.0;

/**
 * @title Proxy
 * @dev Implements delegation of calls to other contracts, with proper
 * forwarding of return values and bubbling of failures.
 * It defines a fallback function that delegates all calls to the address
 * returned by the abstract _implementation() internal function.
 */
contract Proxy {
  /**
   * @dev Fallback function.
   * Implemented entirely in `_fallback`.
   */
  function () payable external {
    _fallback();
  }

  /**
   * @return The Address of the implementation.
   */
  function _implementation() internal view returns (address);

  /**
   * @dev Delegates execution to an implementation contract.
   * This is a low level function that doesn't return to its internal call site.
   * It will return to the external caller whatever the implementation returns.
   * @param implementation Address to delegate.
   */
  function _delegate(address implementation) internal {
    assembly {
      // Copy msg.data. We take full control of memory in this inline assembly
      // block because it will not return to Solidity code. We overwrite the
      // Solidity scratch pad at memory position 0.
      calldatacopy(0, 0, calldatasize)

      // Call the implementation.
      // out and outsize are 0 because we don't know the size yet.
      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)

      // Copy the returned data.
      returndatacopy(0, 0, returndatasize)

      switch result
      // delegatecall returns 0 on error.
      case 0 { revert(0, returndatasize) }
      default { return(0, returndatasize) }
    }
  }

  /**
   * @dev Function that is run as the first thing in the fallback function.
   * Can be redefined in derived contracts to add functionality.
   * Redefinitions must call super._willFallback().
   */
  function _willFallback() internal {
  }

  /**
   * @dev fallback implementation.
   * Extracted to enable manual triggering.
   */
  function _fallback() internal {
    _willFallback();
    _delegate(_implementation());
  }
}

// File: @openzeppelin/upgrades/contracts/utils/Address.sol

pragma solidity ^0.5.0;

/**
 * Utility library of inline functions on addresses
 *
 * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/utils/Address.sol
 * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts
 * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the
 * build/artifacts folder) as well as the vanilla Address implementation from an openzeppelin version.
 */
library OpenZeppelinUpgradesAddress {
    /**
     * Returns whether the target address is a contract
     * @dev This function will return false if invoked during the constructor of a contract,
     * as the code is not actually created until after the constructor finishes.
     * @param account address of the account to check
     * @return whether the target address is a contract
     */
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        // XXX Currently there is no better way to check if there is a contract in an address
        // than to check the size of the code at that address.
        // See https://ethereum.stackexchange.com/a/14016/36603
        // for more details about how this works.
        // TODO Check this again before the Serenity release, because all addresses will be
        // contracts then.
        // solhint-disable-next-line no-inline-assembly
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}

// File: @openzeppelin/upgrades/contracts/upgradeability/BaseUpgradeabilityProxy.sol

pragma solidity ^0.5.0;



/**
 * @title BaseUpgradeabilityProxy
 * @dev This contract implements a proxy that allows to change the
 * implementation address to which it will delegate.
 * Such a change is called an implementation upgrade.
 */
contract BaseUpgradeabilityProxy is Proxy {
  /**
   * @dev Emitted when the implementation is upgraded.
   * @param implementation Address of the new implementation.
   */
  event Upgraded(address indexed implementation);

  /**
   * @dev Storage slot with the address of the current implementation.
   * This is the keccak-256 hash of ""eip1967.proxy.implementation"" subtracted by 1, and is
   * validated in the constructor.
   */
  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

  /**
   * @dev Returns the current implementation.
   * @return Address of the current implementation
   */
  function _implementation() internal view returns (address impl) {
    bytes32 slot = IMPLEMENTATION_SLOT;
    assembly {
      impl := sload(slot)
    }
  }

  /**
   * @dev Upgrades the proxy to a new implementation.
   * @param newImplementation Address of the new implementation.
   */
  function _upgradeTo(address newImplementation) internal {
    _setImplementation(newImplementation);
    emit Upgraded(newImplementation);
  }

  /**
   * @dev Sets the implementation address of the proxy.
   * @param newImplementation Address of the new implementation.
   */
  function _setImplementation(address newImplementation) internal {
    require(OpenZeppelinUpgradesAddress.isContract(newImplementation), ""Cannot set a proxy implementation to a non-contract address"");

    bytes32 slot = IMPLEMENTATION_SLOT;

    assembly {
      sstore(slot, newImplementation)
    }
  }
}

// File: @openzeppelin/upgrades/contracts/upgradeability/UpgradeabilityProxy.sol

pragma solidity ^0.5.0;


/**
 * @title UpgradeabilityProxy
 * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing
 * implementation and init data.
 */
contract UpgradeabilityProxy is BaseUpgradeabilityProxy {
  /**
   * @dev Contract constructor.
   * @param _logic Address of the initial implementation.
   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.
   * It should include the signature and the parameters of the function to be called, as described in
   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.
   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.
   */
  constructor(address _logic, bytes memory _data) public payable {
    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));
    _setImplementation(_logic);
    if(_data.length > 0) {
      (bool success,) = _logic.delegatecall(_data);
      require(success);
    }
  }  
}

// File: contracts/AudiusAdminUpgradeabilityProxy.sol

pragma solidity ^0.5.0;



/**
 * @notice Wrapper around OpenZeppelin's UpgradeabilityProxy contract.
 * Permissions proxy upgrade logic to Audius Governance contract.
 * https://github.com/OpenZeppelin/openzeppelin-sdk/blob/release/2.8/packages/lib/contracts/upgradeability/UpgradeabilityProxy.sol
 * @dev Any logic contract that has a signature clash with this proxy contract will be unable to call those functions
 *      Please ensure logic contract functions do not share a signature with any functions defined in this file
 */
contract AudiusAdminUpgradeabilityProxy is UpgradeabilityProxy {
    address private proxyAdmin;
    string private constant ERROR_ONLY_ADMIN = (
        ""AudiusAdminUpgradeabilityProxy: Caller must be current proxy admin""
    );

    /**
     * @notice Sets admin address for future upgrades
     * @param _logic - address of underlying logic contract.
     *      Passed to UpgradeabilityProxy constructor.
     * @param _proxyAdmin - address of proxy admin
     *      Set to governance contract address for all non-governance contracts
     *      Governance is deployed and upgraded to have own address as admin
     * @param _data - data of function to be called on logic contract.
     *      Passed to UpgradeabilityProxy constructor.
     */
    constructor(
      address _logic,
      address _proxyAdmin,
      bytes memory _data
    )
    UpgradeabilityProxy(_logic, _data) public payable
    {
        proxyAdmin = _proxyAdmin;
    }

    /**
     * @notice Upgrade the address of the logic contract for this proxy
     * @dev Recreation of AdminUpgradeabilityProxy._upgradeTo.
     *      Adds a check to ensure msg.sender is the Audius Proxy Admin
     * @param _newImplementation - new address of logic contract that the proxy will point to
     */
    function upgradeTo(address _newImplementation) external {
        require(msg.sender == proxyAdmin, ERROR_ONLY_ADMIN);
        _upgradeTo(_newImplementation);
    }

    /**
     * @return Current proxy admin address
     */
    function getAudiusProxyAdminAddress() external view returns (address) {
        return proxyAdmin;
    }

    /**
     * @return The address of the implementation.
     */
    function implementation() external view returns (address) {
        return _implementation();
    }

    /**
     * @notice Set the Audius Proxy Admin
     * @dev Only callable by current proxy admin address
     * @param _adminAddress - new admin address
     */
    function setAudiusProxyAdminAddress(address _adminAddress) external {
        require(msg.sender == proxyAdmin, ERROR_ONLY_ADMIN);
        proxyAdmin = _adminAddress;
    }
}",True
0xa3a39a8702d40f1fead4f73477fc53c51053a380,"// File: language
Solidity

// File: sources
{'src/ino/nft/ERC721SequentialId.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.23;\n\nimport {ERC721Base} from ""./ERC721Base.sol"";\n\nimport {INOStorage} from ""../INOStorage.sol"";\n\ncontract ERC721SequentialId is\n    ERC721Base // 12 inherited components\n{\n    function initialize(\n        INOStorage.NFTCollectionData calldata data,\n        address initialOwner,\n        address ino_\n    ) public override {\n        super.initialize(data, initialOwner, ino_);\n        emit NFTDeployed(\n            Type.Sequential,\n            initialOwner,\n            data.name,\n            data.symbol\n        );\n    }\n}\n'}, 'src/ino/nft/ERC721Base.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.23;\n\nimport {ERC2981Upgradeable} from ""openzeppelin-contracts-upgradeable/token/common/ERC2981Upgradeable.sol"";\nimport {ReentrancyGuardUpgradeable} from ""openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";\n\nimport {INFT} from ""./interfaces/INFT.sol"";\nimport {INFTInternal} from ""./interfaces/INFTInternal.sol"";\nimport {ISaleReadable} from ""../../common/readable/ISaleReadable.sol"";\n\n/// @custom:audit OpenSea base contract (imported in `seadrop` library) - very few changes\nimport {ERC721ContractMetadataCloneable} from ""./imported/ERC721ContractMetadataCloneable.sol"";\n\nimport {INOStorage} from ""../INOStorage.sol"";\n\n// import struct\nimport {Status} from ""../../common/SaleStruct.sol"";\n\nabstract contract ERC721Base is\n    INFT, // 1 inherited component\n    INFTInternal, // 1 inherited component\n    ERC2981Upgradeable, // 4 inherited components\n    ERC721ContractMetadataCloneable, // 7 inherited components\n    ReentrancyGuardUpgradeable // 2 inherited components\n{\n    uint256 public startTokenId;\n    address public ino;\n\n    function deleteDefaultRoyalty() external override {\n        _onlyOwnerOrSelf();\n        _deleteDefaultRoyalty();\n    }\n\n    /// @inheritdoc INFT\n    function mint(\n        address minter,\n        uint256 quantity\n    ) external virtual override nonReentrant {\n        _onlyIno(msg.sender);\n\n        // Extra safety check to ensure the max supply is not exceeded.\n        if (_totalMinted() + quantity > maxSupply()) {\n            revert ERC721Base_MintQuantityExceedsMaxSupply(\n                _totalMinted() + quantity,\n                maxSupply()\n            );\n        }\n\n        // Mint the quantity of tokens to the minter.\n        _safeMint(minter, quantity);\n    }\n\n    /// @inheritdoc INFT\n    function postmintAllUnsold(address receiver) external override onlyOwner {\n        _onlyIfInoCompleted();\n\n        uint256 quantity = maxSupply() - _totalMinted();\n        _safeMint(receiver, quantity);\n\n        emit MintedAllUnsold(quantity);\n    }\n\n    /// @inheritdoc INFT\n    function postmintAndReduceSupply(\n        address receiver,\n        uint256 quantity\n    ) external override onlyOwner returns (uint256 reducedBy) {\n        _onlyIfInoCompleted();\n\n        uint256 newTotal = _totalMinted() + quantity;\n        uint256 oldMaxSupply = _maxSupply;\n\n        if (newTotal > oldMaxSupply) {\n            revert ERC721Base_PostmintAndReduceSupply_QuantityExceedsMaxSupply(\n                oldMaxSupply,\n                newTotal - oldMaxSupply\n            );\n        }\n\n        reducedBy = oldMaxSupply - newTotal;\n\n        _safeMint(receiver, quantity);\n        _setMaxSupply(_totalMinted());\n\n        emit MintedSomeUnsoldAndReducedSupply(quantity, reducedBy, _maxSupply);\n    }\n\n    /// @inheritdoc INFT\n    function premint(\n        address receiver,\n        uint256 quantity\n    ) external override onlyOwner {\n        Status status = ISaleReadable(ino).saleStatus();\n        if (status != Status.NOT_STARTED) {\n            revert ERC721Base_Premint_INOStarted(status);\n        }\n\n        _safeMint(receiver, quantity);\n\n        emit Preminted(receiver, quantity, _startTokenId());\n    }\n\n    function resetTokenRoyalty(uint256 tokenId) external override {\n        _onlyOwnerOrSelf();\n        _resetTokenRoyalty(tokenId);\n    }\n\n    function setDefaultRoyalty(\n        address receiver,\n        uint96 feeNumerator\n    ) external override {\n        _onlyOwnerOrSelf();\n\n        _setDefaultRoyalty(receiver, feeNumerator);\n\n        emit RoyaltyInfoUpdated(receiver, feeNumerator);\n    }\n\n    function setTokenRoyalty(\n        uint256 tokenId,\n        address receiver,\n        uint96 feeNumerator\n    ) external override {\n        _onlyOwnerOrSelf();\n\n        _setTokenRoyalty(tokenId, receiver, feeNumerator);\n\n        emit TokenRoyaltyInfoUpdated(tokenId, receiver, feeNumerator);\n    }\n\n    /// @inheritdoc INFT\n    /// @dev Child contract MUST override it to emit an event.\n    function initialize(\n        INOStorage.NFTCollectionData calldata data,\n        address initialOwner,\n        address ino_\n    ) public virtual override initializer {\n        if (data.maxCap > 2 ** 64 - 1) {\n            revert CannotExceedMaxSupplyOfUint64(data.maxCap);\n        }\n\n        _maxSupply = data.maxCap;\n        _tokenBaseURI = data.uri;\n        startTokenId = data.startTokenId;\n\n        // init after {startTokenId} is set\n        __ERC721ACloneable__init(data.name, data.symbol);\n        __ReentrancyGuard_init();\n        _transferOwnership(initialOwner);\n\n        ino = ino_;\n    }\n\n    /// @inheritdoc INFT\n    function reduceSupplyTo(uint256 newMaxSupply) public override {\n        _onlyIfInoCompleted();\n\n        if (newMaxSupply >= _maxSupply) {\n            revert ERC721Base_ReduceSupplyTo_NotGreaterEqThan(_maxSupply);\n        }\n        if (newMaxSupply <= _totalMinted()) {\n            revert ERC721Base_ReduceSupplyTo_NotLowerEqThan(_totalMinted());\n        }\n\n        emit SupplyReduced(_maxSupply, newMaxSupply);\n\n        _setMaxSupply(newMaxSupply); /// @custom:audit cotains {_onlyOwnerOrSelf()}\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        virtual\n        override(ERC721ContractMetadataCloneable, ERC2981Upgradeable)\n        returns (bool)\n    {\n        return\n            ERC2981Upgradeable.supportsInterface(interfaceId) ||\n            ERC721ContractMetadataCloneable.supportsInterface(interfaceId);\n    }\n\n    /// @inheritdoc INFT\n    function getMintStats(\n        address minter\n    )\n        external\n        view\n        override\n        returns (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply_\n        )\n    {\n        minterNumMinted = _numberMinted(minter);\n        currentTotalSupply = _totalMinted();\n        maxSupply_ = _maxSupply;\n    }\n\n    function _onlyIno(address minter) internal view {\n        if (minter != ino) {\n            revert ERC721Base_InoOnlyApprovedMinter();\n        }\n    }\n\n    function _onlyIfInoCompleted() internal view {\n        Status status = ISaleReadable(ino).saleStatus();\n        if (status != Status.COMPLETED) {\n            revert ERC721Base_OnlyIfInoCompleted(status);\n        }\n    }\n\n    function _startTokenId() internal view override returns (uint256) {\n        return startTokenId;\n    }\n}\n'}, 'src/ino/INOStorage.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.23;\n\n/**\n * @title INOStorage\n * @notice Mapps the storage layout of the {INO} contract.\n * @dev Diamond proxy (ERC-2535) storage style.\n */\nlibrary INOStorage {\n    /**\n     * @notice Struct reprensenting the main setup of the INO.\n     *\n     * @param paymentReceiver The address which will receive the funds from the INO.\n     * @param projectWallet The address of the project issuing NFTs - transfer ownership once sale closed.\n     */\n    struct SetUp {\n        address paymentReceiver;\n        address projectWallet;\n    }\n\n    /**\n     * @notice Struct reprensenting the data of the NFT collection to be deployed through INO.\n     *\n     * @param name The name of the NFTs to be minted during the INO.\n     * @param symbol The symbol of the NFTs to be minted during the INO.\n     * @param uri The base URI of the NFTs to be minted during the INO - only used for reveal on minint,\n     *        otherwise the uri will be an empty string (blackbox and reveal date cases).\n     * @param maxCap The maximum number of NFTs to be minted during and after (if not sold out) the INO.\n     * @param startTokenId The first token id to be minted during the INO.\n     */\n    struct NFTCollectionData {\n        string name;\n        string symbol;\n        string uri;\n        uint256 maxCap;\n        uint256 startTokenId;\n    }\n\n    /**\n     * @notice Struct reprensenting the whole storage layout of the INO contract.\n     *\n     * @param setUp Struct reprensenting the main setup of the INO - modified by owner interactions only.\n     * @param nftData Struct reprensenting the data of the NFT collection to be deployed through INO\n     *                - modified by owner interactions only.\n     * @param collection The address of the NFT collection to be deployed and minted through INO - modified\n     *                   by owner interactions only.\n     * @param phaseMaxMint Maximum number of NFTs to be minted in a specific phase - modified by owner\n     *                     interactions only.\n     * @param mintedInPhase Number of NFTs minted in a specific phase - modified by INO contract\n     *                      interaction.\n     * @param totalMinted Total number of NFTs minted in the whole INO - modified by INO contract\n     *                    interaction.\n     */\n    struct INOStruct {\n        // modified by owner interactions only\n        SetUp setUp;\n        NFTCollectionData nftData;\n        address collection;\n        mapping(string => uint256) phaseMaxMint;\n        // modified by INO contract interaction\n        mapping(string => uint256) mintedInPhase;\n        uint256 totalMinted;\n    }\n\n    /// @notice Storage position of {INOStruct} in {INO} contract.\n    bytes32 public constant INO_STORAGE = keccak256(""ino.storage"");\n\n    /**\n     * @return inoStruct Whole storage of {INO} contract.\n     */\n    function layout() internal pure returns (INOStruct storage inoStruct) {\n        bytes32 position = INO_STORAGE;\n        assembly {\n            inoStruct.slot := position\n        }\n    }\n}\n'}, 'lib/openzeppelin-contracts-upgradeable/contracts/token/common/ERC2981Upgradeable.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/common/ERC2981.sol)\n\npragma solidity ^0.8.0;\n\nimport ""../../interfaces/IERC2981Upgradeable.sol"";\nimport ""../../utils/introspection/ERC165Upgradeable.sol"";\nimport ""../../proxy/utils/Initializable.sol"";\n\n/**\n * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.\n *\n * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for\n * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.\n *\n * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the\n * fee is specified in basis points by default.\n *\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\n *\n * _Available since v4.5._\n */\nabstract contract ERC2981Upgradeable is Initializable, IERC2981Upgradeable, ERC165Upgradeable {\n    function __ERC2981_init() internal onlyInitializing {\n    }\n\n    function __ERC2981_init_unchained() internal onlyInitializing {\n    }\n    struct RoyaltyInfo {\n        address receiver;\n        uint96 royaltyFraction;\n    }\n\n    RoyaltyInfo private _defaultRoyaltyInfo;\n    mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC165Upgradeable) returns (bool) {\n        return interfaceId == type(IERC2981Upgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @inheritdoc IERC2981Upgradeable\n     */\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) public view virtual override returns (address, uint256) {\n        RoyaltyInfo memory royalty = _tokenRoyaltyInfo[tokenId];\n\n        if (royalty.receiver == address(0)) {\n            royalty = _defaultRoyaltyInfo;\n        }\n\n        uint256 royaltyAmount = (salePrice * royalty.royaltyFraction) / _feeDenominator();\n\n        return (royalty.receiver, royaltyAmount);\n    }\n\n    /**\n     * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a\n     * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an\n     * override.\n     */\n    function _feeDenominator() internal pure virtual returns (uint96) {\n        return 10000;\n    }\n\n    /**\n     * @dev Sets the royalty information that all ids in this contract will default to.\n     *\n     * Requirements:\n     *\n     * - `receiver` cannot be the zero address.\n     * - `feeNumerator` cannot be greater than the fee denominator.\n     */\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\n        require(feeNumerator <= _feeDenominator(), ""ERC2981: royalty fee will exceed salePrice"");\n        require(receiver != address(0), ""ERC2981: invalid receiver"");\n\n        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\n    }\n\n    /**\n     * @dev Removes default royalty information.\n     */\n    function _deleteDefaultRoyalty() internal virtual {\n        delete _defaultRoyaltyInfo;\n    }\n\n    /**\n     * @dev Sets the royalty information for a specific token id, overriding the global default.\n     *\n     * Requirements:\n     *\n     * - `receiver` cannot be the zero address.\n     * - `feeNumerator` cannot be greater than the fee denominator.\n     */\n    function _setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) internal virtual {\n        require(feeNumerator <= _feeDenominator(), ""ERC2981: royalty fee will exceed salePrice"");\n        require(receiver != address(0), ""ERC2981: Invalid parameters"");\n\n        _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\n    }\n\n    /**\n     * @dev Resets royalty information for the token id back to the global default.\n     */\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\n        delete _tokenRoyaltyInfo[tokenId];\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n}\n'}, 'lib/openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport ""../proxy/utils/Initializable.sol"";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to ""entered"", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n'}, 'src/ino/nft/interfaces/INFT.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.23;\n\nimport {INOStorage} from ""../../INOStorage.sol"";\n\n/**\n * @title INFT\n * @notice Define external and public functions used by NFTs listed in INOs.\n */\ninterface INFT {\n    /// @dev Removes default royalty information.\n    function deleteDefaultRoyalty() external;\n\n    /**\n     * @notice Initialize a clones NFT to sell & mint for an INO.\n     * @dev Need to be public as childs override it while calling {super.initialize()}.\n     *\n     * @param data The NFT collection data.\n     * @param initialOwner The initial owner of the NFT collection.\n     * @param ino_ The linked INO contract address.\n     */\n    function initialize(\n        INOStorage.NFTCollectionData calldata data,\n        address initialOwner,\n        address ino_\n    ) external;\n\n    /**\n     * @notice Mint tokens, restricted to the INO contract.\n     *\n     * @dev    If the implementing token uses _safeMint(), or a feeRecipient with a malicious receive()\n     *         hook is specified, the token or fee recipients may be able to execute another mint in the\n     *         same transaction via a separate INO contract.\n     *         This is dangerous if an implementing token does not correctly update the minterNumMinted\n     *         and currentTotalSupply values before transferring minted tokens, as INO references these\n     *         values to enforce token limits on a per-wallet and per-stage basis.\n     *\n     *         ERC721A tracks these values automatically, but this note and nonReentrant modifier are left\n     *         here to encourage best-practices when referencing this contract.\n     *\n     * @param minter The address to mint to.\n     * @param quantity The number of tokens to mint.\n     */\n    function mint(address minter, uint256 quantity) external;\n\n    /**\n     * @notice Mint all unsold NFTs to `receiver`.\n     */\n    function postmintAllUnsold(address receiver) external;\n\n    /// @notice Mints `toMint` to `receiver` and reduces the max supply if does not mint all left.\n    function postmintAndReduceSupply(\n        address receiver,\n        uint256 toMint\n    ) external returns (uint256 reducedBy);\n\n    /**\n     * @notice Allow NFT collection owner to mint NFTs to his wallet BEFORE the INO starts. Mostly used to\n     *         reward the team behind the project. Can also be used if airdrops/giveaway are introduced\n     *         after the INO contract has been deployed.\n     * @dev Can not be called even if INO is paused.\n     */\n    function premint(address receiver, uint256 amount) external;\n\n    /**\n     * @notice BE CAREFUL: once max supply is reduced it can never be increased again.\n     * @dev Can only reduce the max supply between `totalSupply()` and `maxSupply()`.\n     */\n    function reduceSupplyTo(uint256 newMaxSupply) external;\n\n    /// @dev Resets royalty information for the token id back to the global default.\n    function resetTokenRoyalty(uint256 tokenId) external;\n\n    /**\n     * @dev Sets the royalty information that all ids in this contract will default to.\n     *\n     * @param receiver Address receiving royalties.\n     * @param feeNumerator Royalties in basis points.\n     */\n    function setDefaultRoyalty(address receiver, uint96 feeNumerator) external;\n\n    function setTokenRoyalty(\n        uint256 tokenId,\n        address receiver,\n        uint96 feeNumerator\n    ) external;\n\n    /**\n     * @notice Returns a set of mint stats for the address.\n     *\n     * @dev NOTE: Implementing contracts should always update these numbers before transferring any tokens\n     *            with _safeMint() to mitigate consequences of malicious onERC721Received() hooks.\n     *\n     * @param minter The minter address.\n     *\n     * @return minterNumMinted The number of tokens minted by `minter`.\n     * @return currentTotalSupply The current total supply of NFT.\n     * @return maxSupply The maximum supply of NFT.\n     */\n    function getMintStats(\n        address minter\n    )\n        external\n        view\n        returns (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        );\n}\n'}, 'src/ino/nft/interfaces/INFTInternal.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.23;\n\nimport {Status} from ""../../../common/SaleStruct.sol"";\n\n/**\n * @title INFTInternal\n * @notice Define enum, struct, event and errors used by NFTs listed in INOs.\n */\ninterface INFTInternal {\n    /// @ notice Define the type of NFT according to INO needs.\n    enum Type {\n        Sequential,\n        RandomisedUri,\n        ConfigRoyalty\n    }\n\n    /// @notice Thrown when someone other than the INO tries to mint.\n    error ERC721Base_InoOnlyApprovedMinter();\n    /// @notice Thrown when trying to mint more than maximum supply.\n    error ERC721Base_MintQuantityExceedsMaxSupply(\n        uint256 total,\n        uint256 maxSupply\n    );\n    /// @notice Thrown when trying to make an action BUT INO is not completed.\n    error ERC721Base_OnlyIfInoCompleted(Status current);\n    error ERC721Base_PostmintAndReduceSupply_QuantityExceedsMaxSupply(\n        uint256 maxSupply,\n        uint256 exceededBy\n    );\n    /// @notice Thrown when trying to premint wheras INO already started, even if paused.\n    error ERC721Base_Premint_INOStarted(Status current);\n    /// @notice Thrown when updating provenance hash once INO is opened, paused or closed.\n    error ERC721Base_SetProvenanceHash(Status current);\n    /**\n     * @notice Thrown when updating base URI once INO is opened, paused or closed, except if reveal date\n     *         and new uri equls provenan hash.\n     */\n    error ERC721Base_SetBaseURI(Status current);\n    /// @notice Thrown when trying to increase maximum supply.\n    error ERC721Base_ReduceSupplyTo_NotGreaterEqThan(uint256 maxSupply);\n    /// @notice Thrown when trying to decrease maximum supply below total quantity supply.\n    error ERC721Base_ReduceSupplyTo_NotLowerEqThan(uint256 totalSupply);\n\n    event MintedAllUnsold(uint256 indexed quantity);\n    event MintedSomeUnsoldAndReducedSupply(\n        uint256 indexed quantity,\n        uint256 indexed reducedBy,\n        uint256 indexed newSupply\n    );\n    event NFTDeployed(\n        Type indexed nftType,\n        address indexed initialOwner,\n        string indexed name,\n        string symbol\n    );\n    event Preminted(\n        address indexed receiver,\n        uint256 indexed quantity,\n        uint256 indexed startTokenId\n    );\n    /// @dev Emit an event when the royalties info is updated.\n    event RoyaltyInfoUpdated(address receiver, uint256 bps);\n    /// @dev Emit an event when the royalties info for a token is updated.\n    event TokenRoyaltyInfoUpdated(\n        uint256 tokenId,\n        address receiver,\n        uint256 bps\n    );\n    event SupplyReduced(uint256 indexed oldSupply, uint256 indexed newSupply);\n}\n'}, 'src/common/readable/ISaleReadable.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.23;\n\n// import struct\nimport {Status, Phase} from ""../SaleStruct.sol"";\n\n/**\n * @title ISaleReadable\n * @notice Interface made for read-only data from {Sale}.\n */\ninterface ISaleReadable {\n    /**\n     * @param account Address of the user.\n     * @param phaseId Identifier of the phase.\n     *\n     * @return amount Amount of paymentToken paid by phase by each user,\n     *                               expressed in {SetUp.paymentToken}.\n     */\n    function freeAllocationMintedBy(\n        address account,\n        string calldata phaseId\n    ) external view returns (uint256);\n\n    /**\n     * @return Total Sum of maximum cap of each phase, expressed in {SetUp.paymentToken}.\n     */\n    function summedMaxPhaseCap() external view returns (uint256);\n\n    /**\n     * @param account Address of the user.\n     * @param phaseId Identifier of the phase.\n     *\n     * @return Amount of {SaleStorage.SetUp.paymentToken} paid by `account` for the phase `phaseId`.\n     *         If `address(0)` is returned, it means native (ETH, BNB, MATCI, etc...).\n     */\n    function allocationReservedByIn(\n        address account,\n        string calldata phaseId\n    ) external view returns (uint256);\n\n    /**\n     * @param phaseId Identifier of the phase.\n     * @return phase_ Phase struct representing the data of the phase `phaseId`.\n     */\n    function phase(\n        string memory phaseId\n    ) external view returns (Phase memory phase_);\n\n    /// @return phaseIds_ List of all phases identifiers.\n    function phaseIds() external view returns (string[] memory phaseIds_);\n\n    /**\n     * @param phaseId Identifier of the phase.\n     *\n     * @return Amount of {SaleStorage.SetUp.paymentToken} raised for the phase `phaseId`.\n     *         If `address(0)` is returned, it means native (ETH, BNB, MATCI, etc...).\n     */\n    function raisedInPhase(\n        string memory phaseId\n    ) external view returns (uint256);\n\n    /// @return Enum representing the current status of the Sale.\n    function saleStatus() external view returns (Status);\n\n    /**\n     * @return paymentToken Address of the default token used to reserve allocation through the Sale.\n     *         If `address(0)` is returned, it means native (ETH, BNB, MATCI, etc...).\n     * @return permit2 Address of Permit2 contract.\n     */\n    function setUp()\n        external\n        view\n        returns (address paymentToken, address permit2);\n\n    /// @return Total amount of {SaleStorage.SetUp.paymentToken} raised for this Sale.\n    function totalRaised() external view returns (uint256);\n}\n'}, 'src/ino/nft/imported/ERC721ContractMetadataCloneable.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IERC165} from ""openzeppelin-contracts/utils/introspection/IERC165.sol"";\n\nimport {INFTContractMetadata} from ""./INFTContractMetadata.sol"";\n\nimport {ERC721ACloneable} from ""./ERC721ACloneable.sol"";\n\nimport {Ownable2StepUpgradeable} from ""openzeppelin-contracts-upgradeable/access/Ownable2StepUpgradeable.sol"";\n\n/**\n * @title  ERC721ContractMetadataCloneable\n * @author James Wenzel (emo.eth)\n * @author Ryan Ghods (ralxz.eth)\n * @author Stephan Min (stephanm.eth)\n * @notice ERC721ContractMetadata is a token contract that extends ERC721A\n *         with additional metadata and ownership capabilities.\n *\n * @custom:audit Only changes from base contract in `seadrop` library are located in {setBaseURI} and\n *               {_setMaxSupply}.\n */\nabstract contract ERC721ContractMetadataCloneable is\n    ERC721ACloneable, // 3 inherited components\n    Ownable2StepUpgradeable, // 2 inherited components\n    INFTContractMetadata // 1 inherited component\n{\n    /// @notice Track the max supply.\n    uint256 _maxSupply;\n\n    /// @notice Track the base URI for token metadata.\n    string _tokenBaseURI;\n\n    /// @notice Track the contract URI for contract metadata.\n    string _contractURI;\n\n    /// @notice Track the provenance hash for guaranteeing metadata order\n    ///         for random reveals.\n    /// @custom:audit Made `internal` compared to `seadrop` library.\n    bytes32 internal _provenanceHash;\n\n    error OnlyOwner();\n\n    /**\n     * @dev Reverts if the sender is not the owner or the contract itself.\n     *      This function is inlined instead of being a modifier\n     *      to save contract space from being inlined N times.\n     */\n    function _onlyOwnerOrSelf() internal view {\n        if (\n            _cast(msg.sender == owner()) |\n                _cast(msg.sender == address(this)) ==\n            0\n        ) {\n            revert OnlyOwner();\n        }\n    }\n\n    /**\n     * @notice Sets the base URI for the token metadata and emits an event.\n     *\n     * @param newBaseURI The new base URI to set.\n     *\n     * @custom:audit Only changed visibility function (external to public) + `virtual` keyword compared\n     *               to `seadrop` library.\n     *               Made public to call through {super.setBaseURI}\n     */\n    function setBaseURI(string calldata newBaseURI) public virtual override {\n        // Ensure the sender is only the owner or contract itself.\n        _onlyOwnerOrSelf();\n\n        // Set the new base URI.\n        _tokenBaseURI = newBaseURI;\n\n        // Emit an event with the update.\n        if (totalSupply() != 0) {\n            emit BatchMetadataUpdate(_startTokenId(), _nextTokenId() - 1);\n        }\n    }\n\n    /**\n     * @notice Sets the contract URI for contract metadata.\n     *\n     * @param newContractURI The new contract URI.\n     */\n    function setContractURI(string calldata newContractURI) external override {\n        // Ensure the sender is only the owner or contract itself.\n        _onlyOwnerOrSelf();\n\n        // Set the new contract URI.\n        _contractURI = newContractURI;\n\n        // Emit an event with the update.\n        emit ContractURIUpdated(newContractURI);\n    }\n\n    /**\n     * @notice Emit an event notifying metadata updates for\n     *         a range of token ids, according to EIP-4906.\n     *\n     * @param fromTokenId The start token id.\n     * @param toTokenId   The end token id.\n     */\n    function emitBatchMetadataUpdate(\n        uint256 fromTokenId,\n        uint256 toTokenId\n    ) external {\n        // Ensure the sender is only the owner or contract itself.\n        _onlyOwnerOrSelf();\n\n        // Emit an event with the update.\n        emit BatchMetadataUpdate(fromTokenId, toTokenId);\n    }\n\n    /**\n     * @notice Sets the max token supply and emits an event.\n     *\n     * @param newMaxSupply The new max supply to set.\n     *\n     *\n     * @custom:audit Only changed visibility function (external to internal) compared\n     *               to `seadrop` library.\n     */\n    function _setMaxSupply(uint256 newMaxSupply) internal {\n        // Ensure the sender is only the owner or contract itself.\n        _onlyOwnerOrSelf();\n\n        // Ensure the max supply does not exceed the maximum value of uint64.\n        if (newMaxSupply > 2 ** 64 - 1) {\n            revert CannotExceedMaxSupplyOfUint64(newMaxSupply);\n        }\n\n        // Set the new max supply.\n        _maxSupply = newMaxSupply;\n\n        // Emit an event with the update.\n        emit MaxSupplyUpdated(newMaxSupply);\n    }\n\n    /**\n     * @notice Sets the provenance hash and emits an event.\n     *\n     *         The provenance hash is used for random reveals, which\n     *         is a hash of the ordered metadata to show it has not been\n     *         modified after mint started.\n     *\n     *         In INO case, only useful for mint strategies with reveal date. Blackbox and reveal on mint\n     *         will not use this.\n     *\n     *         This function will revert after the first item has been minted.\n     *\n     * @param newProvenanceHash The new provenance hash to set.\n     *\n     *\n     * @custom:audit Only added `virtual` and changed from `external` to `public` compared to `seadrop`\n     *               library.\n     */\n    function setProvenanceHash(bytes32 newProvenanceHash) public virtual {\n        // Ensure the sender is only the owner or contract itself.\n        _onlyOwnerOrSelf();\n\n        // Revert if any items have been minted.\n        if (_totalMinted() > 0) {\n            revert ProvenanceHashCannotBeSetAfterMintStarted();\n        }\n\n        // Keep track of the old provenance hash for emitting with the event.\n        bytes32 oldProvenanceHash = _provenanceHash;\n\n        // Set the new provenance hash.\n        _provenanceHash = newProvenanceHash;\n\n        // Emit an event with the update.\n        emit ProvenanceHashUpdated(oldProvenanceHash, newProvenanceHash);\n    }\n\n    /**\n     * @notice Returns the base URI for token metadata.\n     */\n    function baseURI() external view override returns (string memory) {\n        return _baseURI();\n    }\n\n    /**\n     * @notice Returns the base URI for the contract, which ERC721A uses\n     *         to return tokenURI.\n     */\n    function _baseURI()\n        internal\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        return _tokenBaseURI;\n    }\n\n    /**\n     * @notice Returns the contract URI for contract metadata.\n     */\n    function contractURI() external view override returns (string memory) {\n        return _contractURI;\n    }\n\n    /**\n     * @notice Returns the max token supply.\n     */\n    function maxSupply() public view returns (uint256) {\n        return _maxSupply;\n    }\n\n    /**\n     * @notice Returns the provenance hash.\n     *         The provenance hash is used for random reveals, which\n     *         is a hash of the ordered metadata to show it is unmodified\n     *         after mint has started.\n     */\n    function provenanceHash() external view override returns (bytes32) {\n        return _provenanceHash;\n    }\n\n    /**\n     * @notice Returns whether the interface is supported.\n     *\n     * @param interfaceId The interface id to check against.\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(ERC721ACloneable) returns (bool) {\n        return\n            interfaceId == 0x49064906 || // ERC-4906\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Internal pure function to cast a `bool` value to a `uint256` value.\n     *\n     * @param b The `bool` value to cast.\n     *\n     * @return u The `uint256` value.\n     */\n    function _cast(bool b) internal pure returns (uint256 u) {\n        assembly {\n            u := b\n        }\n    }\n}\n'}, 'src/common/SaleStruct.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.23;\n\n/**\n * @notice Shared enum representing the different status of a phase or the whole IGO.\n *\n * @custom:value NOT_STARTED IGO/Phase created but not started; allocations/buyAndMint are allowed.\n * @custom:value OPENED IGO/Phase started according to start date; allocations/buyAndMint are allowed.\n * @custom:value COMPLETED IGO/Phase everything has been sold or time has been elapsed;\n *               allocations/buyAndMint can\'t be reserved anymore.\n * @custom:value PAUSED IGO/Phase has been paused by the owner; allocations/buyAndMint can\'t be\n *               reserved until further notice.\n */\nenum Status {\n    NOT_STARTED,\n    OPENED,\n    COMPLETED,\n    PAUSED\n}\n\n/**\n * @notice Struct representing an allocation of a wallet for a specific phase of a sale.\n *\n * @param phaseId Phase identifier of the in the current sale, e.g. ""vpr-social-task"",\n *        ""sale-public-phase-1"", ""ino-public"" etc...\n * @param maxAllocation Maximum amount to spend in {SaleStorage.SetUp.paymentToken}.\n * @param saleTokenPerPaymentToken Price per token/nft of the project behind the Sale, expressed in\n *        {SaleStorage.SetUp.paymentToken}.\n */\nstruct Allocation {\n    string phaseId;\n    uint256 maxAllocation;\n    uint256 saleTokenPerPaymentToken;\n}\n\n/**\n * @notice Struct representing a buy permission signed by `msg.sender` for\n *         {SaleWritable.reserveAllocation} function to use with {Permit2} library.\n *\n * @dev Compulsory to interact with {Permit2.permitTransferFrom} in\n *      {SaleWritableInternal._reserveAllocation}.\n *\n * @param signature {Permit2} signature to transfer tokens from the buyer to {SaleVesting}.\n * @param deadline Seadline on the permit signature.\n * @param nonce Unique value for every token owner\'s signature to prevent signature replays.\n */\nstruct BuyPermission {\n    bytes signature;\n    uint256 deadline;\n    uint256 nonce;\n}\n\n/**\n * @notice Shared struct representing the data of a phase.\n *\n * @param status Enum representing the current status of the phase.\n * @param merkleRoot Merkle root of the merkle tree containing whitelisted data.\n * @param startAt Timestamp at which the phase will be opened to reserve allocation.\n * @param endAt Timestamp at which the phase will not accept allocation reservation anymore.\n * @param maxPhaseCap Maximum amount of {SaleStorage.SetUp.paymentToken} for this phase.\n */\nstruct Phase {\n    Status status;\n    // contains wallet and allocation per wallet\n    bytes32 merkleRoot;\n    uint128 startAt;\n    uint128 endAt;\n    uint256 maxPhaseCap;\n}\n'}, 'lib/openzeppelin-contracts-upgradeable/contracts/interfaces/IERC2981Upgradeable.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC2981.sol)\n\npragma solidity ^0.8.0;\n\nimport ""../utils/introspection/IERC165Upgradeable.sol"";\n\n/**\n * @dev Interface for the NFT Royalty Standard.\n *\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\n *\n * _Available since v4.5._\n */\ninterface IERC2981Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\n     */\n    function royaltyInfo(\n        uint256 tokenId,\n        uint256 salePrice\n    ) external view returns (address receiver, uint256 royaltyAmount);\n}\n'}, 'lib/openzeppelin-contracts-upgradeable/contracts/utils/introspection/ERC165Upgradeable.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport ""./IERC165Upgradeable.sol"";\nimport ""../../proxy/utils/Initializable.sol"";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n'}, 'lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport ""../../utils/AddressUpgradeable.sol"";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it\'s common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each ""step"" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(""MyToken"", ""MTK"");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(""MyToken"");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            ""Initializable: contract is already initialized""\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, ""Initializable: contract is already initialized"");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, ""Initializable: contract is not initializing"");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, ""Initializable: contract is initializing"");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n'}, 'lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n'}, 'src/ino/nft/imported/INFTContractMetadata.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/**\n * @custom:audit Changes from base contract `seadrop/src/interfaces/ISeaDropTokenContractMetadata.sol`:\n * - deleted {setMaxSupply},\n * - deleted everything related to royalties.\n */\ninterface INFTContractMetadata {\n    /**\n     * @notice Throw if the max supply exceeds uint64, a limit\n     *         due to the storage of bit-packed variables in ERC721A.\n     */\n    error CannotExceedMaxSupplyOfUint64(uint256 newMaxSupply);\n\n    /**\n     * @dev Revert with an error when attempting to set the provenance\n     *      hash after the mint has started.\n     */\n    error ProvenanceHashCannotBeSetAfterMintStarted();\n\n    /**\n     * @dev Emit an event for token metadata reveals/updates,\n     *      according to EIP-4906.\n     *\n     * @param _fromTokenId The start token id.\n     * @param _toTokenId   The end token id.\n     */\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\n\n    /**\n     * @dev Emit an event when the URI for the collection-level metadata\n     *      is updated.\n     */\n    event ContractURIUpdated(string newContractURI);\n\n    /**\n     * @dev Emit an event when the max token supply is updated.\n     */\n    event MaxSupplyUpdated(uint256 newMaxSupply);\n\n    /**\n     * @dev Emit an event with the previous and new provenance hash after\n     *      being updated.\n     */\n    event ProvenanceHashUpdated(bytes32 previousHash, bytes32 newHash);\n\n    /**\n     * @notice Sets the base URI for the token metadata and emits an event.\n     *\n     * @param tokenURI The new base URI to set.\n     */\n    function setBaseURI(string calldata tokenURI) external;\n\n    /**\n     * @notice Sets the contract URI for contract metadata.\n     *\n     * @param newContractURI The new contract URI.\n     */\n    function setContractURI(string calldata newContractURI) external;\n\n    /**\n     * @notice Sets the provenance hash and emits an event.\n     *\n     *         The provenance hash is used for random reveals, which\n     *         is a hash of the ordered metadata to show it has not been\n     *         modified after mint started.\n     *\n     *         This function will revert after the first item has been minted.\n     *\n     * @param newProvenanceHash The new provenance hash to set.\n     */\n    function setProvenanceHash(bytes32 newProvenanceHash) external;\n\n    /**\n     * @notice Returns the base URI for token metadata.\n     */\n    function baseURI() external view returns (string memory);\n\n    /**\n     * @notice Returns the contract URI.\n     */\n    function contractURI() external view returns (string memory);\n\n    /**\n     * @notice Returns the max token supply.\n     */\n    function maxSupply() external view returns (uint256);\n\n    /**\n     * @notice Returns the provenance hash.\n     *         The provenance hash is used for random reveals, which\n     *         is a hash of the ordered metadata to show it is unmodified\n     *         after mint has started.\n     */\n    function provenanceHash() external view returns (bytes32);\n}\n'}, 'src/ino/nft/imported/ERC721ACloneable.sol': {'content': '// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.2\n// Creator: Chiru Labs\n\npragma solidity ^0.8.23;\n\nimport {IERC721A} from ""ERC721A/IERC721A.sol"";\n\nimport {Initializable} from ""openzeppelin-contracts-upgradeable/proxy/utils/Initializable.sol"";\n\n/**\n * @dev Interface of ERC721 token receiver.\n */\ninterface ERC721A__IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n/**\n * @custom:audit Added `minterOf` support in `_mint`, compared to OpenSea base contract.\n *\n * @title ERC721A\n *\n * @dev Implementation of the [ERC721](https://eips.ethereum.org/EIPS/eip-721)\n * Non-Fungible Token Standard, including the Metadata extension.\n * Optimized for lower gas during batch mints.\n *\n * Token IDs are minted in sequential order (e.g. 0, 1, 2, 3, ...)\n * starting from `_startTokenId()`.\n *\n * Assumptions:\n *\n * - An owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\n * - The maximum token ID cannot exceed 2**256 - 1 (max value of uint256).\n *\n */\ncontract ERC721ACloneable is IERC721A, Initializable {\n    // Bypass for a `--via-ir` bug (https://github.com/chiru-labs/ERC721A/pull/364).\n    struct TokenApprovalRef {\n        address value;\n    }\n\n    // =============================================================\n    //                           CONSTANTS\n    // =============================================================\n\n    // Mask of an entry in packed address data.\n    uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\n\n    // The bit position of `numberMinted` in packed address data.\n    uint256 private constant _BITPOS_NUMBER_MINTED = 64;\n\n    // The bit position of `numberBurned` in packed address data.\n    uint256 private constant _BITPOS_NUMBER_BURNED = 128;\n\n    // The bit position of `aux` in packed address data.\n    uint256 private constant _BITPOS_AUX = 192;\n\n    // Mask of all 256 bits in packed address data except the 64 bits for `aux`.\n    uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\n\n    // The bit position of `startTimestamp` in packed ownership.\n    uint256 private constant _BITPOS_START_TIMESTAMP = 160;\n\n    // The bit mask of the `burned` bit in packed ownership.\n    uint256 private constant _BITMASK_BURNED = 1 << 224;\n\n    // The bit position of the `nextInitialized` bit in packed ownership.\n    uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;\n\n    // The bit mask of the `nextInitialized` bit in packed ownership.\n    uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 << 225;\n\n    // The bit position of `extraData` in packed ownership.\n    uint256 private constant _BITPOS_EXTRA_DATA = 232;\n\n    // Mask of all 256 bits in a packed ownership except the 24 bits for `extraData`.\n    uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;\n\n    // The mask of the lower 160 bits for addresses.\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\n\n    // The maximum `quantity` that can be minted with {_mintERC2309}.\n    // This limit is to prevent overflows on the address data entries.\n    // For a limit of 5000, a total of 3.689e15 calls to {_mintERC2309}\n    // is required to cause an overflow, which is unrealistic.\n    uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;\n\n    // The `Transfer` event signature is given by:\n    // `keccak256(bytes(""Transfer(address,address,uint256)""))`.\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\n\n    // =============================================================\n    //                            STORAGE\n    // =============================================================\n\n    // The next token ID to be minted.\n    uint256 private _currentIndex;\n\n    // The number of tokens burned.\n    uint256 private _burnCounter;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to ownership details\n    // An empty struct value does not necessarily mean the token is unowned.\n    // See {_packedOwnershipOf} implementation for details.\n    //\n    // Bits Layout:\n    // - [0..159]   `addr`\n    // - [160..223] `startTimestamp`\n    // - [224]      `burned`\n    // - [225]      `nextInitialized`\n    // - [232..255] `extraData`\n    mapping(uint256 => uint256) private _packedOwnerships;\n\n    // Mapping owner address to address data.\n    //\n    // Bits Layout:\n    // - [0..63]    `balance`\n    // - [64..127]  `numberMinted`\n    // - [128..191] `numberBurned`\n    // - [192..255] `aux`\n    mapping(address => uint256) private _packedAddressData;\n\n    // Mapping from token ID to approved address.\n    mapping(uint256 => TokenApprovalRef) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    mapping(uint256 => address) public minterOf;\n\n    // =============================================================\n    //                          CONSTRUCTOR\n    // =============================================================\n\n    function __ERC721ACloneable__init(\n        string memory name_,\n        string memory symbol_\n    ) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n        _currentIndex = _startTokenId();\n    }\n\n    // =============================================================\n    //                   TOKEN COUNTING OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the starting token ID.\n     * To change the starting token ID, please override this function.\n     */\n    function _startTokenId() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev Returns the next token ID to be minted.\n     */\n    function _nextTokenId() internal view virtual returns (uint256) {\n        return _currentIndex;\n    }\n\n    /**\n     * @dev Returns the total number of tokens in existence.\n     * Burned tokens will reduce the count.\n     * To get the total number of tokens minted, please see {_totalMinted}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        // Counter underflow is impossible as _burnCounter cannot be incremented\n        // more than `_currentIndex - _startTokenId()` times.\n        unchecked {\n            return _currentIndex - _burnCounter - _startTokenId();\n        }\n    }\n\n    /**\n     * @dev Returns the total amount of tokens minted in the contract.\n     */\n    function _totalMinted() internal view virtual returns (uint256) {\n        // Counter underflow is impossible as `_currentIndex` does not decrement,\n        // and it is initialized to `_startTokenId()`.\n        unchecked {\n            return _currentIndex - _startTokenId();\n        }\n    }\n\n    /**\n     * @dev Returns the total number of tokens burned.\n     */\n    function _totalBurned() internal view virtual returns (uint256) {\n        return _burnCounter;\n    }\n\n    // =============================================================\n    //                    ADDRESS DATA OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the number of tokens in `owner`\'s account.\n     */\n    function balanceOf(\n        address owner\n    ) public view virtual override returns (uint256) {\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\n        return _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;\n    }\n\n    /**\n     * Returns the number of tokens minted by `owner`.\n     */\n    function _numberMinted(address owner) internal view returns (uint256) {\n        return\n            (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) &\n            _BITMASK_ADDRESS_DATA_ENTRY;\n    }\n\n    /**\n     * Returns the number of tokens burned by or on behalf of `owner`.\n     */\n    function _numberBurned(address owner) internal view returns (uint256) {\n        return\n            (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) &\n            _BITMASK_ADDRESS_DATA_ENTRY;\n    }\n\n    /**\n     * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\n     */\n    function _getAux(address owner) internal view returns (uint64) {\n        return uint64(_packedAddressData[owner] >> _BITPOS_AUX);\n    }\n\n    /**\n     * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\n     * If there are multiple variables, please pack them into a uint64.\n     */\n    function _setAux(address owner, uint64 aux) internal virtual {\n        uint256 packed = _packedAddressData[owner];\n        uint256 auxCasted;\n        // Cast `aux` with assembly to avoid redundant masking.\n        assembly {\n            auxCasted := aux\n        }\n        packed =\n            (packed & _BITMASK_AUX_COMPLEMENT) |\n            (auxCasted << _BITPOS_AUX);\n        _packedAddressData[owner] = packed;\n    }\n\n    // =============================================================\n    //                            IERC165\n    // =============================================================\n\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30000 gas.\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override returns (bool) {\n        // The interface IDs are constants representing the first 4 bytes\n        // of the XOR of all function selectors in the interface.\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\n        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\n    }\n\n    // =============================================================\n    //                        IERC721Metadata\n    // =============================================================\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(\n        uint256 tokenId\n    ) public view virtual override returns (string memory) {\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\n\n        string memory baseURI = _baseURI();\n        return\n            bytes(baseURI).length != 0\n                ? string(abi.encodePacked(baseURI, _toString(tokenId)))\n                : """";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, it can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return """";\n    }\n\n    // =============================================================\n    //                     OWNERSHIPS OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(\n        uint256 tokenId\n    ) public view virtual override returns (address) {\n        return address(uint160(_packedOwnershipOf(tokenId)));\n    }\n\n    /**\n     * @dev Gas spent here starts off proportional to the maximum mint batch size.\n     * It gradually moves to O(1) as tokens get transferred around over time.\n     */\n    function _ownershipOf(\n        uint256 tokenId\n    ) internal view virtual returns (TokenOwnership memory) {\n        return _unpackedOwnership(_packedOwnershipOf(tokenId));\n    }\n\n    /**\n     * @dev Returns the unpacked `TokenOwnership` struct at `index`.\n     */\n    function _ownershipAt(\n        uint256 index\n    ) internal view virtual returns (TokenOwnership memory) {\n        return _unpackedOwnership(_packedOwnerships[index]);\n    }\n\n    /**\n     * @dev Initializes the ownership slot minted at `index` for efficiency purposes.\n     */\n    function _initializeOwnershipAt(uint256 index) internal virtual {\n        if (_packedOwnerships[index] == 0) {\n            _packedOwnerships[index] = _packedOwnershipOf(index);\n        }\n    }\n\n    /**\n     * Returns the packed ownership data of `tokenId`.\n     */\n    function _packedOwnershipOf(\n        uint256 tokenId\n    ) private view returns (uint256) {\n        uint256 curr = tokenId;\n\n        unchecked {\n            if (_startTokenId() <= curr) {\n                if (curr < _currentIndex) {\n                    uint256 packed = _packedOwnerships[curr];\n                    // If not burned.\n                    if (packed & _BITMASK_BURNED == 0) {\n                        // Invariant:\n                        // There will always be an initialized ownership slot\n                        // (i.e. `ownership.addr != address(0) && ownership.burned == false`)\n                        // before an unintialized ownership slot\n                        // (i.e. `ownership.addr == address(0) && ownership.burned == false`)\n                        // Hence, `curr` will not underflow.\n                        //\n                        // We can directly compare the packed value.\n                        // If the address is zero, packed will be zero.\n                        while (packed == 0) {\n                            packed = _packedOwnerships[--curr];\n                        }\n                        return packed;\n                    }\n                }\n            }\n        }\n        revert OwnerQueryForNonexistentToken();\n    }\n\n    /**\n     * @dev Returns the unpacked `TokenOwnership` struct from `packed`.\n     */\n    function _unpackedOwnership(\n        uint256 packed\n    ) private pure returns (TokenOwnership memory ownership) {\n        ownership.addr = address(uint160(packed));\n        ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP);\n        ownership.burned = packed & _BITMASK_BURNED != 0;\n        ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA);\n    }\n\n    /**\n     * @dev Packs ownership data into a single uint256.\n     */\n    function _packOwnershipData(\n        address owner,\n        uint256 flags\n    ) private view returns (uint256 result) {\n        assembly {\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren\'t clean.\n            owner := and(owner, _BITMASK_ADDRESS)\n            // `owner | (block.timestamp << _BITPOS_START_TIMESTAMP) | flags`.\n            result := or(\n                owner,\n                or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags)\n            )\n        }\n    }\n\n    /**\n     * @dev Returns the `nextInitialized` flag set if `quantity` equals 1.\n     */\n    function _nextInitializedFlag(\n        uint256 quantity\n    ) private pure returns (uint256 result) {\n        // For branchless setting of the `nextInitialized` flag.\n        assembly {\n            // `(quantity == 1) << _BITPOS_NEXT_INITIALIZED`.\n            result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))\n        }\n    }\n\n    // =============================================================\n    //                      APPROVAL OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the\n     * zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ownerOf(tokenId);\n\n        if (_msgSenderERC721A() != owner) {\n            if (!isApprovedForAll(owner, _msgSenderERC721A())) {\n                revert ApprovalCallerNotOwnerNorApproved();\n            }\n        }\n\n        _tokenApprovals[tokenId].value = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(\n        uint256 tokenId\n    ) public view virtual override returns (address) {\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\n\n        return _tokenApprovals[tokenId].value;\n    }\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom}\n     * for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(\n        address operator,\n        bool approved\n    ) public virtual override {\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\n    }\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted. See {_mint}.\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return\n            _startTokenId() <= tokenId &&\n            tokenId < _currentIndex && // If within bounds,\n            _packedOwnerships[tokenId] & _BITMASK_BURNED == 0; // and not burned.\n    }\n\n    /**\n     * @dev Returns whether `msgSender` is equal to `approvedAddress` or `owner`.\n     */\n    function _isSenderApprovedOrOwner(\n        address approvedAddress,\n        address owner,\n        address msgSender\n    ) private pure returns (bool result) {\n        assembly {\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren\'t clean.\n            owner := and(owner, _BITMASK_ADDRESS)\n            // Mask `msgSender` to the lower 160 bits, in case the upper bits somehow aren\'t clean.\n            msgSender := and(msgSender, _BITMASK_ADDRESS)\n            // `msgSender == owner || msgSender == approvedAddress`.\n            result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))\n        }\n    }\n\n    /**\n     * @dev Returns the storage slot and value for the approved address of `tokenId`.\n     */\n    function _getApprovedSlotAndAddress(\n        uint256 tokenId\n    )\n        private\n        view\n        returns (uint256 approvedAddressSlot, address approvedAddress)\n    {\n        TokenApprovalRef storage tokenApproval = _tokenApprovals[tokenId];\n        // The following is equivalent to `approvedAddress = _tokenApprovals[tokenId].value`.\n        assembly {\n            approvedAddressSlot := tokenApproval.slot\n            approvedAddress := sload(approvedAddressSlot)\n        }\n    }\n\n    // =============================================================\n    //                      TRANSFER OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\n\n        if (address(uint160(prevOwnershipPacked)) != from)\n            revert TransferFromIncorrectOwner();\n\n        (\n            uint256 approvedAddressSlot,\n            address approvedAddress\n        ) = _getApprovedSlotAndAddress(tokenId);\n\n        // The nested ifs save around 20+ gas over a compound boolean condition.\n        if (\n            !_isSenderApprovedOrOwner(\n                approvedAddress,\n                from,\n                _msgSenderERC721A()\n            )\n        ) {\n            if (!isApprovedForAll(from, _msgSenderERC721A()))\n                revert TransferCallerNotOwnerNorApproved();\n        }\n\n        if (to == address(0)) revert TransferToZeroAddress();\n\n        _beforeTokenTransfers(from, to, tokenId, 1);\n\n        // Clear approvals from the previous owner.\n        assembly {\n            if approvedAddress {\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\n                sstore(approvedAddressSlot, 0)\n            }\n        }\n\n        // Underflow of the sender\'s balance is impossible because we check for\n        // ownership above and the recipient\'s balance can\'t realistically overflow.\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\n        unchecked {\n            // We can directly increment and decrement the balances.\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\n\n            // Updates:\n            // - `address` to the next owner.\n            // - `startTimestamp` to the timestamp of transfering.\n            // - `burned` to `false`.\n            // - `nextInitialized` to `true`.\n            _packedOwnerships[tokenId] = _packOwnershipData(\n                to,\n                _BITMASK_NEXT_INITIALIZED |\n                    _nextExtraData(from, to, prevOwnershipPacked)\n            );\n\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\n                uint256 nextTokenId = tokenId + 1;\n                // If the next slot\'s address is zero and not burned (i.e. packed value is zero).\n                if (_packedOwnerships[nextTokenId] == 0) {\n                    // If the next slot is within bounds.\n                    if (nextTokenId != _currentIndex) {\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\n                    }\n                }\n            }\n        }\n\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfers(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, \'\')`.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, """");\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        transferFrom(from, to, tokenId);\n        if (to.code.length != 0) {\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\n                revert TransferToNonERC721ReceiverImplementer();\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before a set of serially-ordered token IDs\n     * are about to be transferred. This includes minting.\n     * And also called before burning one token.\n     *\n     * `startTokenId` - the first token ID to be transferred.\n     * `quantity` - the amount to be transferred.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`\'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, `tokenId` will be burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _beforeTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after a set of serially-ordered token IDs\n     * have been transferred. This includes minting.\n     * And also called after one token has been burned.\n     *\n     * `startTokenId` - the first token ID to be transferred.\n     * `quantity` - the amount to be transferred.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`\'s `tokenId` has been\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` has been minted for `to`.\n     * - When `to` is zero, `tokenId` has been burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _afterTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n\n    /**\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target contract.\n     *\n     * `from` - Previous owner of the given token ID.\n     * `to` - Target address that will receive the token.\n     * `tokenId` - Token ID to be transferred.\n     * `_data` - Optional data to send along with the call.\n     *\n     * Returns whether the call correctly returned the expected magic value.\n     */\n    function _checkContractOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        try\n            ERC721A__IERC721Receiver(to).onERC721Received(\n                _msgSenderERC721A(),\n                from,\n                tokenId,\n                _data\n            )\n        returns (bytes4 retval) {\n            return\n                retval ==\n                ERC721A__IERC721Receiver(to).onERC721Received.selector;\n        } catch (bytes memory reason) {\n            if (reason.length == 0) {\n                revert TransferToNonERC721ReceiverImplementer();\n            } else {\n                assembly {\n                    revert(add(32, reason), mload(reason))\n                }\n            }\n        }\n    }\n\n    // =============================================================\n    //                        MINT OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {Transfer} event for each mint.\n     */\n    function _mint(address to, uint256 quantity) internal virtual {\n        uint256 startTokenId = _currentIndex;\n        if (quantity == 0) revert MintZeroQuantity();\n\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\n\n        // Overflows are incredibly unrealistic.\n        // `balance` and `numberMinted` have a maximum limit of 2**64.\n        // `tokenId` has a maximum limit of 2**256.\n        unchecked {\n            // Updates:\n            // - `balance += quantity`.\n            // - `numberMinted += quantity`.\n            //\n            // We can directly add to the `balance` and `numberMinted`.\n            _packedAddressData[to] +=\n                quantity *\n                ((1 << _BITPOS_NUMBER_MINTED) | 1);\n\n            // Updates:\n            // - `address` to the owner.\n            // - `startTimestamp` to the timestamp of minting.\n            // - `burned` to `false`.\n            // - `nextInitialized` to `quantity == 1`.\n            _packedOwnerships[startTokenId] = _packOwnershipData(\n                to,\n                _nextInitializedFlag(quantity) |\n                    _nextExtraData(address(0), to, 0)\n            );\n\n            uint256 toMasked;\n            uint256 end = startTokenId + quantity;\n\n            // Use assembly to loop and emit the `Transfer` event for gas savings.\n            // The duplicated `log4` removes an extra check and reduces stack juggling.\n            // The assembly, together with the surrounding Solidity code, have been\n            // delicately arranged to nudge the compiler into producing optimized opcodes.\n            assembly {\n                // Mask `to` to the lower 160 bits, in case the upper bits somehow aren\'t clean.\n                toMasked := and(to, _BITMASK_ADDRESS)\n                // Emit the `Transfer` event.\n                log4(\n                    0, // Start of data (0, since no data).\n                    0, // End of data (0, since no data).\n                    _TRANSFER_EVENT_SIGNATURE, // Signature.\n                    0, // `address(0)`.\n                    toMasked, // `to`.\n                    startTokenId // `tokenId`.\n                )\n                /// @custom:audit adding compared to OpenSea original contract\n                // minterOf[tokenId] = to\n                sstore(hashLocation(startTokenId, minterOf.slot), to)\n\n                /// @custom:audit adding compared to OpenSea original contract\n                function hashLocation(key, slot) -> location {\n                    mstore(0x80, key)\n                    mstore(0xa0, slot)\n                    location := keccak256(0x80, 0x40)\n                }\n\n                // The `iszero(eq(,))` check ensures that large values of `quantity`\n                // that overflows uint256 will make the loop run out of gas.\n                // The compiler will optimize the `iszero` away for performance.\n                for {\n                    let tokenId := add(startTokenId, 1)\n                } iszero(eq(tokenId, end)) {\n                    tokenId := add(tokenId, 1)\n                } {\n                    /// @custom:audit adding compared to OpenSea original contract\n                    // minterOf[tokenId] = to\n                    sstore(hashLocation(tokenId, minterOf.slot), to)\n\n                    // Emit the `Transfer` event. Similar to above.\n                    log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)\n                }\n            }\n            if (toMasked == 0) revert MintToZeroAddress();\n\n            _currentIndex = end;\n        }\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\n    }\n\n    /**\n     * @dev This mint function excludes update of `minterOf`.\n     * @dev Mints `quantity` tokens and transfers them to `to`.\n     *\n     * This function is intended for efficient minting only during contract creation.\n     *\n     * It emits only one {ConsecutiveTransfer} as defined in\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309),\n     * instead of a sequence of {Transfer} event(s).\n     *\n     * Calling this function outside of contract creation WILL make your contract\n     * non-compliant with the ERC721 standard.\n     * For full ERC721 compliance, substituting ERC721 {Transfer} event(s) with the ERC2309\n     * {ConsecutiveTransfer} event is only permissible during contract creation.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {ConsecutiveTransfer} event.\n     */\n    function _mintERC2309(address to, uint256 quantity) internal virtual {\n        uint256 startTokenId = _currentIndex;\n        if (to == address(0)) revert MintToZeroAddress();\n        if (quantity == 0) revert MintZeroQuantity();\n        if (quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT)\n            revert MintERC2309QuantityExceedsLimit();\n\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\n\n        // Overflows are unrealistic due to the above check for `quantity` to be below the limit.\n        unchecked {\n            // Updates:\n            // - `balance += quantity`.\n            // - `numberMinted += quantity`.\n            //\n            // We can directly add to the `balance` and `numberMinted`.\n            _packedAddressData[to] +=\n                quantity *\n                ((1 << _BITPOS_NUMBER_MINTED) | 1);\n\n            // Updates:\n            // - `address` to the owner.\n            // - `startTimestamp` to the timestamp of minting.\n            // - `burned` to `false`.\n            // - `nextInitialized` to `quantity == 1`.\n            _packedOwnerships[startTokenId] = _packOwnershipData(\n                to,\n                _nextInitializedFlag(quantity) |\n                    _nextExtraData(address(0), to, 0)\n            );\n\n            emit ConsecutiveTransfer(\n                startTokenId,\n                startTokenId + quantity - 1,\n                address(0),\n                to\n            );\n\n            _currentIndex = startTokenId + quantity;\n        }\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\n    }\n\n    /**\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement\n     * {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\n     * - `quantity` must be greater than 0.\n     *\n     * See {_mint}.\n     *\n     * Emits a {Transfer} event for each mint.\n     */\n    function _safeMint(\n        address to,\n        uint256 quantity,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, quantity);\n\n        unchecked {\n            if (to.code.length != 0) {\n                uint256 end = _currentIndex;\n                uint256 index = end - quantity;\n                do {\n                    if (\n                        !_checkContractOnERC721Received(\n                            address(0),\n                            to,\n                            index++,\n                            _data\n                        )\n                    ) {\n                        revert TransferToNonERC721ReceiverImplementer();\n                    }\n                } while (index < end);\n                // Reentrancy protection.\n                if (_currentIndex != end) revert();\n            }\n        }\n    }\n\n    /**\n     * @dev Equivalent to `_safeMint(to, quantity, \'\')`.\n     */\n    function _safeMint(address to, uint256 quantity) internal virtual {\n        _safeMint(to, quantity, """");\n    }\n\n    // =============================================================\n    //                        BURN OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Equivalent to `_burn(tokenId, false)`.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        _burn(tokenId, false);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\n\n        address from = address(uint160(prevOwnershipPacked));\n\n        (\n            uint256 approvedAddressSlot,\n            address approvedAddress\n        ) = _getApprovedSlotAndAddress(tokenId);\n\n        if (approvalCheck) {\n            // The nested ifs save around 20+ gas over a compound boolean condition.\n            if (\n                !_isSenderApprovedOrOwner(\n                    approvedAddress,\n                    from,\n                    _msgSenderERC721A()\n                )\n            ) {\n                if (!isApprovedForAll(from, _msgSenderERC721A()))\n                    revert TransferCallerNotOwnerNorApproved();\n            }\n        }\n\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\n\n        // Clear approvals from the previous owner.\n        assembly {\n            if approvedAddress {\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\n                sstore(approvedAddressSlot, 0)\n            }\n        }\n\n        // Underflow of the sender\'s balance is impossible because we check for\n        // ownership above and the recipient\'s balance can\'t realistically overflow.\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\n        unchecked {\n            // Updates:\n            // - `balance -= 1`.\n            // - `numberBurned += 1`.\n            //\n            // We can directly decrement the balance, and increment the number burned.\n            // This is equivalent to `packed -= 1; packed += 1 << _BITPOS_NUMBER_BURNED;`.\n            _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;\n\n            // Updates:\n            // - `address` to the last owner.\n            // - `startTimestamp` to the timestamp of burning.\n            // - `burned` to `true`.\n            // - `nextInitialized` to `true`.\n            _packedOwnerships[tokenId] = _packOwnershipData(\n                from,\n                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) |\n                    _nextExtraData(from, address(0), prevOwnershipPacked)\n            );\n\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\n                uint256 nextTokenId = tokenId + 1;\n                // If the next slot\'s address is zero and not burned (i.e. packed value is zero).\n                if (_packedOwnerships[nextTokenId] == 0) {\n                    // If the next slot is within bounds.\n                    if (nextTokenId != _currentIndex) {\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\n                    }\n                }\n            }\n        }\n\n        emit Transfer(from, address(0), tokenId);\n        _afterTokenTransfers(from, address(0), tokenId, 1);\n\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\n        unchecked {\n            _burnCounter++;\n        }\n    }\n\n    // =============================================================\n    //                     EXTRA DATA OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Directly sets the extra data for the ownership data `index`.\n     */\n    function _setExtraDataAt(\n        uint256 index,\n        uint24 extraData\n    ) internal virtual {\n        uint256 packed = _packedOwnerships[index];\n        if (packed == 0) revert OwnershipNotInitializedForExtraData();\n        uint256 extraDataCasted;\n        // Cast `extraData` with assembly to avoid redundant masking.\n        assembly {\n            extraDataCasted := extraData\n        }\n        packed =\n            (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) |\n            (extraDataCasted << _BITPOS_EXTRA_DATA);\n        _packedOwnerships[index] = packed;\n    }\n\n    /**\n     * @dev Called during each token transfer to set the 24bit `extraData` field.\n     * Intended to be overridden by the cosumer contract.\n     *\n     * `previousExtraData` - the value of `extraData` before transfer.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`\'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, `tokenId` will be burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _extraData(\n        address from,\n        address to,\n        uint24 previousExtraData\n    ) internal view virtual returns (uint24) {}\n\n    /**\n     * @dev Returns the next extra data for the packed ownership data.\n     * The returned result is shifted into position.\n     */\n    function _nextExtraData(\n        address from,\n        address to,\n        uint256 prevOwnershipPacked\n    ) private view returns (uint256) {\n        uint24 extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA);\n        return uint256(_extraData(from, to, extraData)) << _BITPOS_EXTRA_DATA;\n    }\n\n    // =============================================================\n    //                       OTHER OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the message sender (defaults to `msg.sender`).\n     *\n     * If you are writing GSN compatible contracts, you need to override this function.\n     */\n    function _msgSenderERC721A() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    /**\n     * @dev Converts a uint256 to its ASCII string decimal representation.\n     */\n    function _toString(\n        uint256 value\n    ) internal pure virtual returns (string memory str) {\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\n            let m := add(mload(0x40), 0xa0)\n            // Update the free memory pointer to allocate.\n            mstore(0x40, m)\n            // Assign the `str` to the end.\n            str := sub(m, 0x20)\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for { let temp := value } 1 {} {\n                str := sub(str, 1)\n                // Write the character to the pointer.\n                // The ASCII index of the \'0\' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n                // Keep dividing `temp` until zero.\n                temp := div(temp, 10)\n                // prettier-ignore\n                if iszero(temp) { break }\n            }\n\n            let length := sub(end, str)\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 0x20)\n            // Store the length.\n            mstore(str, length)\n        }\n    }\n}\n'}, 'lib/openzeppelin-contracts-upgradeable/contracts/access/Ownable2StepUpgradeable.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.0;\n\nimport ""./OwnableUpgradeable.sol"";\nimport ""../proxy/utils/Initializable.sol"";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2StepUpgradeable is Initializable, OwnableUpgradeable {\n    function __Ownable2Step_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable2Step_init_unchained() internal onlyInitializing {\n    }\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, ""Ownable2Step: caller is not the new owner"");\n        _transferOwnership(sender);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n'}, 'lib/openzeppelin-contracts-upgradeable/contracts/utils/introspection/IERC165Upgradeable.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n'}, 'lib/openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, ""Address: insufficient balance"");\n\n        (bool success, ) = recipient.call{value: amount}("""");\n        require(success, ""Address: unable to send value, recipient may have reverted"");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, ""Address: low-level call failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, ""Address: insufficient balance for call"");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, ""Address: low-level static call failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, ""Address: low-level delegate call failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), ""Address: call to non-contract"");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n'}, 'lib/ERC721A/contracts/IERC721A.sol': {'content': ""// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.2\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\n/**\n * @dev Interface of ERC721A.\n */\ninterface IERC721A {\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error ApprovalCallerNotOwnerNorApproved();\n\n    /**\n     * The token does not exist.\n     */\n    error ApprovalQueryForNonexistentToken();\n\n    /**\n     * The caller cannot approve to their own address.\n     */\n    error ApproveToCaller();\n\n    /**\n     * Cannot query the balance for the zero address.\n     */\n    error BalanceQueryForZeroAddress();\n\n    /**\n     * Cannot mint to the zero address.\n     */\n    error MintToZeroAddress();\n\n    /**\n     * The quantity of tokens minted must be more than zero.\n     */\n    error MintZeroQuantity();\n\n    /**\n     * The token does not exist.\n     */\n    error OwnerQueryForNonexistentToken();\n\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error TransferCallerNotOwnerNorApproved();\n\n    /**\n     * The token must be owned by `from`.\n     */\n    error TransferFromIncorrectOwner();\n\n    /**\n     * Cannot safely transfer to a contract that does not implement the\n     * ERC721Receiver interface.\n     */\n    error TransferToNonERC721ReceiverImplementer();\n\n    /**\n     * Cannot transfer to the zero address.\n     */\n    error TransferToZeroAddress();\n\n    /**\n     * The token does not exist.\n     */\n    error URIQueryForNonexistentToken();\n\n    /**\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\n     */\n    error MintERC2309QuantityExceedsLimit();\n\n    /**\n     * The `extraData` cannot be set on an unintialized ownership slot.\n     */\n    error OwnershipNotInitializedForExtraData();\n\n    // =============================================================\n    //                            STRUCTS\n    // =============================================================\n\n    struct TokenOwnership {\n        // The address of the owner.\n        address addr;\n        // Stores the start time of ownership with minimal overhead for tokenomics.\n        uint64 startTimestamp;\n        // Whether the token has been burned.\n        bool burned;\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\n        uint24 extraData;\n    }\n\n    // =============================================================\n    //                         TOKEN COUNTERS\n    // =============================================================\n\n    /**\n     * @dev Returns the total number of tokens in existence.\n     * Burned tokens will reduce the count.\n     * To get the total number of tokens minted, please see {_totalMinted}.\n     */\n    function totalSupply() external view returns (uint256);\n\n    // =============================================================\n    //                            IERC165\n    // =============================================================\n\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n    // =============================================================\n    //                            IERC721\n    // =============================================================\n\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables\n     * (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in `owner`'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\n     * checking first that contract recipients are aware of the ERC721 protocol\n     * to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move\n     * this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\n     * whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the\n     * zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom}\n     * for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    // =============================================================\n    //                        IERC721Metadata\n    // =============================================================\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n\n    // =============================================================\n    //                           IERC2309\n    // =============================================================\n\n    /**\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\n     * (inclusive) is transferred from `from` to `to`, as defined in the\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\n     *\n     * See {_mintERC2309} for more details.\n     */\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\n}\n""}, 'lib/openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport ""../utils/ContextUpgradeable.sol"";\nimport ""../proxy/utils/Initializable.sol"";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), ""Ownable: caller is not the owner"");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), ""Ownable: new owner is the zero address"");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n'}, 'lib/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport ""../proxy/utils/Initializable.sol"";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n'}}

// File: settings
{'remappings': ['forge-std/=lib/forge-std/src/', 'hardhat/=node_modules/hardhat/', 'murky/=lib/murky/', 'permit2/=lib/permit2/src/', 'solmate/=lib/solmate/', 'vesting-schedule/=lib/vesting-schedule/src/', 'layer0/=lib/layer-zero-examples/contracts/', 'seadrop/=lib/seadrop/', 'ERC721A/=lib/ERC721A/contracts/', 'chainlink/=lib/chainlink-brownie-contracts/contracts/src/v0.8/', '@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/', 'openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/', 'openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/', 'permit2-test/=lib/permit2/test/', '@ensdomains/=lib/vesting-schedule/node_modules/@ensdomains/', '@prb/test/=lib/vesting-schedule/lib/prb-test/src/', '@uniswap/=lib/layer-zero-examples/node_modules/@uniswap/', 'ERC721A-Upgradeable/=lib/seadrop/lib/ERC721A-Upgradeable/contracts/', 'chainlink-brownie-contracts/=lib/chainlink-brownie-contracts/contracts/src/v0.6/vendor/@arbitrum/nitro-contracts/src/', 'create2-helpers/=lib/seadrop/lib/create2-helpers/', 'create2-scripts/=lib/seadrop/lib/create2-helpers/script/', 'decubate-vesting-refund/=lib/decubate-vesting-refund/src/', 'ds-test/=lib/forge-std/lib/ds-test/src/', 'erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/', 'eth-gas-reporter/=node_modules/eth-gas-reporter/', 'forge-gas-snapshot/=lib/permit2/lib/forge-gas-snapshot/src/', 'hardhat-deploy/=lib/layer-zero-examples/node_modules/hardhat-deploy/', 'layer-zero-examples/=lib/layer-zero-examples/contracts/', 'layerzero-v1/=lib/layerzero-v1/contracts/', 'layerzero-v2/=lib/layerzero-v2/', 'openzeppelin-foundry-upgrades/=lib/openzeppelin-foundry-upgrades/src/', 'openzeppelin/=lib/openzeppelin-contracts-upgradeable/contracts/', 'operator-filter-registry/=lib/seadrop/lib/operator-filter-registry/', 'prb-test/=lib/vesting-schedule/lib/prb-test/src/', 'solidity-bytes-utils/=lib/solidity-bytes-utils/contracts/', 'solidity-stringutils/=lib/openzeppelin-foundry-upgrades/lib/solidity-stringutils/', 'utility-contracts/=lib/utility-contracts/'], 'optimizer': {'enabled': True, 'runs': 200}, 'metadata': {'useLiteralContent': False, 'bytecodeHash': 'ipfs', 'appendCBOR': True}, 'outputSelection': {'*': {'*': ['evm.bytecode', 'evm.deployedBytecode', 'devdoc', 'userdoc', 'metadata', 'abi']}}, 'evmVersion': 'paris', 'viaIR': True, 'libraries': {}}",True
0xf338cad020d506e8e3d9b4854986e0ece6c23640,"// File: language
Solidity

// File: sources
{'Addresses.sol': {'content': '/*\n  Copyright 2019-2022 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the ""License"").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an ""AS IS"" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\n/*\n  Common Utility Libraries.\n  I. Addresses (extending address).\n*/\nlibrary Addresses {\n    /*\n      Note: isContract function has some known limitation.\n      See https://github.com/OpenZeppelin/\n      openzeppelin-contracts/blob/master/contracts/utils/Address.sol.\n    */\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function performEthTransfer(address recipient, uint256 amount) internal {\n        if (amount == 0) return;\n        (bool success, ) = recipient.call{value: amount}(""""); // NOLINT: low-level-calls.\n        require(success, ""ETH_TRANSFER_FAILED"");\n    }\n\n    /*\n      Safe wrapper around ERC20/ERC721 calls.\n      This is required because many deployed ERC20 contracts don\'t return a value.\n      See https://github.com/ethereum/solidity/issues/4116.\n    */\n    function safeTokenContractCall(address tokenAddress, bytes memory callData) internal {\n        require(isContract(tokenAddress), ""BAD_TOKEN_ADDRESS"");\n        // NOLINTNEXTLINE: low-level-calls.\n        (bool success, bytes memory returndata) = tokenAddress.call(callData);\n        require(success, string(returndata));\n\n        if (returndata.length > 0) {\n            require(abi.decode(returndata, (bool)), ""TOKEN_OPERATION_FAILED"");\n        }\n    }\n}\n'}, 'Governance.sol': {'content': '/*\n  Copyright 2019-2022 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the ""License"").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an ""AS IS"" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\nimport ""MGovernance.sol"";\n\n/*\n  Implements Generic Governance, applicable for both proxy and main contract, and possibly others.\n  Notes:\n   The use of the same function names by both the Proxy and a delegated implementation\n   is not possible since calling the implementation functions is done via the default function\n   of the Proxy. For this reason, for example, the implementation of MainContract (MainGovernance)\n   exposes mainIsGovernor, which calls the internal _isGovernor method.\n*/\nstruct GovernanceInfoStruct {\n    mapping(address => bool) effectiveGovernors;\n    address candidateGovernor;\n    bool initialized;\n}\n\nabstract contract Governance is MGovernance {\n    event LogNominatedGovernor(address nominatedGovernor);\n    event LogNewGovernorAccepted(address acceptedGovernor);\n    event LogRemovedGovernor(address removedGovernor);\n    event LogNominationCancelled();\n\n    function getGovernanceInfo() internal view virtual returns (GovernanceInfoStruct storage);\n\n    /*\n      Current code intentionally prevents governance re-initialization.\n      This may be a problem in an upgrade situation, in a case that the upgrade-to implementation\n      performs an initialization (for real) and within that calls initGovernance().\n\n      Possible workarounds:\n      1. Clearing the governance info altogether by changing the MAIN_GOVERNANCE_INFO_TAG.\n         This will remove existing main governance information.\n      2. Modify the require part in this function, so that it will exit quietly\n         when trying to re-initialize (uncomment the lines below).\n    */\n    function initGovernance() internal {\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\n        require(!gub.initialized, ""ALREADY_INITIALIZED"");\n        gub.initialized = true; // to ensure acceptNewGovernor() won\'t fail.\n        // Add the initial governer.\n        acceptNewGovernor(msg.sender);\n    }\n\n    function _isGovernor(address user) internal view override returns (bool) {\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\n        return gub.effectiveGovernors[user];\n    }\n\n    /*\n      Cancels the nomination of a governor candidate.\n    */\n    function _cancelNomination() internal onlyGovernance {\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\n        if (gub.candidateGovernor != address(0x0)) {\n            gub.candidateGovernor = address(0x0);\n            emit LogNominationCancelled();\n        }\n    }\n\n    function _nominateNewGovernor(address newGovernor) internal onlyGovernance {\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\n        require(newGovernor != address(0x0), ""BAD_ADDRESS"");\n        require(!_isGovernor(newGovernor), ""ALREADY_GOVERNOR"");\n        require(gub.candidateGovernor == address(0x0), ""OTHER_CANDIDATE_PENDING"");\n        gub.candidateGovernor = newGovernor;\n        emit LogNominatedGovernor(newGovernor);\n    }\n\n    /*\n      The acceptNewGovernor is called in two cases:\n      1. by _acceptGovernance when a new governor accepts its role.\n      2. by initGovernance to add the initial governor.\n      The difference is that the init path skips the nominate step\n      that would fail because of the onlyGovernance modifier.\n    */\n    function acceptNewGovernor(address newGovernor) private {\n        require(!_isGovernor(newGovernor), ""ALREADY_GOVERNOR"");\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\n        gub.effectiveGovernors[newGovernor] = true;\n\n        // Emit governance information.\n        emit LogNewGovernorAccepted(newGovernor);\n    }\n\n    function _acceptGovernance() internal {\n        // The new governor was proposed as a candidate by the current governor.\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\n        require(msg.sender == gub.candidateGovernor, ""ONLY_CANDIDATE_GOVERNOR"");\n\n        // Update state.\n        acceptNewGovernor(msg.sender);\n        gub.candidateGovernor = address(0x0);\n    }\n\n    /*\n      Remove a governor from office.\n    */\n    function _removeGovernor(address governorForRemoval) internal onlyGovernance {\n        require(msg.sender != governorForRemoval, ""GOVERNOR_SELF_REMOVE"");\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\n        require(_isGovernor(governorForRemoval), ""NOT_GOVERNOR"");\n        gub.effectiveGovernors[governorForRemoval] = false;\n        emit LogRemovedGovernor(governorForRemoval);\n    }\n}\n'}, 'GovernanceStorage.sol': {'content': '/*\n  Copyright 2019-2022 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the ""License"").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an ""AS IS"" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\nimport {GovernanceInfoStruct} from ""Governance.sol"";\n\n/*\n  Holds the governance slots for ALL entities, including proxy and the main contract.\n*/\ncontract GovernanceStorage {\n    // A map from a Governor tag to its own GovernanceInfoStruct.\n    mapping(string => GovernanceInfoStruct) internal governanceInfo; //NOLINT uninitialized-state.\n}\n'}, 'MGovernance.sol': {'content': '/*\n  Copyright 2019-2022 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the ""License"").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an ""AS IS"" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\nabstract contract MGovernance {\n    function _isGovernor(address user) internal view virtual returns (bool);\n\n    /*\n      Allows calling the function only by a Governor.\n    */\n    modifier onlyGovernance() {\n        require(_isGovernor(msg.sender), ""ONLY_GOVERNANCE"");\n        _;\n    }\n}\n'}, 'Proxy.sol': {'content': '/*\n  Copyright 2019-2022 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the ""License"").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an ""AS IS"" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\nimport ""ProxyGovernance.sol"";\nimport ""ProxyStorage.sol"";\nimport ""StorageSlots.sol"";\nimport ""Addresses.sol"";\n\n/**\n  The Proxy contract implements delegation of calls to other contracts (`implementations`), with\n  proper forwarding of return values and revert reasons. This pattern allows retaining the contract\n  storage while replacing implementation code.\n\n  The following operations are supported by the proxy contract:\n\n  - :sol:func:`addImplementation`: Defines a new implementation, the data with which it should be initialized and whether this will be the last version of implementation.\n  - :sol:func:`upgradeTo`: Once an implementation is added, the governor may upgrade to that implementation only after a safety time period has passed (time lock), the current implementation is not the last version and the implementation is not frozen (see :sol:mod:`FullWithdrawals`).\n  - :sol:func:`removeImplementation`: Any announced implementation may be removed. Removing an implementation is especially important once it has been used for an upgrade in order to avoid an additional unwanted revert to an older version.\n\n  The only entity allowed to perform the above operations is the proxy governor\n  (see :sol:mod:`ProxyGovernance`).\n\n  Every implementation is required to have an `initialize` function that replaces the constructor\n  of a normal contract. Furthermore, the only parameter of this function is an array of bytes\n  (`data`) which may be decoded arbitrarily by the `initialize` function. It is up to the\n  implementation to ensure that this function cannot be run more than once if so desired.\n\n  When an implementation is added (:sol:func:`addImplementation`) the initialization `data` is also\n  announced, allowing users of the contract to analyze the full effect of an upgrade to the new\n  implementation. During an :sol:func:`upgradeTo`, the `data` is provided again and only if it is\n  identical to the announced `data` is the upgrade performed by pointing the proxy to the new\n  implementation and calling its `initialize` function with this `data`.\n\n  It is the responsibility of the implementation not to overwrite any storage belonging to the\n  proxy (`ProxyStorage`). In addition, upon upgrade, the new implementation is assumed to be\n  backward compatible with previous implementations with respect to the storage used until that\n  point.\n*/\ncontract Proxy is ProxyStorage, ProxyGovernance, StorageSlots {\n    // Emitted when the active implementation is replaced.\n    event ImplementationUpgraded(address indexed implementation, bytes initializer);\n\n    // Emitted when an implementation is submitted as an upgrade candidate and a time lock\n    // is activated.\n    event ImplementationAdded(address indexed implementation, bytes initializer, bool finalize);\n\n    // Emitted when an implementation is removed from the list of upgrade candidates.\n    event ImplementationRemoved(address indexed implementation, bytes initializer, bool finalize);\n\n    // Emitted when the implementation is finalized.\n    event FinalizedImplementation(address indexed implementation);\n\n    using Addresses for address;\n\n    uint256 public constant MAX_UPGRADE_DELAY = 180 days;\n\n    string public constant PROXY_VERSION = ""3.0.2"";\n\n    constructor(uint256 upgradeActivationDelay) public {\n        initGovernance();\n        setUpgradeActivationDelay(upgradeActivationDelay);\n    }\n\n    /*\n      Stores the upgrade activation delay (in seconds) in the appropriate slot.\n      this function does not validate the delay value, as it\'s checked in the getter.\n    */\n    function setUpgradeActivationDelay(uint256 delayInSeconds) private {\n        bytes32 slot = UPGRADE_DELAY_SLOT;\n        assembly {\n            sstore(slot, delayInSeconds)\n        }\n    }\n\n    /*\n      Reads the upgrade activation delay (in seconds) at the appropriate slot.\n      The returned value is capped at MAX_UPGRADE_DELAY.\n      It is safer to do the capping in the getter because an upgrade\n      flow might modify this value without going through the setter function.\n    */\n    function getUpgradeActivationDelay() public view returns (uint256 delay) {\n        bytes32 slot = UPGRADE_DELAY_SLOT;\n        assembly {\n            delay := sload(slot)\n        }\n\n        delay = (delay < MAX_UPGRADE_DELAY) ? delay : MAX_UPGRADE_DELAY;\n        return delay;\n    }\n\n    /*\n      Returns the address of the current implementation.\n    */\n    // NOLINTNEXTLINE external-function.\n    function implementation() public view returns (address _implementation) {\n        bytes32 slot = IMPLEMENTATION_SLOT;\n        assembly {\n            _implementation := sload(slot)\n        }\n    }\n\n    /*\n      Returns true if the implementation is frozen.\n      If the implementation was not assigned yet, returns false.\n    */\n    function implementationIsFrozen() private returns (bool) {\n        address _implementation = implementation();\n\n        // We can\'t call low level implementation before it\'s assigned. (i.e. ZERO).\n        if (_implementation == address(0x0)) {\n            return false;\n        }\n\n        // NOLINTNEXTLINE: low-level-calls.\n        (bool success, bytes memory returndata) = _implementation.delegatecall(\n            abi.encodeWithSignature(""isFrozen()"")\n        );\n        require(success, string(returndata));\n        return abi.decode(returndata, (bool));\n    }\n\n    /*\n      This method blocks delegation to initialize().\n      Only upgradeTo should be able to delegate call to initialize().\n    */\n    function initialize(\n        bytes calldata /*data*/\n    ) external pure {\n        revert(""CANNOT_CALL_INITIALIZE"");\n    }\n\n    modifier notFinalized() {\n        require(isNotFinalized(), ""IMPLEMENTATION_FINALIZED"");\n        _;\n    }\n\n    /*\n      Forbids calling the function if the implementation is frozen.\n      This modifier relies on the lower level (logical contract) implementation of isFrozen().\n    */\n    modifier notFrozen() {\n        require(!implementationIsFrozen(), ""STATE_IS_FROZEN"");\n        _;\n    }\n\n    /*\n      This entry point serves only transactions with empty calldata. (i.e. pure value transfer tx).\n      We don\'t expect to receive such, thus block them.\n    */\n    receive() external payable {\n        revert(""CONTRACT_NOT_EXPECTED_TO_RECEIVE"");\n    }\n\n    /*\n      Contract\'s default function. Delegates execution to the implementation contract.\n      It returns back to the external caller whatever the implementation delegated code returns.\n    */\n    fallback() external payable {\n        address _implementation = implementation();\n        require(_implementation != address(0x0), ""MISSING_IMPLEMENTATION"");\n\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 for now, as we don\'t know the out size yet.\n            let result := delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /*\n      Sets the implementation address of the proxy.\n    */\n    function setImplementation(address newImplementation) private {\n        bytes32 slot = IMPLEMENTATION_SLOT;\n        assembly {\n            sstore(slot, newImplementation)\n        }\n    }\n\n    /*\n      Returns true if the contract is not in the finalized state.\n    */\n    function isNotFinalized() public view returns (bool notFinal) {\n        bytes32 slot = FINALIZED_STATE_SLOT;\n        uint256 slotValue;\n        assembly {\n            slotValue := sload(slot)\n        }\n        notFinal = (slotValue == 0);\n    }\n\n    /*\n      Marks the current implementation as finalized.\n    */\n    function setFinalizedFlag() private {\n        bytes32 slot = FINALIZED_STATE_SLOT;\n        assembly {\n            sstore(slot, 0x1)\n        }\n    }\n\n    /*\n      Introduce an implementation and its initialization vector,\n      and start the time-lock before it can be upgraded to.\n      addImplementation is not blocked when frozen or finalized.\n      (upgradeTo API is blocked when finalized or frozen).\n    */\n    function addImplementation(\n        address newImplementation,\n        bytes calldata data,\n        bool finalize\n    ) external onlyGovernance {\n        require(newImplementation.isContract(), ""ADDRESS_NOT_CONTRACT"");\n\n        bytes32 implVectorHash = keccak256(abi.encode(newImplementation, data, finalize));\n\n        uint256 activationTime = block.timestamp + getUpgradeActivationDelay();\n\n        enabledTime[implVectorHash] = activationTime;\n        emit ImplementationAdded(newImplementation, data, finalize);\n    }\n\n    /*\n      Removes a candidate implementation.\n      Note that it is possible to remove the current implementation. Doing so doesn\'t affect the\n      current implementation, but rather revokes it as a future candidate.\n    */\n    function removeImplementation(\n        address removedImplementation,\n        bytes calldata data,\n        bool finalize\n    ) external onlyGovernance {\n        bytes32 implVectorHash = keccak256(abi.encode(removedImplementation, data, finalize));\n\n        // If we have initializer, we set the hash of it.\n        uint256 activationTime = enabledTime[implVectorHash];\n        require(activationTime > 0, ""UNKNOWN_UPGRADE_INFORMATION"");\n        delete enabledTime[implVectorHash];\n        emit ImplementationRemoved(removedImplementation, data, finalize);\n    }\n\n    /*\n      Upgrades the proxy to a new implementation, with its initialization.\n      to upgrade successfully, implementation must have been added time-lock agreeably\n      before, and the init vector must be identical ot the one submitted before.\n\n      Upon assignment of new implementation address,\n      its initialize will be called with the initializing vector (even if empty).\n      Therefore, the implementation MUST must have such a method.\n\n      Note - Initialization data is committed to in advance, therefore it must remain valid\n      until the actual contract upgrade takes place.\n\n      Care should be taken regarding initialization data and flow when planning the contract upgrade.\n\n      When planning contract upgrade, special care is also needed with regard to governance\n      (See comments in Governance.sol).\n    */\n    // NOLINTNEXTLINE: reentrancy-events timestamp.\n    function upgradeTo(\n        address newImplementation,\n        bytes calldata data,\n        bool finalize\n    ) external payable onlyGovernance notFinalized notFrozen {\n        bytes32 implVectorHash = keccak256(abi.encode(newImplementation, data, finalize));\n        uint256 activationTime = enabledTime[implVectorHash];\n        require(activationTime > 0, ""UNKNOWN_UPGRADE_INFORMATION"");\n        require(newImplementation.isContract(), ""ADDRESS_NOT_CONTRACT"");\n\n        // On the first time an implementation is set - time-lock should not be enforced.\n        require(\n            activationTime <= block.timestamp || implementation() == address(0x0),\n            ""UPGRADE_NOT_ENABLED_YET""\n        );\n\n        setImplementation(newImplementation);\n\n        // NOLINTNEXTLINE: low-level-calls controlled-delegatecall.\n        (bool success, bytes memory returndata) = newImplementation.delegatecall(\n            abi.encodeWithSelector(this.initialize.selector, data)\n        );\n        require(success, string(returndata));\n\n        // Verify that the new implementation is not frozen post initialization.\n        // NOLINTNEXTLINE: low-level-calls controlled-delegatecall.\n        (success, returndata) = newImplementation.delegatecall(\n            abi.encodeWithSignature(""isFrozen()"")\n        );\n        require(success, ""CALL_TO_ISFROZEN_REVERTED"");\n        require(!abi.decode(returndata, (bool)), ""NEW_IMPLEMENTATION_FROZEN"");\n\n        emit ImplementationUpgraded(newImplementation, data);\n\n        if (finalize) {\n            setFinalizedFlag();\n            emit FinalizedImplementation(newImplementation);\n        }\n    }\n}\n'}, 'ProxyGovernance.sol': {'content': '/*\n  Copyright 2019-2022 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the ""License"").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an ""AS IS"" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\nimport ""Governance.sol"";\nimport ""GovernanceStorage.sol"";\n\n/**\n  The Proxy contract is governed by one or more Governors of which the initial one is the\n  deployer of the contract.\n\n  A governor has the sole authority to perform the following operations:\n\n  1. Nominate additional governors (:sol:func:`proxyNominateNewGovernor`)\n  2. Remove other governors (:sol:func:`proxyRemoveGovernor`)\n  3. Add new `implementations` (proxied contracts)\n  4. Remove (new or old) `implementations`\n  5. Update `implementations` after a timelock allows it\n\n  Adding governors is performed in a two step procedure:\n\n  1. First, an existing governor nominates a new governor (:sol:func:`proxyNominateNewGovernor`)\n  2. Then, the new governor must accept governance to become a governor (:sol:func:`proxyAcceptGovernance`)\n\n  This two step procedure ensures that a governor public key cannot be nominated unless there is an\n  entity that has the corresponding private key. This is intended to prevent errors in the addition\n  process.\n\n  The governor private key should typically be held in a secure cold wallet or managed via a\n  multi-sig contract.\n*/\n/*\n  Implements Governance for the proxy contract.\n  It is a thin wrapper to the Governance contract,\n  which is needed so that it can have non-colliding function names,\n  and a specific tag (key) to allow unique state storage.\n*/\ncontract ProxyGovernance is GovernanceStorage, Governance {\n    // The tag is the string key that is used in the Governance storage mapping.\n    string public constant PROXY_GOVERNANCE_TAG = ""StarkEx.Proxy.2019.GovernorsInformation"";\n\n    /*\n      Returns the GovernanceInfoStruct associated with the governance tag.\n    */\n    function getGovernanceInfo() internal view override returns (GovernanceInfoStruct storage) {\n        return governanceInfo[PROXY_GOVERNANCE_TAG];\n    }\n\n    function proxyIsGovernor(address user) external view returns (bool) {\n        return _isGovernor(user);\n    }\n\n    function proxyNominateNewGovernor(address newGovernor) external {\n        _nominateNewGovernor(newGovernor);\n    }\n\n    function proxyRemoveGovernor(address governorForRemoval) external {\n        _removeGovernor(governorForRemoval);\n    }\n\n    function proxyAcceptGovernance() external {\n        _acceptGovernance();\n    }\n\n    function proxyCancelNomination() external {\n        _cancelNomination();\n    }\n}\n'}, 'ProxyStorage.sol': {'content': '/*\n  Copyright 2019-2022 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the ""License"").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an ""AS IS"" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\nimport ""GovernanceStorage.sol"";\n\n/*\n  Holds the Proxy-specific state variables.\n  This contract is inherited by the GovernanceStorage (and indirectly by MainStorage)\n  to prevent collision hazard.\n*/\ncontract ProxyStorage is GovernanceStorage {\n    // NOLINTNEXTLINE: naming-convention uninitialized-state.\n    mapping(address => bytes32) internal initializationHash_DEPRECATED;\n\n    // The time after which we can switch to the implementation.\n    // Hash(implementation, data, finalize) => time.\n    mapping(bytes32 => uint256) internal enabledTime;\n\n    // A central storage of the flags whether implementation has been initialized.\n    // Note - it can be used flexibly enough to accommodate multiple levels of initialization\n    // (i.e. using different key salting schemes for different initialization levels).\n    mapping(bytes32 => bool) internal initialized;\n}\n'}, 'StorageSlots.sol': {'content': '/*\n  Copyright 2019-2022 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the ""License"").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an ""AS IS"" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\n/**\n  StorageSlots holds the arbitrary storage slots used throughout the Proxy pattern.\n  Storage address slots are a mechanism to define an arbitrary location, that will not be\n  overlapped by the logical contracts.\n*/\ncontract StorageSlots {\n    // Storage slot with the address of the current implementation.\n    // We need to keep this variable stored outside of the commonly used space,\n    // so that it\'s not overrun by the logical implementation (the proxied contract).\n    // Web3.keccak(text=""StarkWare2019.implemntation-slot"").\n    bytes32 internal constant IMPLEMENTATION_SLOT =\n        0x177667240aeeea7e35eabe3a35e18306f336219e1386f7710a6bf8783f761b24;\n\n    // Storage slot with the address of the call-proxy current implementation.\n    // We need to keep this variable stored outside of the commonly used space.\n    // so that it\'s not overrun by the logical implementation (the proxied contract).\n    // Web3.keccak(text=""StarkWare2020.CallProxy.Implemntation.Slot"").\n    bytes32 internal constant CALL_PROXY_IMPL_SLOT =\n        0x7184681641399eb4ad2fdb92114857ee6ff239f94ad635a1779978947b8843be;\n\n    // This storage slot stores the finalization flag.\n    // Once the value stored in this slot is set to non-zero\n    // the proxy blocks implementation upgrades.\n    // The current implementation is then referred to as Finalized.\n    // Web3.keccak(text=""StarkWare2019.finalization-flag-slot"").\n    bytes32 internal constant FINALIZED_STATE_SLOT =\n        0x7d433c6f837e8f93009937c466c82efbb5ba621fae36886d0cac433c5d0aa7d2;\n\n    // Storage slot to hold the upgrade delay (time-lock).\n    // The intention of this slot is to allow modification using an EIC.\n    // Web3.keccak(text=""StarkWare.Upgradibility.Delay.Slot"").\n    bytes32 public constant UPGRADE_DELAY_SLOT =\n        0xc21dbb3089fcb2c4f4c6a67854ab4db2b0f233ea4b21b21f912d52d18fc5db1f;\n}\n'}}

// File: settings
{'metadata': {'useLiteralContent': True}, 'libraries': {}, 'remappings': [], 'optimizer': {'enabled': True, 'runs': 100}, 'evmVersion': 'istanbul', 'outputSelection': {'*': {'*': ['evm.bytecode', 'evm.deployedBytecode', 'devdoc', 'userdoc', 'metadata', 'abi']}}}",True
0x2401c39d7ba9e283668a53fcc7b8f5fd9e716fdf,"// File: language
Solidity

// File: sources
{'lib/vsuite/lib/utils.sol/src/TUPProxy.sol': {'content': '// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: 2023 Kiln <contact@kiln.fi>\n//\n// ██╗  ██╗██╗██╗     ███╗   ██╗\n// ██║ ██╔╝██║██║     ████╗  ██║\n// █████╔╝ ██║██║     ██╔██╗ ██║\n// ██╔═██╗ ██║██║     ██║╚██╗██║\n// ██║  ██╗██║███████╗██║ ╚████║\n// ╚═╝  ╚═╝╚═╝╚══════╝╚═╝  ╚═══╝\n//\npragma solidity >=0.8.17;\n\nimport ""openzeppelin-contracts/proxy/ERC1967/ERC1967Proxy.sol"";\nimport ""./Freezable.sol"";\n\n/// @title Openzeppelin Transparent Upgradeable Proxy (with virtual external upgrade methods)\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(address _logic, address admin_, bytes memory _data) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    // slither-disable-next-line incorrect-modifier\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external virtual ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(""""), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable virtual ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), ""TransparentUpgradeableProxy: admin cannot fallback to proxy target"");\n        super._beforeFallback();\n    }\n}\n\n/// @title TUPProxy (Transparent Upgradeable Pausable Proxy)\n/// @author mortimr @ Kiln\n/// @notice This contract extends the Transparent Upgradeable proxy and adds a system wide pause feature.\n///         When the system is paused, the fallback will fail no matter what calls are made.\ncontract TUPProxy is TransparentUpgradeableProxy, Freezable {\n    /// @dev EIP1967 slot to store the pause status value.\n    bytes32 private constant _PAUSE_SLOT = bytes32(uint256(keccak256(""eip1967.proxy.pause"")) - 1);\n    /// @dev EIP1967 slot to store the pauser address value.\n    bytes32 private constant _PAUSER_SLOT = bytes32(uint256(keccak256(""eip1967.proxy.pauser"")) - 1);\n\n    /// @notice Emitted when the proxy dedicated pauser is changed.\n    /// @param previousPauser The address of the previous pauser\n    /// @param newPauser The address of the new pauser\n    event PauserChanged(address previousPauser, address newPauser);\n\n    /// @notice Thrown when a call was attempted and the proxy is paused.\n    error CallWhenPaused();\n\n    // slither-disable-next-line incorrect-modifier\n    modifier ifAdminOrPauser() {\n        if (msg.sender == _getAdmin() || msg.sender == _getPauser()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /// @param _logic The address of the implementation contract\n    /// @param admin_ The address of the admin account able to pause and upgrade the implementation\n    /// @param _data Extra data use to perform atomic initializations\n    constructor(address _logic, address admin_, bytes memory _data)\n        payable\n        TransparentUpgradeableProxy(_logic, admin_, _data)\n    {}\n\n    /// @notice Retrieves Paused state.\n    /// @return Paused state\n    function paused() external ifAdminOrPauser returns (bool) {\n        return StorageSlot.getBooleanSlot(_PAUSE_SLOT).value;\n    }\n\n    /// @notice Pauses system.\n    function pause() external ifAdminOrPauser notFrozen {\n        StorageSlot.getBooleanSlot(_PAUSE_SLOT).value = true;\n    }\n\n    /// @notice Unpauses system.\n    function unpause() external ifAdmin notFrozen {\n        StorageSlot.getBooleanSlot(_PAUSE_SLOT).value = false;\n    }\n\n    /// @notice Sets the freeze timeout.\n    function freeze(uint256 freezeTimeout) external ifAdmin {\n        _freeze(freezeTimeout);\n    }\n\n    /// @notice Cancels the freeze process.\n    function cancelFreeze() external ifAdmin {\n        _cancelFreeze();\n    }\n\n    /// @notice Retrieve the freeze status.\n    /// @return True if frozen\n    function frozen() external ifAdmin returns (bool) {\n        return _isFrozen();\n    }\n\n    /// @notice Retrieve the freeze timestamp.\n    /// @return The freeze timestamp\n    function freezeTime() external ifAdmin returns (uint256) {\n        return _freezeTime();\n    }\n\n    /// @notice Retrieve the dedicated pauser address.\n    /// @return The pauser address\n    function pauser() external ifAdminOrPauser returns (address) {\n        return _getPauser();\n    }\n\n    /// @notice Changes the dedicated pauser address.\n    /// @dev Not callable when frozen\n    /// @param newPauser The new pauser address\n    function changePauser(address newPauser) external ifAdmin notFrozen {\n        emit PauserChanged(_getPauser(), newPauser);\n        _changePauser(newPauser);\n    }\n\n    /// @notice Changed the proxy admin.\n    /// @dev Not callable when frozen\n    function changeAdmin(address newAdmin) external override ifAdmin notFrozen {\n        _changeAdmin(newAdmin);\n    }\n\n    /// @notice Performs an upgrade without reinitialization.\n    /// @param newImplementation The new implementation address\n    function upgradeTo(address newImplementation) external override ifAdmin notFrozen {\n        _upgradeToAndCall(newImplementation, bytes(""""), false);\n    }\n\n    /// @notice Performs an upgrade with reinitialization.\n    /// @param newImplementation The new implementation address\n    /// @param data The calldata to use atomically after the implementation upgrade\n    function upgradeToAndCall(address newImplementation, bytes calldata data)\n        external\n        payable\n        override\n        ifAdmin\n        notFrozen\n    {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /// @dev Internal utility to retrieve the dedicated pauser from storage,\n    /// @return The pauser address\n    function _getPauser() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_PAUSER_SLOT).value;\n    }\n\n    /// @dev Internal utility to change the dedicated pauser.\n    /// @param newPauser The new pauser address\n    function _changePauser(address newPauser) internal {\n        StorageSlot.getAddressSlot(_PAUSER_SLOT).value = newPauser;\n    }\n\n    /// @dev Overrides the fallback method to check if system is not paused before.\n    /// @dev Address Zero is allowed to perform calls even if system is paused. This allows\n    ///      view functions to be called when the system is paused as rpc providers can easily\n    ///      set the sender address to zero.\n    // slither-disable-next-line timestamp\n    function _beforeFallback() internal override {\n        if ((!StorageSlot.getBooleanSlot(_PAUSE_SLOT).value || _isFrozen()) || msg.sender == address(0)) {\n            super._beforeFallback();\n        } else {\n            revert CallWhenPaused();\n        }\n    }\n\n    /// @dev Internal utility to retrieve the account allowed to freeze the contract.\n    /// @return The freezer account\n    function _getFreezer() internal view override returns (address) {\n        return _getAdmin();\n    }\n}\n'}, 'lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport ""../Proxy.sol"";\nimport ""./ERC1967Upgrade.sol"";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn\'t conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it\'s used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n'}, 'lib/vsuite/lib/utils.sol/src/Freezable.sol': {'content': '// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: 2023 Kiln <contact@kiln.fi>\n//\n// ██╗  ██╗██╗██╗     ███╗   ██╗\n// ██║ ██╔╝██║██║     ████╗  ██║\n// █████╔╝ ██║██║     ██╔██╗ ██║\n// ██╔═██╗ ██║██║     ██║╚██╗██║\n// ██║  ██╗██║███████╗██║ ╚████║\n// ╚═╝  ╚═╝╚═╝╚══════╝╚═╝  ╚═══╝\n//\npragma solidity >=0.8.17;\n\n// For some unexplainable and mysterious reason, adding this line would make slither crash\n// This is the reason why we are not using our own unstructured storage libs in this contract\n// (while the libs work properly in a lot of contracts without slither having any issue with it)\n// import ""./types/uint256.sol"";\n\nimport ""./libs/LibErrors.sol"";\nimport ""./libs/LibConstant.sol"";\nimport ""openzeppelin-contracts/utils/StorageSlot.sol"";\n\n/// @title Freezable\n/// @author mortimr @ Kiln\n/// @dev Unstructured Storage Friendly\n/// @notice The Freezable contract is used to add a freezing capability to admin related actions.\n///         The goal would be to ossify an implementation after a certain amount of time.\n// slither-disable-next-line unimplemented-functions\nabstract contract Freezable {\n    /// @notice Thrown when a call happened while it was forbidden when frozen.\n    error Frozen();\n\n    /// @notice Thrown when the provided timeout value is lower than 100 days.\n    /// @param providedValue The user provided value\n    /// @param minimumValue The minimum allowed value\n    error FreezeTimeoutTooLow(uint256 providedValue, uint256 minimumValue);\n\n    /// @notice Emitted when the freeze timeout is changed.\n    /// @param freezeTime The timestamp after which the contract will be frozen\n    event SetFreezeTime(uint256 freezeTime);\n\n    /// @dev This is the keccak-256 hash of ""freezable.freeze_timestamp"" subtracted by 1.\n    bytes32 private constant _FREEZE_TIMESTAMP_SLOT = 0x04b06dd5becaad633b58f99e01f1e05103eff5a573d10d18c9baf1bc4e6bfd3a;\n\n    /// @dev Only callable by the freezer account.\n    modifier onlyFreezer() {\n        _onlyFreezer();\n        _;\n    }\n\n    /// @dev Only callable when not frozen.\n    modifier notFrozen() {\n        _notFrozen();\n        _;\n    }\n\n    /// @dev Override and set it to return the address to consider as the freezer.\n    /// @return The freezer address\n    // slither-disable-next-line dead-code\n    function _getFreezer() internal view virtual returns (address);\n\n    /// @dev Retrieve the freeze status.\n    /// @return True if contract is frozen\n    // slither-disable-next-line dead-code,timestamp\n    function _isFrozen() internal view returns (bool) {\n        uint256 freezeTime_ = _freezeTime();\n        return (freezeTime_ > 0 && block.timestamp >= freezeTime_);\n    }\n\n    /// @dev Retrieve the freeze timestamp.\n    /// @return The freeze timestamp\n    // slither-disable-next-line dead-code\n    function _freezeTime() internal view returns (uint256) {\n        return StorageSlot.getUint256Slot(_FREEZE_TIMESTAMP_SLOT).value;\n    }\n\n    /// @dev Internal utility to set the freeze timestamp.\n    /// @param freezeTime The new freeze timestamp\n    // slither-disable-next-line dead-code\n    function _setFreezeTime(uint256 freezeTime) internal {\n        StorageSlot.getUint256Slot(_FREEZE_TIMESTAMP_SLOT).value = freezeTime;\n        emit SetFreezeTime(freezeTime);\n    }\n\n    /// @dev Internal utility to revert if caller is not freezer.\n    // slither-disable-next-line dead-code\n    function _onlyFreezer() internal view {\n        if (msg.sender != _getFreezer()) {\n            revert LibErrors.Unauthorized(msg.sender, _getFreezer());\n        }\n    }\n\n    /// @dev Internal utility to revert if contract is frozen.\n    // slither-disable-next-line dead-code\n    function _notFrozen() internal view {\n        if (_isFrozen()) {\n            revert Frozen();\n        }\n    }\n\n    /// @dev Internal utility to start the freezing procedure.\n    /// @param freezeTimeout Timeout to add to current timestamp to define freeze timestamp\n    // slither-disable-next-line dead-code\n    function _freeze(uint256 freezeTimeout) internal {\n        _notFrozen();\n        _onlyFreezer();\n        if (freezeTimeout < LibConstant.MINIMUM_FREEZE_TIMEOUT) {\n            revert FreezeTimeoutTooLow(freezeTimeout, LibConstant.MINIMUM_FREEZE_TIMEOUT);\n        }\n\n        // overflow would revert\n        uint256 now_ = block.timestamp;\n        uint256 freezeTime_ = now_ + freezeTimeout;\n\n        _setFreezeTime(freezeTime_);\n    }\n\n    /// @dev Internal utility to cancel the freezing procedure.\n    // slither-disable-next-line dead-code\n    function _cancelFreeze() internal {\n        _notFrozen();\n        _onlyFreezer();\n        _setFreezeTime(0);\n    }\n}\n'}, 'lib/openzeppelin-contracts/contracts/proxy/Proxy.sol': {'content': ""// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n""}, 'lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Upgrade.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport ""../beacon/IBeacon.sol"";\nimport ""../../interfaces/draft-IERC1822.sol"";\nimport ""../../utils/Address.sol"";\nimport ""../../utils/StorageSlot.sol"";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of ""eip1967.proxy.rollback"" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of ""eip1967.proxy.implementation"" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), ""ERC1967: new implementation is not a contract"");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, ""ERC1967Upgrade: unsupported proxiableUUID"");\n            } catch {\n                revert(""ERC1967Upgrade: new implementation is not UUPS"");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of ""eip1967.proxy.admin"" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), ""ERC1967: new admin is the zero address"");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256(\'eip1967.proxy.beacon\')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), ""ERC1967: new beacon is not a contract"");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            ""ERC1967: beacon implementation is not a contract""\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n'}, 'lib/vsuite/lib/utils.sol/src/libs/LibErrors.sol': {'content': '// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: 2023 Kiln <contact@kiln.fi>\n//\n// ██╗  ██╗██╗██╗     ███╗   ██╗\n// ██║ ██╔╝██║██║     ████╗  ██║\n// █████╔╝ ██║██║     ██╔██╗ ██║\n// ██╔═██╗ ██║██║     ██║╚██╗██║\n// ██║  ██╗██║███████╗██║ ╚████║\n// ╚═╝  ╚═╝╚═╝╚══════╝╚═╝  ╚═══╝\n//\npragma solidity >=0.8.17;\n\nlibrary LibErrors {\n    error Unauthorized(address account, address expected);\n    error InvalidZeroAddress();\n    error InvalidNullValue();\n    error InvalidBPSValue();\n    error InvalidEmptyString();\n}\n'}, 'lib/vsuite/lib/utils.sol/src/libs/LibConstant.sol': {'content': '// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: 2023 Kiln <contact@kiln.fi>\n//\n// ██╗  ██╗██╗██╗     ███╗   ██╗\n// ██║ ██╔╝██║██║     ████╗  ██║\n// █████╔╝ ██║██║     ██╔██╗ ██║\n// ██╔═██╗ ██║██║     ██║╚██╗██║\n// ██║  ██╗██║███████╗██║ ╚████║\n// ╚═╝  ╚═╝╚═╝╚══════╝╚═╝  ╚═══╝\n//\npragma solidity >=0.8.17;\n\nlibrary LibConstant {\n    /// @dev The basis points value representing 100%.\n    uint256 internal constant BASIS_POINTS_MAX = 10_000;\n    /// @dev The size of a deposit to activate a validator.\n    uint256 internal constant DEPOSIT_SIZE = 32 ether;\n    /// @dev The minimum freeze timeout before freeze is active.\n    uint256 internal constant MINIMUM_FREEZE_TIMEOUT = 100 days;\n    /// @dev Address used to represent ETH when an address is required to identify an asset.\n    address internal constant ETHER = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n}\n'}, 'lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), ""ERC1967: new implementation is not a contract"");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n'}, 'lib/openzeppelin-contracts/contracts/proxy/beacon/IBeacon.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n'}, 'lib/openzeppelin-contracts/contracts/interfaces/draft-IERC1822.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n'}, 'lib/openzeppelin-contracts/contracts/utils/Address.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, ""Address: insufficient balance"");\n\n        (bool success, ) = recipient.call{value: amount}("""");\n        require(success, ""Address: unable to send value, recipient may have reverted"");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, ""Address: low-level call failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, ""Address: insufficient balance for call"");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, ""Address: low-level static call failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, ""Address: low-level delegate call failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), ""Address: call to non-contract"");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n'}}

// File: settings
{'remappings': ['deploy.sol/=lib/deploy.sol/src/', 'ds-test/=lib/forge-std/lib/ds-test/src/', 'forge-gas-snapshot/=lib/forge-gas-snapshot/src/', 'forge-std/=lib/forge-std/src/', 'murky/=lib/murky/src/', 'openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/', 'solmate/=lib/deploy.sol/lib/solmate/src/', 'vsuite/=lib/vsuite/src/', 'vsuite.test/=lib/vsuite/test/', 'prb-math/=lib/vsuite/lib/utils.sol/lib/prb-math/contracts/', 'utils.sol.test/=lib/vsuite/lib/utils.sol/test/', 'utils.sol/=lib/vsuite/lib/utils.sol/src/', 'erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/'], 'optimizer': {'enabled': True, 'runs': 200}, 'metadata': {'useLiteralContent': False, 'bytecodeHash': 'ipfs'}, 'outputSelection': {'*': {'*': ['evm.bytecode', 'evm.deployedBytecode', 'devdoc', 'userdoc', 'metadata', 'abi']}}, 'evmVersion': 'london', 'viaIR': False, 'libraries': {}}",True
0x87870bca3f3fd6335c3f4ce8392d69350b4fa4e2,"// File: language
Solidity

// File: settings
{'evmVersion': 'berlin', 'libraries': {}, 'metadata': {'bytecodeHash': 'ipfs', 'useLiteralContent': True}, 'optimizer': {'enabled': True, 'runs': 100000}, 'remappings': [], 'outputSelection': {'*': {'*': ['evm.bytecode', 'evm.deployedBytecode', 'devdoc', 'userdoc', 'metadata', 'abi']}}}

// File: sources
{'@aave/core-v3/contracts/dependencies/openzeppelin/contracts/Address.sol': {'content': ""// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n  /**\n   * @dev Returns true if `account` is a contract.\n   *\n   * [IMPORTANT]\n   * ====\n   * It is unsafe to assume that an address for which this function returns\n   * false is an externally-owned account (EOA) and not a contract.\n   *\n   * Among others, `isContract` will return false for the following\n   * types of addresses:\n   *\n   *  - an externally-owned account\n   *  - a contract in construction\n   *  - an address where a contract will be created\n   *  - an address where a contract lived, but was destroyed\n   * ====\n   */\n  function isContract(address account) internal view returns (bool) {\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n    // for accounts without code, i.e. `keccak256('')`\n    bytes32 codehash;\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      codehash := extcodehash(account)\n    }\n    return (codehash != accountHash && codehash != 0x0);\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n   * `recipient`, forwarding all available gas and reverting on errors.\n   *\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\n   * imposed by `transfer`, making them unable to receive funds via\n   * `transfer`. {sendValue} removes this limitation.\n   *\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n   *\n   * IMPORTANT: because control is transferred to `recipient`, care must be\n   * taken to not create reentrancy vulnerabilities. Consider using\n   * {ReentrancyGuard} or the\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n   */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, 'Address: insufficient balance');\n\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n    (bool success, ) = recipient.call{value: amount}('');\n    require(success, 'Address: unable to send value, recipient may have reverted');\n  }\n}\n""}, '@aave/core-v3/contracts/dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy.sol': {'content': '// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\nimport \'./Proxy.sol\';\nimport \'../contracts/Address.sol\';\n\n/**\n * @title BaseUpgradeabilityProxy\n * @dev This contract implements a proxy that allows to change the\n * implementation address to which it will delegate.\n * Such a change is called an implementation upgrade.\n */\ncontract BaseUpgradeabilityProxy is Proxy {\n  /**\n   * @dev Emitted when the implementation is upgraded.\n   * @param implementation Address of the new implementation.\n   */\n  event Upgraded(address indexed implementation);\n\n  /**\n   * @dev Storage slot with the address of the current implementation.\n   * This is the keccak-256 hash of ""eip1967.proxy.implementation"" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant IMPLEMENTATION_SLOT =\n    0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  /**\n   * @dev Returns the current implementation.\n   * @return impl Address of the current implementation\n   */\n  function _implementation() internal view override returns (address impl) {\n    bytes32 slot = IMPLEMENTATION_SLOT;\n    //solium-disable-next-line\n    assembly {\n      impl := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Upgrades the proxy to a new implementation.\n   * @param newImplementation Address of the new implementation.\n   */\n  function _upgradeTo(address newImplementation) internal {\n    _setImplementation(newImplementation);\n    emit Upgraded(newImplementation);\n  }\n\n  /**\n   * @dev Sets the implementation address of the proxy.\n   * @param newImplementation Address of the new implementation.\n   */\n  function _setImplementation(address newImplementation) internal {\n    require(\n      Address.isContract(newImplementation),\n      \'Cannot set a proxy implementation to a non-contract address\'\n    );\n\n    bytes32 slot = IMPLEMENTATION_SLOT;\n\n    //solium-disable-next-line\n    assembly {\n      sstore(slot, newImplementation)\n    }\n  }\n}\n'}, '@aave/core-v3/contracts/dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy.sol': {'content': ""// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\nimport './BaseUpgradeabilityProxy.sol';\n\n/**\n * @title InitializableUpgradeabilityProxy\n * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing\n * implementation and init data.\n */\ncontract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {\n  /**\n   * @dev Contract initializer.\n   * @param _logic Address of the initial implementation.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n  function initialize(address _logic, bytes memory _data) public payable {\n    require(_implementation() == address(0));\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n    _setImplementation(_logic);\n    if (_data.length > 0) {\n      (bool success, ) = _logic.delegatecall(_data);\n      require(success);\n    }\n  }\n}\n""}, '@aave/core-v3/contracts/dependencies/openzeppelin/upgradeability/Proxy.sol': {'content': ""// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\n/**\n * @title Proxy\n * @dev Implements delegation of calls to other contracts, with proper\n * forwarding of return values and bubbling of failures.\n * It defines a fallback function that delegates all calls to the address\n * returned by the abstract _implementation() internal function.\n */\nabstract contract Proxy {\n  /**\n   * @dev Fallback function.\n   * Will run if no other function in the contract matches the call data.\n   * Implemented entirely in `_fallback`.\n   */\n  fallback() external payable {\n    _fallback();\n  }\n\n  /**\n   * @return The Address of the implementation.\n   */\n  function _implementation() internal view virtual returns (address);\n\n  /**\n   * @dev Delegates execution to an implementation contract.\n   * This is a low level function that doesn't return to its internal call site.\n   * It will return to the external caller whatever the implementation returns.\n   * @param implementation Address to delegate.\n   */\n  function _delegate(address implementation) internal {\n    //solium-disable-next-line\n    assembly {\n      // Copy msg.data. We take full control of memory in this inline assembly\n      // block because it will not return to Solidity code. We overwrite the\n      // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize())\n\n      // Call the implementation.\n      // out and outsize are 0 because we don't know the size yet.\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n      // Copy the returned data.\n      returndatacopy(0, 0, returndatasize())\n\n      switch result\n      // delegatecall returns 0 on error.\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  /**\n   * @dev Function that is run as the first thing in the fallback function.\n   * Can be redefined in derived contracts to add functionality.\n   * Redefinitions must call super._willFallback().\n   */\n  function _willFallback() internal virtual {}\n\n  /**\n   * @dev fallback implementation.\n   * Extracted to enable manual triggering.\n   */\n  function _fallback() internal {\n    _willFallback();\n    _delegate(_implementation());\n  }\n}\n""}, '@aave/core-v3/contracts/protocol/libraries/aave-upgradeability/BaseImmutableAdminUpgradeabilityProxy.sol': {'content': ""// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\nimport {BaseUpgradeabilityProxy} from '../../../dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy.sol';\n\n/**\n * @title BaseImmutableAdminUpgradeabilityProxy\n * @author Aave, inspired by the OpenZeppelin upgradeability proxy pattern\n * @notice This contract combines an upgradeability proxy with an authorization\n * mechanism for administrative tasks.\n * @dev The admin role is stored in an immutable, which helps saving transactions costs\n * All external functions in this contract must be guarded by the\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n * feature proposal that would enable this to be done automatically.\n */\ncontract BaseImmutableAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\n  address internal immutable _admin;\n\n  /**\n   * @dev Constructor.\n   * @param admin The address of the admin\n   */\n  constructor(address admin) {\n    _admin = admin;\n  }\n\n  modifier ifAdmin() {\n    if (msg.sender == _admin) {\n      _;\n    } else {\n      _fallback();\n    }\n  }\n\n  /**\n   * @notice Return the admin address\n   * @return The address of the proxy admin.\n   */\n  function admin() external ifAdmin returns (address) {\n    return _admin;\n  }\n\n  /**\n   * @notice Return the implementation address\n   * @return The address of the implementation.\n   */\n  function implementation() external ifAdmin returns (address) {\n    return _implementation();\n  }\n\n  /**\n   * @notice Upgrade the backing implementation of the proxy.\n   * @dev Only the admin can call this function.\n   * @param newImplementation The address of the new implementation.\n   */\n  function upgradeTo(address newImplementation) external ifAdmin {\n    _upgradeTo(newImplementation);\n  }\n\n  /**\n   * @notice Upgrade the backing implementation of the proxy and call a function\n   * on the new implementation.\n   * @dev This is useful to initialize the proxied contract.\n   * @param newImplementation The address of the new implementation.\n   * @param data Data to send as msg.data in the low level call.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   */\n  function upgradeToAndCall(address newImplementation, bytes calldata data)\n    external\n    payable\n    ifAdmin\n  {\n    _upgradeTo(newImplementation);\n    (bool success, ) = newImplementation.delegatecall(data);\n    require(success);\n  }\n\n  /**\n   * @notice Only fall back when the sender is not the admin.\n   */\n  function _willFallback() internal virtual override {\n    require(msg.sender != _admin, 'Cannot call fallback function from the proxy admin');\n    super._willFallback();\n  }\n}\n""}, '@aave/core-v3/contracts/protocol/libraries/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy.sol': {'content': ""// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\nimport {InitializableUpgradeabilityProxy} from '../../../dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy.sol';\nimport {Proxy} from '../../../dependencies/openzeppelin/upgradeability/Proxy.sol';\nimport {BaseImmutableAdminUpgradeabilityProxy} from './BaseImmutableAdminUpgradeabilityProxy.sol';\n\n/**\n * @title InitializableAdminUpgradeabilityProxy\n * @author Aave\n * @dev Extends BaseAdminUpgradeabilityProxy with an initializer function\n */\ncontract InitializableImmutableAdminUpgradeabilityProxy is\n  BaseImmutableAdminUpgradeabilityProxy,\n  InitializableUpgradeabilityProxy\n{\n  /**\n   * @dev Constructor.\n   * @param admin The address of the admin\n   */\n  constructor(address admin) BaseImmutableAdminUpgradeabilityProxy(admin) {\n    // Intentionally left blank\n  }\n\n  /// @inheritdoc BaseImmutableAdminUpgradeabilityProxy\n  function _willFallback() internal override(BaseImmutableAdminUpgradeabilityProxy, Proxy) {\n    BaseImmutableAdminUpgradeabilityProxy._willFallback();\n  }\n}\n""}}",True
0x1495bc9e44af1f8bcb62278d2bec4540cf0c05ea,"// File: language
Solidity

// File: sources
{'@openzeppelin/contracts/access/Ownable.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport ""../utils/Context.sol"";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), ""Ownable: caller is not the owner"");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), ""Ownable: new owner is the zero address"");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n'}, '@openzeppelin/contracts/interfaces/draft-IERC1822.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n'}, '@openzeppelin/contracts/interfaces/IERC1967.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.3) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.9._\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n'}, '@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/beacon/BeaconProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport ""./IBeacon.sol"";\nimport ""../Proxy.sol"";\nimport ""../ERC1967/ERC1967Upgrade.sol"";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256(\'eip1967.proxy.beacon\')) - 1`, so that it doesn\'t\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract BeaconProxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it\'s used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address) {\n        return _getBeacon();\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\n     *\n     * If `data` is nonempty, it\'s used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n}\n'}, '@openzeppelin/contracts/proxy/beacon/IBeacon.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n'}, '@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/UpgradeableBeacon.sol)\n\npragma solidity ^0.8.0;\n\nimport ""./IBeacon.sol"";\nimport ""../../access/Ownable.sol"";\nimport ""../../utils/Address.sol"";\n\n/**\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\n * implementation contract, which is where they will delegate all function calls.\n *\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\n */\ncontract UpgradeableBeacon is IBeacon, Ownable {\n    address private _implementation;\n\n    /**\n     * @dev Emitted when the implementation returned by the beacon is changed.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the\n     * beacon.\n     */\n    constructor(address implementation_) {\n        _setImplementation(implementation_);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function implementation() public view virtual override returns (address) {\n        return _implementation;\n    }\n\n    /**\n     * @dev Upgrades the beacon to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * Requirements:\n     *\n     * - msg.sender must be the owner of the contract.\n     * - `newImplementation` must be a contract.\n     */\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation contract address for this beacon\n     *\n     * Requirements:\n     *\n     * - `newImplementation` must be a contract.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), ""UpgradeableBeacon: implementation is not a contract"");\n        _implementation = newImplementation;\n    }\n}\n'}, '@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport ""../Proxy.sol"";\nimport ""./ERC1967Upgrade.sol"";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn\'t conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it\'s used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n'}, '@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.3) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport ""../beacon/IBeacon.sol"";\nimport ""../../interfaces/IERC1967.sol"";\nimport ""../../interfaces/draft-IERC1822.sol"";\nimport ""../../utils/Address.sol"";\nimport ""../../utils/StorageSlot.sol"";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade is IERC1967 {\n    // This is the keccak-256 hash of ""eip1967.proxy.rollback"" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of ""eip1967.proxy.implementation"" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), ""ERC1967: new implementation is not a contract"");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, ""ERC1967Upgrade: unsupported proxiableUUID"");\n            } catch {\n                revert(""ERC1967Upgrade: new implementation is not UUPS"");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of ""eip1967.proxy.admin"" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), ""ERC1967: new admin is the zero address"");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256(\'eip1967.proxy.beacon\')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), ""ERC1967: new beacon is not a contract"");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            ""ERC1967: beacon implementation is not a contract""\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n'}, '@openzeppelin/contracts/proxy/Proxy.sol': {'content': ""// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n""}, '@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.3) (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.0;\n\nimport ""./TransparentUpgradeableProxy.sol"";\nimport ""../../access/Ownable.sol"";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(ITransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(""implementation()"")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex""5c60da1b"");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(ITransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(""admin()"")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex""f851a440"");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(ITransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(ITransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        ITransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n'}, '@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.3) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport ""../ERC1967/ERC1967Proxy.sol"";\n\n/**\n * @dev Interface for {TransparentUpgradeableProxy}. In order to implement transparency, {TransparentUpgradeableProxy}\n * does not implement this interface directly, and some of its functions are implemented by an internal dispatch\n * mechanism. The compiler is unaware that these functions are implemented by {TransparentUpgradeableProxy} and will not\n * include them in the ABI so this interface must be used to interact with it.\n */\ninterface ITransparentUpgradeableProxy is IERC1967 {\n    function admin() external view returns (address);\n\n    function implementation() external view returns (address);\n\n    function changeAdmin(address) external;\n\n    function upgradeTo(address) external;\n\n    function upgradeToAndCall(address, bytes memory) external payable;\n}\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * ""admin cannot fallback to proxy target"".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it\'s best if it\'s a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n *\n * NOTE: The real interface of this proxy is that defined in `ITransparentUpgradeableProxy`. This contract does not\n * inherit from that interface, and instead the admin functions are implicitly implemented using a custom dispatch\n * mechanism in `_fallback`. Consequently, the compiler will not produce an ABI for this contract. This is necessary to\n * fully implement transparency without decoding reverts caused by selector clashes between the proxy and the\n * implementation.\n *\n * WARNING: It is not recommended to extend this contract to add additional external functions. If you do so, the compiler\n * will not check that there are no selector conflicts, due to the note above. A selector clash between any new function\n * and the functions declared in {ITransparentUpgradeableProxy} will be resolved in favor of the new one. This could\n * render the admin operations inaccessible, which could prevent upgradeability. Transparency may also be compromised.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     *\n     * CAUTION: This modifier is deprecated, as it could cause issues if the modified function has arguments, and the\n     * implementation provides a function with the same selector.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior\n     */\n    function _fallback() internal virtual override {\n        if (msg.sender == _getAdmin()) {\n            bytes memory ret;\n            bytes4 selector = msg.sig;\n            if (selector == ITransparentUpgradeableProxy.upgradeTo.selector) {\n                ret = _dispatchUpgradeTo();\n            } else if (selector == ITransparentUpgradeableProxy.upgradeToAndCall.selector) {\n                ret = _dispatchUpgradeToAndCall();\n            } else if (selector == ITransparentUpgradeableProxy.changeAdmin.selector) {\n                ret = _dispatchChangeAdmin();\n            } else if (selector == ITransparentUpgradeableProxy.admin.selector) {\n                ret = _dispatchAdmin();\n            } else if (selector == ITransparentUpgradeableProxy.implementation.selector) {\n                ret = _dispatchImplementation();\n            } else {\n                revert(""TransparentUpgradeableProxy: admin cannot fallback to proxy target"");\n            }\n            assembly {\n                return(add(ret, 0x20), mload(ret))\n            }\n        } else {\n            super._fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function _dispatchAdmin() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address admin = _getAdmin();\n        return abi.encode(admin);\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function _dispatchImplementation() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address implementation = _implementation();\n        return abi.encode(implementation);\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _dispatchChangeAdmin() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address newAdmin = abi.decode(msg.data[4:], (address));\n        _changeAdmin(newAdmin);\n\n        return """";\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     */\n    function _dispatchUpgradeTo() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address newImplementation = abi.decode(msg.data[4:], (address));\n        _upgradeToAndCall(newImplementation, bytes(""""), false);\n\n        return """";\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     */\n    function _dispatchUpgradeToAndCall() private returns (bytes memory) {\n        (address newImplementation, bytes memory data) = abi.decode(msg.data[4:], (address, bytes));\n        _upgradeToAndCall(newImplementation, data, true);\n\n        return """";\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev To keep this contract fully transparent, all `ifAdmin` functions must be payable. This helper is here to\n     * emulate some proxy functions being non-payable while still allowing value to pass through.\n     */\n    function _requireZeroValue() private {\n        require(msg.value == 0);\n    }\n}\n'}, '@openzeppelin/contracts/utils/Address.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, ""Address: insufficient balance"");\n\n        (bool success, ) = recipient.call{value: amount}("""");\n        require(success, ""Address: unable to send value, recipient may have reverted"");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, ""Address: low-level call failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, ""Address: insufficient balance for call"");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, ""Address: low-level static call failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, ""Address: low-level delegate call failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), ""Address: call to non-contract"");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n'}, '@openzeppelin/contracts/utils/Context.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n'}, '@openzeppelin/contracts/utils/StorageSlot.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), ""ERC1967: new implementation is not a contract"");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n'}}

// File: settings
{'optimizer': {'enabled': True, 'runs': 200}, 'outputSelection': {'*': {'*': ['evm.bytecode', 'evm.deployedBytecode', 'devdoc', 'userdoc', 'metadata', 'abi']}}}",True
0x388c818ca8b9251b393131c08a736a67ccb19297,"// File: language
Solidity

// File: sources
{'contracts/0.8.9/LidoExecutionLayerRewardsVault.sol': {'content': '// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>\n\n// SPDX-License-Identifier: GPL-3.0\n\n/* See contracts/COMPILERS.md */\npragma solidity 0.8.9;\n\nimport ""@openzeppelin/contracts-v4.4/token/ERC20/IERC20.sol"";\nimport ""@openzeppelin/contracts-v4.4/token/ERC721/IERC721.sol"";\nimport ""@openzeppelin/contracts-v4.4/token/ERC20/utils/SafeERC20.sol"";\n\ninterface ILido {\n    /**\n      * @notice A payable function supposed to be called only by LidoExecLayerRewardsVault contract\n      * @dev We need a dedicated function because funds received by the default payable function\n      * are treated as a user deposit\n      */\n    function receiveELRewards() external payable;\n}\n\n\n/**\n * @title A vault for temporary storage of execution layer rewards (MEV and tx priority fee)\n */\ncontract LidoExecutionLayerRewardsVault {\n    using SafeERC20 for IERC20;\n\n    address public immutable LIDO;\n    address public immutable TREASURY;\n\n    /**\n      * Emitted when the ERC20 `token` recovered (i.e. transferred)\n      * to the Lido treasury address by `requestedBy` sender.\n      */\n    event ERC20Recovered(\n        address indexed requestedBy,\n        address indexed token,\n        uint256 amount\n    );\n\n    /**\n      * Emitted when the ERC721-compatible `token` (NFT) recovered (i.e. transferred)\n      * to the Lido treasury address by `requestedBy` sender.\n      */\n    event ERC721Recovered(\n        address indexed requestedBy,\n        address indexed token,\n        uint256 tokenId\n    );\n\n    /**\n      * Emitted when the vault received ETH\n      */\n    event ETHReceived(\n        uint256 amount\n    );\n\n    /**\n      * Ctor\n      *\n      * @param _lido the Lido token (stETH) address\n      * @param _treasury the Lido treasury address (see ERC20/ERC721-recovery interfaces)\n      */\n    constructor(address _lido, address _treasury) {\n        require(_lido != address(0), ""LIDO_ZERO_ADDRESS"");\n        require(_treasury != address(0), ""TREASURY_ZERO_ADDRESS"");\n\n        LIDO = _lido;\n        TREASURY = _treasury;\n    }\n\n    /**\n      * @notice Allows the contract to receive ETH\n      * @dev execution layer rewards may be sent as plain ETH transfers\n      */\n    receive() external payable {\n        emit ETHReceived(msg.value);\n    }\n\n    /**\n      * @notice Withdraw all accumulated rewards to Lido contract\n      * @dev Can be called only by the Lido contract\n      * @param _maxAmount Max amount of ETH to withdraw\n      * @return amount of funds received as execution layer rewards (in wei)\n      */\n    function withdrawRewards(uint256 _maxAmount) external returns (uint256 amount) {\n        require(msg.sender == LIDO, ""ONLY_LIDO_CAN_WITHDRAW"");\n\n        uint256 balance = address(this).balance;\n        amount = (balance > _maxAmount) ? _maxAmount : balance;\n        if (amount > 0) {\n            ILido(LIDO).receiveELRewards{value: amount}();\n        }\n        return amount;\n    }\n\n    /**\n      * Transfers a given `_amount` of an ERC20-token (defined by the `_token` contract address)\n      * currently belonging to the burner contract address to the Lido treasury address.\n      *\n      * @param _token an ERC20-compatible token\n      * @param _amount token amount\n      */\n    function recoverERC20(address _token, uint256 _amount) external {\n        require(_amount > 0, ""ZERO_RECOVERY_AMOUNT"");\n\n        emit ERC20Recovered(msg.sender, _token, _amount);\n\n        IERC20(_token).safeTransfer(TREASURY, _amount);\n    }\n\n    /**\n      * Transfers a given token_id of an ERC721-compatible NFT (defined by the token contract address)\n      * currently belonging to the burner contract address to the Lido treasury address.\n      *\n      * @param _token an ERC721-compatible token\n      * @param _tokenId minted token id\n      */\n    function recoverERC721(address _token, uint256 _tokenId) external {\n        emit ERC721Recovered(msg.sender, _token, _tokenId);\n\n        IERC721(_token).transferFrom(address(this), TREASURY, _tokenId);\n    }\n}\n'}, '@openzeppelin/contracts-v4.4/token/ERC20/IERC20.sol': {'content': ""// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n""}, '@openzeppelin/contracts-v4.4/token/ERC721/IERC721.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport ""../../utils/introspection/IERC165.sol"";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``\'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n'}, '@openzeppelin/contracts-v4.4/token/ERC20/utils/SafeERC20.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport ""../IERC20.sol"";\nimport ""../../../utils/Address.sol"";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            ""SafeERC20: approve from non-zero to non-zero allowance""\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, ""SafeERC20: decreased allowance below zero"");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, ""SafeERC20: low-level call failed"");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), ""SafeERC20: ERC20 operation did not succeed"");\n        }\n    }\n}\n'}, '@openzeppelin/contracts-v4.4/utils/introspection/IERC165.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n'}, '@openzeppelin/contracts-v4.4/utils/Address.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, ""Address: insufficient balance"");\n\n        (bool success, ) = recipient.call{value: amount}("""");\n        require(success, ""Address: unable to send value, recipient may have reverted"");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, ""Address: low-level call failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, ""Address: insufficient balance for call"");\n        require(isContract(target), ""Address: call to non-contract"");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, ""Address: low-level static call failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), ""Address: static call to non-contract"");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, ""Address: low-level delegate call failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), ""Address: delegate call to non-contract"");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n'}}

// File: settings
{'optimizer': {'enabled': True, 'runs': 200}, 'evmVersion': 'istanbul', 'outputSelection': {'*': {'*': ['evm.bytecode', 'evm.deployedBytecode', 'devdoc', 'userdoc', 'metadata', 'abi']}}, 'libraries': {}}",True
0x16d5a408e807db8ef7c578279beeee6b228f1c1c,"// File: language
Solidity

// File: sources
{'@openzeppelin/contracts/token/ERC20/IERC20.sol': {'content': ""// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n""}, '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol': {'content': '// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n'}, '@uniswap/v3-periphery/contracts/interfaces/IQuoter.sol': {'content': '// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Quoter Interface\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\ninterface IQuoter {\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool fee\n    /// @param amountIn The amount of the first token to swap\n    /// @return amountOut The amount of the last token that would be received\n    function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);\n\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\n    /// @param tokenIn The token being swapped in\n    /// @param tokenOut The token being swapped out\n    /// @param fee The fee of the token pool to consider for the pair\n    /// @param amountIn The desired input amount\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountOut The amount of `tokenOut` that would be received\n    function quoteExactInputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountIn,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountOut);\n\n    /// @notice Returns the amount in required for a given exact output swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\n    /// @param amountOut The amount of the last token to receive\n    /// @return amountIn The amount of first token required to be paid\n    function quoteExactOutput(bytes memory path, uint256 amountOut) external returns (uint256 amountIn);\n\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\n    /// @param tokenIn The token being swapped in\n    /// @param tokenOut The token being swapped out\n    /// @param fee The fee of the token pool to consider for the pair\n    /// @param amountOut The desired output amount\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\n    function quoteExactOutputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountOut,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountIn);\n}\n'}, '@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol': {'content': ""// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n""}, '@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol': {'content': ""// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nlibrary TransferHelper {\n    /// @notice Transfers tokens from the targeted address to the given destination\n    /// @notice Errors with 'STF' if transfer fails\n    /// @param token The contract address of the token to be transferred\n    /// @param from The originating address from which the tokens will be transferred\n    /// @param to The destination address of the transfer\n    /// @param value The amount to be transferred\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\n    }\n\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Errors with ST if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev Errors with 'SA' if transfer fails\n    /// @param token The contract address of the token to be approved\n    /// @param to The target of the approval\n    /// @param value The amount of the given token the target will be allowed to spend\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\n    }\n\n    /// @notice Transfers ETH to the recipient address\n    /// @dev Fails with `STE`\n    /// @param to The destination of the transfer\n    /// @param value The value to be transferred\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'STE');\n    }\n}\n""}, 'contracts/interface/IrETH.sol': {'content': ""// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ninterface IrETH is IERC20 {\n    function getTotalCollateral() external view returns (uint256);\n    function burn(uint256 _rethAmount) external;\n    function getEthValue(uint256 _rethAmount) external view returns (uint256);\n    function getRethValue(uint256 _ethAmount) external view returns (uint256);\n}\n""}, 'contracts/interface/RocketDAOProtocolSettingsDepositInterface.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.9;\n\ninterface RocketDAOProtocolSettingsDepositInterface {\n    function getDepositEnabled() external view returns (bool);\n    function getMaximumDepositPoolSize() external view returns (uint256);\n    function getMinimumDeposit() external view returns (uint256);\n}\n'}, 'contracts/interface/RocketDepositPool.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.9;\n\ninterface RocketDepositPoolInterface {\n    function getBalance() external view returns (uint256);\n    function deposit() external payable;\n}\n'}, 'contracts/interface/RocketStorageInterface.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.9;\n\ninterface RocketStorageInterface {\n    function getAddress(bytes32 _key) external view returns (address);\n}'}, 'contracts/lib/@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/IAuthentication.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.9;\n\ninterface IAuthentication {\n    /**\n     * @dev Returns the action identifier associated with the external function described by `selector`.\n     */\n    function getActionId(bytes4 selector) external view returns (bytes32);\n}\n'}, 'contracts/lib/@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/ISignaturesValidator.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.9;\n\n/**\n * @dev Interface for the SignatureValidator helper, used to support meta-transactions.\n */\ninterface ISignaturesValidator {\n    /**\n     * @dev Returns the EIP712 domain separator.\n     */\n    function getDomainSeparator() external view returns (bytes32);\n\n    /**\n     * @dev Returns the next nonce used by an address to sign messages.\n     */\n    function getNextNonce(address user) external view returns (uint256);\n}\n'}, 'contracts/lib/@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/ITemporarilyPausable.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.9;\n\n/**\n * @dev Interface for the TemporarilyPausable helper.\n */\ninterface ITemporarilyPausable {\n    /**\n     * @dev Emitted every time the pause state changes by `_setPaused`.\n     */\n    event PausedStateChanged(bool paused);\n\n    /**\n     * @dev Returns the current paused state.\n     */\n    function getPausedState()\n        external\n        view\n        returns (\n            bool paused,\n            uint256 pauseWindowEndTime,\n            uint256 bufferPeriodEndTime\n        );\n}\n'}, 'contracts/lib/@balancer-labs/v2-interfaces/contracts/solidity-utils/misc/IWETH.sol': {'content': ""// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\n/**\n * @dev Interface for WETH9.\n * See https://github.com/gnosis/canonical-weth/blob/0dd1ea3e295eef916d0c6223ec63141137d22d67/contracts/WETH9.sol\n */\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n\n    function withdraw(uint256 amount) external;\n}\n""}, 'contracts/lib/@balancer-labs/v2-interfaces/contracts/vault/IAsset.sol': {'content': ""// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.9;\n\n/**\n * @dev This is an empty interface used to represent either ERC20-conforming token contracts or ETH (using the zero\n * address sentinel value). We're just relying on the fact that `interface` can be used to declare new address-like\n * types.\n *\n * This concept is unrelated to a Pool's Asset Managers.\n */\ninterface IAsset {\n    // solhint-disable-previous-line no-empty-blocks\n}\n""}, 'contracts/lib/@balancer-labs/v2-interfaces/contracts/vault/IAuthorizer.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.9;\n\ninterface IAuthorizer {\n    /**\n     * @dev Returns true if `account` can perform the action described by `actionId` in the contract `where`.\n     */\n    function canPerform(\n        bytes32 actionId,\n        address account,\n        address where\n    ) external view returns (bool);\n}\n'}, 'contracts/lib/@balancer-labs/v2-interfaces/contracts/vault/IFlashLoanRecipient.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.9;\n\n// Inspired by Aave Protocol\'s IFlashLoanReceiver.\n\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\n\ninterface IFlashLoanRecipient {\n    /**\n     * @dev When `flashLoan` is called on the Vault, it invokes the `receiveFlashLoan` hook on the recipient.\n     *\n     * At the time of the call, the Vault will have transferred `amounts` for `tokens` to the recipient. Before this\n     * call returns, the recipient must have transferred `amounts` plus `feeAmounts` for each token back to the\n     * Vault, or else the entire flash loan will revert.\n     *\n     * `userData` is the same value passed in the `IVault.flashLoan` call.\n     */\n    function receiveFlashLoan(\n        IERC20[] memory tokens,\n        uint256[] memory amounts,\n        uint256[] memory feeAmounts,\n        bytes memory userData\n    ) external;\n}\n'}, 'contracts/lib/@balancer-labs/v2-interfaces/contracts/vault/IProtocolFeesCollector.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.9;\npragma experimental ABIEncoderV2;\n\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\n\nimport ""./IVault.sol"";\nimport ""./IAuthorizer.sol"";\n\ninterface IProtocolFeesCollector {\n    event SwapFeePercentageChanged(uint256 newSwapFeePercentage);\n    event FlashLoanFeePercentageChanged(uint256 newFlashLoanFeePercentage);\n\n    function withdrawCollectedFees(\n        IERC20[] calldata tokens,\n        uint256[] calldata amounts,\n        address recipient\n    ) external;\n\n    function setSwapFeePercentage(uint256 newSwapFeePercentage) external;\n\n    function setFlashLoanFeePercentage(uint256 newFlashLoanFeePercentage) external;\n\n    function getSwapFeePercentage() external view returns (uint256);\n\n    function getFlashLoanFeePercentage() external view returns (uint256);\n\n    function getCollectedFeeAmounts(IERC20[] memory tokens) external view returns (uint256[] memory feeAmounts);\n\n    function getAuthorizer() external view returns (IAuthorizer);\n\n    function vault() external view returns (IVault);\n}\n'}, 'contracts/lib/@balancer-labs/v2-interfaces/contracts/vault/IVault.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma experimental ABIEncoderV2;\n\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport ""../solidity-utils/helpers/IAuthentication.sol"";\nimport ""../solidity-utils/helpers/ISignaturesValidator.sol"";\nimport ""../solidity-utils/helpers/ITemporarilyPausable.sol"";\nimport ""../solidity-utils/misc/IWETH.sol"";\n\nimport ""./IAsset.sol"";\nimport ""./IAuthorizer.sol"";\nimport ""./IFlashLoanRecipient.sol"";\nimport ""./IProtocolFeesCollector.sol"";\n\npragma solidity ^0.8.9;\n\n/**\n * @dev Full external interface for the Vault core contract - no external or public methods exist in the contract that\n * don\'t override one of these declarations.\n */\ninterface IVault is ISignaturesValidator, ITemporarilyPausable, IAuthentication {\n    // Generalities about the Vault:\n    //\n    // - Whenever documentation refers to \'tokens\', it strictly refers to ERC20-compliant token contracts. Tokens are\n    // transferred out of the Vault by calling the `IERC20.transfer` function, and transferred in by calling\n    // `IERC20.transferFrom`. In these cases, the sender must have previously allowed the Vault to use their tokens by\n    // calling `IERC20.approve`. The only deviation from the ERC20 standard that is supported is functions not returning\n    // a boolean value: in these scenarios, a non-reverting call is assumed to be successful.\n    //\n    // - All non-view functions in the Vault are non-reentrant: calling them while another one is mid-execution (e.g.\n    // while execution control is transferred to a token contract during a swap) will result in a revert. View\n    // functions can be called in a re-reentrant way, but doing so might cause them to return inconsistent results.\n    // Contracts calling view functions in the Vault must make sure the Vault has not already been entered.\n    //\n    // - View functions revert if referring to either unregistered Pools, or unregistered tokens for registered Pools.\n\n    // Authorizer\n    //\n    // Some system actions are permissioned, like setting and collecting protocol fees. This permissioning system exists\n    // outside of the Vault in the Authorizer contract: the Vault simply calls the Authorizer to check if the caller\n    // can perform a given action.\n\n    /**\n     * @dev Returns the Vault\'s Authorizer.\n     */\n    function getAuthorizer() external view returns (IAuthorizer);\n\n    /**\n     * @dev Sets a new Authorizer for the Vault. The caller must be allowed by the current Authorizer to do this.\n     *\n     * Emits an `AuthorizerChanged` event.\n     */\n    function setAuthorizer(IAuthorizer newAuthorizer) external;\n\n    /**\n     * @dev Emitted when a new authorizer is set by `setAuthorizer`.\n     */\n    event AuthorizerChanged(IAuthorizer indexed newAuthorizer);\n\n    // Relayers\n    //\n    // Additionally, it is possible for an account to perform certain actions on behalf of another one, using their\n    // Vault ERC20 allowance and Internal Balance. These accounts are said to be \'relayers\' for these Vault functions,\n    // and are expected to be smart contracts with sound authentication mechanisms. For an account to be able to wield\n    // this power, two things must occur:\n    //  - The Authorizer must grant the account the permission to be a relayer for the relevant Vault function. This\n    //    means that Balancer governance must approve each individual contract to act as a relayer for the intended\n    //    functions.\n    //  - Each user must approve the relayer to act on their behalf.\n    // This double protection means users cannot be tricked into approving malicious relayers (because they will not\n    // have been allowed by the Authorizer via governance), nor can malicious relayers approved by a compromised\n    // Authorizer or governance drain user funds, since they would also need to be approved by each individual user.\n\n    /**\n     * @dev Returns true if `user` has approved `relayer` to act as a relayer for them.\n     */\n    function hasApprovedRelayer(address user, address relayer) external view returns (bool);\n\n    /**\n     * @dev Allows `relayer` to act as a relayer for `sender` if `approved` is true, and disallows it otherwise.\n     *\n     * Emits a `RelayerApprovalChanged` event.\n     */\n    function setRelayerApproval(\n        address sender,\n        address relayer,\n        bool approved\n    ) external;\n\n    /**\n     * @dev Emitted every time a relayer is approved or disapproved by `setRelayerApproval`.\n     */\n    event RelayerApprovalChanged(address indexed relayer, address indexed sender, bool approved);\n\n    // Internal Balance\n    //\n    // Users can deposit tokens into the Vault, where they are allocated to their Internal Balance, and later\n    // transferred or withdrawn. It can also be used as a source of tokens when joining Pools, as a destination\n    // when exiting them, and as either when performing swaps. This usage of Internal Balance results in greatly reduced\n    // gas costs when compared to relying on plain ERC20 transfers, leading to large savings for frequent users.\n    //\n    // Internal Balance management features batching, which means a single contract call can be used to perform multiple\n    // operations of different kinds, with different senders and recipients, at once.\n\n    /**\n     * @dev Returns `user`\'s Internal Balance for a set of tokens.\n     */\n    function getInternalBalance(address user, IERC20[] memory tokens) external view returns (uint256[] memory);\n\n    /**\n     * @dev Performs a set of user balance operations, which involve Internal Balance (deposit, withdraw or transfer)\n     * and plain ERC20 transfers using the Vault\'s allowance. This last feature is particularly useful for relayers, as\n     * it lets integrators reuse a user\'s Vault allowance.\n     *\n     * For each operation, if the caller is not `sender`, it must be an authorized relayer for them.\n     */\n    function manageUserBalance(UserBalanceOp[] memory ops) external payable;\n\n    /**\n     * @dev Data for `manageUserBalance` operations, which include the possibility for ETH to be sent and received\n     without manual WETH wrapping or unwrapping.\n     */\n    struct UserBalanceOp {\n        UserBalanceOpKind kind;\n        IAsset asset;\n        uint256 amount;\n        address sender;\n        address payable recipient;\n    }\n\n    // There are four possible operations in `manageUserBalance`:\n    //\n    // - DEPOSIT_INTERNAL\n    // Increases the Internal Balance of the `recipient` account by transferring tokens from the corresponding\n    // `sender`. The sender must have allowed the Vault to use their tokens via `IERC20.approve()`.\n    //\n    // ETH can be used by passing the ETH sentinel value as the asset and forwarding ETH in the call: it will be wrapped\n    // and deposited as WETH. Any ETH amount remaining will be sent back to the caller (not the sender, which is\n    // relevant for relayers).\n    //\n    // Emits an `InternalBalanceChanged` event.\n    //\n    //\n    // - WITHDRAW_INTERNAL\n    // Decreases the Internal Balance of the `sender` account by transferring tokens to the `recipient`.\n    //\n    // ETH can be used by passing the ETH sentinel value as the asset. This will deduct WETH instead, unwrap it and send\n    // it to the recipient as ETH.\n    //\n    // Emits an `InternalBalanceChanged` event.\n    //\n    //\n    // - TRANSFER_INTERNAL\n    // Transfers tokens from the Internal Balance of the `sender` account to the Internal Balance of `recipient`.\n    //\n    // Reverts if the ETH sentinel value is passed.\n    //\n    // Emits an `InternalBalanceChanged` event.\n    //\n    //\n    // - TRANSFER_EXTERNAL\n    // Transfers tokens from `sender` to `recipient`, using the Vault\'s ERC20 allowance. This is typically used by\n    // relayers, as it lets them reuse a user\'s Vault allowance.\n    //\n    // Reverts if the ETH sentinel value is passed.\n    //\n    // Emits an `ExternalBalanceTransfer` event.\n\n    enum UserBalanceOpKind { DEPOSIT_INTERNAL, WITHDRAW_INTERNAL, TRANSFER_INTERNAL, TRANSFER_EXTERNAL }\n\n    /**\n     * @dev Emitted when a user\'s Internal Balance changes, either from calls to `manageUserBalance`, or through\n     * interacting with Pools using Internal Balance.\n     *\n     * Because Internal Balance works exclusively with ERC20 tokens, ETH deposits and withdrawals will use the WETH\n     * address.\n     */\n    event InternalBalanceChanged(address indexed user, IERC20 indexed token, int256 delta);\n\n    /**\n     * @dev Emitted when a user\'s Vault ERC20 allowance is used by the Vault to transfer tokens to an external account.\n     */\n    event ExternalBalanceTransfer(IERC20 indexed token, address indexed sender, address recipient, uint256 amount);\n\n    // Pools\n    //\n    // There are three specialization settings for Pools, which allow for cheaper swaps at the cost of reduced\n    // functionality:\n    //\n    //  - General: no specialization, suited for all Pools. IGeneralPool is used for swap request callbacks, passing the\n    // balance of all tokens in the Pool. These Pools have the largest swap costs (because of the extra storage reads),\n    // which increase with the number of registered tokens.\n    //\n    //  - Minimal Swap Info: IMinimalSwapInfoPool is used instead of IGeneralPool, which saves gas by only passing the\n    // balance of the two tokens involved in the swap. This is suitable for some pricing algorithms, like the weighted\n    // constant product one popularized by Balancer V1. Swap costs are smaller compared to general Pools, and are\n    // independent of the number of registered tokens.\n    //\n    //  - Two Token: only allows two tokens to be registered. This achieves the lowest possible swap gas cost. Like\n    // minimal swap info Pools, these are called via IMinimalSwapInfoPool.\n\n    enum PoolSpecialization { GENERAL, MINIMAL_SWAP_INFO, TWO_TOKEN }\n\n    /**\n     * @dev Registers the caller account as a Pool with a given specialization setting. Returns the Pool\'s ID, which\n     * is used in all Pool-related functions. Pools cannot be deregistered, nor can the Pool\'s specialization be\n     * changed.\n     *\n     * The caller is expected to be a smart contract that implements either `IGeneralPool` or `IMinimalSwapInfoPool`,\n     * depending on the chosen specialization setting. This contract is known as the Pool\'s contract.\n     *\n     * Note that the same contract may register itself as multiple Pools with unique Pool IDs, or in other words,\n     * multiple Pools may share the same contract.\n     *\n     * Emits a `PoolRegistered` event.\n     */\n    function registerPool(PoolSpecialization specialization) external returns (bytes32);\n\n    /**\n     * @dev Emitted when a Pool is registered by calling `registerPool`.\n     */\n    event PoolRegistered(bytes32 indexed poolId, address indexed poolAddress, PoolSpecialization specialization);\n\n    /**\n     * @dev Returns a Pool\'s contract address and specialization setting.\n     */\n    function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\n\n    /**\n     * @dev Registers `tokens` for the `poolId` Pool. Must be called by the Pool\'s contract.\n     *\n     * Pools can only interact with tokens they have registered. Users join a Pool by transferring registered tokens,\n     * exit by receiving registered tokens, and can only swap registered tokens.\n     *\n     * Each token can only be registered once. For Pools with the Two Token specialization, `tokens` must have a length\n     * of two, that is, both tokens must be registered in the same `registerTokens` call, and they must be sorted in\n     * ascending order.\n     *\n     * The `tokens` and `assetManagers` arrays must have the same length, and each entry in these indicates the Asset\n     * Manager for the corresponding token. Asset Managers can manage a Pool\'s tokens via `managePoolBalance`,\n     * depositing and withdrawing them directly, and can even set their balance to arbitrary amounts. They are therefore\n     * expected to be highly secured smart contracts with sound design principles, and the decision to register an\n     * Asset Manager should not be made lightly.\n     *\n     * Pools can choose not to assign an Asset Manager to a given token by passing in the zero address. Once an Asset\n     * Manager is set, it cannot be changed except by deregistering the associated token and registering again with a\n     * different Asset Manager.\n     *\n     * Emits a `TokensRegistered` event.\n     */\n    function registerTokens(\n        bytes32 poolId,\n        IERC20[] memory tokens,\n        address[] memory assetManagers\n    ) external;\n\n    /**\n     * @dev Emitted when a Pool registers tokens by calling `registerTokens`.\n     */\n    event TokensRegistered(bytes32 indexed poolId, IERC20[] tokens, address[] assetManagers);\n\n    /**\n     * @dev Deregisters `tokens` for the `poolId` Pool. Must be called by the Pool\'s contract.\n     *\n     * Only registered tokens (via `registerTokens`) can be deregistered. Additionally, they must have zero total\n     * balance. For Pools with the Two Token specialization, `tokens` must have a length of two, that is, both tokens\n     * must be deregistered in the same `deregisterTokens` call.\n     *\n     * A deregistered token can be re-registered later on, possibly with a different Asset Manager.\n     *\n     * Emits a `TokensDeregistered` event.\n     */\n    function deregisterTokens(bytes32 poolId, IERC20[] memory tokens) external;\n\n    /**\n     * @dev Emitted when a Pool deregisters tokens by calling `deregisterTokens`.\n     */\n    event TokensDeregistered(bytes32 indexed poolId, IERC20[] tokens);\n\n    /**\n     * @dev Returns detailed information for a Pool\'s registered token.\n     *\n     * `cash` is the number of tokens the Vault currently holds for the Pool. `managed` is the number of tokens\n     * withdrawn and held outside the Vault by the Pool\'s token Asset Manager. The Pool\'s total balance for `token`\n     * equals the sum of `cash` and `managed`.\n     *\n     * Internally, `cash` and `managed` are stored using 112 bits. No action can ever cause a Pool\'s token `cash`,\n     * `managed` or `total` balance to be greater than 2^112 - 1.\n     *\n     * `lastChangeBlock` is the number of the block in which `token`\'s total balance was last modified (via either a\n     * join, exit, swap, or Asset Manager update). This value is useful to avoid so-called \'sandwich attacks\', for\n     * example when developing price oracles. A change of zero (e.g. caused by a swap with amount zero) is considered a\n     * change for this purpose, and will update `lastChangeBlock`.\n     *\n     * `assetManager` is the Pool\'s token Asset Manager.\n     */\n    function getPoolTokenInfo(bytes32 poolId, IERC20 token)\n        external\n        view\n        returns (\n            uint256 cash,\n            uint256 managed,\n            uint256 lastChangeBlock,\n            address assetManager\n        );\n\n    /**\n     * @dev Returns a Pool\'s registered tokens, the total balance for each, and the latest block when *any* of\n     * the tokens\' `balances` changed.\n     *\n     * The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all\n     * Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order.\n     *\n     * If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same\n     * order as passed to `registerTokens`.\n     *\n     * Total balances include both tokens held by the Vault and those withdrawn by the Pool\'s Asset Managers. These are\n     * the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo`\n     * instead.\n     */\n    function getPoolTokens(bytes32 poolId)\n        external\n        view\n        returns (\n            IERC20[] memory tokens,\n            uint256[] memory balances,\n            uint256 lastChangeBlock\n        );\n\n    /**\n     * @dev Called by users to join a Pool, which transfers tokens from `sender` into the Pool\'s balance. This will\n     * trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized\n     * Pool shares.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount\n     * to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces\n     * these maximums.\n     *\n     * If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable\n     * this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the\n     * WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent\n     * back to the caller (not the sender, which is important for relayers).\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be\n     * sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final\n     * `assets` array might not be sorted. Pools with no registered tokens cannot be joined.\n     *\n     * If `fromInternalBalance` is true, the caller\'s Internal Balance will be preferred: ERC20 transfers will only\n     * be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be\n     * withdrawn from Internal Balance: attempting to do so will trigger a revert.\n     *\n     * This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool\'s contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed\n     * directly to the Pool\'s contract, as is `recipient`.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     */\n    function joinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        JoinPoolRequest memory request\n    ) external payable;\n\n    struct JoinPoolRequest {\n        IAsset[] assets;\n        uint256[] maxAmountsIn;\n        bytes userData;\n        bool fromInternalBalance;\n    }\n\n    /**\n     * @dev Called by users to exit a Pool, which transfers tokens from the Pool\'s balance to `recipient`. This will\n     * trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized\n     * Pool shares. The amount of tokens that can be withdrawn is limited by the Pool\'s `cash` balance (see\n     * `getPoolTokenInfo`).\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum\n     * token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault:\n     * it just enforces these minimums.\n     *\n     * If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To\n     * enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead\n     * of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit.\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must\n     * be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the\n     * final `assets` array might not be sorted. Pools with no registered tokens cannot be exited.\n     *\n     * If `toInternalBalance` is true, the tokens will be deposited to `recipient`\'s Internal Balance. Otherwise,\n     * an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to\n     * do so will trigger a revert.\n     *\n     * `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the\n     * `tokens` array. This array must match the Pool\'s registered tokens.\n     *\n     * This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool\'s contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and\n     * passed directly to the Pool\'s contract.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     */\n    function exitPool(\n        bytes32 poolId,\n        address sender,\n        address payable recipient,\n        ExitPoolRequest memory request\n    ) external;\n\n    struct ExitPoolRequest {\n        IAsset[] assets;\n        uint256[] minAmountsOut;\n        bytes userData;\n        bool toInternalBalance;\n    }\n\n    /**\n     * @dev Emitted when a user joins or exits a Pool by calling `joinPool` or `exitPool`, respectively.\n     */\n    event PoolBalanceChanged(\n        bytes32 indexed poolId,\n        address indexed liquidityProvider,\n        IERC20[] tokens,\n        int256[] deltas,\n        uint256[] protocolFeeAmounts\n    );\n\n    enum PoolBalanceChangeKind { JOIN, EXIT }\n\n    // Swaps\n    //\n    // Users can swap tokens with Pools by calling the `swap` and `batchSwap` functions. To do this,\n    // they need not trust Pool contracts in any way: all security checks are made by the Vault. They must however be\n    // aware of the Pools\' pricing algorithms in order to estimate the prices Pools will quote.\n    //\n    // The `swap` function executes a single swap, while `batchSwap` can perform multiple swaps in sequence.\n    // In each individual swap, tokens of one kind are sent from the sender to the Pool (this is the \'token in\'),\n    // and tokens of another kind are sent from the Pool to the recipient in exchange (this is the \'token out\').\n    // More complex swaps, such as one token in to multiple tokens out can be achieved by batching together\n    // individual swaps.\n    //\n    // There are two swap kinds:\n    //  - \'given in\' swaps, where the amount of tokens in (sent to the Pool) is known, and the Pool determines (via the\n    // `onSwap` hook) the amount of tokens out (to send to the recipient).\n    //  - \'given out\' swaps, where the amount of tokens out (received from the Pool) is known, and the Pool determines\n    // (via the `onSwap` hook) the amount of tokens in (to receive from the sender).\n    //\n    // Additionally, it is possible to chain swaps using a placeholder input amount, which the Vault replaces with\n    // the calculated output of the previous swap. If the previous swap was \'given in\', this will be the calculated\n    // tokenOut amount. If the previous swap was \'given out\', it will use the calculated tokenIn amount. These extended\n    // swaps are known as \'multihop\' swaps, since they \'hop\' through a number of intermediate tokens before arriving at\n    // the final intended token.\n    //\n    // In all cases, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into Internal\n    // Balance) after all individual swaps have been completed, and the net token balance change computed. This makes\n    // certain swap patterns, such as multihops, or swaps that interact with the same token pair in multiple Pools, cost\n    // much less gas than they would otherwise.\n    //\n    // It also means that under certain conditions it is possible to perform arbitrage by swapping with multiple\n    // Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (only\n    // updating the Pool\'s internal accounting).\n    //\n    // To protect users from front-running or the market changing rapidly, they supply a list of \'limits\' for each token\n    // involved in the swap, where either the maximum number of tokens to send (by passing a positive value) or the\n    // minimum amount of tokens to receive (by passing a negative value) is specified.\n    //\n    // Additionally, a \'deadline\' timestamp can also be provided, forcing the swap to fail if it occurs after\n    // this point in time (e.g. if the transaction failed to be included in a block promptly).\n    //\n    // If interacting with Pools that hold WETH, it is possible to both send and receive ETH directly: the Vault will do\n    // the wrapping and unwrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be\n    // passed in the `assets` array instead of the WETH address. Note that it is possible to combine ETH and WETH in the\n    // same swap. Any excess ETH will be sent back to the caller (not the sender, which is relevant for relayers).\n    //\n    // Finally, Internal Balance can be used when either sending or receiving tokens.\n\n    enum SwapKind { GIVEN_IN, GIVEN_OUT }\n\n    /**\n     * @dev Performs a swap with a single Pool.\n     *\n     * If the swap is \'given in\' (the number of tokens to send to the Pool is known), it returns the amount of tokens\n     * taken from the Pool, which must be greater than or equal to `limit`.\n     *\n     * If the swap is \'given out\' (the number of tokens to take from the Pool is known), it returns the amount of tokens\n     * sent to the Pool, which must be less than or equal to `limit`.\n     *\n     * Internal Balance usage and the recipient are determined by the `funds` struct.\n     *\n     * Emits a `Swap` event.\n     */\n    function swap(\n        SingleSwap memory singleSwap,\n        FundManagement memory funds,\n        uint256 limit,\n        uint256 deadline\n    ) external payable returns (uint256);\n\n    /**\n     * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\n     * the `kind` value.\n     *\n     * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\n     * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n    struct SingleSwap {\n        bytes32 poolId;\n        SwapKind kind;\n        IAsset assetIn;\n        IAsset assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n\n    /**\n     * @dev Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either\n     * the amount of tokens sent to or received from the Pool, depending on the `kind` value.\n     *\n     * Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the\n     * Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at\n     * the same index in the `assets` array.\n     *\n     * Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a\n     * Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or\n     * `amountOut` depending on the swap kind.\n     *\n     * Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out\n     * of the previous swap to be used as the amount in for the current one. In a \'given in\' swap, \'tokenIn\' must equal\n     * the previous swap\'s `tokenOut`. For a \'given out\' swap, `tokenOut` must equal the previous swap\'s `tokenIn`.\n     *\n     * The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses,\n     * or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and\n     * out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to\n     * or unwrapped from WETH by the Vault.\n     *\n     * Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies\n     * the minimum or maximum amount of each token the vault is allowed to transfer.\n     *\n     * `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the\n     * equivalent `swap` call.\n     *\n     * Emits `Swap` events.\n     */\n    function batchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory funds,\n        int256[] memory limits,\n        uint256 deadline\n    ) external payable returns (int256[] memory);\n\n    /**\n     * @dev Data for each individual swap executed by `batchSwap`. The asset in and out fields are indexes into the\n     * `assets` array passed to that function, and ETH assets are converted to WETH.\n     *\n     * If `amount` is zero, the multihop mechanism is used to determine the actual amount based on the amount in/out\n     * from the previous swap, depending on the swap kind.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n    struct BatchSwapStep {\n        bytes32 poolId;\n        uint256 assetInIndex;\n        uint256 assetOutIndex;\n        uint256 amount;\n        bytes userData;\n    }\n\n    /**\n     * @dev Emitted for each individual swap performed by `swap` or `batchSwap`.\n     */\n    event Swap(\n        bytes32 indexed poolId,\n        IERC20 indexed tokenIn,\n        IERC20 indexed tokenOut,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n\n    /**\n     * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\n     * `recipient` account.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * If `fromInternalBalance` is true, the `sender`\'s Internal Balance will be preferred, performing an ERC20\n     * transfer for the difference between the requested amount and the User\'s Internal Balance (if any). The `sender`\n     * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\n     * `joinPool`.\n     *\n     * If `toInternalBalance` is true, tokens will be deposited to `recipient`\'s internal balance instead of\n     * transferred. This matches the behavior of `exitPool`.\n     *\n     * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\n     * revert.\n     */\n    struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address payable recipient;\n        bool toInternalBalance;\n    }\n\n    /**\n     * @dev Simulates a call to `batchSwap`, returning an array of Vault asset deltas. Calls to `swap` cannot be\n     * simulated directly, but an equivalent `batchSwap` call can and will yield the exact same result.\n     *\n     * Each element in the array corresponds to the asset at the same index, and indicates the number of tokens (or ETH)\n     * the Vault would take from the sender (if positive) or send to the recipient (if negative). The arguments it\n     * receives are the same that an equivalent `batchSwap` call would receive.\n     *\n     * Unlike `batchSwap`, this function performs no checks on the sender or recipient field in the `funds` struct.\n     * This makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens,\n     * approve them for the Vault, or even know a user\'s address.\n     *\n     * Note that this function is not \'view\' (due to implementation details): the client code must explicitly execute\n     * eth_call instead of eth_sendTransaction.\n     */\n    function queryBatchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory funds\n    ) external returns (int256[] memory assetDeltas);\n\n    // Flash Loans\n\n    /**\n     * @dev Performs a \'flash loan\', sending tokens to `recipient`, executing the `receiveFlashLoan` hook on it,\n     * and then reverting unless the tokens plus a proportional protocol fee have been returned.\n     *\n     * The `tokens` and `amounts` arrays must have the same length, and each entry in these indicates the loan amount\n     * for each token contract. `tokens` must be sorted in ascending order.\n     *\n     * The \'userData\' field is ignored by the Vault, and forwarded as-is to `recipient` as part of the\n     * `receiveFlashLoan` call.\n     *\n     * Emits `FlashLoan` events.\n     */\n    function flashLoan(\n        IFlashLoanRecipient recipient,\n        IERC20[] memory tokens,\n        uint256[] memory amounts,\n        bytes memory userData\n    ) external;\n\n    /**\n     * @dev Emitted for each individual flash loan performed by `flashLoan`.\n     */\n    event FlashLoan(IFlashLoanRecipient indexed recipient, IERC20 indexed token, uint256 amount, uint256 feeAmount);\n\n    // Asset Management\n    //\n    // Each token registered for a Pool can be assigned an Asset Manager, which is able to freely withdraw the Pool\'s\n    // tokens from the Vault, deposit them, or assign arbitrary values to its `managed` balance (see\n    // `getPoolTokenInfo`). This makes them extremely powerful and dangerous. Even if an Asset Manager only directly\n    // controls one of the tokens in a Pool, a malicious manager could set that token\'s balance to manipulate the\n    // prices of the other tokens, and then drain the Pool with swaps. The risk of using Asset Managers is therefore\n    // not constrained to the tokens they are managing, but extends to the entire Pool\'s holdings.\n    //\n    // However, a properly designed Asset Manager smart contract can be safely used for the Pool\'s benefit,\n    // for example by lending unused tokens out for interest, or using them to participate in voting protocols.\n    //\n    // This concept is unrelated to the IAsset interface.\n\n    /**\n     * @dev Performs a set of Pool balance operations, which may be either withdrawals, deposits or updates.\n     *\n     * Pool Balance management features batching, which means a single contract call can be used to perform multiple\n     * operations of different kinds, with different Pools and tokens, at once.\n     *\n     * For each operation, the caller must be registered as the Asset Manager for `token` in `poolId`.\n     */\n    function managePoolBalance(PoolBalanceOp[] memory ops) external;\n\n    struct PoolBalanceOp {\n        PoolBalanceOpKind kind;\n        bytes32 poolId;\n        IERC20 token;\n        uint256 amount;\n    }\n\n    /**\n     * Withdrawals decrease the Pool\'s cash, but increase its managed balance, leaving the total balance unchanged.\n     *\n     * Deposits increase the Pool\'s cash, but decrease its managed balance, leaving the total balance unchanged.\n     *\n     * Updates don\'t affect the Pool\'s cash balance, but because the managed balance changes, it does alter the total.\n     * The external amount can be either increased or decreased by this call (i.e., reporting a gain or a loss).\n     */\n    enum PoolBalanceOpKind { WITHDRAW, DEPOSIT, UPDATE }\n\n    /**\n     * @dev Emitted when a Pool\'s token Asset Manager alters its balance via `managePoolBalance`.\n     */\n    event PoolBalanceManaged(\n        bytes32 indexed poolId,\n        address indexed assetManager,\n        IERC20 indexed token,\n        int256 cashDelta,\n        int256 managedDelta\n    );\n\n    // Protocol Fees\n    //\n    // Some operations cause the Vault to collect tokens in the form of protocol fees, which can then be withdrawn by\n    // permissioned accounts.\n    //\n    // There are two kinds of protocol fees:\n    //\n    //  - flash loan fees: charged on all flash loans, as a percentage of the amounts lent.\n    //\n    //  - swap fees: a percentage of the fees charged by Pools when performing swaps. For a number of reasons, including\n    // swap gas costs and interface simplicity, protocol swap fees are not charged on each individual swap. Rather,\n    // Pools are expected to keep track of how much they have charged in swap fees, and pay any outstanding debts to the\n    // Vault when they are joined or exited. This prevents users from joining a Pool with unpaid debt, as well as\n    // exiting a Pool in debt without first paying their share.\n\n    /**\n     * @dev Returns the current protocol fee module.\n     */\n    function getProtocolFeesCollector() external view returns (IProtocolFeesCollector);\n\n    /**\n     * @dev Safety mechanism to pause most Vault operations in the event of an emergency - typically detection of an\n     * error in some part of the system.\n     *\n     * The Vault can only be paused during an initial time period, after which pausing is forever disabled.\n     *\n     * While the contract is paused, the following features are disabled:\n     * - depositing and transferring internal balance\n     * - transferring external balance (using the Vault\'s allowance)\n     * - swaps\n     * - joining Pools\n     * - Asset Manager interactions\n     *\n     * Internal Balance can still be withdrawn, and Pools exited.\n     */\n    function setPaused(bool paused) external;\n\n    /**\n     * @dev Returns the Vault\'s WETH instance.\n     */\n    function WETH() external view returns (IWETH);\n    // solhint-disable-previous-line func-name-mixedcase\n}\n'}, 'contracts/RocketSwapRouter.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.9;\n\nimport \'@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\';\nimport \'@uniswap/v3-periphery/contracts/interfaces/IQuoter.sol\';\nimport \'@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\';\n\nimport ""./lib/@balancer-labs/v2-interfaces/contracts/vault/IVault.sol"";\nimport ""./lib/@balancer-labs/v2-interfaces/contracts/solidity-utils/misc/IWETH.sol"";\n\nimport ""./interface/RocketStorageInterface.sol"";\nimport ""./interface/RocketDepositPool.sol"";\nimport ""./interface/RocketDAOProtocolSettingsDepositInterface.sol"";\nimport ""./interface/IrETH.sol"";\n\n/// @notice Routes swaps through Uniswap and Balancer liquidity sources\ncontract RocketSwapRouter {\n    // Rocket Pool immutables\n    RocketStorageInterface immutable rocketStorage;\n\n    // Uniswap immutables\n    ISwapRouter public immutable uniswapRouter;\n    IQuoter public immutable uniswapQuoter;\n    uint24 immutable uniswapPoolFee;\n\n    // Balance immutables\n    IVault public immutable balancerVault;\n    bytes32 public immutable balancerPoolId;\n\n    // Token addresses\n    IrETH public immutable rETH;\n    IWETH public immutable WETH;\n\n    // Errors\n    error LessThanMinimum(uint256 amountOut);\n    error TransferFailed();\n\n    /// @param _rocketStorage Address of Rocket Pool\'s main RocketStorage contract\n    /// @param _wethAddress Address of WETH token\n    /// @param _uniswapRouter Address of UniswapV2Router02\n    /// @param _uniswapPoolFee The fee to identify which Uniswap pool to use\n    /// @param _balancerVault Address of Balancer\'s vault contract\n    /// @param _balancerPoolId ID of the liquidity pool on balancer to use\n    constructor(address _rocketStorage, address _wethAddress, address _uniswapRouter, uint24 _uniswapPoolFee, address _uniswapQuoter, address _balancerVault, bytes32 _balancerPoolId) {\n        rocketStorage = RocketStorageInterface(_rocketStorage);\n        rETH = IrETH(rocketStorage.getAddress(keccak256(abi.encodePacked(""contract.address"", ""rocketTokenRETH""))));\n        WETH = IWETH(_wethAddress);\n\n        uniswapRouter = ISwapRouter(_uniswapRouter);\n        uniswapQuoter = IQuoter(_uniswapQuoter);\n        uniswapPoolFee = _uniswapPoolFee;\n\n        balancerVault = IVault(_balancerVault);\n        balancerPoolId = _balancerPoolId;\n    }\n\n    receive() external payable {}\n\n    /// @notice Executes a swap of ETH to rETH\n    /// @param _uniswapPortion The portion to swap via Uniswap\n    /// @param _balancerPortion The portion to swap via Balancer\n    /// @param _minTokensOut Swap will revert if at least this amount of rETH is not output\n    /// @param _idealTokensOut If the protocol can provide a better swap than this, it will swap as much as possible that way\n    function swapTo(uint256 _uniswapPortion, uint256 _balancerPortion, uint256 _minTokensOut, uint256 _idealTokensOut) external payable {\n        // Get addresses from Rocket Pool\n        RocketDepositPoolInterface depositPool = RocketDepositPoolInterface(rocketStorage.getAddress(keccak256(abi.encodePacked(""contract.address"", ""rocketDepositPool""))));\n        RocketDAOProtocolSettingsDepositInterface depositSettings = RocketDAOProtocolSettingsDepositInterface(rocketStorage.getAddress(keccak256(abi.encodePacked(""contract.address"", ""rocketDAOProtocolSettingsDeposit""))));\n\n        // Record balance before the swap\n        uint256 balanceBefore = rETH.balanceOf(msg.sender);\n\n        uint256 toExchange = msg.value;\n        uint256 toDepositPool = 0;\n\n        // Check in-protocol mint rate\n        if (rETH.getRethValue(msg.value) >= _idealTokensOut) {\n            // Query deposit pool settings\n            bool depositPoolEnabled = depositSettings.getDepositEnabled();\n\n            // If deposits are enabled, work out how much space there is and subtract that from amount swapping on exchanges\n            if (depositPoolEnabled) {\n                uint256 depositPoolBalance = depositPool.getBalance();\n                uint256 maxDepositBalance = depositSettings.getMaximumDepositPoolSize();\n\n                if (depositPoolBalance < maxDepositBalance) {\n                    uint256 minDeposit = depositSettings.getMinimumDeposit();\n\n                    toDepositPool = maxDepositBalance - depositPoolBalance;\n                    if (toDepositPool > msg.value) {\n                        toDepositPool = msg.value;\n                    }\n\n                    // Check deposit pool minimum deposit amount\n                    if (toDepositPool < minDeposit) {\n                        toDepositPool = 0;\n                    } else {\n                        toExchange = toExchange - toDepositPool;\n                    }\n                }\n            }\n        }\n\n        // Calculate splits\n        uint256 totalPortions = _uniswapPortion + _balancerPortion;\n        uint256 toUniswap = toExchange * _uniswapPortion / totalPortions;\n        uint256 toBalancer = toExchange - toUniswap;\n\n        // Convert toExchange ETH to WETH\n        WETH.deposit{value : toExchange}();\n\n        // Execute swaps\n        uniswapSwap(toUniswap, address(WETH), address(rETH), msg.sender);\n        balancerSwap(toBalancer, address(WETH), address(rETH), payable(msg.sender));\n        depositPoolDeposit(depositPool, toDepositPool, msg.sender);\n\n        // Verify minimum out\n        uint256 balanceAfter = rETH.balanceOf(msg.sender);\n        uint256 amountOut = balanceAfter - balanceBefore;\n        if (amountOut < _minTokensOut) {\n            revert LessThanMinimum(amountOut);\n        }\n    }\n\n    /// @notice Executes a swap of rETH to ETH. User should approve this contract to spend their rETH before calling.\n    /// @param _uniswapPortion The portion to swap via Uniswap\n    /// @param _balancerPortion The portion to swap via Balancer\n    /// @param _minTokensOut Swap will revert if at least this amount of ETH is not output\n    /// @param _idealTokensOut If the protocol can provide a better swap than this, it will swap as much as possible that way\n    function swapFrom(uint256 _uniswapPortion, uint256 _balancerPortion, uint256 _minTokensOut, uint256 _idealTokensOut, uint256 _tokensIn) external {\n        // Record balance before the swap\n        uint256 balanceBefore = msg.sender.balance;\n\n        uint256 toExchange = _tokensIn;\n        uint256 toBurn = 0;\n\n        // Check in-protocol burn rate\n        if (rETH.getEthValue(_tokensIn) >= _idealTokensOut) {\n            uint256 totalCollateral = rETH.getTotalCollateral();\n            if (totalCollateral > 0) {\n                if (_tokensIn > totalCollateral) {\n                    toBurn = totalCollateral;\n                    toExchange = _tokensIn - toBurn;\n                } else {\n                    toBurn = _tokensIn;\n                    toExchange = 0;\n                }\n            }\n        }\n\n        // Calculate splits\n        uint256 totalPortions = _uniswapPortion + _balancerPortion;\n        uint256 toUniswap = toExchange * _uniswapPortion / totalPortions;\n        uint256 toBalancer = toExchange - toUniswap;\n\n        // Collect tokens\n        rETH.transferFrom(msg.sender, address(this), _tokensIn);\n\n        // Execute swaps\n        uniswapSwap(toUniswap, address(rETH), address(WETH), address(this));\n        balancerSwap(toBalancer, address(rETH), address(WETH), payable(this));\n        rethBurn(toBurn);\n\n        // Convert WETH back to ETH\n        WETH.withdraw(WETH.balanceOf(address(this)));\n        (bool result,) = msg.sender.call{value : address(this).balance}("""");\n        if (!result) {\n            revert TransferFailed();\n        }\n\n        // Verify minimum out\n        uint256 balanceAfter = msg.sender.balance;\n        uint256 amountOut = balanceAfter - balanceBefore;\n        if (amountOut < _minTokensOut) {\n            revert LessThanMinimum(amountOut);\n        }\n    }\n\n    /// @dev Perform a swap via Rocket Pool deposit pool\n    /// @param _depositPool Instance of the deposit pool\n    /// @param _amount Amount of ETH to deposit\n    /// @param _recipient Recipient of the minted rETH tokens\n    function depositPoolDeposit(RocketDepositPoolInterface _depositPool, uint256 _amount, address _recipient) private {\n        if (_amount == 0) {\n            return;\n        }\n\n        _depositPool.deposit{value : _amount}();\n\n        if (_recipient != address(this)) {\n            uint256 rETHBalance = rETH.balanceOf(address(this));\n            rETH.transfer(_recipient, rETHBalance);\n        }\n    }\n\n    /// @dev Perform a burn of rETH via Rocket Pool\n    /// @param _amount Amount of rETH to burn\n    function rethBurn(uint256 _amount) private {\n        if (_amount == 0) {\n            return;\n        }\n\n        rETH.burn(_amount);\n    }\n\n    /// @dev Perform a swap via Uniswap\n    /// @param _amount Amount of ETH to swap\n    /// @param _from The token input\n    /// @param _to The token output\n    /// @param _recipient The recipient of the output tokens\n    function uniswapSwap(uint256 _amount, address _from, address _to, address _recipient) private {\n        if (_amount == 0) {\n            return;\n        }\n\n        // Perform swap (don\'t care about amountOutMinimum here as we check overall slippage at end)\n        ISwapRouter.ExactInputSingleParams memory params =\n        ISwapRouter.ExactInputSingleParams({\n            tokenIn : _from,\n            tokenOut : _to,\n            fee : uniswapPoolFee,\n            recipient : _recipient,\n            deadline : block.timestamp,\n            amountIn : _amount,\n            amountOutMinimum : 0,\n            sqrtPriceLimitX96 : 0\n        });\n\n        // Approve the router to spend our WETH\n        TransferHelper.safeApprove(_from, address(uniswapRouter), _amount);\n\n        // The call to `exactInputSingle` executes the swap.\n        uniswapRouter.exactInputSingle(params);\n    }\n\n    /// @dev Perform a swap via Balancer\n    /// @param _amount Amount of ETH to swap\n    /// @param _from The token input\n    /// @param _to The token output\n    /// @param _recipient The recipient of the output tokens\n    function balancerSwap(uint256 _amount, address _from, address _to, address payable _recipient) private {\n        if (_amount == 0) {\n            return;\n        }\n\n        IVault.SingleSwap memory swap;\n        swap.poolId = balancerPoolId;\n        swap.kind = IVault.SwapKind.GIVEN_IN;\n        swap.assetIn = IAsset(_from);\n        swap.assetOut = IAsset(_to);\n        swap.amount = _amount;\n\n        IVault.FundManagement memory fundManagement;\n        fundManagement.sender = address(this);\n        fundManagement.recipient = _recipient;\n        fundManagement.fromInternalBalance = false;\n        fundManagement.toInternalBalance = false;\n\n        // Approve the vault to spend our WETH\n        TransferHelper.safeApprove(_from, address(balancerVault), _amount);\n\n        // Execute swap\n        balancerVault.swap(swap, fundManagement, 0, block.timestamp);\n    }\n\n    /// @notice Calculates optimal values for a swap from ETH to rETH. Very gas inefficient. Should be called offline\n    /// via `eth_call` and should not be used on-chain\n    /// @param _amount The amount of ETH to swap\n    /// @param _steps The more number of steps used the more optimal the swap will be (10 is a reasonable number for most swaps)\n    function optimiseSwapTo(uint256 _amount, uint256 _steps) external returns (uint256[2] memory portions, uint256 amountOut) {\n        return optimiseSwap(address(WETH), address(rETH), _amount, _steps);\n    }\n\n    /// @notice Calculates optimal values for a swap from rETH to ETH. Very gas inefficient. Should be called offline\n    /// via `eth_call` and should not be used on-chain\n    /// @param _amount The amount of ETH to swap\n    /// @param _steps The more number of steps used the more optimal the swap will be (10 is a reasonable number for most swaps)\n    function optimiseSwapFrom(uint256 _amount, uint256 _steps) external returns (uint256[2] memory portions, uint256 amountOut) {\n        return optimiseSwap(address(rETH), address(WETH), _amount, _steps);\n    }\n\n    /// @dev Simulates a call to `IVault.queryBatchSwap` and returns the amount out\n    function simulateBalancerQuote(\n        IVault.SwapKind kind,\n        IVault.BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        IVault.FundManagement memory funds\n    ) internal returns (uint256) {\n        bytes memory input = abi.encodeWithSelector(IVault.queryBatchSwap.selector, kind, swaps, assets, funds);\n        bytes memory output = RocketSwapRouter(this).simulate(address(balancerVault), input);\n        int256[] memory assetDeltas = abi.decode(output, (int256[]));\n        return uint256(-assetDeltas[1]);\n    }\n\n    /// @dev Simulates a call to Uniswap\'s `IQuoter` and returns the amount out\n    function simulateUniswapQuote(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountIn,\n        uint160 sqrtPriceLimitX96\n    ) internal returns (uint256 amountOut) {\n        bytes memory input = abi.encodeWithSelector(uniswapQuoter.quoteExactInputSingle.selector, tokenIn, tokenOut, fee, amountIn, sqrtPriceLimitX96);\n        bytes memory output = RocketSwapRouter(this).simulate(address(uniswapQuoter), input);\n        return abi.decode(output, (uint256));\n    }\n\n    /// @dev Internal logic for swap optimisation\n    function optimiseSwap(address _from, address _to, uint256 _amount, uint256 _steps) private returns (uint256[2] memory portions, uint256 amountOut) {\n        uint256 perStep = _amount / _steps;\n\n        IVault.BatchSwapStep[] memory balancerSwapStep = new IVault.BatchSwapStep[](1);\n        balancerSwapStep[0].assetInIndex = 0;\n        balancerSwapStep[0].assetOutIndex = 1;\n        balancerSwapStep[0].poolId = balancerPoolId;\n        balancerSwapStep[0].amount = perStep;\n\n        IVault.FundManagement memory funds;\n        funds.sender = address(this);\n        funds.recipient = payable(address(this));\n        funds.fromInternalBalance = false;\n        funds.toInternalBalance = false;\n\n        IAsset[] memory assets = new IAsset[](2);\n        assets[0] = IAsset(_from);\n        assets[1] = IAsset(_to);\n\n        uint256[2] memory lastOut;\n        lastOut[0] = simulateUniswapQuote(_from, _to, uniswapPoolFee, perStep, 0);\n        lastOut[1] = simulateBalancerQuote(IVault.SwapKind.GIVEN_IN, balancerSwapStep, assets, funds);\n\n        uint256[2] memory delta;\n        delta[0] = lastOut[0];\n        delta[1] = lastOut[1];\n\n        portions[0] = 0;\n        portions[1] = 0;\n        amountOut = 0;\n\n        for (uint256 i = 0; i < _steps; i++) {\n            if (delta[1] > delta[0]) {\n                portions[1]++;\n                amountOut += delta[1];\n\n                if (i < _steps - 1) {\n                    // Get amountOut of next step\n                    balancerSwapStep[0].amount = perStep * (portions[1] + 1);\n                    uint256 nextOut = simulateBalancerQuote(IVault.SwapKind.GIVEN_IN, balancerSwapStep, assets, funds);\n                    delta[1] = nextOut - lastOut[1];\n                    lastOut[1] = nextOut;\n                }\n            } else {\n                portions[0]++;\n                amountOut += delta[0];\n\n                if (i < _steps - 1) {\n                    // Get amountOut of next step\n                    uint256 nextOut = simulateUniswapQuote(_from, _to, uniswapPoolFee, perStep * (portions[0] + 1), 0);\n                    delta[0] = nextOut - lastOut[0];\n                    lastOut[0] = nextOut;\n                }\n            }\n        }\n    }\n\n    /// @notice Internal functionality that must be exposed externally as an implementation detail\n    /// https://github.com/gnosis/util-contracts/blob/main/contracts/storage/StorageAccessible.sol\n    function simulate(\n        address targetContract,\n        bytes memory calldataPayload\n    ) public returns (bytes memory response) {\n        require(msg.sender == address(this));\n\n        // Suppress compiler warnings about not using parameters, while allowing\n        // parameters to keep names for documentation purposes. This does not\n        // generate code.\n        targetContract;\n        calldataPayload;\n\n        assembly {\n            let internalCalldata := mload(0x40)\n            // Store `simulateAndRevert.selector`.\n            mstore(internalCalldata, ""\\xb4\\xfa\\xba\\x09"")\n            // Abuse the fact that both this and the internal methods have the\n            // same signature, and differ only in symbol name (and therefore,\n            // selector) and copy calldata directly. This saves us approximately\n            // 250 bytes of code and 300 gas at runtime over the\n            // `abi.encodeWithSelector` builtin.\n            calldatacopy(\n            add(internalCalldata, 0x04),\n            0x04,\n            sub(calldatasize(), 0x04)\n            )\n\n            // `pop` is required here by the compiler, as top level expressions\n            // can\'t have return values in inline assembly. `call` typically\n            // returns a 0 or 1 value indicated whether or not it reverted, but\n            // since we know it will always revert, we can safely ignore it.\n            pop(call(\n            gas(),\n            address(),\n            0,\n            internalCalldata,\n            calldatasize(),\n            // The `simulateAndRevert` call always reverts, and instead\n            // encodes whether or not it was successful in the return data.\n            // The first 32-byte word of the return data contains the\n            // `success` value, so write it to memory address 0x00 (which is\n            // reserved Solidity scratch space and OK to use).\n            0x00,\n            0x20\n            ))\n\n\n            // Allocate and copy the response bytes, making sure to increment\n            // the free memory pointer accordingly (in case this method is\n            // called as an internal function). The remaining `returndata[0x20:]`\n            // contains the ABI encoded response bytes, so we can just write it\n            // as is to memory.\n            let responseSize := sub(returndatasize(), 0x20)\n            response := mload(0x40)\n            mstore(0x40, add(response, responseSize))\n            returndatacopy(response, 0x20, responseSize)\n\n            if iszero(mload(0x00)) {\n                revert(add(response, 0x20), mload(response))\n            }\n        }\n    }\n\n    /// @notice Internal functionality that must be exposed externally as an implementation detail\n    /// https://github.com/gnosis/util-contracts/blob/main/contracts/storage/StorageSimulation.sol\n    function simulateAndRevert(\n        address targetContract,\n        bytes memory calldataPayload\n    ) public {\n        require(msg.sender == address(this));\n\n        assembly {\n            let success := call(\n                gas(),\n                targetContract,\n                0,\n                add(calldataPayload, 0x20),\n                mload(calldataPayload),\n                0,\n                0\n            )\n\n            mstore(0x00, success)\n            mstore(0x20, returndatasize())\n            returndatacopy(0x40, 0, returndatasize())\n            revert(0, add(returndatasize(), 0x40))\n        }\n    }\n}\n'}}

// File: settings
{'optimizer': {'enabled': False, 'runs': 200}, 'outputSelection': {'*': {'*': ['evm.bytecode', 'evm.deployedBytecode', 'abi']}}}",True
0x111111125421ca6dc452d289314280a0f8842a65,"// File: language
Solidity

// File: sources
{'contracts/networks/AggregationRouterV6.mainnet.sol': {'content': '/*\n                                                           ,▄▓▓██▌   ,╓▄▄▓▓▓▓▓▓▓▓▄▄▄,,\n                                                        ,▓██▓███▓▄▓███▓╬╬╬╬╬╬╬╬╬╬╬╬╬▓███▓▄,\n                                                  ▄█   ▓██╬╣███████╬▓▀╬╬▓▓▓████████████▓█████▄,\n                                                 ▓██▌ ▓██╬╣██████╬▓▌  ██████████████████████▌╙╙▀ⁿ\n                                                ▐████████╬▓████▓▓█╨ ▄ ╟█████████▓▓╬╬╬╬╬▓▓█████▓▄\n                                  └▀▓▓▄╓        ╟█▓╣█████▓██████▀ ╓█▌ ███████▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬▓██▓▄\n                                     └▀████▓▄╥  ▐██╬╬██████████╙ Æ▀─ ▓███▀╚╠╬╩▀▀███████▓▓╬╬╬╬╬╬╬╬╬██▄\n                                        └▀██▓▀▀█████▓╬▓██████▀     ▄█████▒╠""      └╙▓██████▓╬╬╬╬╬╬╬╬██▄\n                                           └▀██▄,└╙▀▀████▌└╙    ^""▀╙╙╙""╙██      @▄    ╙▀███████╬╬╬╬╬╬╬██µ\n                                              └▀██▓▄, ██▌       ╒       ╙█▓     ]▓█▓╔    ▀███████▓╬╬╬╬╬▓█▌\n                                                  ▀█████       ▓         ╟█▌    ]╠██▓░▒╓   ▀████████╬╬╬╬╣█▌\n                                                  ▐████      ╓█▀█▌      ,██▌    ╚Å███▓▒▒╠╓  ╙█████████╬╬╬╣█▌\n                                                  └████     ▓█░░▓█      ▀▀▀    φ▒╫████▒▒▒▒╠╓  █████████▓╬╬▓█µ\n                                                   ╘███µ ▌▄█▓▄▓▀`     ,▀    ,╔╠░▓██████▌╠▒▒▒φ  ██████████╬╬██\n                                                   ▐████µ╙▓▀`     ,▀╙,╔╔φφφ╠░▄▓███████▌░▓╙▒▒▒╠ └██╬███████╬▓█⌐\n                                                   ╫██ ▓▌         ▌φ▒▒░▓██████████████▌▒░▓╚▒▒▒╠ ▓██╬▓██████╣█▌\n                                                   ██▌           ▌╔▒▒▄████████████████▒▒▒░▌╠▒▒▒≥▐██▓╬╬███████▌\n                                                   ██▌      ,╓φ╠▓«▒▒▓████▀  ▀█████████▌▒▒▒╟░▒▒▒▒▐███╬╬╣████▓█▌\n                                                  ▐██      ╠▒▄▓▓███▓████└     ▀████████▌▒▒░▌╚▒▒▒▐███▓╬╬████ ╙▌\n                                                  ███  )  ╠▒░░░▒░╬████▀        └████████░▒▒░╬∩▒▒▓████╬╬╣███\n                                                 ▓██    ╠╠▒▒▐█▀▀▌`░╫██           ███████▒▒▒▒░▒▒½█████╬╬╣███\n                                                ███ ,█▄ ╠▒▒▒╫▌,▄▀,▒╫██           ╟██████▒▒▒░╣⌠▒▓█████╬╬╣██▌\n                                               ╘██µ ██` ╠▒▒░██╬φ╠▄▓██`            ██████░░▌φ╠░▓█████▓╬╬▓██\n                                                ╟██  .φ╠▒░▄█▀░░▄██▀└              █████▌▒╣φ▒░▓██████╬╬╣██\n                                                 ▀██▄▄▄╓▄███████▀                ▐█████░▓φ▒▄███████▓╬╣██\n                                                   ╙▀▀▀██▀└                      ████▓▄▀φ▄▓████████╬▓█▀\n                                                                                ▓███╬╩╔╣██████████▓██└\n                                                                              ╓████▀▄▓████████▀████▀\n                                                                            ,▓███████████████─]██╙\n                                                                         ,▄▓██████████████▀└  ╙\n                                                                    ,╓▄▓███████████████▀╙\n                                                             `""▀▀▀████████▀▀▀▀`▄███▀▀└\n                                                                              └└\n\n\n\n                    11\\   11\\                     11\\             11\\   11\\            11\\                                       11\\\n                  1111 |  \\__|                    11 |            111\\  11 |           11 |                                      11 |\n                  \\_11 |  11\\ 1111111\\   1111111\\ 1111111\\        1111\\ 11 | 111111\\ 111111\\   11\\  11\\  11\\  111111\\   111111\\  11 |  11\\\n                    11 |  11 |11  __11\\ 11  _____|11  __11\\       11 11\\11 |11  __11\\\\_11  _|  11 | 11 | 11 |11  __11\\ 11  __11\\ 11 | 11  |\n                    11 |  11 |11 |  11 |11 /      11 |  11 |      11 \\1111 |11111111 | 11 |    11 | 11 | 11 |11 /  11 |11 |  \\__|111111  /\n                    11 |  11 |11 |  11 |11 |      11 |  11 |      11 |\\111 |11   ____| 11 |11\\ 11 | 11 | 11 |11 |  11 |11 |      11  _11<\n                  111111\\ 11 |11 |  11 |\\1111111\\ 11 |  11 |      11 | \\11 |\\1111111\\  \\1111  |\\11111\\1111  |\\111111  |11 |      11 | \\11\\\n                  \\______|\\__|\\__|  \\__| \\_______|\\__|  \\__|      \\__|  \\__| \\_______|  \\____/  \\_____\\____/  \\______/ \\__|      \\__|  \\__|\n\n\n\n                               111111\\                                                               11\\     11\\\n                              11  __11\\                                                              11 |    \\__|\n                              11 /  11 | 111111\\   111111\\   111111\\   111111\\   111111\\   111111\\ 111111\\   11\\  111111\\  1111111\\\n                              11111111 |11  __11\\ 11  __11\\ 11  __11\\ 11  __11\\ 11  __11\\  \\____11\\\\_11  _|  11 |11  __11\\ 11  __11\\\n                              11  __11 |11 /  11 |11 /  11 |11 |  \\__|11111111 |11 /  11 | 1111111 | 11 |    11 |11 /  11 |11 |  11 |\n                              11 |  11 |11 |  11 |11 |  11 |11 |      11   ____|11 |  11 |11  __11 | 11 |11\\ 11 |11 |  11 |11 |  11 |\n                              11 |  11 |\\1111111 |\\1111111 |11 |      \\1111111\\ \\1111111 |\\1111111 | \\1111  |11 |\\111111  |11 |  11 |\n                              \\__|  \\__| \\____11 | \\____11 |\\__|       \\_______| \\____11 | \\_______|  \\____/ \\__| \\______/ \\__|  \\__|\n                                        11\\   11 |11\\   11 |                    11\\   11 |\n                                        \\111111  |\\111111  |                    \\111111  |\n                                         \\______/  \\______/                      \\______/\n                                                1111111\\                        11\\\n                                                11  __11\\                       11 |\n                                                11 |  11 | 111111\\  11\\   11\\ 111111\\    111111\\   111111\\\n                                                1111111  |11  __11\\ 11 |  11 |\\_11  _|  11  __11\\ 11  __11\\\n                                                11  __11< 11 /  11 |11 |  11 |  11 |    11111111 |11 |  \\__|\n                                                11 |  11 |11 |  11 |11 |  11 |  11 |11\\ 11   ____|11 |\n                                                11 |  11 |\\111111  |\\111111  |  \\1111  |\\1111111\\ 11 |\n                                                \\__|  \\__| \\______/  \\______/    \\____/  \\_______|\\__|\n*/\n\n// SPDX-License-Identifier: MIT\n\n// File @1inch/limit-order-protocol-contract/contracts/libraries/MakerTraitsLib.sol@v4.0.0-prerelease-19\n\npragma solidity 0.8.23;\n\ntype MakerTraits is uint256;\n\n/**\n * @title MakerTraitsLib\n * @notice A library to manage and check MakerTraits, which are used to encode the maker\'s preferences for an order in a single uint256.\n * @dev\n * The MakerTraits type is a uint256 and different parts of the number are used to encode different traits.\n * High bits are used for flags\n * 255 bit `NO_PARTIAL_FILLS_FLAG`          - if set, the order does not allow partial fills\n * 254 bit `ALLOW_MULTIPLE_FILLS_FLAG`      - if set, the order permits multiple fills\n * 253 bit                                  - unused\n * 252 bit `PRE_INTERACTION_CALL_FLAG`      - if set, the order requires pre-interaction call\n * 251 bit `POST_INTERACTION_CALL_FLAG`     - if set, the order requires post-interaction call\n * 250 bit `NEED_CHECK_EPOCH_MANAGER_FLAG`  - if set, the order requires to check the epoch manager\n * 249 bit `HAS_EXTENSION_FLAG`             - if set, the order has extension(s)\n * 248 bit `USE_PERMIT2_FLAG`               - if set, the order uses permit2\n * 247 bit `UNWRAP_WETH_FLAG`               - if set, the order requires to unwrap WETH\n\n * Low 200 bits are used for allowed sender, expiration, nonceOrEpoch, and series\n * uint80 last 10 bytes of allowed sender address (0 if any)\n * uint40 expiration timestamp (0 if none)\n * uint40 nonce or epoch\n * uint40 series\n */\nlibrary MakerTraitsLib {\n    // Low 200 bits are used for allowed sender, expiration, nonceOrEpoch, and series\n    uint256 private constant _ALLOWED_SENDER_MASK = type(uint80).max;\n    uint256 private constant _EXPIRATION_OFFSET = 80;\n    uint256 private constant _EXPIRATION_MASK = type(uint40).max;\n    uint256 private constant _NONCE_OR_EPOCH_OFFSET = 120;\n    uint256 private constant _NONCE_OR_EPOCH_MASK = type(uint40).max;\n    uint256 private constant _SERIES_OFFSET = 160;\n    uint256 private constant _SERIES_MASK = type(uint40).max;\n\n    uint256 private constant _NO_PARTIAL_FILLS_FLAG = 1 << 255;\n    uint256 private constant _ALLOW_MULTIPLE_FILLS_FLAG = 1 << 254;\n    uint256 private constant _PRE_INTERACTION_CALL_FLAG = 1 << 252;\n    uint256 private constant _POST_INTERACTION_CALL_FLAG = 1 << 251;\n    uint256 private constant _NEED_CHECK_EPOCH_MANAGER_FLAG = 1 << 250;\n    uint256 private constant _HAS_EXTENSION_FLAG = 1 << 249;\n    uint256 private constant _USE_PERMIT2_FLAG = 1 << 248;\n    uint256 private constant _UNWRAP_WETH_FLAG = 1 << 247;\n\n    /**\n     * @notice Checks if the order has the extension flag set.\n     * @dev If the `HAS_EXTENSION_FLAG` is set in the makerTraits, then the protocol expects that the order has extension(s).\n     * @param makerTraits The traits of the maker.\n     * @return result A boolean indicating whether the flag is set.\n     */\n    function hasExtension(MakerTraits makerTraits) internal pure returns (bool) {\n        return (MakerTraits.unwrap(makerTraits) & _HAS_EXTENSION_FLAG) != 0;\n    }\n\n    /**\n     * @notice Checks if the maker allows a specific taker to fill the order.\n     * @param makerTraits The traits of the maker.\n     * @param sender The address of the taker to be checked.\n     * @return result A boolean indicating whether the taker is allowed.\n     */\n    function isAllowedSender(MakerTraits makerTraits, address sender) internal pure returns (bool) {\n        uint160 allowedSender = uint160(MakerTraits.unwrap(makerTraits) & _ALLOWED_SENDER_MASK);\n        return allowedSender == 0 || allowedSender == uint160(sender) & _ALLOWED_SENDER_MASK;\n    }\n\n    /**\n     * @notice Checks if the order has expired.\n     * @param makerTraits The traits of the maker.\n     * @return result A boolean indicating whether the order has expired.\n     */\n    function isExpired(MakerTraits makerTraits) internal view returns (bool) {\n        uint256 expiration = (MakerTraits.unwrap(makerTraits) >> _EXPIRATION_OFFSET) & _EXPIRATION_MASK;\n        return expiration != 0 && expiration < block.timestamp;  // solhint-disable-line not-rely-on-time\n    }\n\n    /**\n     * @notice Returns the nonce or epoch of the order.\n     * @param makerTraits The traits of the maker.\n     * @return result The nonce or epoch of the order.\n     */\n    function nonceOrEpoch(MakerTraits makerTraits) internal pure returns (uint256) {\n        return (MakerTraits.unwrap(makerTraits) >> _NONCE_OR_EPOCH_OFFSET) & _NONCE_OR_EPOCH_MASK;\n    }\n\n    /**\n     * @notice Returns the series of the order.\n     * @param makerTraits The traits of the maker.\n     * @return result The series of the order.\n     */\n    function series(MakerTraits makerTraits) internal pure returns (uint256) {\n        return (MakerTraits.unwrap(makerTraits) >> _SERIES_OFFSET) & _SERIES_MASK;\n    }\n\n    /**\n      * @notice Determines if the order allows partial fills.\n      * @dev If the _NO_PARTIAL_FILLS_FLAG is not set in the makerTraits, then the order allows partial fills.\n      * @param makerTraits The traits of the maker, determining their preferences for the order.\n      * @return result A boolean indicating whether the maker allows partial fills.\n      */\n    function allowPartialFills(MakerTraits makerTraits) internal pure returns (bool) {\n        return (MakerTraits.unwrap(makerTraits) & _NO_PARTIAL_FILLS_FLAG) == 0;\n    }\n\n    /**\n     * @notice Checks if the maker needs pre-interaction call.\n     * @param makerTraits The traits of the maker.\n     * @return result A boolean indicating whether the maker needs a pre-interaction call.\n     */\n    function needPreInteractionCall(MakerTraits makerTraits) internal pure returns (bool) {\n        return (MakerTraits.unwrap(makerTraits) & _PRE_INTERACTION_CALL_FLAG) != 0;\n    }\n\n    /**\n     * @notice Checks if the maker needs post-interaction call.\n     * @param makerTraits The traits of the maker.\n     * @return result A boolean indicating whether the maker needs a post-interaction call.\n     */\n    function needPostInteractionCall(MakerTraits makerTraits) internal pure returns (bool) {\n        return (MakerTraits.unwrap(makerTraits) & _POST_INTERACTION_CALL_FLAG) != 0;\n    }\n\n    /**\n      * @notice Determines if the order allows multiple fills.\n      * @dev If the _ALLOW_MULTIPLE_FILLS_FLAG is set in the makerTraits, then the maker allows multiple fills.\n      * @param makerTraits The traits of the maker, determining their preferences for the order.\n      * @return result A boolean indicating whether the maker allows multiple fills.\n      */\n    function allowMultipleFills(MakerTraits makerTraits) internal pure returns (bool) {\n        return (MakerTraits.unwrap(makerTraits) & _ALLOW_MULTIPLE_FILLS_FLAG) != 0;\n    }\n\n    /**\n      * @notice Determines if an order should use the bit invalidator or remaining amount validator.\n      * @dev The bit invalidator can be used if the order does not allow partial or multiple fills.\n      * @param makerTraits The traits of the maker, determining their preferences for the order.\n      * @return result A boolean indicating whether the bit invalidator should be used.\n      * True if the order requires the use of the bit invalidator.\n      */\n    function useBitInvalidator(MakerTraits makerTraits) internal pure returns (bool) {\n        return !allowPartialFills(makerTraits) || !allowMultipleFills(makerTraits);\n    }\n\n    /**\n     * @notice Checks if the maker needs to check the epoch.\n     * @param makerTraits The traits of the maker.\n     * @return result A boolean indicating whether the maker needs to check the epoch manager.\n     */\n    function needCheckEpochManager(MakerTraits makerTraits) internal pure returns (bool) {\n        return (MakerTraits.unwrap(makerTraits) & _NEED_CHECK_EPOCH_MANAGER_FLAG) != 0;\n    }\n\n    /**\n     * @notice Checks if the maker uses permit2.\n     * @param makerTraits The traits of the maker.\n     * @return result A boolean indicating whether the maker uses permit2.\n     */\n    function usePermit2(MakerTraits makerTraits) internal pure returns (bool) {\n        return MakerTraits.unwrap(makerTraits) & _USE_PERMIT2_FLAG != 0;\n    }\n\n    /**\n     * @notice Checks if the maker needs to unwraps WETH.\n     * @param makerTraits The traits of the maker.\n     * @return result A boolean indicating whether the maker needs to unwrap WETH.\n     */\n    function unwrapWeth(MakerTraits makerTraits) internal pure returns (bool) {\n        return MakerTraits.unwrap(makerTraits) & _UNWRAP_WETH_FLAG != 0;\n    }\n}\n\n// File @1inch/limit-order-protocol-contract/contracts/libraries/TakerTraitsLib.sol@v4.0.0-prerelease-19\n\ntype TakerTraits is uint256;\n\n/**\n * @title TakerTraitsLib\n * @notice This library to manage and check TakerTraits, which are used to encode the taker\'s preferences for an order in a single uint256.\n * @dev The TakerTraits are structured as follows:\n * High bits are used for flags\n * 255 bit `_MAKER_AMOUNT_FLAG`           - If set, the taking amount is calculated based on making amount, otherwise making amount is calculated based on taking amount.\n * 254 bit `_UNWRAP_WETH_FLAG`            - If set, the WETH will be unwrapped into ETH before sending to taker.\n * 253 bit `_SKIP_ORDER_PERMIT_FLAG`      - If set, the order skips maker\'s permit execution.\n * 252 bit `_USE_PERMIT2_FLAG`            - If set, the order uses the permit2 function for authorization.\n * 251 bit `_ARGS_HAS_TARGET`             - If set, then first 20 bytes of args are treated as target address for maker’s funds transfer.\n * 224-247 bits `ARGS_EXTENSION_LENGTH`   - The length of the extension calldata in the args.\n * 200-223 bits `ARGS_INTERACTION_LENGTH` - The length of the interaction calldata in the args.\n * 0-184 bits                             - The threshold amount (the maximum amount a taker agrees to give in exchange for a making amount).\n */\nlibrary TakerTraitsLib {\n    uint256 private constant _MAKER_AMOUNT_FLAG = 1 << 255;\n    uint256 private constant _UNWRAP_WETH_FLAG = 1 << 254;\n    uint256 private constant _SKIP_ORDER_PERMIT_FLAG = 1 << 253;\n    uint256 private constant _USE_PERMIT2_FLAG = 1 << 252;\n    uint256 private constant _ARGS_HAS_TARGET = 1 << 251;\n\n    uint256 private constant _ARGS_EXTENSION_LENGTH_OFFSET = 224;\n    uint256 private constant _ARGS_EXTENSION_LENGTH_MASK = 0xffffff;\n    uint256 private constant _ARGS_INTERACTION_LENGTH_OFFSET = 200;\n    uint256 private constant _ARGS_INTERACTION_LENGTH_MASK = 0xffffff;\n\n    uint256 private constant _AMOUNT_MASK = 0x000000000000000000ffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /**\n     * @notice Checks if the args should contain target address.\n     * @param takerTraits The traits of the taker.\n     * @return result A boolean indicating whether the args should contain target address.\n     */\n    function argsHasTarget(TakerTraits takerTraits) internal pure returns (bool) {\n        return (TakerTraits.unwrap(takerTraits) & _ARGS_HAS_TARGET) != 0;\n    }\n\n    /**\n     * @notice Retrieves the length of the extension calldata from the takerTraits.\n     * @param takerTraits The traits of the taker.\n     * @return result The length of the extension calldata encoded in the takerTraits.\n     */\n    function argsExtensionLength(TakerTraits takerTraits) internal pure returns (uint256) {\n        return (TakerTraits.unwrap(takerTraits) >> _ARGS_EXTENSION_LENGTH_OFFSET) & _ARGS_EXTENSION_LENGTH_MASK;\n    }\n\n    /**\n     * @notice Retrieves the length of the interaction calldata from the takerTraits.\n     * @param takerTraits The traits of the taker.\n     * @return result The length of the interaction calldata encoded in the takerTraits.\n     */\n    function argsInteractionLength(TakerTraits takerTraits) internal pure returns (uint256) {\n        return (TakerTraits.unwrap(takerTraits) >> _ARGS_INTERACTION_LENGTH_OFFSET) & _ARGS_INTERACTION_LENGTH_MASK;\n    }\n\n    /**\n     * @notice Checks if the taking amount should be calculated based on making amount.\n     * @param takerTraits The traits of the taker.\n     * @return result A boolean indicating whether the taking amount should be calculated based on making amount.\n     */\n    function isMakingAmount(TakerTraits takerTraits) internal pure returns (bool) {\n        return (TakerTraits.unwrap(takerTraits) & _MAKER_AMOUNT_FLAG) != 0;\n    }\n\n    /**\n     * @notice Checks if the order should unwrap WETH and send ETH to taker.\n     * @param takerTraits The traits of the taker.\n     * @return result A boolean indicating whether the order should unwrap WETH.\n     */\n    function unwrapWeth(TakerTraits takerTraits) internal pure returns (bool) {\n        return (TakerTraits.unwrap(takerTraits) & _UNWRAP_WETH_FLAG) != 0;\n    }\n\n    /**\n     * @notice Checks if the order should skip maker\'s permit execution.\n     * @param takerTraits The traits of the taker.\n     * @return result A boolean indicating whether the order don\'t apply permit.\n     */\n    function skipMakerPermit(TakerTraits takerTraits) internal pure returns (bool) {\n        return (TakerTraits.unwrap(takerTraits) & _SKIP_ORDER_PERMIT_FLAG) != 0;\n    }\n\n    /**\n     * @notice Checks if the order uses the permit2 instead of permit.\n     * @param takerTraits The traits of the taker.\n     * @return result A boolean indicating whether the order uses the permit2.\n     */\n    function usePermit2(TakerTraits takerTraits) internal pure returns (bool) {\n        return (TakerTraits.unwrap(takerTraits) & _USE_PERMIT2_FLAG) != 0;\n    }\n\n    /**\n     * @notice Retrieves the threshold amount from the takerTraits.\n     * The maximum amount a taker agrees to give in exchange for a making amount.\n     * @param takerTraits The traits of the taker.\n     * @return result The threshold amount encoded in the takerTraits.\n     */\n    function threshold(TakerTraits takerTraits) internal pure returns (uint256) {\n        return TakerTraits.unwrap(takerTraits) & _AMOUNT_MASK;\n    }\n}\n\n// File @1inch/solidity-utils/contracts/libraries/AddressLib.sol@v3.7.1\n\ntype Address is uint256;\n\n/**\n* @dev Library for working with addresses encoded as uint256 values, which can include flags in the highest bits.\n*/\nlibrary AddressLib {\n    uint256 private constant _LOW_160_BIT_MASK = (1 << 160) - 1;\n\n    /**\n    * @notice Returns the address representation of a uint256.\n    * @param a The uint256 value to convert to an address.\n    * @return The address representation of the provided uint256 value.\n    */\n    function get(Address a) internal pure returns (address) {\n        return address(uint160(Address.unwrap(a) & _LOW_160_BIT_MASK));\n    }\n\n    /**\n    * @notice Checks if a given flag is set for the provided address.\n    * @param a The address to check for the flag.\n    * @param flag The flag to check for in the provided address.\n    * @return True if the provided flag is set in the address, false otherwise.\n    */\n    function getFlag(Address a, uint256 flag) internal pure returns (bool) {\n        return (Address.unwrap(a) & flag) != 0;\n    }\n\n    /**\n    * @notice Returns a uint32 value stored at a specific bit offset in the provided address.\n    * @param a The address containing the uint32 value.\n    * @param offset The bit offset at which the uint32 value is stored.\n    * @return The uint32 value stored in the address at the specified bit offset.\n    */\n    function getUint32(Address a, uint256 offset) internal pure returns (uint32) {\n        return uint32(Address.unwrap(a) >> offset);\n    }\n\n    /**\n    * @notice Returns a uint64 value stored at a specific bit offset in the provided address.\n    * @param a The address containing the uint64 value.\n    * @param offset The bit offset at which the uint64 value is stored.\n    * @return The uint64 value stored in the address at the specified bit offset.\n    */\n    function getUint64(Address a, uint256 offset) internal pure returns (uint64) {\n        return uint64(Address.unwrap(a) >> offset);\n    }\n}\n\n// File @1inch/limit-order-protocol-contract/contracts/interfaces/IOrderMixin.sol@v4.0.0-prerelease-19\n\ninterface IOrderMixin {\n    struct Order {\n        uint256 salt;\n        Address maker;\n        Address receiver;\n        Address makerAsset;\n        Address takerAsset;\n        uint256 makingAmount;\n        uint256 takingAmount;\n        MakerTraits makerTraits;\n    }\n\n    error InvalidatedOrder();\n    error TakingAmountExceeded();\n    error PrivateOrder();\n    error BadSignature();\n    error OrderExpired();\n    error WrongSeriesNonce();\n    error SwapWithZeroAmount();\n    error PartialFillNotAllowed();\n    error OrderIsNotSuitableForMassInvalidation();\n    error EpochManagerAndBitInvalidatorsAreIncompatible();\n    error ReentrancyDetected();\n    error PredicateIsNotTrue();\n    error TakingAmountTooHigh();\n    error MakingAmountTooLow();\n    error TransferFromMakerToTakerFailed();\n    error TransferFromTakerToMakerFailed();\n    error MismatchArraysLengths();\n    error InvalidPermit2Transfer();\n    error SimulationResults(bool success, bytes res);\n\n    /**\n     * @notice Emitted when order gets filled\n     * @param orderHash Hash of the order\n     * @param remainingAmount Amount of the maker asset that remains to be filled\n     */\n    event OrderFilled(\n        bytes32 orderHash,\n        uint256 remainingAmount\n    );\n\n    /**\n     * @notice Emitted when order without `useBitInvalidator` gets cancelled\n     * @param orderHash Hash of the order\n     */\n    event OrderCancelled(\n        bytes32 orderHash\n    );\n\n    /**\n     * @notice Emitted when order with `useBitInvalidator` gets cancelled\n     * @param maker Maker address\n     * @param slotIndex Slot index that was updated\n     * @param slotValue New slot value\n     */\n    event BitInvalidatorUpdated(\n        address indexed maker,\n        uint256 slotIndex,\n        uint256 slotValue\n    );\n\n    /**\n     * @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes\n     * @param maker Maker address\n     * @param slot Slot number to return bitmask for\n     * @return result Each bit represents whether corresponding was already invalidated\n     */\n    function bitInvalidatorForOrder(address maker, uint256 slot) external view returns(uint256 result);\n\n    /**\n     * @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes\n     * @param orderHash Hash of the order\n     * @return remaining Remaining amount of the order\n     */\n    function remainingInvalidatorForOrder(address maker, bytes32 orderHash) external view returns(uint256 remaining);\n\n    /**\n     * @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes\n     * @param orderHash Hash of the order\n     * @return remainingRaw Inverse of the remaining amount of the order if order was filled at least once, otherwise 0\n     */\n    function rawRemainingInvalidatorForOrder(address maker, bytes32 orderHash) external view returns(uint256 remainingRaw);\n\n    /**\n     * @notice Cancels order\'s quote\n     * @param makerTraits Order makerTraits\n     * @param orderHash Hash of the order to cancel\n     */\n    function cancelOrder(MakerTraits makerTraits, bytes32 orderHash) external;\n\n    /**\n     * @notice Cancels orders\' quotes\n     * @param makerTraits Orders makerTraits\n     * @param orderHashes Hashes of the orders to cancel\n     */\n    function cancelOrders(MakerTraits[] calldata makerTraits, bytes32[] calldata orderHashes) external;\n\n    /**\n     * @notice Cancels all quotes of the maker (works for bit-invalidating orders only)\n     * @param makerTraits Order makerTraits\n     * @param additionalMask Additional bitmask to invalidate orders\n     */\n    function bitsInvalidateForOrder(MakerTraits makerTraits, uint256 additionalMask) external;\n\n    /**\n     * @notice Returns order hash, hashed with limit order protocol contract EIP712\n     * @param order Order\n     * @return orderHash Hash of the order\n     */\n    function hashOrder(IOrderMixin.Order calldata order) external view returns(bytes32 orderHash);\n\n    /**\n     * @notice Delegates execution to custom implementation. Could be used to validate if `transferFrom` works properly\n     * @dev The function always reverts and returns the simulation results in revert data.\n     * @param target Addresses that will be delegated\n     * @param data Data that will be passed to delegatee\n     */\n    function simulate(address target, bytes calldata data) external;\n\n    /**\n     * @notice Fills order\'s quote, fully or partially (whichever is possible).\n     * @param order Order quote to fill\n     * @param r R component of signature\n     * @param vs VS component of signature\n     * @param amount Taker amount to fill\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker\'s permit.\n     * @return makingAmount Actual amount transferred from maker to taker\n     * @return takingAmount Actual amount transferred from taker to maker\n     * @return orderHash Hash of the filled order\n     */\n    function fillOrder(\n        Order calldata order,\n        bytes32 r,\n        bytes32 vs,\n        uint256 amount,\n        TakerTraits takerTraits\n    ) external payable returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\n\n    /**\n     * @notice Same as `fillOrder` but allows to specify arguments that are used by the taker.\n     * @param order Order quote to fill\n     * @param r R component of signature\n     * @param vs VS component of signature\n     * @param amount Taker amount to fill\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker\'s permit.\n     * @param args Arguments that are used by the taker (target, extension, interaction, permit)\n     * @return makingAmount Actual amount transferred from maker to taker\n     * @return takingAmount Actual amount transferred from taker to maker\n     * @return orderHash Hash of the filled order\n     */\n    function fillOrderArgs(\n        IOrderMixin.Order calldata order,\n        bytes32 r,\n        bytes32 vs,\n        uint256 amount,\n        TakerTraits takerTraits,\n        bytes calldata args\n    ) external payable returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\n\n    /**\n     * @notice Same as `fillOrder` but uses contract-based signatures.\n     * @param order Order quote to fill\n     * @param signature Signature to confirm quote ownership\n     * @param amount Taker amount to fill\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker\'s permit.\n     * @return makingAmount Actual amount transferred from maker to taker\n     * @return takingAmount Actual amount transferred from taker to maker\n     * @return orderHash Hash of the filled order\n     * @dev See tests for examples\n     */\n    function fillContractOrder(\n        Order calldata order,\n        bytes calldata signature,\n        uint256 amount,\n        TakerTraits takerTraits\n    ) external returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\n\n    /**\n     * @notice Same as `fillContractOrder` but allows to specify arguments that are used by the taker.\n     * @param order Order quote to fill\n     * @param signature Signature to confirm quote ownership\n     * @param amount Taker amount to fill\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker\'s permit.\n     * @param args Arguments that are used by the taker (target, extension, interaction, permit)\n     * @return makingAmount Actual amount transferred from maker to taker\n     * @return takingAmount Actual amount transferred from taker to maker\n     * @return orderHash Hash of the filled order\n     * @dev See tests for examples\n     */\n    function fillContractOrderArgs(\n        Order calldata order,\n        bytes calldata signature,\n        uint256 amount,\n        TakerTraits takerTraits,\n        bytes calldata args\n    ) external returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\n}\n\n// File @1inch/limit-order-protocol-contract/contracts/interfaces/IAmountGetter.sol@v4.0.0-prerelease-19\n\ninterface IAmountGetter {\n    /**\n     * @notice View method that gets called to determine the actual making amount\n     * @param order Order being processed\n     * @param extension Order extension data\n     * @param orderHash Hash of the order being processed\n     * @param taker Taker address\n     * @param takingAmount Actual taking amount\n     * @param remainingMakingAmount Order remaining making amount\n     * @param extraData Extra data\n     */\n    function getMakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 takingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) external view returns (uint256);\n\n    /**\n     * @notice View method that gets called to determine the actual making amount\n     * @param order Order being processed\n     * @param extension Order extension data\n     * @param orderHash Hash of the order being processed\n     * @param taker Taker address\n     * @param makingAmount Actual taking amount\n     * @param remainingMakingAmount Order remaining making amount\n     * @param extraData Extra data\n     */\n    function getTakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 makingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) external view returns (uint256);\n}\n\n// File @1inch/limit-order-protocol-contract/contracts/interfaces/IPostInteraction.sol@v4.0.0-prerelease-19\n\ninterface IPostInteraction {\n    /**\n     * @notice Callback method that gets called after all fund transfers\n     * @param order Order being processed\n     * @param extension Order extension data\n     * @param orderHash Hash of the order being processed\n     * @param taker Taker address\n     * @param makingAmount Actual making amount\n     * @param takingAmount Actual taking amount\n     * @param remainingMakingAmount Order remaining making amount\n     * @param extraData Extra data\n     */\n    function postInteraction(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) external;\n}\n\n// File @1inch/limit-order-protocol-contract/contracts/interfaces/IPreInteraction.sol@v4.0.0-prerelease-19\n\ninterface IPreInteraction {\n    /**\n     * @notice Callback method that gets called before any funds transfers\n     * @param order Order being processed\n     * @param extension Order extension data\n     * @param orderHash Hash of the order being processed\n     * @param taker Taker address\n     * @param makingAmount Actual making amount\n     * @param takingAmount Actual taking amount\n     * @param remainingMakingAmount Order remaining making amount\n     * @param extraData Extra data\n     */\n    function preInteraction(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) external;\n}\n\n// File @1inch/limit-order-protocol-contract/contracts/interfaces/ITakerInteraction.sol@v4.0.0-prerelease-19\n\n/**\n * @title Interface for interactor which acts after `maker -> taker` transfer but before `taker -> maker` transfer.\n * @notice The order filling steps are `preInteraction` =>` Transfer ""maker -> taker""` => **`Interaction`** => `Transfer ""taker -> maker""` => `postInteraction`\n */\ninterface ITakerInteraction {\n    /**\n     * @dev This callback allows to interactively handle maker aseets to produce takers assets, doesn\'t supports ETH as taker assets\n     * @notice Callback method that gets called after maker fund transfer but before taker fund transfer\n     * @param order Order being processed\n     * @param extension Order extension data\n     * @param orderHash Hash of the order being processed\n     * @param taker Taker address\n     * @param makingAmount Actual making amount\n     * @param takingAmount Actual taking amount\n     * @param remainingMakingAmount Order remaining making amount\n     * @param extraData Extra data\n     */\n    function takerInteraction(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        bytes32 orderHash,\n        address taker,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 remainingMakingAmount,\n        bytes calldata extraData\n    ) external;\n}\n\n// File @1inch/limit-order-protocol-contract/contracts/libraries/OffsetsLib.sol@v4.0.0-prerelease-19\n\ntype Offsets is uint256;\n\n/// @title OffsetsLib\n/// @dev A library for retrieving values by offsets from a concatenated calldata.\nlibrary OffsetsLib {\n\n    /// @dev Error to be thrown when the offset is out of bounds.\n    error OffsetOutOfBounds();\n\n    /**\n     * @notice Retrieves the field value calldata corresponding to the provided field index from the concatenated calldata.\n     * @dev\n     * The function performs the following steps:\n     * 1. Retrieve the start and end of the segment corresponding to the provided index from the offsets array.\n     * 2. Get the value from segment using offset and length calculated based on the start and end of the segment.\n     * 3. Throw `OffsetOutOfBounds` error if the length of the segment is greater than the length of the concatenated data.\n     * @param offsets The offsets encoding the start and end of each segment within the concatenated calldata.\n     * @param concat The concatenated calldata.\n     * @param index The index of the segment to retrieve. The field index 0 corresponds to the lowest bytes of the offsets array.\n     * @return result The calldata from a segment of the concatenated calldata corresponding to the provided index.\n     */\n    function get(Offsets offsets, bytes calldata concat, uint256 index) internal pure returns(bytes calldata result) {\n        bytes4 exception = OffsetOutOfBounds.selector;\n        assembly (""memory-safe"") {  // solhint-disable-line no-inline-assembly\n            let bitShift := shl(5, index)                                   // bitShift = index * 32\n            let begin := and(0xffffffff, shr(bitShift, shl(32, offsets)))   // begin = offsets[ bitShift : bitShift + 32 ]\n            let end := and(0xffffffff, shr(bitShift, offsets))              // end   = offsets[ bitShift + 32 : bitShift + 64 ]\n            result.offset := add(concat.offset, begin)\n            result.length := sub(end, begin)\n            if gt(end, concat.length) {\n                mstore(0, exception)\n                revert(0, 4)\n            }\n        }\n    }\n}\n\n// File @1inch/limit-order-protocol-contract/contracts/libraries/ExtensionLib.sol@v4.0.0-prerelease-19\n\n/**\n * @title ExtensionLib\n * @notice Library for retrieving extensions information for the IOrderMixin Interface.\n */\nlibrary ExtensionLib {\n    using AddressLib for Address;\n    using OffsetsLib for Offsets;\n\n    enum DynamicField {\n        MakerAssetSuffix,\n        TakerAssetSuffix,\n        MakingAmountData,\n        TakingAmountData,\n        Predicate,\n        MakerPermit,\n        PreInteractionData,\n        PostInteractionData,\n        CustomData\n    }\n\n    /**\n     * @notice Returns the MakerAssetSuffix from the provided extension calldata.\n     * @param extension The calldata from which the MakerAssetSuffix is to be retrieved.\n     * @return calldata Bytes representing the MakerAssetSuffix.\n     */\n    function makerAssetSuffix(bytes calldata extension) internal pure returns(bytes calldata) {\n        return _get(extension, DynamicField.MakerAssetSuffix);\n    }\n\n    /**\n     * @notice Returns the TakerAssetSuffix from the provided extension calldata.\n     * @param extension The calldata from which the TakerAssetSuffix is to be retrieved.\n     * @return calldata Bytes representing the TakerAssetSuffix.\n     */\n    function takerAssetSuffix(bytes calldata extension) internal pure returns(bytes calldata) {\n        return _get(extension, DynamicField.TakerAssetSuffix);\n    }\n\n    /**\n     * @notice Returns the MakingAmountData from the provided extension calldata.\n     * @param extension The calldata from which the MakingAmountData is to be retrieved.\n     * @return calldata Bytes representing the MakingAmountData.\n     */\n    function makingAmountData(bytes calldata extension) internal pure returns(bytes calldata) {\n        return _get(extension, DynamicField.MakingAmountData);\n    }\n\n    /**\n     * @notice Returns the TakingAmountData from the provided extension calldata.\n     * @param extension The calldata from which the TakingAmountData is to be retrieved.\n     * @return calldata Bytes representing the TakingAmountData.\n     */\n    function takingAmountData(bytes calldata extension) internal pure returns(bytes calldata) {\n        return _get(extension, DynamicField.TakingAmountData);\n    }\n\n    /**\n     * @notice Returns the order\'s predicate from the provided extension calldata.\n     * @param extension The calldata from which the predicate is to be retrieved.\n     * @return calldata Bytes representing the predicate.\n     */\n    function predicate(bytes calldata extension) internal pure returns(bytes calldata) {\n        return _get(extension, DynamicField.Predicate);\n    }\n\n    /**\n     * @notice Returns the maker\'s permit from the provided extension calldata.\n     * @param extension The calldata from which the maker\'s permit is to be retrieved.\n     * @return calldata Bytes representing the maker\'s permit.\n     */\n    function makerPermit(bytes calldata extension) internal pure returns(bytes calldata) {\n        return _get(extension, DynamicField.MakerPermit);\n    }\n\n    /**\n     * @notice Returns the pre-interaction from the provided extension calldata.\n     * @param extension The calldata from which the pre-interaction is to be retrieved.\n     * @return calldata Bytes representing the pre-interaction.\n     */\n    function preInteractionTargetAndData(bytes calldata extension) internal pure returns(bytes calldata) {\n        return _get(extension, DynamicField.PreInteractionData);\n    }\n\n    /**\n     * @notice Returns the post-interaction from the provided extension calldata.\n     * @param extension The calldata from which the post-interaction is to be retrieved.\n     * @return calldata Bytes representing the post-interaction.\n     */\n    function postInteractionTargetAndData(bytes calldata extension) internal pure returns(bytes calldata) {\n        return _get(extension, DynamicField.PostInteractionData);\n    }\n\n    /**\n     * @notice Returns extra suffix data from the provided extension calldata.\n     * @param extension The calldata from which the extra suffix data is to be retrieved.\n     * @return calldata Bytes representing the extra suffix data.\n     */\n    function customData(bytes calldata extension) internal pure returns(bytes calldata) {\n        if (extension.length < 0x20) return msg.data[:0];\n        uint256 offsets = uint256(bytes32(extension));\n        unchecked {\n            return extension[0x20 + (offsets >> 224):];\n        }\n    }\n\n    /**\n     * @notice Retrieves a specific field from the provided extension calldata.\n     * @dev The first 32 bytes of an extension calldata contain offsets to the end of each field within the calldata.\n     * @param extension The calldata from which the field is to be retrieved.\n     * @param field The specific dynamic field to retrieve from the extension.\n     * @return calldata Bytes representing the requested field.\n     */\n    function _get(bytes calldata extension, DynamicField field) private pure returns(bytes calldata) {\n        if (extension.length < 0x20) return msg.data[:0];\n\n        Offsets offsets;\n        bytes calldata concat;\n        assembly (""memory-safe"") {  // solhint-disable-line no-inline-assembly\n            offsets := calldataload(extension.offset)\n            concat.offset := add(extension.offset, 0x20)\n            concat.length := sub(extension.length, 0x20)\n        }\n\n        return offsets.get(concat, uint256(field));\n    }\n}\n\n// File @1inch/limit-order-protocol-contract/contracts/libraries/AmountCalculatorLib.sol@v4.0.0-prerelease-19\n\n/// @title The helper library to calculate linearly taker amount from maker amount and vice versa.\nlibrary AmountCalculatorLib {\n    /// @notice Calculates maker amount\n    /// @return Result Floored maker amount\n    function getMakingAmount(uint256 orderMakerAmount, uint256 orderTakerAmount, uint256 swapTakerAmount) internal pure returns(uint256) {\n        if ((swapTakerAmount | orderMakerAmount) >> 128 == 0) {\n            unchecked {\n                return (swapTakerAmount * orderMakerAmount) / orderTakerAmount;\n            }\n        }\n        return swapTakerAmount * orderMakerAmount / orderTakerAmount;\n    }\n\n    /// @notice Calculates taker amount\n    /// @return Result Ceiled taker amount\n    function getTakingAmount(uint256 orderMakerAmount, uint256 orderTakerAmount, uint256 swapMakerAmount) internal pure returns(uint256) {\n        if ((swapMakerAmount | orderTakerAmount) >> 128 == 0) {\n            unchecked {\n                return (swapMakerAmount * orderTakerAmount + orderMakerAmount - 1) / orderMakerAmount;\n            }\n        }\n        return (swapMakerAmount * orderTakerAmount + orderMakerAmount - 1) / orderMakerAmount;\n    }\n}\n\n// File @openzeppelin/contracts/interfaces/IERC1271.sol@v5.0.1\n\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1271.sol)\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n\n// File @1inch/solidity-utils/contracts/libraries/ECDSA.sol@v3.7.1\n\nlibrary ECDSA {\n    // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n    // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n    // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n    // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n    //\n    // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n    // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n    // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n    // these malleable signatures as well.\n    uint256 private constant _S_BOUNDARY = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0 + 1;\n    uint256 private constant _COMPACT_S_MASK = 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    uint256 private constant _COMPACT_V_SHIFT = 255;\n\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal view returns (address signer) {\n        assembly (""memory-safe"") { // solhint-disable-line no-inline-assembly\n            if lt(s, _S_BOUNDARY) {\n                let ptr := mload(0x40)\n\n                mstore(ptr, hash)\n                mstore(add(ptr, 0x20), v)\n                mstore(add(ptr, 0x40), r)\n                mstore(add(ptr, 0x60), s)\n                mstore(0, 0)\n                pop(staticcall(gas(), 0x1, ptr, 0x80, 0, 0x20))\n                signer := mload(0)\n            }\n        }\n    }\n\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal view returns (address signer) {\n        assembly (""memory-safe"") { // solhint-disable-line no-inline-assembly\n            let s := and(vs, _COMPACT_S_MASK)\n            if lt(s, _S_BOUNDARY) {\n                let ptr := mload(0x40)\n\n                mstore(ptr, hash)\n                mstore(add(ptr, 0x20), add(27, shr(_COMPACT_V_SHIFT, vs)))\n                mstore(add(ptr, 0x40), r)\n                mstore(add(ptr, 0x60), s)\n                mstore(0, 0)\n                pop(staticcall(gas(), 0x1, ptr, 0x80, 0, 0x20))\n                signer := mload(0)\n            }\n        }\n    }\n\n    /// @dev WARNING!!!\n    /// There is a known signature malleability issue with two representations of signatures!\n    /// Even though this function is able to verify both standard 65-byte and compact 64-byte EIP-2098 signatures\n    /// one should never use raw signatures for any kind of invalidation logic in their code.\n    /// As the standard and compact representations are interchangeable any invalidation logic that relies on\n    /// signature uniqueness will get rekt.\n    /// More info: https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-4h98-2769-gh6h\n    function recover(bytes32 hash, bytes calldata signature) internal view returns (address signer) {\n        assembly (""memory-safe"") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            // memory[ptr:ptr+0x80] = (hash, v, r, s)\n            switch signature.length\n            case 65 {\n                // memory[ptr+0x20:ptr+0x80] = (v, r, s)\n                mstore(add(ptr, 0x20), byte(0, calldataload(add(signature.offset, 0x40))))\n                calldatacopy(add(ptr, 0x40), signature.offset, 0x40)\n            }\n            case 64 {\n                // memory[ptr+0x20:ptr+0x80] = (v, r, s)\n                let vs := calldataload(add(signature.offset, 0x20))\n                mstore(add(ptr, 0x20), add(27, shr(_COMPACT_V_SHIFT, vs)))\n                calldatacopy(add(ptr, 0x40), signature.offset, 0x20)\n                mstore(add(ptr, 0x60), and(vs, _COMPACT_S_MASK))\n            }\n            default {\n                ptr := 0\n            }\n\n            if ptr {\n                if lt(mload(add(ptr, 0x60)), _S_BOUNDARY) {\n                    // memory[ptr:ptr+0x20] = (hash)\n                    mstore(ptr, hash)\n\n                    mstore(0, 0)\n                    pop(staticcall(gas(), 0x1, ptr, 0x80, 0, 0x20))\n                    signer := mload(0)\n                }\n            }\n        }\n    }\n\n    function recoverOrIsValidSignature(\n        address signer,\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view returns (bool success) {\n        if (signer == address(0)) return false;\n        if ((signature.length == 64 || signature.length == 65) && recover(hash, signature) == signer) {\n            return true;\n        }\n        return isValidSignature(signer, hash, signature);\n    }\n\n    function recoverOrIsValidSignature(\n        address signer,\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal view returns (bool success) {\n        if (signer == address(0)) return false;\n        if (recover(hash, v, r, s) == signer) {\n            return true;\n        }\n        return isValidSignature(signer, hash, v, r, s);\n    }\n\n    function recoverOrIsValidSignature(\n        address signer,\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal view returns (bool success) {\n        if (signer == address(0)) return false;\n        if (recover(hash, r, vs) == signer) {\n            return true;\n        }\n        return isValidSignature(signer, hash, r, vs);\n    }\n\n    function recoverOrIsValidSignature65(\n        address signer,\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal view returns (bool success) {\n        if (signer == address(0)) return false;\n        if (recover(hash, r, vs) == signer) {\n            return true;\n        }\n        return isValidSignature65(signer, hash, r, vs);\n    }\n\n    function isValidSignature(\n        address signer,\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view returns (bool success) {\n        // (bool success, bytes memory data) = signer.staticcall(abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature));\n        // return success && data.length >= 4 && abi.decode(data, (bytes4)) == IERC1271.isValidSignature.selector;\n        bytes4 selector = IERC1271.isValidSignature.selector;\n        assembly (""memory-safe"") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            mstore(ptr, selector)\n            mstore(add(ptr, 0x04), hash)\n            mstore(add(ptr, 0x24), 0x40)\n            mstore(add(ptr, 0x44), signature.length)\n            calldatacopy(add(ptr, 0x64), signature.offset, signature.length)\n            if staticcall(gas(), signer, ptr, add(0x64, signature.length), 0, 0x20) {\n                success := and(eq(selector, mload(0)), eq(returndatasize(), 0x20))\n            }\n        }\n    }\n\n    function isValidSignature(\n        address signer,\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal view returns (bool success) {\n        bytes4 selector = IERC1271.isValidSignature.selector;\n        assembly (""memory-safe"") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            mstore(ptr, selector)\n            mstore(add(ptr, 0x04), hash)\n            mstore(add(ptr, 0x24), 0x40)\n            mstore(add(ptr, 0x44), 65)\n            mstore(add(ptr, 0x64), r)\n            mstore(add(ptr, 0x84), s)\n            mstore8(add(ptr, 0xa4), v)\n            if staticcall(gas(), signer, ptr, 0xa5, 0, 0x20) {\n                success := and(eq(selector, mload(0)), eq(returndatasize(), 0x20))\n            }\n        }\n    }\n\n    function isValidSignature(\n        address signer,\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal view returns (bool success) {\n        // (bool success, bytes memory data) = signer.staticcall(abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, abi.encodePacked(r, vs)));\n        // return success && data.length >= 4 && abi.decode(data, (bytes4)) == IERC1271.isValidSignature.selector;\n        bytes4 selector = IERC1271.isValidSignature.selector;\n        assembly (""memory-safe"") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            mstore(ptr, selector)\n            mstore(add(ptr, 0x04), hash)\n            mstore(add(ptr, 0x24), 0x40)\n            mstore(add(ptr, 0x44), 64)\n            mstore(add(ptr, 0x64), r)\n            mstore(add(ptr, 0x84), vs)\n            if staticcall(gas(), signer, ptr, 0xa4, 0, 0x20) {\n                success := and(eq(selector, mload(0)), eq(returndatasize(), 0x20))\n            }\n        }\n    }\n\n    function isValidSignature65(\n        address signer,\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal view returns (bool success) {\n        // (bool success, bytes memory data) = signer.staticcall(abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, abi.encodePacked(r, vs & ~uint256(1 << 255), uint8(vs >> 255))));\n        // return success && data.length >= 4 && abi.decode(data, (bytes4)) == IERC1271.isValidSignature.selector;\n        bytes4 selector = IERC1271.isValidSignature.selector;\n        assembly (""memory-safe"") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            mstore(ptr, selector)\n            mstore(add(ptr, 0x04), hash)\n            mstore(add(ptr, 0x24), 0x40)\n            mstore(add(ptr, 0x44), 65)\n            mstore(add(ptr, 0x64), r)\n            mstore(add(ptr, 0x84), and(vs, _COMPACT_S_MASK))\n            mstore8(add(ptr, 0xa4), add(27, shr(_COMPACT_V_SHIFT, vs)))\n            if staticcall(gas(), signer, ptr, 0xa5, 0, 0x20) {\n                success := and(eq(selector, mload(0)), eq(returndatasize(), 0x20))\n            }\n        }\n    }\n\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 res) {\n        // 32 is the length in bytes of hash, enforced by the type signature above\n        // return keccak256(abi.encodePacked(""\\x19Ethereum Signed Message:\\n32"", hash));\n        assembly (""memory-safe"") { // solhint-disable-line no-inline-assembly\n            mstore(0, 0x19457468657265756d205369676e6564204d6573736167653a0a333200000000) // ""\\x19Ethereum Signed Message:\\n32""\n            mstore(28, hash)\n            res := keccak256(0, 60)\n        }\n    }\n\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 res) {\n        // return keccak256(abi.encodePacked(""\\x19\\x01"", domainSeparator, structHash));\n        assembly (""memory-safe"") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n            mstore(ptr, 0x1901000000000000000000000000000000000000000000000000000000000000) // ""\\x19\\x01""\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            res := keccak256(ptr, 66)\n        }\n    }\n}\n\n// File @1inch/limit-order-protocol-contract/contracts/OrderLib.sol@v4.0.0-prerelease-19\n\n/**\n * @title OrderLib\n * @dev The library provides common functionality for processing and manipulating limit orders.\n * It provides functionality to calculate and verify order hashes, calculate trade amounts, and validate\n * extension data associated with orders. The library also contains helper methods to get the receiver of\n * an order and call getter functions.\n */\n library OrderLib {\n    using AddressLib for Address;\n    using MakerTraitsLib for MakerTraits;\n    using ExtensionLib for bytes;\n\n    /// @dev Error to be thrown when the extension data of an order is missing.\n    error MissingOrderExtension();\n    /// @dev Error to be thrown when the order has an unexpected extension.\n    error UnexpectedOrderExtension();\n    /// @dev Error to be thrown when the order extension hash is invalid.\n    error InvalidExtensionHash();\n\n    /// @dev The typehash of the order struct.\n    bytes32 constant internal _LIMIT_ORDER_TYPEHASH = keccak256(\n        ""Order(""\n            ""uint256 salt,""\n            ""address maker,""\n            ""address receiver,""\n            ""address makerAsset,""\n            ""address takerAsset,""\n            ""uint256 makingAmount,""\n            ""uint256 takingAmount,""\n            ""uint256 makerTraits""\n        "")""\n    );\n    uint256 constant internal _ORDER_STRUCT_SIZE = 0x100;\n    uint256 constant internal _DATA_HASH_SIZE = 0x120;\n\n    /**\n      * @notice Calculates the hash of an order.\n      * @param order The order to be hashed.\n      * @param domainSeparator The domain separator to be used for the EIP-712 hashing.\n      * @return result The keccak256 hash of the order data.\n      */\n    function hash(IOrderMixin.Order calldata order, bytes32 domainSeparator) internal pure returns(bytes32 result) {\n        bytes32 typehash = _LIMIT_ORDER_TYPEHASH;\n        assembly (""memory-safe"") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            // keccak256(abi.encode(_LIMIT_ORDER_TYPEHASH, order));\n            mstore(ptr, typehash)\n            calldatacopy(add(ptr, 0x20), order, _ORDER_STRUCT_SIZE)\n            result := keccak256(ptr, _DATA_HASH_SIZE)\n        }\n        result = ECDSA.toTypedDataHash(domainSeparator, result);\n    }\n\n    /**\n      * @notice Returns the receiver address for an order.\n      * @param order The order.\n      * @return receiver The address of the receiver, either explicitly defined in the order or the maker\'s address if not specified.\n      */\n    function getReceiver(IOrderMixin.Order calldata order) internal pure returns(address /*receiver*/) {\n        address receiver = order.receiver.get();\n        return receiver != address(0) ? receiver : order.maker.get();\n    }\n\n    /**\n      * @notice Calculates the making amount based on the requested taking amount.\n      * @dev If getter is specified in the extension data, the getter is called to calculate the making amount,\n      * otherwise the making amount is calculated linearly.\n      * @param order The order.\n      * @param extension The extension data associated with the order.\n      * @param requestedTakingAmount The amount the taker wants to take.\n      * @param remainingMakingAmount The remaining amount of the asset left to fill.\n      * @param orderHash The hash of the order.\n      * @return makingAmount The amount of the asset the maker receives.\n      */\n    function calculateMakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        uint256 requestedTakingAmount,\n        uint256 remainingMakingAmount,\n        bytes32 orderHash\n    ) internal view returns(uint256) {\n        bytes calldata data = extension.makingAmountData();\n        if (data.length == 0) {\n            // Linear proportion\n            return AmountCalculatorLib.getMakingAmount(order.makingAmount, order.takingAmount, requestedTakingAmount);\n        }\n        return IAmountGetter(address(bytes20(data))).getMakingAmount(\n            order,\n            extension,\n            orderHash,\n            msg.sender,\n            requestedTakingAmount,\n            remainingMakingAmount,\n            data[20:]\n        );\n    }\n\n    /**\n      * @notice Calculates the taking amount based on the requested making amount.\n      * @dev If getter is specified in the extension data, the getter is called to calculate the taking amount,\n      * otherwise the taking amount is calculated linearly.\n      * @param order The order.\n      * @param extension The extension data associated with the order.\n      * @param requestedMakingAmount The amount the maker wants to receive.\n      * @param remainingMakingAmount The remaining amount of the asset left to be filled.\n      * @param orderHash The hash of the order.\n      * @return takingAmount The amount of the asset the taker takes.\n      */\n    function calculateTakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata extension,\n        uint256 requestedMakingAmount,\n        uint256 remainingMakingAmount,\n        bytes32 orderHash\n    ) internal view returns(uint256) {\n        bytes calldata data = extension.takingAmountData();\n        if (data.length == 0) {\n            // Linear proportion\n            return AmountCalculatorLib.getTakingAmount(order.makingAmount, order.takingAmount, requestedMakingAmount);\n        }\n        return IAmountGetter(address(bytes20(data))).getTakingAmount(\n            order,\n            extension,\n            orderHash,\n            msg.sender,\n            requestedMakingAmount,\n            remainingMakingAmount,\n            data[20:]\n        );\n    }\n\n    /**\n      * @dev Validates the extension associated with an order.\n      * @param order The order to validate against.\n      * @param extension The extension associated with the order.\n      * @return valid True if the extension is valid, false otherwise.\n      * @return errorSelector The error selector if the extension is invalid, 0x00000000 otherwise.\n      */\n    function isValidExtension(IOrderMixin.Order calldata order, bytes calldata extension) internal pure returns(bool, bytes4) {\n        if (order.makerTraits.hasExtension()) {\n            if (extension.length == 0) return (false, MissingOrderExtension.selector);\n            // Lowest 160 bits of the order salt must be equal to the lowest 160 bits of the extension hash\n            if (uint256(keccak256(extension)) & type(uint160).max != order.salt & type(uint160).max) return (false, InvalidExtensionHash.selector);\n        } else {\n            if (extension.length > 0) return (false, UnexpectedOrderExtension.selector);\n        }\n        return (true, 0x00000000);\n    }\n}\n\n// File @1inch/limit-order-protocol-contract/contracts/helpers/PredicateHelper.sol@v4.0.0-prerelease-19\n\n/// @title A helper contract for executing boolean functions on arbitrary target call results\ncontract PredicateHelper {\n    error ArbitraryStaticCallFailed();\n\n    /// @notice Calls every target with corresponding data\n    /// @return Result True if call to any target returned True. Otherwise, false\n    function or(uint256 offsets, bytes calldata data) public view returns(bool) {\n        uint256 previous;\n        for (uint256 current; (current = uint32(offsets)) != 0; offsets >>= 32) {\n            (bool success, uint256 res) = _staticcallForUint(address(this), data[previous:current]);\n            if (success && res == 1) {\n                return true;\n            }\n            previous = current;\n        }\n        return false;\n    }\n\n    /// @notice Calls every target with corresponding data\n    /// @return Result True if calls to all targets returned True. Otherwise, false\n    function and(uint256 offsets, bytes calldata data) public view returns(bool) {\n        uint256 previous;\n        for (uint256 current; (current = uint32(offsets)) != 0; offsets >>= 32) {\n            (bool success, uint256 res) = _staticcallForUint(address(this), data[previous:current]);\n            if (!success || res != 1) {\n                return false;\n            }\n            previous = current;\n        }\n        return true;\n    }\n\n    /// @notice Calls target with specified data and tests if it\'s equal to 0\n    /// @return Result True if call to target returns 0. Otherwise, false\n    function not(bytes calldata data) public view returns(bool) {\n        (bool success, uint256 res) = _staticcallForUint(address(this), data);\n        return success && res == 0;\n    }\n\n    /// @notice Calls target with specified data and tests if it\'s equal to the value\n    /// @param value Value to test\n    /// @return Result True if call to target returns the same value as `value`. Otherwise, false\n    function eq(uint256 value, bytes calldata data) public view returns(bool) {\n        (bool success, uint256 res) = _staticcallForUint(address(this), data);\n        return success && res == value;\n    }\n\n    /// @notice Calls target with specified data and tests if it\'s lower than value\n    /// @param value Value to test\n    /// @return Result True if call to target returns value which is lower than `value`. Otherwise, false\n    function lt(uint256 value, bytes calldata data) public view returns(bool) {\n        (bool success, uint256 res) = _staticcallForUint(address(this), data);\n        return success && res < value;\n    }\n\n    /// @notice Calls target with specified data and tests if it\'s bigger than value\n    /// @param value Value to test\n    /// @return Result True if call to target returns value which is bigger than `value`. Otherwise, false\n    function gt(uint256 value, bytes calldata data) public view returns(bool) {\n        (bool success, uint256 res) = _staticcallForUint(address(this), data);\n        return success && res > value;\n    }\n\n    /// @notice Performs an arbitrary call to target with data\n    /// @return Result Bytes transmuted to uint256\n    function arbitraryStaticCall(address target, bytes calldata data) public view returns(uint256) {\n        (bool success, uint256 res) = _staticcallForUint(target, data);\n        if (!success) revert ArbitraryStaticCallFailed();\n        return res;\n    }\n\n    function _staticcallForUint(address target, bytes calldata data) internal view returns(bool success, uint256 res) {\n        assembly (""memory-safe"") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            calldatacopy(ptr, data.offset, data.length)\n            success := staticcall(gas(), target, ptr, data.length, 0x0, 0x20)\n            success := and(success, eq(returndatasize(), 32))\n            if success {\n                res := mload(0)\n            }\n        }\n    }\n}\n\n// File @1inch/limit-order-protocol-contract/contracts/helpers/SeriesEpochManager.sol@v4.0.0-prerelease-19\n\n/// @title A helper contract to manage nonce with the series\ncontract SeriesEpochManager {\n    error AdvanceEpochFailed();\n    event EpochIncreased(address indexed maker, uint256 series, uint256 newEpoch);\n\n    // {\n    //    1: {\n    //        \'0x762f73Ad...842Ffa8\': 0,\n    //        \'0xd20c41ee...32aaDe2\': 1\n    //    },\n    //    2: {\n    //        \'0x762f73Ad...842Ffa8\': 3,\n    //        \'0xd20c41ee...32aaDe2\': 15\n    //    },\n    //    ...\n    // }\n    mapping(uint256 seriesId => uint256 epoch) private _epochs;\n\n    /// @notice Returns nonce for `maker` and `series`\n    function epoch(address maker, uint96 series) public view returns(uint256) {\n        return _epochs[uint160(maker) | (uint256(series) << 160)];\n    }\n\n    /// @notice Advances nonce by one\n    function increaseEpoch(uint96 series) external {\n        advanceEpoch(series, 1);\n    }\n\n    /// @notice Advances nonce by specified amount\n    function advanceEpoch(uint96 series, uint256 amount) public {\n        if (amount == 0 || amount > 255) revert AdvanceEpochFailed();\n        unchecked {\n            uint256 key = uint160(msg.sender) | (uint256(series) << 160);\n            uint256 newEpoch = _epochs[key] + amount;\n            _epochs[key] = newEpoch;\n            emit EpochIncreased(msg.sender, series, newEpoch);\n        }\n    }\n\n    /// @notice Checks if `maker` has specified `makerEpoch` for `series`\n    /// @return Result True if `maker` has specified epoch. Otherwise, false\n    function epochEquals(address maker, uint256 series, uint256 makerEpoch) public view returns(bool) {\n        return _epochs[uint160(maker) | (uint256(series) << 160)] == makerEpoch;\n    }\n}\n\n// File @1inch/limit-order-protocol-contract/contracts/libraries/BitInvalidatorLib.sol@v4.0.0-prerelease-19\n\n/**\n * @title BitInvalidatorLib\n * @dev The library provides a mechanism to invalidate objects based on a bit invalidator.\n * The bit invalidator holds a mapping where each key represents a slot number and each value contains an integer.\n * Each bit of the integer represents whether the object with corresponding index is valid or has been invalidated (0 - valid, 1 - invalidated).\n * The nonce given to access or invalidate an entity\'s state follows this structure:\n * - bits [0..7] represent the object state index in the slot.\n * - bits [8..255] represent the slot number (mapping key).\n */\nlibrary BitInvalidatorLib {\n    /// @dev The error is thrown when an attempt is made to invalidate an already invalidated entity.\n    error BitInvalidatedOrder();\n\n    struct Data {\n        mapping(uint256 slotIndex => uint256 slotData) _raw;\n    }\n\n    /**\n     * @notice Retrieves the validity status of entities in a specific slot.\n     * @dev Each bit in the returned value corresponds to the validity of an entity. 0 for valid, 1 for invalidated.\n     * @param self The data structure.\n     * @param nonce The nonce identifying the slot.\n     * @return result The validity status of entities in the slot as a uint256.\n     */\n    function checkSlot(Data storage self, uint256 nonce) internal view returns(uint256) {\n        uint256 invalidatorSlot = nonce >> 8;\n        return self._raw[invalidatorSlot];\n    }\n\n    /**\n     * @notice Checks the validity of a specific entity and invalidates it if valid.\n     * @dev Throws an error if the entity has already been invalidated.\n     * @param self The data structure.\n     * @param nonce The nonce identifying the slot and the entity.\n     */\n    function checkAndInvalidate(Data storage self, uint256 nonce) internal {\n        uint256 invalidatorSlot = nonce >> 8;\n        uint256 invalidatorBit = 1 << (nonce & 0xff);\n        uint256 invalidator = self._raw[invalidatorSlot];\n        if (invalidator & invalidatorBit == invalidatorBit) revert BitInvalidatedOrder();\n        self._raw[invalidatorSlot] = invalidator | invalidatorBit;\n    }\n\n    /**\n     * @notice Invalidates multiple entities in a single slot.\n     * @dev The entities to be invalidated are identified by setting their corresponding bits to 1 in a mask.\n     * @param self The data structure.\n     * @param nonce The nonce identifying the slot.\n     * @param additionalMask A mask of bits to be invalidated.\n     * @return result Resulting validity status of entities in the slot as a uint256.\n     */\n    function massInvalidate(Data storage self, uint256 nonce, uint256 additionalMask) internal returns(uint256 result) {\n        uint256 invalidatorSlot = nonce >> 8;\n        uint256 invalidatorBits = (1 << (nonce & 0xff)) | additionalMask;\n        result = self._raw[invalidatorSlot] | invalidatorBits;\n        self._raw[invalidatorSlot] = result;\n    }\n}\n\n// File @1inch/limit-order-protocol-contract/contracts/libraries/Errors.sol@v4.0.0-prerelease-19\n\nlibrary Errors {\n    error InvalidMsgValue();\n    error ETHTransferFailed();\n}\n\n// File @1inch/limit-order-protocol-contract/contracts/libraries/RemainingInvalidatorLib.sol@v4.0.0-prerelease-19\n\ntype RemainingInvalidator is uint256;\n\n/**\n * @title RemainingInvalidatorLib\n * @notice The library provides a mechanism to invalidate order based on the remaining amount of the order.\n * @dev The remaining amount is used as a nonce to invalidate the order.\n * When order is created, the remaining invalidator is 0.\n * When order is filled, the remaining invalidator is the inverse of the remaining amount.\n */\nlibrary RemainingInvalidatorLib {\n\n    /// @dev The error is thrown when an attempt is made to invalidate an already invalidated entity.\n    error RemainingInvalidatedOrder();\n\n    /**\n     * @notice Checks if an order is new based on the invalidator value.\n     * @param invalidator The remaining invalidator of the order.\n     * @return result Whether the order is new or not.\n     */\n    function isNewOrder(RemainingInvalidator invalidator) internal pure returns(bool) {\n        return RemainingInvalidator.unwrap(invalidator) == 0;\n    }\n\n    /**\n     * @notice Retrieves the remaining amount for an order.\n     * @dev If the order is unknown, a RemainingInvalidatedOrder error is thrown.\n     * @param invalidator The remaining invalidator for the order.\n     * @return result The remaining amount for the order.\n     */\n    function remaining(RemainingInvalidator invalidator) internal pure returns(uint256) {\n        uint256 value = RemainingInvalidator.unwrap(invalidator);\n        if (value == 0) {\n            revert RemainingInvalidatedOrder();\n        }\n        unchecked {\n            return ~value;\n        }\n    }\n\n    /**\n     * @notice Calculates the remaining amount for an order.\n     * @dev If the order is unknown, the order maker amount is returned.\n     * @param invalidator The remaining invalidator for the order.\n     * @param orderMakerAmount The amount to return if the order is new.\n     * @return result The remaining amount for the order.\n     */\n    function remaining(RemainingInvalidator invalidator, uint256 orderMakerAmount) internal pure returns(uint256) {\n        uint256 value = RemainingInvalidator.unwrap(invalidator);\n        if (value == 0) {\n            return orderMakerAmount;\n        }\n        unchecked {\n            return ~value;\n        }\n    }\n\n    /**\n     * @notice Calculates the remaining invalidator of the order.\n     * @param remainingMakingAmount The remaining making amount of the order.\n     * @param makingAmount The making amount of the order.\n     * @return result The remaining invalidator for the order.\n     */\n    function remains(uint256 remainingMakingAmount, uint256 makingAmount) internal pure returns(RemainingInvalidator) {\n        unchecked {\n            return RemainingInvalidator.wrap(~(remainingMakingAmount - makingAmount));\n        }\n    }\n\n    /**\n     * @notice Provides the remaining invalidator for a fully filled order.\n     * @return result The remaining invalidator for a fully filled order.\n     */\n    function fullyFilled() internal pure returns(RemainingInvalidator) {\n        return RemainingInvalidator.wrap(type(uint256).max);\n    }\n}\n\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v5.0.1\n\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller\'s account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller\'s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\'s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller\'s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n\n// File @1inch/solidity-utils/contracts/interfaces/IWETH.sol@v3.7.1\n\ninterface IWETH is IERC20 {\n    event Deposit(address indexed dst, uint256 wad);\n\n    event Withdrawal(address indexed src, uint256 wad);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 amount) external;\n}\n\n// File @1inch/solidity-utils/contracts/interfaces/IDaiLikePermit.sol@v3.7.1\n\ninterface IDaiLikePermit {\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\n// File @1inch/solidity-utils/contracts/interfaces/IPermit2.sol@v3.7.1\n\ninterface IPermit2 {\n    struct PermitDetails {\n        // ERC20 token address\n        address token;\n        // the maximum amount allowed to spend\n        uint160 amount;\n        // timestamp at which a spender\'s token allowances become invalid\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n    /// @notice The permit message signed for a single token allownce\n    struct PermitSingle {\n        // the permit data for a single token alownce\n        PermitDetails details;\n        // address permissioned on the allowed tokens\n        address spender;\n        // deadline on the permit signature\n        uint256 sigDeadline;\n    }\n    /// @notice Packed allowance\n    struct PackedAllowance {\n        // amount allowed\n        uint160 amount;\n        // permission expiry\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n\n    function transferFrom(address user, address spender, uint160 amount, address token) external;\n\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n\n    function allowance(address user, address token, address spender) external view returns (PackedAllowance memory);\n}\n\n// File @1inch/solidity-utils/contracts/libraries/RevertReasonForwarder.sol@v3.7.1\n\n/// @title Revert reason forwarder.\nlibrary RevertReasonForwarder {\n    /// @dev Forwards latest externall call revert.\n    function reRevert() internal pure {\n        // bubble up revert reason from latest external call\n        assembly (""memory-safe"") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n            returndatacopy(ptr, 0, returndatasize())\n            revert(ptr, returndatasize())\n        }\n    }\n\n    /// @dev Returns latest external call revert reason.\n    function reReason() internal pure returns (bytes memory reason) {\n        assembly (""memory-safe"") { // solhint-disable-line no-inline-assembly\n            reason := mload(0x40)\n            let length := returndatasize()\n            mstore(reason, length)\n            returndatacopy(add(reason, 0x20), 0, length)\n            mstore(0x40, add(reason, add(0x20, length)))\n        }\n    }\n}\n\n// File @openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol@v5.0.1\n\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account\'s ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn\'t\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don\'t rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``\'s tokens,\n     * given ``owner``\'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``\'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``\'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n\n// File @1inch/solidity-utils/contracts/libraries/SafeERC20.sol@v3.7.1\n\n/**\n * @title Implements efficient safe methods for ERC20 interface.\n * @notice Compared to the standard ERC20, this implementation offers several enhancements:\n * 1. more gas-efficient, providing significant savings in transaction costs.\n * 2. support for different permit implementations\n * 3. forceApprove functionality\n * 4. support for WETH deposit and withdraw\n */\nlibrary SafeERC20 {\n    error SafeTransferFailed();\n    error SafeTransferFromFailed();\n    error ForceApproveFailed();\n    error SafeIncreaseAllowanceFailed();\n    error SafeDecreaseAllowanceFailed();\n    error SafePermitBadLength();\n    error Permit2TransferAmountTooHigh();\n\n    // Uniswap Permit2 address\n    address private constant _PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n    bytes4 private constant _PERMIT_LENGTH_ERROR = 0x68275857;  // SafePermitBadLength.selector\n    uint256 private constant _RAW_CALL_GAS_LIMIT = 5000;\n\n    /**\n     * @notice Fetches the balance of a specific ERC20 token held by an account.\n     * Consumes less gas then regular `ERC20.balanceOf`.\n     * @dev Note that the implementation does not perform dirty bits cleaning, so it is the\n     * responsibility of the caller to make sure that the higher 96 bits of the `account` parameter are clean.\n     * @param token The IERC20 token contract for which the balance will be fetched.\n     * @param account The address of the account whose token balance will be fetched.\n     * @return tokenBalance The balance of the specified ERC20 token held by the account.\n     */\n    function safeBalanceOf(\n        IERC20 token,\n        address account\n    ) internal view returns(uint256 tokenBalance) {\n        bytes4 selector = IERC20.balanceOf.selector;\n        assembly (""memory-safe"") { // solhint-disable-line no-inline-assembly\n            mstore(0x00, selector)\n            mstore(0x04, account)\n            let success := staticcall(gas(), token, 0x00, 0x24, 0x00, 0x20)\n            tokenBalance := mload(0)\n\n            if or(iszero(success), lt(returndatasize(), 0x20)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens from one address to another.\n     * @dev If permit2 is true, uses the Permit2 standard; otherwise uses the standard ERC20 transferFrom.\n     * Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `from` and `to` parameters are clean.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param amount The amount of tokens to transfer.\n     * @param permit2 If true, uses the Permit2 standard for the transfer; otherwise uses the standard ERC20 transferFrom.\n     */\n    function safeTransferFromUniversal(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        bool permit2\n    ) internal {\n        if (permit2) {\n            safeTransferFromPermit2(token, from, to, amount);\n        } else {\n            safeTransferFrom(token, from, to, amount);\n        }\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens from one address to another using the ERC20 standard.\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `from` and `to` parameters are clean.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param amount The amount of tokens to transfer.\n     */\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bytes4 selector = token.transferFrom.selector;\n        bool success;\n        assembly (""memory-safe"") { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n\n            mstore(data, selector)\n            mstore(add(data, 0x04), from)\n            mstore(add(data, 0x24), to)\n            mstore(add(data, 0x44), amount)\n            success := call(gas(), token, 0, data, 100, 0x0, 0x20)\n            if success {\n                switch returndatasize()\n                case 0 {\n                    success := gt(extcodesize(token), 0)\n                }\n                default {\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\n                }\n            }\n        }\n        if (!success) revert SafeTransferFromFailed();\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens from one address to another using the Permit2 standard.\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `from` and `to` parameters are clean.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param amount The amount of tokens to transfer.\n     */\n    function safeTransferFromPermit2(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        if (amount > type(uint160).max) revert Permit2TransferAmountTooHigh();\n        bytes4 selector = IPermit2.transferFrom.selector;\n        bool success;\n        assembly (""memory-safe"") { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n\n            mstore(data, selector)\n            mstore(add(data, 0x04), from)\n            mstore(add(data, 0x24), to)\n            mstore(add(data, 0x44), amount)\n            mstore(add(data, 0x64), token)\n            success := call(gas(), _PERMIT2, 0, data, 0x84, 0x0, 0x0)\n            if success {\n                success := gt(extcodesize(_PERMIT2), 0)\n            }\n        }\n        if (!success) revert SafeTransferFromFailed();\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens to another address.\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `to` parameter are clean.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param value The amount of tokens to transfer.\n     */\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        if (!_makeCall(token, token.transfer.selector, to, value)) {\n            revert SafeTransferFailed();\n        }\n    }\n\n    /**\n     * @notice Attempts to approve a spender to spend a certain amount of tokens.\n     * @dev If `approve(from, to, amount)` fails, it tries to set the allowance to zero, and retries the `approve` call.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `spender` parameter are clean.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     */\n    function forceApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        if (!_makeCall(token, token.approve.selector, spender, value)) {\n            if (\n                !_makeCall(token, token.approve.selector, spender, 0) ||\n                !_makeCall(token, token.approve.selector, spender, value)\n            ) {\n                revert ForceApproveFailed();\n            }\n        }\n    }\n\n    /**\n     * @notice Safely increases the allowance of a spender.\n     * @dev Increases with safe math check. Checks if the increased allowance will overflow, if yes, then it reverts the transaction.\n     * Then uses `forceApprove` to increase the allowance.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `spender` parameter are clean.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to increase the allowance by.\n     */\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 allowance = token.allowance(address(this), spender);\n        if (value > type(uint256).max - allowance) revert SafeIncreaseAllowanceFailed();\n        forceApprove(token, spender, allowance + value);\n    }\n\n    /**\n     * @notice Safely decreases the allowance of a spender.\n     * @dev Decreases with safe math check. Checks if the decreased allowance will underflow, if yes, then it reverts the transaction.\n     * Then uses `forceApprove` to increase the allowance.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `spender` parameter are clean.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to decrease the allowance by.\n     */\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 allowance = token.allowance(address(this), spender);\n        if (value > allowance) revert SafeDecreaseAllowanceFailed();\n        forceApprove(token, spender, allowance - value);\n    }\n\n    /**\n     * @notice Attempts to execute the `permit` function on the provided token with the sender and contract as parameters.\n     * Permit type is determined automatically based on permit calldata (IERC20Permit, IDaiLikePermit, and IPermit2).\n     * @dev Wraps `tryPermit` function and forwards revert reason if permit fails.\n     * @param token The IERC20 token to execute the permit function on.\n     * @param permit The permit data to be used in the function call.\n     */\n    function safePermit(IERC20 token, bytes calldata permit) internal {\n        if (!tryPermit(token, msg.sender, address(this), permit)) RevertReasonForwarder.reRevert();\n    }\n\n    /**\n     * @notice Attempts to execute the `permit` function on the provided token with custom owner and spender parameters.\n     * Permit type is determined automatically based on permit calldata (IERC20Permit, IDaiLikePermit, and IPermit2).\n     * @dev Wraps `tryPermit` function and forwards revert reason if permit fails.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `owner` and `spender` parameters are clean.\n     * @param token The IERC20 token to execute the permit function on.\n     * @param owner The owner of the tokens for which the permit is made.\n     * @param spender The spender allowed to spend the tokens by the permit.\n     * @param permit The permit data to be used in the function call.\n     */\n    function safePermit(IERC20 token, address owner, address spender, bytes calldata permit) internal {\n        if (!tryPermit(token, owner, spender, permit)) RevertReasonForwarder.reRevert();\n    }\n\n    /**\n     * @notice Attempts to execute the `permit` function on the provided token with the sender and contract as parameters.\n     * @dev Invokes `tryPermit` with sender as owner and contract as spender.\n     * @param token The IERC20 token to execute the permit function on.\n     * @param permit The permit data to be used in the function call.\n     * @return success Returns true if the permit function was successfully executed, false otherwise.\n     */\n    function tryPermit(IERC20 token, bytes calldata permit) internal returns(bool success) {\n        return tryPermit(token, msg.sender, address(this), permit);\n    }\n\n    /**\n     * @notice The function attempts to call the permit function on a given ERC20 token.\n     * @dev The function is designed to support a variety of permit functions, namely: IERC20Permit, IDaiLikePermit, and IPermit2.\n     * It accommodates both Compact and Full formats of these permit types.\n     * Please note, it is expected that the `expiration` parameter for the compact Permit2 and the `deadline` parameter\n     * for the compact Permit are to be incremented by one before invoking this function. This approach is motivated by\n     * gas efficiency considerations; as the unlimited expiration period is likely to be the most common scenario, and\n     * zeros are cheaper to pass in terms of gas cost. Thus, callers should increment the expiration or deadline by one\n     * before invocation for optimized performance.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `owner` and `spender` parameters are clean.\n     * @param token The address of the ERC20 token on which to call the permit function.\n     * @param owner The owner of the tokens. This address should have signed the off-chain permit.\n     * @param spender The address which will be approved for transfer of tokens.\n     * @param permit The off-chain permit data, containing different fields depending on the type of permit function.\n     * @return success A boolean indicating whether the permit call was successful.\n     */\n    function tryPermit(IERC20 token, address owner, address spender, bytes calldata permit) internal returns(bool success) {\n        // load function selectors for different permit standards\n        bytes4 permitSelector = IERC20Permit.permit.selector;\n        bytes4 daiPermitSelector = IDaiLikePermit.permit.selector;\n        bytes4 permit2Selector = IPermit2.permit.selector;\n        assembly (""memory-safe"") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            // Switch case for different permit lengths, indicating different permit standards\n            switch permit.length\n            // Compact IERC20Permit\n            case 100 {\n                mstore(ptr, permitSelector)     // store selector\n                mstore(add(ptr, 0x04), owner)   // store owner\n                mstore(add(ptr, 0x24), spender) // store spender\n\n                // Compact IERC20Permit.permit(uint256 value, uint32 deadline, uint256 r, uint256 vs)\n                {  // stack too deep\n                    let deadline := shr(224, calldataload(add(permit.offset, 0x20))) // loads permit.offset 0x20..0x23\n                    let vs := calldataload(add(permit.offset, 0x44))                 // loads permit.offset 0x44..0x63\n\n                    calldatacopy(add(ptr, 0x44), permit.offset, 0x20)            // store value     = copy permit.offset 0x00..0x19\n                    mstore(add(ptr, 0x64), sub(deadline, 1))                     // store deadline  = deadline - 1\n                    mstore(add(ptr, 0x84), add(27, shr(255, vs)))                // store v         = most significant bit of vs + 27 (27 or 28)\n                    calldatacopy(add(ptr, 0xa4), add(permit.offset, 0x24), 0x20) // store r         = copy permit.offset 0x24..0x43\n                    mstore(add(ptr, 0xc4), shr(1, shl(1, vs)))                   // store s         = vs without most significant bit\n                }\n                // IERC20Permit.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0xe4, 0, 0)\n            }\n            // Compact IDaiLikePermit\n            case 72 {\n                mstore(ptr, daiPermitSelector)  // store selector\n                mstore(add(ptr, 0x04), owner)   // store owner\n                mstore(add(ptr, 0x24), spender) // store spender\n\n                // Compact IDaiLikePermit.permit(uint32 nonce, uint32 expiry, uint256 r, uint256 vs)\n                {  // stack too deep\n                    let expiry := shr(224, calldataload(add(permit.offset, 0x04))) // loads permit.offset 0x04..0x07\n                    let vs := calldataload(add(permit.offset, 0x28))               // loads permit.offset 0x28..0x47\n\n                    mstore(add(ptr, 0x44), shr(224, calldataload(permit.offset))) // store nonce   = copy permit.offset 0x00..0x03\n                    mstore(add(ptr, 0x64), sub(expiry, 1))                        // store expiry  = expiry - 1\n                    mstore(add(ptr, 0x84), true)                                  // store allowed = true\n                    mstore(add(ptr, 0xa4), add(27, shr(255, vs)))                 // store v       = most significant bit of vs + 27 (27 or 28)\n                    calldatacopy(add(ptr, 0xc4), add(permit.offset, 0x08), 0x20)  // store r       = copy permit.offset 0x08..0x27\n                    mstore(add(ptr, 0xe4), shr(1, shl(1, vs)))                    // store s       = vs without most significant bit\n                }\n                // IDaiLikePermit.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0x104, 0, 0)\n            }\n            // IERC20Permit\n            case 224 {\n                mstore(ptr, permitSelector)\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\n                // IERC20Permit.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0xe4, 0, 0)\n            }\n            // IDaiLikePermit\n            case 256 {\n                mstore(ptr, daiPermitSelector)\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\n                // IDaiLikePermit.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0x104, 0, 0)\n            }\n            // Compact IPermit2\n            case 96 {\n                // Compact IPermit2.permit(uint160 amount, uint32 expiration, uint32 nonce, uint32 sigDeadline, uint256 r, uint256 vs)\n                mstore(ptr, permit2Selector)  // store selector\n                mstore(add(ptr, 0x04), owner) // store owner\n                mstore(add(ptr, 0x24), token) // store token\n\n                calldatacopy(add(ptr, 0x50), permit.offset, 0x14)             // store amount = copy permit.offset 0x00..0x13\n                // and(0xffffffffffff, ...) - conversion to uint48\n                mstore(add(ptr, 0x64), and(0xffffffffffff, sub(shr(224, calldataload(add(permit.offset, 0x14))), 1))) // store expiration = ((permit.offset 0x14..0x17 - 1) & 0xffffffffffff)\n                mstore(add(ptr, 0x84), shr(224, calldataload(add(permit.offset, 0x18)))) // store nonce = copy permit.offset 0x18..0x1b\n                mstore(add(ptr, 0xa4), spender)                               // store spender\n                // and(0xffffffffffff, ...) - conversion to uint48\n                mstore(add(ptr, 0xc4), and(0xffffffffffff, sub(shr(224, calldataload(add(permit.offset, 0x1c))), 1))) // store sigDeadline = ((permit.offset 0x1c..0x1f - 1) & 0xffffffffffff)\n                mstore(add(ptr, 0xe4), 0x100)                                 // store offset = 256\n                mstore(add(ptr, 0x104), 0x40)                                 // store length = 64\n                calldatacopy(add(ptr, 0x124), add(permit.offset, 0x20), 0x20) // store r      = copy permit.offset 0x20..0x3f\n                calldatacopy(add(ptr, 0x144), add(permit.offset, 0x40), 0x20) // store vs     = copy permit.offset 0x40..0x5f\n                // IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\n                success := call(gas(), _PERMIT2, 0, ptr, 0x164, 0, 0)\n            }\n            // IPermit2\n            case 352 {\n                mstore(ptr, permit2Selector)\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\n                // IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\n                success := call(gas(), _PERMIT2, 0, ptr, 0x164, 0, 0)\n            }\n            // Unknown\n            default {\n                mstore(ptr, _PERMIT_LENGTH_ERROR)\n                revert(ptr, 4)\n            }\n        }\n    }\n\n    /**\n     * @dev Executes a low level call to a token contract, making it resistant to reversion and erroneous boolean returns.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param selector The function signature that is to be called on the token contract.\n     * @param to The address to which the token amount will be transferred.\n     * @param amount The token amount to be transferred.\n     * @return success A boolean indicating if the call was successful. Returns \'true\' on success and \'false\' on failure.\n     * In case of success but no returned data, validates that the contract code exists.\n     * In case of returned data, ensures that it\'s a boolean `true`.\n     */\n    function _makeCall(\n        IERC20 token,\n        bytes4 selector,\n        address to,\n        uint256 amount\n    ) private returns (bool success) {\n        assembly (""memory-safe"") { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n\n            mstore(data, selector)\n            mstore(add(data, 0x04), to)\n            mstore(add(data, 0x24), amount)\n            success := call(gas(), token, 0, data, 0x44, 0x0, 0x20)\n            if success {\n                switch returndatasize()\n                case 0 {\n                    success := gt(extcodesize(token), 0)\n                }\n                default {\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Safely deposits a specified amount of Ether into the IWETH contract. Consumes less gas then regular `IWETH.deposit`.\n     * @param weth The IWETH token contract.\n     * @param amount The amount of Ether to deposit into the IWETH contract.\n     */\n    function safeDeposit(IWETH weth, uint256 amount) internal {\n        if (amount > 0) {\n            bytes4 selector = IWETH.deposit.selector;\n            assembly (""memory-safe"") { // solhint-disable-line no-inline-assembly\n                mstore(0, selector)\n                if iszero(call(gas(), weth, amount, 0, 4, 0, 0)) {\n                    let ptr := mload(0x40)\n                    returndatacopy(ptr, 0, returndatasize())\n                    revert(ptr, returndatasize())\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Safely withdraws a specified amount of wrapped Ether from the IWETH contract. Consumes less gas then regular `IWETH.withdraw`.\n     * @dev Uses inline assembly to interact with the IWETH contract.\n     * @param weth The IWETH token contract.\n     * @param amount The amount of wrapped Ether to withdraw from the IWETH contract.\n     */\n    function safeWithdraw(IWETH weth, uint256 amount) internal {\n        bytes4 selector = IWETH.withdraw.selector;\n        assembly (""memory-safe"") {  // solhint-disable-line no-inline-assembly\n            mstore(0, selector)\n            mstore(4, amount)\n            if iszero(call(gas(), weth, 0, 0, 0x24, 0, 0)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice Safely withdraws a specified amount of wrapped Ether from the IWETH contract to a specified recipient.\n     * Consumes less gas then regular `IWETH.withdraw`.\n     * @param weth The IWETH token contract.\n     * @param amount The amount of wrapped Ether to withdraw from the IWETH contract.\n     * @param to The recipient of the withdrawn Ether.\n     */\n    function safeWithdrawTo(IWETH weth, uint256 amount, address to) internal {\n        safeWithdraw(weth, amount);\n        if (to != address(this)) {\n            assembly (""memory-safe"") {  // solhint-disable-line no-inline-assembly\n                if iszero(call(_RAW_CALL_GAS_LIMIT, to, amount, 0, 0, 0, 0)) {\n                    let ptr := mload(0x40)\n                    returndatacopy(ptr, 0, returndatasize())\n                    revert(ptr, returndatasize())\n                }\n            }\n        }\n    }\n}\n\n// File @1inch/solidity-utils/contracts/EthReceiver.sol@v3.7.1\n\nabstract contract EthReceiver {\n    error EthDepositRejected();\n\n    receive() external payable {\n        _receive();\n    }\n\n    function _receive() internal virtual {\n        // solhint-disable-next-line avoid-tx-origin\n        if (msg.sender == tx.origin) revert EthDepositRejected();\n    }\n}\n\n// File @1inch/solidity-utils/contracts/OnlyWethReceiver.sol@v3.7.1\n\nabstract contract OnlyWethReceiver is EthReceiver {\n    address private immutable _WETH; // solhint-disable-line var-name-mixedcase\n\n    constructor(address weth) {\n        _WETH = address(weth);\n    }\n\n    function _receive() internal virtual override {\n        if (msg.sender != _WETH) revert EthDepositRejected();\n    }\n}\n\n// File @1inch/solidity-utils/contracts/PermitAndCall.sol@v3.7.1\n\nabstract contract PermitAndCall {\n    using SafeERC20 for IERC20;\n\n    function permitAndCall(bytes calldata permit, bytes calldata action) external payable {\n        IERC20(address(bytes20(permit))).tryPermit(permit[20:]);\n        // solhint-disable-next-line no-inline-assembly\n        assembly (""memory-safe"") {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, action.offset, action.length)\n            let success := delegatecall(gas(), address(), ptr, action.length, 0, 0)\n            returndatacopy(ptr, 0, returndatasize())\n            switch success\n            case 0 {\n                revert(ptr, returndatasize())\n            }\n            default {\n                return(ptr, returndatasize())\n            }\n        }\n    }\n}\n\n// File @openzeppelin/contracts/interfaces/IERC5267.sol@v5.0.1\n\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n\n// File @openzeppelin/contracts/utils/math/Math.sol@v5.0.1\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n            // benefit is lost if \'b\' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s ""Hacker\'s Delight"" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the ""msb"" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n\n// File @openzeppelin/contracts/utils/math/SignedMath.sol@v5.0.1\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book ""Hacker\'s Delight""\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n\n// File @openzeppelin/contracts/utils/Strings.sol@v5.0.1\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = ""0123456789abcdef"";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn\'t fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? ""-"" : """", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = ""0"";\n        buffer[1] = ""x"";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n\n// File @openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol@v5.0.1\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `""\\x19Ethereum Signed Message:\\n32""` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, ""\\x19Ethereum Signed Message:\\n32"") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `""\\x19Ethereum Signed Message:\\n"" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(""\\x19Ethereum Signed Message:\\n"", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `""\\x19\\x00""` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex""19_00"", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex""19_01"")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n\n// File @openzeppelin/contracts/utils/StorageSlot.sol@v5.0.1\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n\n// File @openzeppelin/contracts/utils/ShortStrings.sol@v5.0.1\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ShortStrings.sol)\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a ""normal"" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\n     * {setWithFallback}.\n     *\n     * WARNING: This will return the ""byte length"" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n\n// File @openzeppelin/contracts/utils/cryptography/EIP712.sol@v5.0.1\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/EIP712.sol)\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as ""v4"", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant TYPE_HASH =\n        keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(""Mail(address to,string contents)""),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex""0f"", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _name which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Name() internal view returns (string memory) {\n        return _name.toStringWithFallback(_nameFallback);\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _version which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Version() internal view returns (string memory) {\n        return _version.toStringWithFallback(_versionFallback);\n    }\n}\n\n// File @openzeppelin/contracts/utils/Context.sol@v5.0.1\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// File @openzeppelin/contracts/utils/Pausable.sol@v5.0.1\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n\n// File @1inch/limit-order-protocol-contract/contracts/OrderMixin.sol@v4.0.0-prerelease-19\n\n/// @title Limit Order mixin\nabstract contract OrderMixin is IOrderMixin, EIP712, PredicateHelper, SeriesEpochManager, Pausable, OnlyWethReceiver, PermitAndCall {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IWETH;\n    using OrderLib for IOrderMixin.Order;\n    using ExtensionLib for bytes;\n    using AddressLib for Address;\n    using MakerTraitsLib for MakerTraits;\n    using TakerTraitsLib for TakerTraits;\n    using BitInvalidatorLib for BitInvalidatorLib.Data;\n    using RemainingInvalidatorLib for RemainingInvalidator;\n\n    IWETH private immutable _WETH;  // solhint-disable-line var-name-mixedcase\n    mapping(address maker => BitInvalidatorLib.Data data) private _bitInvalidator;\n    mapping(address maker => mapping(bytes32 orderHash => RemainingInvalidator remaining)) private _remainingInvalidator;\n\n    constructor(IWETH weth) OnlyWethReceiver(address(weth)) {\n        _WETH = weth;\n    }\n\n    /**\n     * @notice See {IOrderMixin-bitInvalidatorForOrder}.\n     */\n    function bitInvalidatorForOrder(address maker, uint256 slot) external view returns(uint256 /* result */) {\n        return _bitInvalidator[maker].checkSlot(slot);\n    }\n\n    /**\n     * @notice See {IOrderMixin-remainingInvalidatorForOrder}.\n     */\n    function remainingInvalidatorForOrder(address maker, bytes32 orderHash) external view returns(uint256 /* remaining */) {\n        return _remainingInvalidator[maker][orderHash].remaining();\n    }\n\n    /**\n     * @notice See {IOrderMixin-rawRemainingInvalidatorForOrder}.\n     */\n    function rawRemainingInvalidatorForOrder(address maker, bytes32 orderHash) external view returns(uint256 /* remainingRaw */) {\n        return RemainingInvalidator.unwrap(_remainingInvalidator[maker][orderHash]);\n    }\n\n    /**\n     * @notice See {IOrderMixin-simulate}.\n     */\n    function simulate(address target, bytes calldata data) external {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory result) = target.delegatecall(data);\n        revert SimulationResults(success, result);\n    }\n\n    /**\n     * @notice See {IOrderMixin-cancelOrder}.\n     */\n    function cancelOrder(MakerTraits makerTraits, bytes32 orderHash) public {\n        if (makerTraits.useBitInvalidator()) {\n            uint256 invalidator = _bitInvalidator[msg.sender].massInvalidate(makerTraits.nonceOrEpoch(), 0);\n            emit BitInvalidatorUpdated(msg.sender, makerTraits.nonceOrEpoch() >> 8, invalidator);\n        } else {\n            _remainingInvalidator[msg.sender][orderHash] = RemainingInvalidatorLib.fullyFilled();\n            emit OrderCancelled(orderHash);\n        }\n    }\n\n    /**\n     * @notice See {IOrderMixin-cancelOrders}.\n     */\n    function cancelOrders(MakerTraits[] calldata makerTraits, bytes32[] calldata orderHashes) external {\n        if (makerTraits.length != orderHashes.length) revert MismatchArraysLengths();\n        unchecked {\n            for (uint256 i = 0; i < makerTraits.length; i++) {\n                cancelOrder(makerTraits[i], orderHashes[i]);\n            }\n        }\n    }\n\n    /**\n     * @notice See {IOrderMixin-bitsInvalidateForOrder}.\n     */\n    function bitsInvalidateForOrder(MakerTraits makerTraits, uint256 additionalMask) external {\n        if (!makerTraits.useBitInvalidator()) revert OrderIsNotSuitableForMassInvalidation();\n        uint256 invalidator = _bitInvalidator[msg.sender].massInvalidate(makerTraits.nonceOrEpoch(), additionalMask);\n        emit BitInvalidatorUpdated(msg.sender, makerTraits.nonceOrEpoch() >> 8, invalidator);\n    }\n\n     /**\n     * @notice See {IOrderMixin-hashOrder}.\n     */\n    function hashOrder(IOrderMixin.Order calldata order) external view returns(bytes32) {\n        return order.hash(_domainSeparatorV4());\n    }\n\n    /**\n     * @notice See {IOrderMixin-checkPredicate}.\n     */\n    function checkPredicate(bytes calldata predicate) public view returns(bool) {\n        (bool success, uint256 res) = _staticcallForUint(address(this), predicate);\n        return success && res == 1;\n    }\n\n    /**\n     * @notice See {IOrderMixin-fillOrder}.\n     */\n    function fillOrder(\n        IOrderMixin.Order calldata order,\n        bytes32 r,\n        bytes32 vs,\n        uint256 amount,\n        TakerTraits takerTraits\n    ) external payable returns(uint256 /* makingAmount */, uint256 /* takingAmount */, bytes32 /* orderHash */) {\n        return _fillOrder(order, r, vs, amount, takerTraits, msg.sender, msg.data[:0], msg.data[:0]);\n    }\n\n    /**\n     * @notice See {IOrderMixin-fillOrderArgs}.\n     */\n    function fillOrderArgs(\n        IOrderMixin.Order calldata order,\n        bytes32 r,\n        bytes32 vs,\n        uint256 amount,\n        TakerTraits takerTraits,\n        bytes calldata args\n    ) external payable returns(uint256 /* makingAmount */, uint256 /* takingAmount */, bytes32 /* orderHash */) {\n        (\n            address target,\n            bytes calldata extension,\n            bytes calldata interaction\n        ) = _parseArgs(takerTraits, args);\n\n        return _fillOrder(order, r, vs, amount, takerTraits, target, extension, interaction);\n    }\n\n    function _fillOrder(\n        IOrderMixin.Order calldata order,\n        bytes32 r,\n        bytes32 vs,\n        uint256 amount,\n        TakerTraits takerTraits,\n        address target,\n        bytes calldata extension,\n        bytes calldata interaction\n    ) private returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash) {\n        // Check signature and apply order/maker permit only on the first fill\n        orderHash = order.hash(_domainSeparatorV4());\n        uint256 remainingMakingAmount = _checkRemainingMakingAmount(order, orderHash);\n        if (remainingMakingAmount == order.makingAmount) {\n            address maker = order.maker.get();\n            if (maker == address(0) || maker != ECDSA.recover(orderHash, r, vs)) revert BadSignature();\n            if (!takerTraits.skipMakerPermit()) {\n                bytes calldata makerPermit = extension.makerPermit();\n                if (makerPermit.length >= 20) {\n                    // proceed only if taker is willing to execute permit and its length is enough to store address\n                    IERC20(address(bytes20(makerPermit))).tryPermit(maker, address(this), makerPermit[20:]);\n                    if (!order.makerTraits.useBitInvalidator()) {\n                        // Bit orders are not subjects for reentrancy, but we still need to check remaining-based orders for reentrancy\n                        if (!_remainingInvalidator[order.maker.get()][orderHash].isNewOrder()) revert ReentrancyDetected();\n                    }\n                }\n            }\n        }\n\n        (makingAmount, takingAmount) = _fill(order, orderHash, remainingMakingAmount, amount, takerTraits, target, extension, interaction);\n    }\n\n    /**\n     * @notice See {IOrderMixin-fillContractOrder}.\n     */\n    function fillContractOrder(\n        IOrderMixin.Order calldata order,\n        bytes calldata signature,\n        uint256 amount,\n        TakerTraits takerTraits\n    ) external returns(uint256 /* makingAmount */, uint256 /* takingAmount */, bytes32 /* orderHash */) {\n        return _fillContractOrder(order, signature, amount, takerTraits, msg.sender, msg.data[:0], msg.data[:0]);\n    }\n\n    /**\n     * @notice See {IOrderMixin-fillContractOrderArgs}.\n     */\n    function fillContractOrderArgs(\n        IOrderMixin.Order calldata order,\n        bytes calldata signature,\n        uint256 amount,\n        TakerTraits takerTraits,\n        bytes calldata args\n    ) external returns(uint256 /* makingAmount */, uint256 /* takingAmount */, bytes32 /* orderHash */) {\n        (\n            address target,\n            bytes calldata extension,\n            bytes calldata interaction\n        ) = _parseArgs(takerTraits, args);\n\n        return _fillContractOrder(order, signature, amount, takerTraits, target, extension, interaction);\n    }\n\n    function _fillContractOrder(\n        IOrderMixin.Order calldata order,\n        bytes calldata signature,\n        uint256 amount,\n        TakerTraits takerTraits,\n        address target,\n        bytes calldata extension,\n        bytes calldata interaction\n    ) private returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash) {\n        // Check signature only on the first fill\n        orderHash = order.hash(_domainSeparatorV4());\n        uint256 remainingMakingAmount = _checkRemainingMakingAmount(order, orderHash);\n        if (remainingMakingAmount == order.makingAmount) {\n            if (!ECDSA.isValidSignature(order.maker.get(), orderHash, signature)) revert BadSignature();\n        }\n\n        (makingAmount, takingAmount) = _fill(order, orderHash, remainingMakingAmount, amount, takerTraits, target, extension, interaction);\n    }\n\n    /**\n      * @notice Fills an order and transfers making amount to a specified target.\n      * @dev If the target is zero assigns it the caller\'s address.\n      * The function flow is as follows:\n      * 1. Validate order\n      * 2. Call maker pre-interaction\n      * 3. Transfer maker asset to taker\n      * 4. Call taker interaction\n      * 5. Transfer taker asset to maker\n      * 5. Call maker post-interaction\n      * 6. Emit OrderFilled event\n      * @param order The order details.\n      * @param orderHash The hash of the order.\n      * @param extension The extension calldata of the order.\n      * @param remainingMakingAmount The remaining amount to be filled.\n      * @param amount The order amount.\n      * @param takerTraits The taker preferences for the order.\n      * @param target The address to which the order is filled.\n      * @param interaction The interaction calldata.\n      * @return makingAmount The computed amount that the maker will get.\n      * @return takingAmount The computed amount that the taker will send.\n      */\n    function _fill(\n        IOrderMixin.Order calldata order,\n        bytes32 orderHash,\n        uint256 remainingMakingAmount,\n        uint256 amount,\n        TakerTraits takerTraits,\n        address target,\n        bytes calldata extension,\n        bytes calldata interaction\n    ) private whenNotPaused() returns(uint256 makingAmount, uint256 takingAmount) {\n        // Validate order\n        {\n            (bool valid, bytes4 validationResult) = order.isValidExtension(extension);\n            if (!valid) {\n                // solhint-disable-next-line no-inline-assembly\n                assembly (""memory-safe"") {\n                    mstore(0, validationResult)\n                    revert(0, 4)\n                }\n            }\n        }\n        if (!order.makerTraits.isAllowedSender(msg.sender)) revert PrivateOrder();\n        if (order.makerTraits.isExpired()) revert OrderExpired();\n        if (order.makerTraits.needCheckEpochManager()) {\n            if (order.makerTraits.useBitInvalidator()) revert EpochManagerAndBitInvalidatorsAreIncompatible();\n            if (!epochEquals(order.maker.get(), order.makerTraits.series(), order.makerTraits.nonceOrEpoch())) revert WrongSeriesNonce();\n        }\n\n        // Check if orders predicate allows filling\n        if (extension.length > 0) {\n            bytes calldata predicate = extension.predicate();\n            if (predicate.length > 0) {\n                if (!checkPredicate(predicate)) revert PredicateIsNotTrue();\n            }\n        }\n\n        // Compute maker and taker assets amount\n        if (takerTraits.isMakingAmount()) {\n            makingAmount = Math.min(amount, remainingMakingAmount);\n            takingAmount = order.calculateTakingAmount(extension, makingAmount, remainingMakingAmount, orderHash);\n\n            uint256 threshold = takerTraits.threshold();\n            if (threshold > 0) {\n                // Check rate: takingAmount / makingAmount <= threshold / amount\n                if (amount == makingAmount) {  // Gas optimization, no SafeMath.mul()\n                    if (takingAmount > threshold) revert TakingAmountTooHigh();\n                } else {\n                    if (takingAmount * amount > threshold * makingAmount) revert TakingAmountTooHigh();\n                }\n            }\n        }\n        else {\n            takingAmount = amount;\n            makingAmount = order.calculateMakingAmount(extension, takingAmount, remainingMakingAmount, orderHash);\n            if (makingAmount > remainingMakingAmount) {\n                // Try to decrease taking amount because computed making amount exceeds remaining amount\n                makingAmount = remainingMakingAmount;\n                takingAmount = order.calculateTakingAmount(extension, makingAmount, remainingMakingAmount, orderHash);\n                if (takingAmount > amount) revert TakingAmountExceeded();\n            }\n\n            uint256 threshold = takerTraits.threshold();\n            if (threshold > 0) {\n                // Check rate: makingAmount / takingAmount >= threshold / amount\n                if (amount == takingAmount) { // Gas optimization, no SafeMath.mul()\n                    if (makingAmount < threshold) revert MakingAmountTooLow();\n                } else {\n                    if (makingAmount * amount < threshold * takingAmount) revert MakingAmountTooLow();\n                }\n            }\n        }\n        if (!order.makerTraits.allowPartialFills() && makingAmount != order.makingAmount) revert PartialFillNotAllowed();\n        unchecked { if (makingAmount * takingAmount == 0) revert SwapWithZeroAmount(); }\n\n        // Invalidate order depending on makerTraits\n        if (order.makerTraits.useBitInvalidator()) {\n            _bitInvalidator[order.maker.get()].checkAndInvalidate(order.makerTraits.nonceOrEpoch());\n        } else {\n            _remainingInvalidator[order.maker.get()][orderHash] = RemainingInvalidatorLib.remains(remainingMakingAmount, makingAmount);\n        }\n\n        // Pre interaction, where maker can prepare funds interactively\n        if (order.makerTraits.needPreInteractionCall()) {\n            bytes calldata data = extension.preInteractionTargetAndData();\n            address listener = order.maker.get();\n            if (data.length > 19) {\n                listener = address(bytes20(data));\n                data = data[20:];\n            }\n            IPreInteraction(listener).preInteraction(\n                order, extension, orderHash, msg.sender, makingAmount, takingAmount, remainingMakingAmount, data\n            );\n        }\n\n        // Maker => Taker\n        {\n            bool needUnwrap = order.makerAsset.get() == address(_WETH) && takerTraits.unwrapWeth();\n            address receiver = needUnwrap ? address(this) : target;\n            if (order.makerTraits.usePermit2()) {\n                if (extension.makerAssetSuffix().length > 0) revert InvalidPermit2Transfer();\n                IERC20(order.makerAsset.get()).safeTransferFromPermit2(order.maker.get(), receiver, makingAmount);\n            } else {\n                if (!_callTransferFromWithSuffix(\n                    order.makerAsset.get(),\n                    order.maker.get(),\n                    receiver,\n                    makingAmount,\n                    extension.makerAssetSuffix()\n                )) revert TransferFromMakerToTakerFailed();\n            }\n            if (needUnwrap) {\n                _WETH.safeWithdrawTo(makingAmount, target);\n            }\n        }\n\n        if (interaction.length > 19) {\n            // proceed only if interaction length is enough to store address\n            ITakerInteraction(address(bytes20(interaction))).takerInteraction(\n                order, extension, orderHash, msg.sender, makingAmount, takingAmount, remainingMakingAmount, interaction[20:]\n            );\n        }\n\n        // Taker => Maker\n        if (order.takerAsset.get() == address(_WETH) && msg.value > 0) {\n            if (msg.value < takingAmount) revert Errors.InvalidMsgValue();\n            if (msg.value > takingAmount) {\n                unchecked {\n                    // solhint-disable-next-line avoid-low-level-calls\n                    (bool success, ) = msg.sender.call{value: msg.value - takingAmount}("""");\n                    if (!success) revert Errors.ETHTransferFailed();\n                }\n            }\n\n            if (order.makerTraits.unwrapWeth()) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (bool success, ) = order.getReceiver().call{value: takingAmount}("""");\n                if (!success) revert Errors.ETHTransferFailed();\n            } else {\n                _WETH.safeDeposit(takingAmount);\n                _WETH.safeTransfer(order.getReceiver(), takingAmount);\n            }\n        } else {\n            if (msg.value != 0) revert Errors.InvalidMsgValue();\n\n            bool needUnwrap = order.takerAsset.get() == address(_WETH) && order.makerTraits.unwrapWeth();\n            address receiver = needUnwrap ? address(this) : order.getReceiver();\n            if (takerTraits.usePermit2()) {\n                if (extension.takerAssetSuffix().length > 0) revert InvalidPermit2Transfer();\n                IERC20(order.takerAsset.get()).safeTransferFromPermit2(msg.sender, receiver, takingAmount);\n            } else {\n                if (!_callTransferFromWithSuffix(\n                    order.takerAsset.get(),\n                    msg.sender,\n                    receiver,\n                    takingAmount,\n                    extension.takerAssetSuffix()\n                )) revert TransferFromTakerToMakerFailed();\n            }\n\n            if (needUnwrap) {\n                _WETH.safeWithdrawTo(takingAmount, order.getReceiver());\n            }\n        }\n\n        // Post interaction, where maker can handle funds interactively\n        if (order.makerTraits.needPostInteractionCall()) {\n            bytes calldata data = extension.postInteractionTargetAndData();\n            address listener = order.maker.get();\n            if (data.length > 19) {\n                listener = address(bytes20(data));\n                data = data[20:];\n            }\n            IPostInteraction(listener).postInteraction(\n                order, extension, orderHash, msg.sender, makingAmount, takingAmount, remainingMakingAmount, data\n            );\n        }\n\n        emit OrderFilled(orderHash, remainingMakingAmount - makingAmount);\n    }\n\n    /**\n      * @notice Processes the taker interaction arguments.\n      * @param takerTraits The taker preferences for the order.\n      * @param args The taker interaction arguments.\n      * @return target The address to which the order is filled.\n      * @return extension The extension calldata of the order.\n      * @return interaction The interaction calldata.\n      */\n    function _parseArgs(TakerTraits takerTraits, bytes calldata args)\n        private\n        view\n        returns(\n            address target,\n            bytes calldata extension,\n            bytes calldata interaction\n        )\n    {\n        if (takerTraits.argsHasTarget()) {\n            target = address(bytes20(args));\n            args = args[20:];\n        } else {\n            target = msg.sender;\n        }\n\n        uint256 extensionLength = takerTraits.argsExtensionLength();\n        if (extensionLength > 0) {\n            extension = args[:extensionLength];\n            args = args[extensionLength:];\n        } else {\n            extension = msg.data[:0];\n        }\n\n        uint256 interactionLength = takerTraits.argsInteractionLength();\n        if (interactionLength > 0) {\n            interaction = args[:interactionLength];\n        } else {\n            interaction = msg.data[:0];\n        }\n    }\n\n    /**\n      * @notice Checks the remaining making amount for the order.\n      * @dev If the order has been invalidated, the function will revert.\n      * @param order The order to check.\n      * @param orderHash The hash of the order.\n      * @return remainingMakingAmount The remaining amount of the order.\n      */\n    function _checkRemainingMakingAmount(IOrderMixin.Order calldata order, bytes32 orderHash) private view returns(uint256 remainingMakingAmount) {\n        if (order.makerTraits.useBitInvalidator()) {\n            remainingMakingAmount = order.makingAmount;\n        } else {\n            remainingMakingAmount = _remainingInvalidator[order.maker.get()][orderHash].remaining(order.makingAmount);\n        }\n        if (remainingMakingAmount == 0) revert InvalidatedOrder();\n    }\n\n    /**\n      * @notice Calls the transferFrom function with an arbitrary suffix.\n      * @dev The suffix is appended to the end of the standard ERC20 transferFrom function parameters.\n      * @param asset The token to be transferred.\n      * @param from The address to transfer the token from.\n      * @param to The address to transfer the token to.\n      * @param amount The amount of the token to transfer.\n      * @param suffix The suffix (additional data) to append to the end of the transferFrom call.\n      * @return success A boolean indicating whether the transfer was successful.\n      */\n    function _callTransferFromWithSuffix(address asset, address from, address to, uint256 amount, bytes calldata suffix) private returns(bool success) {\n        bytes4 selector = IERC20.transferFrom.selector;\n        assembly (""memory-safe"") { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n            mstore(data, selector)\n            mstore(add(data, 0x04), from)\n            mstore(add(data, 0x24), to)\n            mstore(add(data, 0x44), amount)\n            if suffix.length {\n                calldatacopy(add(data, 0x64), suffix.offset, suffix.length)\n            }\n            let status := call(gas(), asset, 0, data, add(0x64, suffix.length), 0x0, 0x20)\n            success := and(status, or(iszero(returndatasize()), and(gt(returndatasize(), 31), eq(mload(0), 1))))\n        }\n    }\n}\n\n// File @1inch/solidity-utils/contracts/interfaces/IERC20MetadataUppercase.sol@v3.7.1\n\ninterface IERC20MetadataUppercase {\n    function NAME() external view returns (string memory); // solhint-disable-line func-name-mixedcase\n\n    function SYMBOL() external view returns (string memory); // solhint-disable-line func-name-mixedcase\n}\n\n// File @1inch/solidity-utils/contracts/libraries/StringUtil.sol@v3.7.1\n\n/// @title Library with gas-efficient string operations\nlibrary StringUtil {\n    function toHex(uint256 value) internal pure returns (string memory) {\n        return toHex(abi.encodePacked(value));\n    }\n\n    function toHex(address value) internal pure returns (string memory) {\n        return toHex(abi.encodePacked(value));\n    }\n\n    /// @dev this is the assembly adaptation of highly optimized toHex16 code from Mikhail Vladimirov\n    /// https://stackoverflow.com/a/69266989\n    function toHex(bytes memory data) internal pure returns (string memory result) {\n        assembly (""memory-safe"") { // solhint-disable-line no-inline-assembly\n            function _toHex16(input) -> output {\n                output := or(\n                    and(input, 0xFFFFFFFFFFFFFFFF000000000000000000000000000000000000000000000000),\n                    shr(64, and(input, 0x0000000000000000FFFFFFFFFFFFFFFF00000000000000000000000000000000))\n                )\n                output := or(\n                    and(output, 0xFFFFFFFF000000000000000000000000FFFFFFFF000000000000000000000000),\n                    shr(32, and(output, 0x00000000FFFFFFFF000000000000000000000000FFFFFFFF0000000000000000))\n                )\n                output := or(\n                    and(output, 0xFFFF000000000000FFFF000000000000FFFF000000000000FFFF000000000000),\n                    shr(16, and(output, 0x0000FFFF000000000000FFFF000000000000FFFF000000000000FFFF00000000))\n                )\n                output := or(\n                    and(output, 0xFF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000),\n                    shr(8, and(output, 0x00FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF0000))\n                )\n                output := or(\n                    shr(4, and(output, 0xF000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000)),\n                    shr(8, and(output, 0x0F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F00))\n                )\n                output := add(\n                    add(0x3030303030303030303030303030303030303030303030303030303030303030, output),\n                    mul(\n                        and(\n                            shr(4, add(output, 0x0606060606060606060606060606060606060606060606060606060606060606)),\n                            0x0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F\n                        ),\n                        7 // Change 7 to 39 for lower case output\n                    )\n                )\n            }\n\n            result := mload(0x40)\n            let length := mload(data)\n            let resultLength := shl(1, length)\n            let toPtr := add(result, 0x22) // 32 bytes for length + 2 bytes for \'0x\'\n            mstore(0x40, add(toPtr, resultLength)) // move free memory pointer\n            mstore(add(result, 2), 0x3078) // 0x3078 is right aligned so we write to `result + 2`\n            // to store the last 2 bytes in the beginning of the string\n            mstore(result, add(resultLength, 2)) // extra 2 bytes for \'0x\'\n\n            for {\n                let fromPtr := add(data, 0x20)\n                let endPtr := add(fromPtr, length)\n            } lt(fromPtr, endPtr) {\n                fromPtr := add(fromPtr, 0x20)\n            } {\n                let rawData := mload(fromPtr)\n                let hexData := _toHex16(rawData)\n                mstore(toPtr, hexData)\n                toPtr := add(toPtr, 0x20)\n                hexData := _toHex16(shl(128, rawData))\n                mstore(toPtr, hexData)\n                toPtr := add(toPtr, 0x20)\n            }\n        }\n    }\n}\n\n// File @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol@v5.0.1\n\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n\n// File @1inch/solidity-utils/contracts/libraries/UniERC20.sol@v3.7.1\n\n/// @title Library, which allows usage of ETH as ERC20 and ERC20 itself. Uses SafeERC20 library for ERC20 interface.\nlibrary UniERC20 {\n    using SafeERC20 for IERC20;\n\n    error InsufficientBalance();\n    error ApproveCalledOnETH();\n    error NotEnoughValue();\n    error FromIsNotSender();\n    error ToIsNotThis();\n    error ETHTransferFailed();\n\n    uint256 private constant _RAW_CALL_GAS_LIMIT = 5000;\n    IERC20 private constant _ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n    IERC20 private constant _ZERO_ADDRESS = IERC20(address(0));\n\n    /// @dev Returns true if `token` is ETH.\n    function isETH(IERC20 token) internal pure returns (bool) {\n        return (token == _ZERO_ADDRESS || token == _ETH_ADDRESS);\n    }\n\n    /// @dev Returns `account` ERC20 `token` balance.\n    function uniBalanceOf(IERC20 token, address account) internal view returns (uint256) {\n        if (isETH(token)) {\n            return account.balance;\n        } else {\n            return token.balanceOf(account);\n        }\n    }\n\n    /// @dev `token` transfer `to` `amount`.\n    /// Note that this function does nothing in case of zero amount.\n    function uniTransfer(\n        IERC20 token,\n        address payable to,\n        uint256 amount\n    ) internal {\n        if (amount > 0) {\n            if (isETH(token)) {\n                if (address(this).balance < amount) revert InsufficientBalance();\n                // solhint-disable-next-line avoid-low-level-calls\n                (bool success, ) = to.call{value: amount, gas: _RAW_CALL_GAS_LIMIT}("""");\n                if (!success) revert ETHTransferFailed();\n            } else {\n                token.safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /// @dev `token` transfer `from` `to` `amount`.\n    /// Note that this function does nothing in case of zero amount.\n    function uniTransferFrom(\n        IERC20 token,\n        address payable from,\n        address to,\n        uint256 amount\n    ) internal {\n        if (amount > 0) {\n            if (isETH(token)) {\n                if (msg.value < amount) revert NotEnoughValue();\n                if (from != msg.sender) revert FromIsNotSender();\n                if (to != address(this)) revert ToIsNotThis();\n                if (msg.value > amount) {\n                    // Return remainder if exist\n                    unchecked {\n                        // solhint-disable-next-line avoid-low-level-calls\n                        (bool success, ) = from.call{value: msg.value - amount, gas: _RAW_CALL_GAS_LIMIT}("""");\n                        if (!success) revert ETHTransferFailed();\n                    }\n                }\n            } else {\n                token.safeTransferFrom(from, to, amount);\n            }\n        }\n    }\n\n    /// @dev Returns `token` symbol from ERC20 metadata.\n    function uniSymbol(IERC20 token) internal view returns (string memory) {\n        return _uniDecode(token, IERC20Metadata.symbol.selector, IERC20MetadataUppercase.SYMBOL.selector);\n    }\n\n    /// @dev Returns `token` name from ERC20 metadata.\n    function uniName(IERC20 token) internal view returns (string memory) {\n        return _uniDecode(token, IERC20Metadata.name.selector, IERC20MetadataUppercase.NAME.selector);\n    }\n\n    /// @dev Reverts if `token` is ETH, otherwise performs ERC20 forceApprove.\n    function uniApprove(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        if (isETH(token)) revert ApproveCalledOnETH();\n\n        token.forceApprove(to, amount);\n    }\n\n    /// @dev 20K gas is provided to account for possible implementations of name/symbol\n    /// (token implementation might be behind proxy or store the value in storage)\n    function _uniDecode(\n        IERC20 token,\n        bytes4 lowerCaseSelector,\n        bytes4 upperCaseSelector\n    ) private view returns (string memory result) {\n        if (isETH(token)) {\n            return ""ETH"";\n        }\n\n        (bool success, bytes memory data) = address(token).staticcall{gas: 20000}(\n            abi.encodeWithSelector(lowerCaseSelector)\n        );\n        if (!success) {\n            (success, data) = address(token).staticcall{gas: 20000}(abi.encodeWithSelector(upperCaseSelector));\n        }\n\n        if (success && data.length >= 0x40) {\n            (uint256 offset, uint256 len) = abi.decode(data, (uint256, uint256));\n            /*\n                return data is padded up to 32 bytes with ABI encoder also sometimes\n                there is extra 32 bytes of zeros padded in the end:\n                https://github.com/ethereum/solidity/issues/10170\n                because of that we can\'t check for equality and instead check\n                that overall data length is greater or equal than string length + extra 64 bytes\n            */\n            if (offset == 0x20 && data.length >= 0x40 + len) {\n                assembly (""memory-safe"") { // solhint-disable-line no-inline-assembly\n                    result := add(data, 0x40)\n                }\n                return result;\n            }\n        }\n        if (success && data.length == 32) {\n            uint256 len = 0;\n            while (len < data.length && data[len] >= 0x20 && data[len] <= 0x7E) {\n                unchecked {\n                    len++;\n                }\n            }\n\n            if (len > 0) {\n                assembly (""memory-safe"") { // solhint-disable-line no-inline-assembly\n                    mstore(data, len)\n                }\n                return string(data);\n            }\n        }\n\n        return StringUtil.toHex(address(token));\n    }\n}\n\n// File @openzeppelin/contracts/access/Ownable.sol@v5.0.1\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// File contracts/helpers/RouterErrors.sol\n\nlibrary RouterErrors {\n    error ReturnAmountIsNotEnough(uint256 result, uint256 minReturn);\n    error InvalidMsgValue();\n    error ERC20TransferFailed();\n    error Permit2TransferFromFailed();\n    error ApproveFailed();\n}\n\n// File contracts/interfaces/IClipperExchange.sol\n\n/// @title Clipper interface subset used in swaps\ninterface IClipperExchange {\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    function sellEthForToken(address outputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, Signature calldata theSignature, bytes calldata auxiliaryData) external payable;\n    function sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, Signature calldata theSignature, bytes calldata auxiliaryData) external;\n    function swap(address inputToken, address outputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, Signature calldata theSignature, bytes calldata auxiliaryData) external;\n}\n\n// File contracts/routers/ClipperRouter.sol\n\n/**\n * @title ClipperRouter\n * @notice Clipper router that allows to use `IClipperExchange` for swaps.\n */\ncontract ClipperRouter is Pausable, EthReceiver {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IWETH;\n    using AddressLib for Address;\n\n    uint256 private constant _PERMIT2_FLAG = 1 << 255;\n    uint256 private constant _SIGNATURE_S_MASK = 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    uint256 private constant _SIGNATURE_V_SHIFT = 255;\n    bytes5 private constant _INCH_TAG = ""1INCH"";\n    uint256 private constant _INCH_TAG_LENGTH = 5;\n    IERC20 private constant _ETH = IERC20(address(0));\n    IWETH private immutable _WETH;  // solhint-disable-line var-name-mixedcase\n\n    constructor(IWETH weth) {\n        _WETH = weth;\n    }\n\n    /**\n    * @notice Same as `clipperSwapTo` but uses `msg.sender` as recipient.\n    * @param clipperExchange Clipper pool address.\n    * @param srcToken Source token and flags.\n    * @param dstToken Destination token.\n    * @param inputAmount Amount of source tokens to swap.\n    * @param outputAmount Amount of destination tokens to receive.\n    * @param goodUntil Clipper parameter.\n    * @param r Clipper order signature (r part).\n    * @param vs Clipper order signature (vs part).\n    * @return returnAmount Amount of destination tokens received.\n    */\n    function clipperSwap(\n        IClipperExchange clipperExchange,\n        Address srcToken,\n        IERC20 dstToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 goodUntil,\n        bytes32 r,\n        bytes32 vs\n    ) external payable returns(uint256 returnAmount) {\n        return clipperSwapTo(clipperExchange, payable(msg.sender), srcToken, dstToken, inputAmount, outputAmount, goodUntil, r, vs);\n    }\n\n    /**\n    * @notice Performs swap using Clipper exchange. Wraps and unwraps ETH if required.\n    *         Sending non-zero `msg.value` for anything but ETH swaps is prohibited.\n    * @param clipperExchange Clipper pool address.\n    * @param recipient Address that will receive swap funds.\n    * @param srcToken Source token and flags.\n    * @param dstToken Destination token.\n    * @param inputAmount Amount of source tokens to swap.\n    * @param outputAmount Amount of destination tokens to receive.\n    * @param goodUntil Clipper parameter.\n    * @param r Clipper order signature (r part).\n    * @param vs Clipper order signature (vs part).\n    * @return returnAmount Amount of destination tokens received.\n    */\n    function clipperSwapTo(\n        IClipperExchange clipperExchange,\n        address payable recipient,\n        Address srcToken,\n        IERC20 dstToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 goodUntil,\n        bytes32 r,\n        bytes32 vs\n    ) public payable whenNotPaused() returns(uint256 returnAmount) {\n        IERC20 srcToken_ = IERC20(srcToken.get());\n        if (srcToken_ == _ETH) {\n            if (msg.value != inputAmount) revert RouterErrors.InvalidMsgValue();\n        } else {\n            if (msg.value != 0) revert RouterErrors.InvalidMsgValue();\n            srcToken_.safeTransferFromUniversal(msg.sender, address(clipperExchange), inputAmount, srcToken.getFlag(_PERMIT2_FLAG));\n        }\n        if (srcToken_ == _ETH) {\n            // clipperExchange.sellEthForToken{value: inputAmount}(address(dstToken), inputAmount, outputAmount, goodUntil, recipient, signature, _INCH_TAG);\n            address clipper = address(clipperExchange);\n            bytes4 selector = clipperExchange.sellEthForToken.selector;\n            assembly (""memory-safe"") { // solhint-disable-line no-inline-assembly\n                let ptr := mload(0x40)\n\n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), dstToken)\n                mstore(add(ptr, 0x24), inputAmount)\n                mstore(add(ptr, 0x44), outputAmount)\n                mstore(add(ptr, 0x64), goodUntil)\n                mstore(add(ptr, 0x84), recipient)\n                mstore(add(ptr, 0xa4), add(27, shr(_SIGNATURE_V_SHIFT, vs)))\n                mstore(add(ptr, 0xc4), r)\n                mstore(add(ptr, 0xe4), and(vs, _SIGNATURE_S_MASK))\n                mstore(add(ptr, 0x104), 0x120)\n                mstore(add(ptr, 0x124), _INCH_TAG_LENGTH)\n                mstore(add(ptr, 0x144), _INCH_TAG)\n                if iszero(call(gas(), clipper, inputAmount, ptr, 0x149, 0, 0)) {\n                    returndatacopy(ptr, 0, returndatasize())\n                    revert(ptr, returndatasize())\n                }\n            }\n        } else if (dstToken == _ETH) {\n            // clipperExchange.sellTokenForEth(address(srcToken_), inputAmount, outputAmount, goodUntil, recipient, signature, _INCH_TAG);\n            address clipper = address(clipperExchange);\n            bytes4 selector = clipperExchange.sellTokenForEth.selector;\n            assembly (""memory-safe"") { // solhint-disable-line no-inline-assembly\n                let ptr := mload(0x40)\n\n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), srcToken_)\n                mstore(add(ptr, 0x24), inputAmount)\n                mstore(add(ptr, 0x44), outputAmount)\n                mstore(add(ptr, 0x64), goodUntil)\n                switch iszero(dstToken)\n                case 1 {\n                    mstore(add(ptr, 0x84), recipient)\n                }\n                default {\n                    mstore(add(ptr, 0x84), address())\n                }\n                mstore(add(ptr, 0xa4), add(27, shr(_SIGNATURE_V_SHIFT, vs)))\n                mstore(add(ptr, 0xc4), r)\n                mstore(add(ptr, 0xe4), and(vs, _SIGNATURE_S_MASK))\n                mstore(add(ptr, 0x104), 0x120)\n                mstore(add(ptr, 0x124), _INCH_TAG_LENGTH)\n                mstore(add(ptr, 0x144), _INCH_TAG)\n                if iszero(call(gas(), clipper, 0, ptr, 0x149, 0, 0)) {\n                    returndatacopy(ptr, 0, returndatasize())\n                    revert(ptr, returndatasize())\n                }\n            }\n        } else {\n            // clipperExchange.swap(address(srcToken_), address(dstToken), inputAmount, outputAmount, goodUntil, recipient, signature, _INCH_TAG);\n            address clipper = address(clipperExchange);\n            bytes4 selector = clipperExchange.swap.selector;\n            assembly (""memory-safe"") { // solhint-disable-line no-inline-assembly\n                let ptr := mload(0x40)\n\n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), srcToken_)\n                mstore(add(ptr, 0x24), dstToken)\n                mstore(add(ptr, 0x44), inputAmount)\n                mstore(add(ptr, 0x64), outputAmount)\n                mstore(add(ptr, 0x84), goodUntil)\n                mstore(add(ptr, 0xa4), recipient)\n                mstore(add(ptr, 0xc4), add(27, shr(_SIGNATURE_V_SHIFT, vs)))\n                mstore(add(ptr, 0xe4), r)\n                mstore(add(ptr, 0x104), and(vs, _SIGNATURE_S_MASK))\n                mstore(add(ptr, 0x124), 0x140)\n                mstore(add(ptr, 0x144), _INCH_TAG_LENGTH)\n                mstore(add(ptr, 0x164), _INCH_TAG)\n                if iszero(call(gas(), clipper, 0, ptr, 0x169, 0, 0)) {\n                    returndatacopy(ptr, 0, returndatasize())\n                    revert(ptr, returndatasize())\n                }\n            }\n        }\n\n        return outputAmount;\n    }\n}\n\n// File contracts/interfaces/IAggregationExecutor.sol\n\n/// @title Interface for making arbitrary calls during swap\ninterface IAggregationExecutor {\n    /// @notice propagates information about original msg.sender and executes arbitrary data\n    function execute(address msgSender) external payable returns(uint256);  // 0x4b64e492\n}\n\n// File contracts/routers/GenericRouter.sol\n\n/**\n * @title GenericRouter\n * @notice Router that allows to use `IAggregationExecutor` for swaps.\n */\ncontract GenericRouter is Pausable, EthReceiver {\n    using UniERC20 for IERC20;\n    using SafeERC20 for IERC20;\n\n    error ZeroMinReturn();\n\n    uint256 private constant _PARTIAL_FILL = 1 << 0;\n    uint256 private constant _REQUIRES_EXTRA_ETH = 1 << 1;\n    uint256 private constant _USE_PERMIT2 = 1 << 2;\n\n    struct SwapDescription {\n        IERC20 srcToken;\n        IERC20 dstToken;\n        address payable srcReceiver;\n        address payable dstReceiver;\n        uint256 amount;\n        uint256 minReturnAmount;\n        uint256 flags;\n    }\n\n    /**\n    * @notice Performs a swap, delegating all calls encoded in `data` to `executor`. See tests for usage examples.\n    * @dev Router keeps 1 wei of every token on the contract balance for gas optimisations reasons.\n    *      This affects first swap of every token by leaving 1 wei on the contract.\n    * @param executor Aggregation executor that executes calls described in `data`.\n    * @param desc Swap description.\n    * @param data Encoded calls that `caller` should execute in between of swaps.\n    * @return returnAmount Resulting token amount.\n    * @return spentAmount Source token amount.\n    */\n    function swap(\n        IAggregationExecutor executor,\n        SwapDescription calldata desc,\n        bytes calldata data\n    )\n        external\n        payable\n        whenNotPaused()\n        returns (\n            uint256 returnAmount,\n            uint256 spentAmount\n        )\n    {\n        if (desc.minReturnAmount == 0) revert ZeroMinReturn();\n\n        IERC20 srcToken = desc.srcToken;\n        IERC20 dstToken = desc.dstToken;\n\n        bool srcETH = srcToken.isETH();\n        if (desc.flags & _REQUIRES_EXTRA_ETH != 0) {\n            if (msg.value <= (srcETH ? desc.amount : 0)) revert RouterErrors.InvalidMsgValue();\n        } else {\n            if (msg.value != (srcETH ? desc.amount : 0)) revert RouterErrors.InvalidMsgValue();\n        }\n\n        if (!srcETH) {\n            srcToken.safeTransferFromUniversal(msg.sender, desc.srcReceiver, desc.amount, desc.flags & _USE_PERMIT2 != 0);\n        }\n\n        returnAmount = _execute(executor, msg.sender, desc.amount, data);\n        spentAmount = desc.amount;\n\n        if (desc.flags & _PARTIAL_FILL != 0) {\n            uint256 unspentAmount = srcToken.uniBalanceOf(address(this));\n            if (unspentAmount > 1) {\n                // we leave 1 wei on the router for gas optimisations reasons\n                unchecked { unspentAmount--; }\n                spentAmount -= unspentAmount;\n                srcToken.uniTransfer(payable(msg.sender), unspentAmount);\n            }\n            if (returnAmount * desc.amount < desc.minReturnAmount * spentAmount) revert RouterErrors.ReturnAmountIsNotEnough(returnAmount, desc.minReturnAmount * spentAmount / desc.amount);\n        } else {\n            if (returnAmount < desc.minReturnAmount) revert RouterErrors.ReturnAmountIsNotEnough(returnAmount, desc.minReturnAmount);\n        }\n\n        address payable dstReceiver = (desc.dstReceiver == address(0)) ? payable(msg.sender) : desc.dstReceiver;\n        dstToken.uniTransfer(dstReceiver, returnAmount);\n    }\n\n    function _execute(\n        IAggregationExecutor executor,\n        address srcTokenOwner,\n        uint256 inputAmount,\n        bytes calldata data\n    ) private returns(uint256 result) {\n        bytes4 executeSelector = executor.execute.selector;\n        assembly (""memory-safe"") {  // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            mstore(ptr, executeSelector)\n            mstore(add(ptr, 0x04), srcTokenOwner)\n            calldatacopy(add(ptr, 0x24), data.offset, data.length)\n            mstore(add(add(ptr, 0x24), data.length), inputAmount)\n\n            if iszero(call(gas(), executor, callvalue(), ptr, add(0x44, data.length), 0, 0x20)) {\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n\n            result := mload(0)\n        }\n    }\n}\n\n// File contracts/interfaces/IUniswapV3Pool.sol\n\ninterface IUniswapV3Pool {\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the output of the swap\n    /// @param amount0 The delta of the token0 balance of the pool\n    /// @param amount1 The delta of the token1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of price of the pool after the swap\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool\'s fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n}\n\n// File contracts/interfaces/IUniswapV3SwapCallback.sol\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n\n// File contracts/libs/ProtocolLib.sol\n\nlibrary ProtocolLib {\n    using AddressLib for Address;\n\n    enum Protocol {\n        UniswapV2,\n        UniswapV3,\n        Curve\n    }\n\n    uint256 private constant _PROTOCOL_OFFSET = 253;\n    uint256 private constant _WETH_UNWRAP_FLAG = 1 << 252;\n    uint256 private constant _WETH_NOT_WRAP_FLAG = 1 << 251;\n    uint256 private constant _USE_PERMIT2_FLAG = 1 << 250;\n\n    function protocol(Address self) internal pure returns(Protocol) {\n        // there is no need to mask because protocol is stored in the highest 3 bits\n        return Protocol((Address.unwrap(self) >> _PROTOCOL_OFFSET));\n    }\n\n    function shouldUnwrapWeth(Address self) internal pure returns(bool) {\n        return self.getFlag(_WETH_UNWRAP_FLAG);\n    }\n\n    function shouldWrapWeth(Address self) internal pure returns(bool) {\n        return !self.getFlag(_WETH_NOT_WRAP_FLAG);\n    }\n\n    function usePermit2(Address self) internal pure returns(bool) {\n        return self.getFlag(_USE_PERMIT2_FLAG);\n    }\n\n    function addressForPreTransfer(Address self) internal view returns(address) {\n        if (protocol(self) == Protocol.UniswapV2) {\n            return self.get();\n        }\n        return address(this);\n    }\n}\n\n// File contracts/routers/UnoswapRouter.sol\n\n/**\n * @title UnoswapRouter\n * @notice A router contract for executing token swaps on Unoswap-compatible decentralized exchanges: UniswapV3, UniswapV2, Curve.\n */\ncontract UnoswapRouter is Pausable, EthReceiver, IUniswapV3SwapCallback {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IWETH;\n    using AddressLib for Address;\n    using ProtocolLib for Address;\n\n    error BadPool();\n    error BadCurveSwapSelector();\n\n    /// @dev WETH address is network-specific and needs to be changed before deployment.\n    /// It can not be moved to immutable as immutables are not supported in assembly\n    address private constant _WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address private constant _ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address private constant _PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n    bytes4 private constant _WETH_DEPOSIT_CALL_SELECTOR = 0xd0e30db0;\n    bytes4 private constant _WETH_WITHDRAW_CALL_SELECTOR = 0x2e1a7d4d;\n    uint256 private constant _ADDRESS_MASK = 0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff;\n\n    uint256 private constant _SELECTORS = (\n        (uint256(uint32(IUniswapV3Pool.token0.selector)) << 224) |\n        (uint256(uint32(IUniswapV3Pool.token1.selector)) << 192) |\n        (uint256(uint32(IUniswapV3Pool.fee.selector)) << 160) |\n        (uint256(uint32(IERC20.transfer.selector)) << 128) |\n        (uint256(uint32(IERC20.transferFrom.selector)) << 96) |\n        (uint256(uint32(IPermit2.transferFrom.selector)) << 64)\n    );\n\n    uint256 private constant _TOKEN0_SELECTOR_OFFSET = 0;\n    uint256 private constant _TOKEN1_SELECTOR_OFFSET = 4;\n    uint256 private constant _FEE_SELECTOR_OFFSET = 8;\n    uint256 private constant _TRANSFER_SELECTOR_OFFSET = 12;\n    uint256 private constant _TRANSFER_FROM_SELECTOR_OFFSET = 16;\n    uint256 private constant _PERMIT2_TRANSFER_FROM_SELECTOR_OFFSET = 20;\n\n    bytes32 private constant _POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\n    bytes32 private constant _FF_FACTORY = 0xff1F98431c8aD98523631AE4a59f267346ea31F9840000000000000000000000;\n\n    // =====================================================================\n    //                          Methods with 1 pool\n    // =====================================================================\n\n    /**\n    * @notice Swaps `amount` of the specified `token` for another token using an Unoswap-compatible exchange\'s pool,\n    *         with a minimum return specified by `minReturn`.\n    * @param token The address of the token to be swapped.\n    * @param amount The amount of tokens to be swapped.\n    * @param minReturn The minimum amount of tokens to be received after the swap.\n    * @param dex The address of the Unoswap-compatible exchange\'s pool.\n    * @return returnAmount The actual amount of tokens received after the swap.\n    */\n    function unoswap(Address token, uint256 amount, uint256 minReturn, Address dex) external returns(uint256 returnAmount) {\n        returnAmount = _unoswapTo(msg.sender, msg.sender, token, amount, minReturn, dex);\n    }\n\n    /**\n    * @notice Swaps `amount` of the specified `token` for another token using an Unoswap-compatible exchange\'s pool,\n    *         sending the resulting tokens to the `to` address, with a minimum return specified by `minReturn`.\n    * @param to The address to receive the swapped tokens.\n    * @param token The address of the token to be swapped.\n    * @param amount The amount of tokens to be swapped.\n    * @param minReturn The minimum amount of tokens to be received after the swap.\n    * @param dex The address of the Unoswap-compatible exchange\'s pool.\n    * @return returnAmount The actual amount of tokens received after the swap.\n    */\n    function unoswapTo(Address to, Address token, uint256 amount, uint256 minReturn, Address dex) external returns(uint256 returnAmount) {\n        returnAmount = _unoswapTo(msg.sender, to.get(), token, amount, minReturn, dex);\n    }\n\n    /**\n    * @notice Swaps ETH for another token using an Unoswap-compatible exchange\'s pool, with a minimum return specified by `minReturn`.\n    *         The function is payable and requires the sender to attach ETH.\n    *         It is necessary to check if it\'s cheaper to use _WETH_NOT_WRAP_FLAG in `dex` Address (for example: for Curve pools).\n    * @param minReturn The minimum amount of tokens to be received after the swap.\n    * @param dex The address of the Unoswap-compatible exchange\'s pool.\n    * @return returnAmount The actual amount of tokens received after the swap.\n    */\n    function ethUnoswap(uint256 minReturn, Address dex) external payable returns(uint256 returnAmount) {\n        if (dex.shouldWrapWeth()) {\n            IWETH(_WETH).safeDeposit(msg.value);\n        }\n        returnAmount = _unoswapTo(address(this), msg.sender, Address.wrap(uint160(_WETH)), msg.value, minReturn, dex);\n    }\n\n    /**\n    * @notice Swaps ETH for another token using an Unoswap-compatible exchange\'s pool, sending the resulting tokens to the `to` address,\n    *         with a minimum return specified by `minReturn`. The function is payable and requires the sender to attach ETH.\n    *         It is necessary to check if it\'s cheaper to use _WETH_NOT_WRAP_FLAG in `dex` Address (for example: for Curve pools).\n    * @param to The address to receive the swapped tokens.\n    * @param minReturn The minimum amount of tokens to be received after the swap.\n    * @param dex The address of the Unoswap-compatible exchange\'s pool.\n    * @return returnAmount The actual amount of tokens received after the swap.\n    */\n    function ethUnoswapTo(Address to, uint256 minReturn, Address dex) external payable returns(uint256 returnAmount) {\n        if (dex.shouldWrapWeth()) {\n            IWETH(_WETH).safeDeposit(msg.value);\n        }\n        returnAmount = _unoswapTo(address(this), to.get(), Address.wrap(uint160(_WETH)), msg.value, minReturn, dex);\n    }\n\n    function _unoswapTo(address from, address to, Address token, uint256 amount, uint256 minReturn, Address dex) private whenNotPaused() returns(uint256 returnAmount) {\n        if (dex.shouldUnwrapWeth()) {\n            returnAmount = _unoswap(from, address(this), token, amount, minReturn, dex);\n            IWETH(_WETH).safeWithdrawTo(returnAmount, to);\n        } else {\n            returnAmount = _unoswap(from, to, token, amount, minReturn, dex);\n        }\n    }\n\n    // =====================================================================\n    //                    Methods with 2 sequential pools\n    // =====================================================================\n\n    /**\n    * @notice Swaps `amount` of the specified `token` for another token using two Unoswap-compatible exchange pools (`dex` and `dex2`) sequentially,\n    *         with a minimum return specified by `minReturn`.\n    * @param token The address of the token to be swapped.\n    * @param amount The amount of tokens to be swapped.\n    * @param minReturn The minimum amount of tokens to be received after the swap.\n    * @param dex The address of the first Unoswap-compatible exchange\'s pool.\n    * @param dex2 The address of the second Unoswap-compatible exchange\'s pool.\n    * @return returnAmount The actual amount of tokens received after the swap through both pools.\n    */\n    function unoswap2(Address token, uint256 amount, uint256 minReturn, Address dex, Address dex2) external returns(uint256 returnAmount) {\n        returnAmount = _unoswapTo2(msg.sender, msg.sender, token, amount, minReturn, dex, dex2);\n    }\n\n    /**\n    * @notice Swaps `amount` of the specified `token` for another token using two Unoswap-compatible exchange pools (`dex` and `dex2`) sequentially,\n    *         sending the resulting tokens to the `to` address, with a minimum return specified by `minReturn`.\n    * @param to The address to receive the swapped tokens.\n    * @param token The address of the token to be swapped.\n    * @param amount The amount of tokens to be swapped.\n    * @param minReturn The minimum amount of tokens to be received after the swap.\n    * @param dex The address of the first Unoswap-compatible exchange\'s pool.\n    * @param dex2 The address of the second Unoswap-compatible exchange\'s pool.\n    * @return returnAmount The actual amount of tokens received after the swap through both pools.\n    */\n    function unoswapTo2(Address to, Address token, uint256 amount, uint256 minReturn, Address dex, Address dex2) external returns(uint256 returnAmount) {\n        returnAmount = _unoswapTo2(msg.sender, to.get(), token, amount, minReturn, dex, dex2);\n    }\n\n    /**\n    * @notice Swaps ETH for another token using two Unoswap-compatible exchange pools (`dex` and `dex2`) sequentially,\n    *         with a minimum return specified by `minReturn`. The function is payable and requires the sender to attach ETH.\n    *         It is necessary to check if it\'s cheaper to use _WETH_NOT_WRAP_FLAG in `dex` Address (for example: for Curve pools).\n    * @param minReturn The minimum amount of tokens to be received after the swap.\n    * @param dex The address of the first Unoswap-compatible exchange\'s pool.\n    * @param dex2 The address of the second Unoswap-compatible exchange\'s pool.\n    * @return returnAmount The actual amount of tokens received after the swap through both pools.\n    */\n    function ethUnoswap2(uint256 minReturn, Address dex, Address dex2) external payable returns(uint256 returnAmount) {\n        if (dex.shouldWrapWeth()) {\n            IWETH(_WETH).safeDeposit(msg.value);\n        }\n        returnAmount = _unoswapTo2(address(this), msg.sender, Address.wrap(uint160(_WETH)), msg.value, minReturn, dex, dex2);\n    }\n\n    /**\n    * @notice Swaps ETH for another token using two Unoswap-compatible exchange pools (`dex` and `dex2`) sequentially,\n    *         sending the resulting tokens to the `to` address, with a minimum return specified by `minReturn`.\n    *         The function is payable and requires the sender to attach ETH.\n    *         It is necessary to check if it\'s cheaper to use _WETH_NOT_WRAP_FLAG in `dex` Address (for example: for Curve pools).\n    * @param to The address to receive the swapped tokens.\n    * @param minReturn The minimum amount of tokens to be received after the swap.\n    * @param dex The address of the first Unoswap-compatible exchange\'s pool.\n    * @param dex2 The address of the second Unoswap-compatible exchange\'s pool.\n    * @return returnAmount The actual amount of tokens received after the swap through both pools.\n    */\n    function ethUnoswapTo2(Address to, uint256 minReturn, Address dex, Address dex2) external payable returns(uint256 returnAmount) {\n        if (dex.shouldWrapWeth()) {\n            IWETH(_WETH).safeDeposit(msg.value);\n        }\n        returnAmount = _unoswapTo2(address(this), to.get(), Address.wrap(uint160(_WETH)), msg.value, minReturn, dex, dex2);\n    }\n\n    function _unoswapTo2(address from, address to, Address token, uint256 amount, uint256 minReturn, Address dex, Address dex2) private whenNotPaused() returns(uint256 returnAmount) {\n        address pool2 = dex2.addressForPreTransfer();\n        address target = dex2.shouldUnwrapWeth() ? address(this) : to;\n        returnAmount = _unoswap(from, pool2, token, amount, 0, dex);\n        returnAmount = _unoswap(pool2, target, Address.wrap(0), returnAmount, minReturn, dex2);\n        if (dex2.shouldUnwrapWeth()) {\n            IWETH(_WETH).safeWithdrawTo(returnAmount, to);\n        }\n    }\n\n    // =====================================================================\n    //                    Methods with 3 sequential pools\n    // =====================================================================\n\n    /**\n    * @notice Swaps `amount` of the specified `token` for another token using three Unoswap-compatible exchange pools\n    *         (`dex`, `dex2`, and `dex3`) sequentially, with a minimum return specified by `minReturn`.\n    * @param token The address of the token to be swapped.\n    * @param amount The amount of tokens to be swapped.\n    * @param minReturn The minimum amount of tokens to be received after the swap.\n    * @param dex The address of the first Unoswap-compatible exchange\'s pool.\n    * @param dex2 The address of the second Unoswap-compatible exchange\'s pool.\n    * @param dex3 The address of the third Unoswap-compatible exchange\'s pool.\n    * @return returnAmount The actual amount of tokens received after the swap through all three pools.\n    */\n    function unoswap3(Address token, uint256 amount, uint256 minReturn, Address dex, Address dex2, Address dex3) external returns(uint256 returnAmount) {\n        returnAmount = _unoswapTo3(msg.sender, msg.sender, token, amount, minReturn, dex, dex2, dex3);\n    }\n\n    /**\n    * @notice Swaps `amount` of the specified `token` for another token using three Unoswap-compatible exchange pools\n    *         (`dex`, `dex2`, and `dex3`) sequentially, sending the resulting tokens to the `to` address, with a minimum return specified by `minReturn`.\n    * @param to The address to receive the swapped tokens.\n    * @param token The address of the token to be swapped.\n    * @param amount The amount of tokens to be swapped.\n    * @param minReturn The minimum amount of tokens to be received after the swap.\n    * @param dex The address of the first Unoswap-compatible exchange\'s pool.\n    * @param dex2 The address of the second Unoswap-compatible exchange\'s pool.\n    * @param dex3 The address of the third Unoswap-compatible exchange\'s pool.\n    * @return returnAmount The actual amount of tokens received after the swap through all three pools.\n    */\n    function unoswapTo3(Address to, Address token, uint256 amount, uint256 minReturn, Address dex, Address dex2, Address dex3) external returns(uint256 returnAmount) {\n        returnAmount = _unoswapTo3(msg.sender, to.get(), token, amount, minReturn, dex, dex2, dex3);\n    }\n\n    /**\n    * @notice Swaps ETH for another token using three Unoswap-compatible exchange pools (`dex`, `dex2`, and `dex3`) sequentially,\n    *         with a minimum return specified by `minReturn`. The function is payable and requires the sender to attach ETH.\n    *         It is necessary to check if it\'s cheaper to use _WETH_NOT_WRAP_FLAG in `dex` Address (for example: for Curve pools).\n    * @param minReturn The minimum amount of tokens to be received after the swap.\n    * @param dex The address of the first Unoswap-compatible exchange\'s pool.\n    * @param dex2 The address of the second Unoswap-compatible exchange\'s pool.\n    * @param dex3 The address of the third Unoswap-compatible exchange\'s pool.\n    * @return returnAmount The actual amount of tokens received after the swap through all three pools.\n    */\n    function ethUnoswap3(uint256 minReturn, Address dex, Address dex2, Address dex3) external payable returns(uint256 returnAmount) {\n        if (dex.shouldWrapWeth()) {\n            IWETH(_WETH).safeDeposit(msg.value);\n        }\n        returnAmount = _unoswapTo3(address(this), msg.sender, Address.wrap(uint160(_WETH)), msg.value, minReturn, dex, dex2, dex3);\n    }\n\n    /**\n    * @notice Swaps ETH for another token using three Unoswap-compatible exchange pools (`dex`, `dex2`, and `dex3`) sequentially,\n    *         sending the resulting tokens to the `to` address, with a minimum return specified by `minReturn`.\n    *         The function is payable and requires the sender to attach ETH.\n    *         It is necessary to check if it\'s cheaper to use _WETH_NOT_WRAP_FLAG in `dex` Address (for example: for Curve pools).\n    * @param to The address to receive the swapped tokens.\n    * @param minReturn The minimum amount of tokens to be received after the swap.\n    * @param dex The address of the first Unoswap-compatible exchange\'s pool.\n    * @param dex2 The address of the second Unoswap-compatible exchange\'s pool.\n    * @param dex3 The address of the third Unoswap-compatible exchange\'s pool.\n    * @return returnAmount The actual amount of tokens received after the swap through all three pools.\n    */\n    function ethUnoswapTo3(Address to, uint256 minReturn, Address dex, Address dex2, Address dex3) external payable returns(uint256 returnAmount) {\n        if (dex.shouldWrapWeth()) {\n            IWETH(_WETH).safeDeposit(msg.value);\n        }\n        returnAmount = _unoswapTo3(address(this), to.get(), Address.wrap(uint160(_WETH)), msg.value, minReturn, dex, dex2, dex3);\n    }\n\n    function _unoswapTo3(address from, address to, Address token, uint256 amount, uint256 minReturn, Address dex, Address dex2, Address dex3) private whenNotPaused() returns(uint256 returnAmount) {\n        address pool2 = dex2.addressForPreTransfer();\n        address pool3 = dex3.addressForPreTransfer();\n        address target = dex3.shouldUnwrapWeth() ? address(this) : to;\n        returnAmount = _unoswap(from, pool2, token, amount, 0, dex);\n        returnAmount = _unoswap(pool2, pool3, Address.wrap(0), returnAmount, 0, dex2);\n        returnAmount = _unoswap(pool3, target, Address.wrap(0), returnAmount, minReturn, dex3);\n        if (dex3.shouldUnwrapWeth()) {\n            IWETH(_WETH).safeWithdrawTo(returnAmount, to);\n        }\n    }\n\n    function _unoswap(\n        address spender,\n        address recipient,\n        Address token,\n        uint256 amount,\n        uint256 minReturn,\n        Address dex\n    ) private returns(uint256 returnAmount) {\n        ProtocolLib.Protocol protocol = dex.protocol();\n        if (protocol == ProtocolLib.Protocol.UniswapV3) {\n            returnAmount = _unoswapV3(spender, recipient, amount, minReturn, dex);\n        } else if (protocol == ProtocolLib.Protocol.UniswapV2) {\n            if (spender == address(this)) {\n                IERC20(token.get()).safeTransfer(dex.get(), amount);\n            } else if (spender == msg.sender) {\n                IERC20(token.get()).safeTransferFromUniversal(msg.sender, dex.get(), amount, dex.usePermit2());\n            }\n            returnAmount = _unoswapV2(recipient, amount, minReturn, dex);\n        } else if (protocol == ProtocolLib.Protocol.Curve) {\n            if (spender == msg.sender && msg.value == 0) {\n                IERC20(token.get()).safeTransferFromUniversal(msg.sender, address(this), amount, dex.usePermit2());\n            }\n            returnAmount = _curfe(recipient, amount, minReturn, dex);\n        }\n    }\n\n    uint256 private constant _UNISWAP_V2_ZERO_FOR_ONE_OFFSET = 247;\n    uint256 private constant _UNISWAP_V2_ZERO_FOR_ONE_MASK = 0x01;\n    uint256 private constant _UNISWAP_V2_NUMERATOR_OFFSET = 160;\n    uint256 private constant _UNISWAP_V2_NUMERATOR_MASK = 0xffffffff;\n\n    bytes4 private constant _UNISWAP_V2_PAIR_RESERVES_CALL_SELECTOR = 0x0902f1ac;\n    bytes4 private constant _UNISWAP_V2_PAIR_SWAP_CALL_SELECTOR = 0x022c0d9f;\n    uint256 private constant _UNISWAP_V2_DENOMINATOR = 1e9;\n    uint256 private constant _UNISWAP_V2_DEFAULT_NUMERATOR = 997_000_000;\n\n    error ReservesCallFailed();\n\n    function _unoswapV2(\n        address recipient,\n        uint256 amount,\n        uint256 minReturn,\n        Address dex\n    ) private returns(uint256 ret) {\n        bytes4 returnAmountNotEnoughException = RouterErrors.ReturnAmountIsNotEnough.selector;\n        bytes4 reservesCallFailedException = ReservesCallFailed.selector;\n        assembly (""memory-safe"") {  // solhint-disable-line no-inline-assembly\n            let pool := and(dex, _ADDRESS_MASK)\n            let zeroForOne := and(shr(_UNISWAP_V2_ZERO_FOR_ONE_OFFSET, dex), _UNISWAP_V2_ZERO_FOR_ONE_MASK)\n            let numerator := and(shr(_UNISWAP_V2_NUMERATOR_OFFSET, dex), _UNISWAP_V2_NUMERATOR_MASK)\n            if iszero(numerator) {\n                numerator := _UNISWAP_V2_DEFAULT_NUMERATOR\n            }\n\n            let ptr := mload(0x40)\n\n            mstore(0, _UNISWAP_V2_PAIR_RESERVES_CALL_SELECTOR)\n            if iszero(staticcall(gas(), pool, 0, 4, 0, 0x40)) {\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            if sub(returndatasize(), 0x60) {\n                mstore(0, reservesCallFailedException)\n                revert(0, 4)\n            }\n\n            let reserve0 := mload(mul(0x20, iszero(zeroForOne)))\n            let reserve1 := mload(mul(0x20, zeroForOne))\n            // this will not overflow as reserve0, reserve1 and ret fit to 112 bit and numerator and _DENOMINATOR fit to 32 bit\n            ret := mul(amount, numerator)\n            ret := div(mul(ret, reserve1), add(ret, mul(reserve0, _UNISWAP_V2_DENOMINATOR)))\n\n            if lt(ret, minReturn) {\n                mstore(ptr, returnAmountNotEnoughException)\n                mstore(add(ptr, 0x04), ret)\n                mstore(add(ptr, 0x24), minReturn)\n                revert(ptr, 0x44)\n            }\n\n            mstore(ptr, _UNISWAP_V2_PAIR_SWAP_CALL_SELECTOR)\n            mstore(add(ptr, 0x04), mul(ret, iszero(zeroForOne)))\n            mstore(add(ptr, 0x24), mul(ret, zeroForOne))\n            mstore(add(ptr, 0x44), recipient)\n            mstore(add(ptr, 0x64), 0x80)\n            mstore(add(ptr, 0x84), 0)\n            if iszero(call(gas(), pool, 0, ptr, 0xa4, 0, 0)) {\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n        }\n    }\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 private constant _UNISWAP_V3_MIN_SQRT_RATIO = 4295128739 + 1;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 private constant _UNISWAP_V3_MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342 - 1;\n    uint256 private constant _UNISWAP_V3_ZERO_FOR_ONE_OFFSET = 247;\n    uint256 private constant _UNISWAP_V3_ZERO_FOR_ONE_MASK = 0x01;\n\n    function _unoswapV3(\n        address spender,\n        address recipient,\n        uint256 amount,\n        uint256 minReturn,\n        Address dex\n    ) private returns(uint256 ret) {\n        bytes4 swapSelector = IUniswapV3Pool.swap.selector;\n        bool usePermit2 = dex.usePermit2();\n        assembly (""memory-safe"") {  // solhint-disable-line no-inline-assembly\n            let pool := and(dex, _ADDRESS_MASK)\n            let zeroForOne := and(shr(_UNISWAP_V3_ZERO_FOR_ONE_OFFSET, dex), _UNISWAP_V3_ZERO_FOR_ONE_MASK)\n\n            let ptr := mload(0x40)\n            mstore(ptr, swapSelector)\n            mstore(add(ptr, 0x04), recipient)\n            mstore(add(ptr, 0x24), zeroForOne)\n            mstore(add(ptr, 0x44), amount)\n            switch zeroForOne\n            case 1 {\n                mstore(add(ptr, 0x64), _UNISWAP_V3_MIN_SQRT_RATIO)\n            }\n            case 0 {\n                mstore(add(ptr, 0x64), _UNISWAP_V3_MAX_SQRT_RATIO)\n            }\n            mstore(add(ptr, 0x84), 0xa0)\n            mstore(add(ptr, 0xa4), 0x40)\n            mstore(add(ptr, 0xc4), spender)\n            mstore(add(ptr, 0xe4), usePermit2)\n            if iszero(call(gas(), pool, 0, ptr, 0x0104, 0, 0x40)) {\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            ret := sub(0, mload(mul(0x20, zeroForOne)))\n        }\n        if (ret < minReturn) revert RouterErrors.ReturnAmountIsNotEnough(ret, minReturn);\n    }\n\n    uint256 private constant _CURVE_SWAP_SELECTOR_IDX_OFFSET = 184;\n    uint256 private constant _CURVE_SWAP_SELECTOR_IDX_MASK = 0xff;\n    uint256 private constant _CURVE_FROM_COINS_SELECTOR_OFFSET = 192;\n    uint256 private constant _CURVE_FROM_COINS_SELECTOR_MASK = 0xff;\n    uint256 private constant _CURVE_FROM_COINS_ARG_OFFSET = 200;\n    uint256 private constant _CURVE_FROM_COINS_ARG_MASK = 0xff;\n    uint256 private constant _CURVE_TO_COINS_SELECTOR_OFFSET = 208;\n    uint256 private constant _CURVE_TO_COINS_SELECTOR_MASK = 0xff;\n    uint256 private constant _CURVE_TO_COINS_ARG_OFFSET = 216;\n    uint256 private constant _CURVE_TO_COINS_ARG_MASK = 0xff;\n    uint256 private constant _CURVE_FROM_TOKEN_OFFSET = 224;\n    uint256 private constant _CURVE_FROM_TOKEN_MASK = 0xff;\n    uint256 private constant _CURVE_TO_TOKEN_OFFSET = 232;\n    uint256 private constant _CURVE_TO_TOKEN_MASK = 0xff;\n\n    uint256 private constant _CURVE_INPUT_WETH_DEPOSIT_OFFSET = 240;\n    uint256 private constant _CURVE_INPUT_WETH_WITHDRAW_OFFSET = 241;\n    uint256 private constant _CURVE_SWAP_USE_ETH_OFFSET = 242;\n    uint256 private constant _CURVE_SWAP_HAS_ARG_USE_ETH_OFFSET = 243;\n    uint256 private constant _CURVE_SWAP_HAS_ARG_DESTINATION_OFFSET = 244;\n    uint256 private constant _CURVE_OUTPUT_WETH_DEPOSIT_OFFSET = 245;\n    uint256 private constant _CURVE_OUTPUT_WETH_WITHDRAW_OFFSET = 246;\n    uint256 private constant _CURVE_SWAP_USE_SECOND_OUTPUT_OFFSET = 247;\n    uint256 private constant _CURVE_SWAP_HAS_ARG_CALLBACK_OFFSET = 249;\n\n    // Curve Pool function selectors for different `coins` methods. For details, see contracts/interfaces/ICurvePool.sol\n    bytes32 private constant _CURVE_COINS_SELECTORS = 0x87cb4f5723746eb8c6610657b739953eb9947eb0000000000000000000000000;\n    // Curve Pool function selectors for different `exchange` methods. For details, see contracts/interfaces/ICurvePool.sol\n    bytes32 private constant _CURVE_SWAP_SELECTORS_1 = 0x3df02124a6417ed6ddc1f59d44ee1986ed4ae2b8bf5ed0562f7865a837cab679;\n    bytes32 private constant _CURVE_SWAP_SELECTORS_2 = 0x2a064e3c5b41b90865b2489ba64833a0e2ad025a394747c5cb7558f1ce7d6503;\n    bytes32 private constant _CURVE_SWAP_SELECTORS_3 = 0xd2e2833add96994f000000000000000000000000000000000000000000000000;\n    uint256 private constant _CURVE_MAX_SELECTOR_INDEX = 17;\n\n    function _curfe(\n        address recipient,\n        uint256 amount,\n        uint256 minReturn,\n        Address dex\n    ) private returns(uint256 ret) {\n        bytes4 callbackSelector = this.curveSwapCallback.selector;\n        assembly (""memory-safe"") {  // solhint-disable-line no-inline-assembly\n            function reRevert() {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n\n            function callReturnSize(status) -> rds {\n                if iszero(status) {\n                    reRevert()\n                }\n                rds := returndatasize()\n            }\n\n            function tokenBalanceOf(tokenAddress, accountAddress) -> tokenBalance {\n                mstore(0, 0x70a0823100000000000000000000000000000000000000000000000000000000)\n                mstore(4, accountAddress)\n                if iszero(callReturnSize(staticcall(gas(), tokenAddress, 0, 0x24, 0, 0x20))) {\n                    revert(0, 0)\n                }\n                tokenBalance := mload(0)\n            }\n\n            function asmApprove(token, to, value, mem) {\n                let selector := 0x095ea7b300000000000000000000000000000000000000000000000000000000 // IERC20.approve.selector\n                let exception := 0x3e3f8f7300000000000000000000000000000000000000000000000000000000 // error ApproveFailed()\n                if iszero(_asmCall(token, selector, to, value, mem)) {\n                    if iszero(_asmCall(token, selector, to, 0, mem)) {\n                        mstore(mem, exception)\n                        revert(mem, 4)\n                    }\n                    if iszero(_asmCall(token, selector, to, value, mem)) {\n                        mstore(mem, exception)\n                        revert(mem, 4)\n                    }\n                }\n            }\n\n            function _asmCall(token, selector, to, value, mem) -> done {\n                mstore(mem, selector)\n                mstore(add(mem, 0x04), to)\n                mstore(add(mem, 0x24), value)\n                let success := call(gas(), token, 0, mem, 0x44, 0x0, 0x20)\n                done := and(\n                    success,\n                    or(\n                        iszero(returndatasize()),\n                        and(gt(returndatasize(), 31), eq(mload(0), 1))\n                    )\n                )\n            }\n\n            function curveCoins(pool, selectorOffset, index) -> coin {\n                mstore(0, _CURVE_COINS_SELECTORS)\n                mstore(add(selectorOffset, 4), index)\n                if iszero(staticcall(gas(), pool, selectorOffset, 0x24, 0, 0x20)) {\n                    reRevert()\n                }\n                coin := mload(0)\n            }\n\n            let pool := and(dex, _ADDRESS_MASK)\n            let useEth := and(shr(_CURVE_SWAP_USE_ETH_OFFSET, dex), 0x01)\n            let hasCallback := and(shr(_CURVE_SWAP_HAS_ARG_CALLBACK_OFFSET, dex), 0x01)\n\n            if and(shr(_CURVE_INPUT_WETH_DEPOSIT_OFFSET, dex), 0x01) {\n                // Deposit ETH to WETH\n                mstore(0, _WETH_DEPOSIT_CALL_SELECTOR)\n                if iszero(call(gas(), _WETH, amount, 0, 4, 0, 0)) {\n                    reRevert()\n                }\n            }\n\n            if and(shr(_CURVE_INPUT_WETH_WITHDRAW_OFFSET, dex), 0x01) {\n                // Withdraw ETH from WETH\n                mstore(0, _WETH_WITHDRAW_CALL_SELECTOR)\n                mstore(4, amount)\n                if iszero(call(gas(), _WETH, 0, 0, 0x24, 0, 0)) {\n                    reRevert()\n                }\n            }\n\n            let toToken\n            {  // Stack too deep\n                let toSelectorOffset := and(shr(_CURVE_TO_COINS_SELECTOR_OFFSET, dex), _CURVE_TO_COINS_SELECTOR_MASK)\n                let toTokenIndex := and(shr(_CURVE_TO_COINS_ARG_OFFSET, dex), _CURVE_TO_COINS_ARG_MASK)\n                toToken := curveCoins(pool, toSelectorOffset, toTokenIndex)\n            }\n            let toTokenIsEth := or(eq(toToken, _ETH), eq(toToken, _WETH))\n\n            // use approve when the callback is not used AND (raw ether is not used at all OR ether is used on the output)\n            if and(iszero(hasCallback), or(iszero(useEth), toTokenIsEth)) {\n                let fromSelectorOffset := and(shr(_CURVE_FROM_COINS_SELECTOR_OFFSET, dex), _CURVE_FROM_COINS_SELECTOR_MASK)\n                let fromTokenIndex := and(shr(_CURVE_FROM_COINS_ARG_OFFSET, dex), _CURVE_FROM_COINS_ARG_MASK)\n                let fromToken := curveCoins(pool, fromSelectorOffset, fromTokenIndex)\n                if eq(fromToken, _ETH) {\n                    fromToken := _WETH\n                }\n                asmApprove(fromToken, pool, amount, mload(0x40))\n            }\n\n            // Swap\n            let ptr := mload(0x40)\n            {  // stack too deep\n                let selectorIndex := and(shr(_CURVE_SWAP_SELECTOR_IDX_OFFSET, dex), _CURVE_SWAP_SELECTOR_IDX_MASK)\n                if gt(selectorIndex, _CURVE_MAX_SELECTOR_INDEX) {\n                    mstore(0, 0xa231cb8200000000000000000000000000000000000000000000000000000000)  // BadCurveSwapSelector()\n                    revert(0, 4)\n                }\n                mstore(ptr, _CURVE_SWAP_SELECTORS_1)\n                mstore(add(ptr, 0x20), _CURVE_SWAP_SELECTORS_2)\n                mstore(add(ptr, 0x40), _CURVE_SWAP_SELECTORS_3)\n                ptr := add(ptr, mul(selectorIndex, 4))\n            }\n            mstore(add(ptr, 0x04), and(shr(_CURVE_FROM_TOKEN_OFFSET, dex), _CURVE_FROM_TOKEN_MASK))\n            mstore(add(ptr, 0x24), and(shr(_CURVE_TO_TOKEN_OFFSET, dex), _CURVE_TO_TOKEN_MASK))\n            mstore(add(ptr, 0x44), amount)\n            mstore(add(ptr, 0x64), minReturn)\n            let offset := 0x84\n            if and(shr(_CURVE_SWAP_HAS_ARG_USE_ETH_OFFSET, dex), 0x01) {\n                mstore(add(ptr, offset), useEth)\n                offset := add(offset, 0x20)\n            }\n            switch hasCallback\n            case 1 {\n                mstore(add(ptr, offset), address())\n                mstore(add(ptr, add(offset, 0x20)), recipient)\n                mstore(add(ptr, add(offset, 0x40)), callbackSelector)\n                offset := add(offset, 0x60)\n            }\n            default {\n                if and(shr(_CURVE_SWAP_HAS_ARG_DESTINATION_OFFSET, dex), 0x01) {\n                    mstore(add(ptr, offset), recipient)\n                    offset := add(offset, 0x20)\n                }\n            }\n\n            // swap call\n            // value is passed when useEth is set but toToken is not ETH\n            switch callReturnSize(call(gas(), pool, mul(mul(amount, useEth), iszero(toTokenIsEth)), ptr, offset, 0, 0x40))\n            case 0 {\n                // we expect that curve pools that do not return any value also do not have the recipient argument\n                switch and(useEth, toTokenIsEth)\n                case 1 {\n                    ret := balance(address())\n                }\n                default {\n                    ret := tokenBalanceOf(toToken, address())\n                }\n                ret := sub(ret, 1)  // keep 1 wei\n            }\n            default {\n                ret := mload(mul(0x20, and(shr(_CURVE_SWAP_USE_SECOND_OUTPUT_OFFSET, dex), 0x01)))\n            }\n\n            if iszero(and(shr(_CURVE_SWAP_HAS_ARG_DESTINATION_OFFSET, dex), 0x01)) {\n                if and(shr(_CURVE_OUTPUT_WETH_DEPOSIT_OFFSET, dex), 0x01) {\n                    // Deposit ETH to WETH\n                    mstore(0, _WETH_DEPOSIT_CALL_SELECTOR)\n                    if iszero(call(gas(), _WETH, ret, 0, 4, 0, 0)) {\n                        reRevert()\n                    }\n                }\n\n                if and(shr(_CURVE_OUTPUT_WETH_WITHDRAW_OFFSET, dex), 0x01) {\n                    // Withdraw ETH from WETH\n                    mstore(0, _WETH_WITHDRAW_CALL_SELECTOR)\n                    mstore(4, ret)\n                    if iszero(call(gas(), _WETH, 0, 0, 0x24, 0, 0)) {\n                        reRevert()\n                    }\n                }\n\n                // Post transfer toToken if needed\n                if xor(recipient, address()) {\n                    switch and(useEth, toTokenIsEth)\n                    case 1 {\n                        if iszero(call(gas(), recipient, ret, 0, 0, 0, 0)) {\n                            reRevert()\n                        }\n                    }\n                    default {\n                        if eq(toToken, _ETH) {\n                            toToken := _WETH\n                        }\n                        // toToken.transfer(recipient, ret)\n                        if iszero(_asmCall(toToken, 0xa9059cbb00000000000000000000000000000000000000000000000000000000, recipient, ret, ptr)) {\n                            mstore(ptr, 0xf27f64e400000000000000000000000000000000000000000000000000000000)  // error ERC20TransferFailed()\n                            revert(ptr, 4)\n                        }\n                    }\n                }\n            }\n        }\n        if (ret < minReturn) revert RouterErrors.ReturnAmountIsNotEnough(ret, minReturn);\n    }\n\n    /**\n     * @notice Called by Curve pool during the swap operation initiated by `_curfe`.\n     * @dev This function can be called by anyone assuming there are no tokens\n     * stored on this contract between transactions.\n     * @param inCoin Address of the token to be exchanged.\n     * @param dx Amount of tokens to be exchanged.\n     */\n    function curveSwapCallback(\n        address /* sender */,\n        address /* receiver */,\n        address inCoin,\n        uint256 dx,\n        uint256 /* dy */\n    ) external {\n        IERC20(inCoin).safeTransfer(msg.sender, dx);\n    }\n\n    /**\n     * @notice See {IUniswapV3SwapCallback-uniswapV3SwapCallback}\n     *         Called by UniswapV3 pool during the swap operation initiated by `_unoswapV3`.\n     *         This callback function ensures the proper transfer of tokens based on the swap\'s\n     *         configuration. It handles the transfer of tokens by either directly transferring\n     *         the tokens from the payer to the recipient, or by using a secondary permit contract\n     *         to transfer the tokens if required by the pool. It verifies the correct pool is\n     *         calling the function and uses inline assembly for efficient execution and to access\n     *         low-level EVM features.\n     */\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata /* data */\n    ) external override {\n        uint256 selectors = _SELECTORS;\n        assembly (""memory-safe"") {  // solhint-disable-line no-inline-assembly\n            function reRevert() {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n\n            function safeERC20(target, value, mem, memLength, outLen) {\n                let status := call(gas(), target, value, mem, memLength, 0, outLen)\n                if iszero(status) {\n                    reRevert()\n                }\n                let success := or(\n                    iszero(returndatasize()),                       // empty return data\n                    and(gt(returndatasize(), 31), eq(mload(0), 1))  // true in return data\n                )\n                if iszero(success) {\n                    mstore(0, 0xf27f64e400000000000000000000000000000000000000000000000000000000)  // ERC20TransferFailed()\n                    revert(0, 4)\n                }\n            }\n\n            let emptyPtr := mload(0x40)\n            let resultPtr := add(emptyPtr, 0x15)  // 0x15 = _FF_FACTORY size\n\n            mstore(emptyPtr, selectors)\n\n            let amount\n            let token\n            switch sgt(amount0Delta, 0)\n            case 1 {\n                if iszero(staticcall(gas(), caller(), add(emptyPtr, _TOKEN0_SELECTOR_OFFSET), 0x4, resultPtr, 0x20)) {\n                    reRevert()\n                }\n                token := mload(resultPtr)\n                amount := amount0Delta\n            }\n            default {\n                if iszero(staticcall(gas(), caller(), add(emptyPtr, _TOKEN1_SELECTOR_OFFSET), 0x4, add(resultPtr, 0x20), 0x20)) {\n                    reRevert()\n                }\n                token := mload(add(resultPtr, 0x20))\n                amount := amount1Delta\n            }\n\n            let payer := calldataload(0x84)\n            let usePermit2 := calldataload(0xa4)\n            switch eq(payer, address())\n            case 1 {\n                // IERC20(token.get()).safeTransfer(msg.sender,amount)\n                mstore(add(emptyPtr, add(_TRANSFER_SELECTOR_OFFSET, 0x04)), caller())\n                mstore(add(emptyPtr, add(_TRANSFER_SELECTOR_OFFSET, 0x24)), amount)\n                safeERC20(token, 0, add(emptyPtr, _TRANSFER_SELECTOR_OFFSET), 0x44, 0x20)\n            }\n            default {\n                switch sgt(amount0Delta, 0)\n                case 1 {\n                    if iszero(staticcall(gas(), caller(), add(emptyPtr, _TOKEN1_SELECTOR_OFFSET), 0x4, add(resultPtr, 0x20), 0x20)) {\n                        reRevert()\n                    }\n                }\n                default {\n                    if iszero(staticcall(gas(), caller(), add(emptyPtr, _TOKEN0_SELECTOR_OFFSET), 0x4, resultPtr, 0x20)) {\n                        reRevert()\n                    }\n                }\n                if iszero(staticcall(gas(), caller(), add(emptyPtr, _FEE_SELECTOR_OFFSET), 0x4, add(resultPtr, 0x40), 0x20)) {\n                    reRevert()\n                }\n\n                mstore(emptyPtr, _FF_FACTORY)\n                mstore(resultPtr, keccak256(resultPtr, 0x60)) // Compute the inner hash in-place\n                mstore(add(resultPtr, 0x20), _POOL_INIT_CODE_HASH)\n                let pool := and(keccak256(emptyPtr, 0x55), _ADDRESS_MASK)\n                if xor(pool, caller()) {\n                    mstore(0, 0xb2c0272200000000000000000000000000000000000000000000000000000000)  // BadPool()\n                    revert(0, 4)\n                }\n                switch usePermit2\n                case 1 {\n                    // permit2.transferFrom(payer, msg.sender, amount, token);\n                    mstore(emptyPtr, selectors)\n                    emptyPtr := add(emptyPtr, _PERMIT2_TRANSFER_FROM_SELECTOR_OFFSET)\n                    mstore(add(emptyPtr, 0x04), payer)\n                    mstore(add(emptyPtr, 0x24), caller())\n                    mstore(add(emptyPtr, 0x44), amount)\n                    mstore(add(emptyPtr, 0x64), token)\n                    let success := call(gas(), _PERMIT2, 0, emptyPtr, 0x84, 0, 0)\n                    if success {\n                        success := gt(extcodesize(_PERMIT2), 0)\n                    }\n                    if iszero(success) {\n                        mstore(0, 0xc3f9d33200000000000000000000000000000000000000000000000000000000)  // Permit2TransferFromFailed()\n                        revert(0, 4)\n                    }\n                }\n                case 0 {\n                    // IERC20(token.get()).safeTransferFrom(payer, msg.sender, amount);\n                    mstore(emptyPtr, selectors)\n                    emptyPtr := add(emptyPtr, _TRANSFER_FROM_SELECTOR_OFFSET)\n                    mstore(add(emptyPtr, 0x04), payer)\n                    mstore(add(emptyPtr, 0x24), caller())\n                    mstore(add(emptyPtr, 0x44), amount)\n                    safeERC20(token, 0, emptyPtr, 0x64, 0x20)\n                }\n            }\n        }\n    }\n}\n\n// File contracts/AggregationRouterV6.sol\n\n/// @notice Main contract incorporates a number of routers to perform swaps and limit orders protocol to fill limit orders\ncontract AggregationRouterV6 is EIP712(""1inch Aggregation Router"", ""6""), Ownable, Pausable,\n    ClipperRouter, GenericRouter, UnoswapRouter, PermitAndCall, OrderMixin\n{\n    using UniERC20 for IERC20;\n\n    error ZeroAddress();\n\n    /**\n     * @dev Sets the wrapped eth token and clipper exhange interface\n     * Both values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(IWETH weth)\n        ClipperRouter(weth)\n        OrderMixin(weth)\n        Ownable(msg.sender)\n    {\n        if (address(weth) == address(0)) revert ZeroAddress();\n    }\n\n    /**\n     * @notice Retrieves funds accidently sent directly to the contract address\n     * @param token ERC20 token to retrieve\n     * @param amount amount to retrieve\n     */\n    function rescueFunds(IERC20 token, uint256 amount) external onlyOwner {\n        token.uniTransfer(payable(msg.sender), amount);\n    }\n\n    /**\n     * @notice Pauses all the trading functionality in the contract.\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Unpauses all the trading functionality in the contract.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function _receive() internal override(EthReceiver, OnlyWethReceiver) {\n        EthReceiver._receive();\n    }\n}\n'}}

// File: settings
{'optimizer': {'enabled': True, 'runs': 1600, 'details': {'yul': True, 'yulDetails': {'optimizerSteps': 'dhfoDgvulfnTUtnIf[xa[r]EscLMcCTUtTOntnfDIulLculVcul [j]Tpeulxa[rul]xa[r]cLCTUca[r]LSsTFOtfDnca[r]Iulc]jmul[jul] VcTOcul jmul : fDnTOc'}}}, 'evmVersion': 'shanghai', 'viaIR': True, 'outputSelection': {'*': {'*': ['evm.bytecode', 'evm.deployedBytecode', 'devdoc', 'userdoc', 'metadata', 'abi']}}, 'libraries': {}}",True
0x3bd7d4f524d09f4e331577247a048d56e4b67a7f,"// File: language
Solidity

// File: sources
{'@openzeppelin/contracts/token/ERC20/ERC20.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport ""./IERC20.sol"";\nimport ""./extensions/IERC20Metadata.sol"";\nimport ""../../utils/Context.sol"";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn\'t required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it\'s overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``\'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, ""ERC20: decreased allowance below zero"");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), ""ERC20: transfer from the zero address"");\n        require(to != address(0), ""ERC20: transfer to the zero address"");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, ""ERC20: transfer amount exceeds balance"");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), ""ERC20: mint to the zero address"");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), ""ERC20: burn from the zero address"");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, ""ERC20: burn amount exceeds balance"");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), ""ERC20: approve from the zero address"");\n        require(spender != address(0), ""ERC20: approve to the zero address"");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, ""ERC20: insufficient allowance"");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n'}, '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport ""../IERC20.sol"";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n'}, '@openzeppelin/contracts/token/ERC20/IERC20.sol': {'content': ""// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n""}, '@openzeppelin/contracts/utils/Context.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n'}, 'contracts/FireErc20.sol': {'content': '//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.21;\n\nimport { ERC20 } from ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";\n\n/**\n * @author 5ire Team [5ire](https://github.com/5ire-org)\n */\ncontract FireErc20 is ERC20 {\n    uint256 private constant _INITIAL_SUPPLY = 1500000000 * 1e18;\n    uint256 private constant _DISTRIBUTION_PERCENT_BASE = 10000000000; // lowest possible percent value is 0.00000001%\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address[] memory _addresses,\n        uint256[] memory _distributionPercents\n    ) ERC20(_name, _symbol) {\n        uint256 totalAddresses = _addresses.length;\n        require(\n            totalAddresses == _distributionPercents.length,\n            ""5ire: Inequal array""\n        );\n\n        uint256 percentSum;\n        for (uint256 index; index < totalAddresses; ++index) {\n            percentSum += _distributionPercents[index];\n            require(_addresses[index] != address(0), ""5ire: zero address"");\n            _mint(\n                _addresses[index],\n                (_INITIAL_SUPPLY * _distributionPercents[index]) /\n                    _DISTRIBUTION_PERCENT_BASE\n            );\n        }\n\n        require(\n            percentSum == _DISTRIBUTION_PERCENT_BASE,\n            ""5ire: bad percentages""\n        );\n    }\n}\n'}}

// File: settings
{'optimizer': {'enabled': True, 'runs': 2000}, 'outputSelection': {'*': {'*': ['evm.bytecode', 'evm.deployedBytecode', 'devdoc', 'userdoc', 'metadata', 'abi']}}, 'libraries': {}}",True
0x19b5cc75846bf6286d599ec116536a333c4c2c14,"// File: language
Solidity

// File: sources
{'@openzeppelin/contracts/access/Ownable.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from ""../utils/Context.sol"";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n'}, '@openzeppelin/contracts/interfaces/IERC1967.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n'}, '@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/BeaconProxy.sol)\n\npragma solidity ^0.8.20;\n\nimport {IBeacon} from ""./IBeacon.sol"";\nimport {Proxy} from ""../Proxy.sol"";\nimport {ERC1967Utils} from ""../ERC1967/ERC1967Utils.sol"";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\n *\n * The beacon address can only be set once during construction, and cannot be changed afterwards. It is stored in an\n * immutable variable to avoid unnecessary storage reads, and also in the beacon storage slot specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] so that it can be accessed externally.\n *\n * CAUTION: Since the beacon address can never be changed, you must ensure that you either control the beacon, or trust\n * the beacon to not upgrade the implementation maliciously.\n *\n * IMPORTANT: Do not use the implementation logic to modify the beacon storage slot. Doing so would leave the proxy in\n * an inconsistent state where the beacon storage slot does not match the beacon address.\n */\ncontract BeaconProxy is Proxy {\n    // An immutable address for the beacon to avoid unnecessary SLOADs before each delegate call.\n    address private immutable _beacon;\n\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it\'s used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     * - If `data` is empty, `msg.value` must be zero.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        ERC1967Utils.upgradeBeaconToAndCall(beacon, data);\n        _beacon = beacon;\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /**\n     * @dev Returns the beacon.\n     */\n    function _getBeacon() internal view virtual returns (address) {\n        return _beacon;\n    }\n}\n'}, '@openzeppelin/contracts/proxy/beacon/IBeacon.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {UpgradeableBeacon} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n'}, '@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/UpgradeableBeacon.sol)\n\npragma solidity ^0.8.20;\n\nimport {IBeacon} from ""./IBeacon.sol"";\nimport {Ownable} from ""../../access/Ownable.sol"";\n\n/**\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\n * implementation contract, which is where they will delegate all function calls.\n *\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\n */\ncontract UpgradeableBeacon is IBeacon, Ownable {\n    address private _implementation;\n\n    /**\n     * @dev The `implementation` of the beacon is invalid.\n     */\n    error BeaconInvalidImplementation(address implementation);\n\n    /**\n     * @dev Emitted when the implementation returned by the beacon is changed.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Sets the address of the initial implementation, and the initial owner who can upgrade the beacon.\n     */\n    constructor(address implementation_, address initialOwner) Ownable(initialOwner) {\n        _setImplementation(implementation_);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function implementation() public view virtual returns (address) {\n        return _implementation;\n    }\n\n    /**\n     * @dev Upgrades the beacon to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * Requirements:\n     *\n     * - msg.sender must be the owner of the contract.\n     * - `newImplementation` must be a contract.\n     */\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\n        _setImplementation(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation contract address for this beacon\n     *\n     * Requirements:\n     *\n     * - `newImplementation` must be a contract.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert BeaconInvalidImplementation(newImplementation);\n        }\n        _implementation = newImplementation;\n        emit Upgraded(newImplementation);\n    }\n}\n'}, '@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.20;\n\nimport {Proxy} from ""../Proxy.sol"";\nimport {ERC1967Utils} from ""./ERC1967Utils.sol"";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn\'t conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `implementation`.\n     *\n     * If `_data` is nonempty, it\'s used as data in a delegate call to `implementation`. This will typically be an\n     * encoded function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     *\n     * Requirements:\n     *\n     * - If `data` is empty, `msg.value` must be zero.\n     */\n    constructor(address implementation, bytes memory _data) payable {\n        ERC1967Utils.upgradeToAndCall(implementation, _data);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return ERC1967Utils.getImplementation();\n    }\n}\n'}, '@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Utils.sol)\n\npragma solidity ^0.8.20;\n\nimport {IBeacon} from ""../beacon/IBeacon.sol"";\nimport {Address} from ""../../utils/Address.sol"";\nimport {StorageSlot} from ""../../utils/StorageSlot.sol"";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n */\nlibrary ERC1967Utils {\n    // We re-declare ERC-1967 events here because they can\'t be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of ""eip1967.proxy.implementation"" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of ""eip1967.proxy.admin"" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of ""eip1967.proxy.beacon"" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn\'t perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}\n'}, '@openzeppelin/contracts/proxy/Proxy.sol': {'content': ""// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback\n     * function and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n}\n""}, '@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.20;\n\nimport {ITransparentUpgradeableProxy} from ""./TransparentUpgradeableProxy.sol"";\nimport {Ownable} from ""../../access/Ownable.sol"";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgrade(address)`\n     * and `upgradeAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `""5.0.0""`, only `upgradeAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = ""5.0.0"";\n\n    /**\n     * @dev Sets the initial owner who can perform upgrades.\n     */\n    constructor(address initialOwner) Ownable(initialOwner) {}\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation.\n     * See {TransparentUpgradeableProxy-_dispatchUpgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     * - If `data` is empty, `msg.value` must be zero.\n     */\n    function upgradeAndCall(\n        ITransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n'}, '@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC1967Utils} from ""../ERC1967/ERC1967Utils.sol"";\nimport {ERC1967Proxy} from ""../ERC1967/ERC1967Proxy.sol"";\nimport {IERC1967} from ""../../interfaces/IERC1967.sol"";\nimport {ProxyAdmin} from ""./ProxyAdmin.sol"";\n\n/**\n * @dev Interface for {TransparentUpgradeableProxy}. In order to implement transparency, {TransparentUpgradeableProxy}\n * does not implement this interface directly, and its upgradeability mechanism is implemented by an internal dispatch\n * mechanism. The compiler is unaware that these functions are implemented by {TransparentUpgradeableProxy} and will not\n * include them in the ABI so this interface must be used to interact with it.\n */\ninterface ITransparentUpgradeableProxy is IERC1967 {\n    function upgradeToAndCall(address, bytes calldata) external payable;\n}\n\n/**\n * @dev This contract implements a proxy that is upgradeable through an associated {ProxyAdmin} instance.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches the {ITransparentUpgradeableProxy-upgradeToAndCall} function exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can call the `upgradeToAndCall` function but any other call won\'t be forwarded to\n * the implementation. If the admin tries to call a function on the implementation it will fail with an error indicating\n * the proxy admin cannot fallback to the target implementation.\n *\n * These properties mean that the admin account can only be used for upgrading the proxy, so it\'s best if it\'s a\n * dedicated account that is not used for anything else. This will avoid headaches due to sudden errors when trying to\n * call a function from the proxy implementation. For this reason, the proxy deploys an instance of {ProxyAdmin} and\n * allows upgrades only if they come through it. You should think of the `ProxyAdmin` instance as the administrative\n * interface of the proxy, including the ability to change who can trigger upgrades by transferring ownership.\n *\n * NOTE: The real interface of this proxy is that defined in `ITransparentUpgradeableProxy`. This contract does not\n * inherit from that interface, and instead `upgradeToAndCall` is implicitly implemented using a custom dispatch\n * mechanism in `_fallback`. Consequently, the compiler will not produce an ABI for this contract. This is necessary to\n * fully implement transparency without decoding reverts caused by selector clashes between the proxy and the\n * implementation.\n *\n * NOTE: This proxy does not inherit from {Context} deliberately. The {ProxyAdmin} of this contract won\'t send a\n * meta-transaction in any way, and any other meta-transaction setup should be made in the implementation contract.\n *\n * IMPORTANT: This contract avoids unnecessary storage reads by setting the admin only during construction as an\n * immutable variable, preventing any changes thereafter. However, the admin slot defined in ERC-1967 can still be\n * overwritten by the implementation logic pointed to by this proxy. In such cases, the contract may end up in an\n * undesirable state where the admin slot is different from the actual admin.\n *\n * WARNING: It is not recommended to extend this contract to add additional external functions. If you do so, the\n * compiler will not check that there are no selector conflicts, due to the note above. A selector clash between any new\n * function and the functions declared in {ITransparentUpgradeableProxy} will be resolved in favor of the new one. This\n * could render the `upgradeToAndCall` function inaccessible, preventing upgradeability and compromising transparency.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    // An immutable address for the admin to avoid unnecessary SLOADs before each call\n    // at the expense of removing the ability to change the admin once it\'s set.\n    // This is acceptable if the admin is always a ProxyAdmin instance or similar contract\n    // with its own ability to transfer the permissions to another account.\n    address private immutable _admin;\n\n    /**\n     * @dev The proxy caller is the current admin, and can\'t fallback to the proxy target.\n     */\n    error ProxyDeniedAdminAccess();\n\n    /**\n     * @dev Initializes an upgradeable proxy managed by an instance of a {ProxyAdmin} with an `initialOwner`,\n     * backed by the implementation at `_logic`, and optionally initialized with `_data` as explained in\n     * {ERC1967Proxy-constructor}.\n     */\n    constructor(address _logic, address initialOwner, bytes memory _data) payable ERC1967Proxy(_logic, _data) {\n        _admin = address(new ProxyAdmin(initialOwner));\n        // Set the storage value and emit an event for ERC-1967 compatibility\n        ERC1967Utils.changeAdmin(_proxyAdmin());\n    }\n\n    /**\n     * @dev Returns the admin of this proxy.\n     */\n    function _proxyAdmin() internal virtual returns (address) {\n        return _admin;\n    }\n\n    /**\n     * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior.\n     */\n    function _fallback() internal virtual override {\n        if (msg.sender == _proxyAdmin()) {\n            if (msg.sig != ITransparentUpgradeableProxy.upgradeToAndCall.selector) {\n                revert ProxyDeniedAdminAccess();\n            } else {\n                _dispatchUpgradeToAndCall();\n            }\n        } else {\n            super._fallback();\n        }\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy. See {ERC1967Utils-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - If `data` is empty, `msg.value` must be zero.\n     */\n    function _dispatchUpgradeToAndCall() private {\n        (address newImplementation, bytes memory data) = abi.decode(msg.data[4:], (address, bytes));\n        ERC1967Utils.upgradeToAndCall(newImplementation, data);\n    }\n}\n'}, '@openzeppelin/contracts/utils/Address.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("""");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n'}, '@openzeppelin/contracts/utils/Context.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n'}, '@openzeppelin/contracts/utils/StorageSlot.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n'}}

// File: settings
{'optimizer': {'enabled': True, 'runs': 200}, 'outputSelection': {'*': {'*': ['evm.bytecode', 'evm.deployedBytecode', 'devdoc', 'userdoc', 'metadata', 'abi']}}, 'evmVersion': 'paris'}",True
0x83f20f44975d03b1b09e64809b757c47f942beea,"// SPDX-License-Identifier: AGPL-3.0-or-later

/// SavingsDai.sol -- A tokenized representation DAI in the DSR (pot)

// Copyright (C) 2017, 2018, 2019 dbrock, rain, mrchico
// Copyright (C) 2021-2022 Dai Foundation
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

pragma solidity ^0.8.17;

interface IERC1271 {
    function isValidSignature(
        bytes32,
        bytes memory
    ) external view returns (bytes4);
}

interface VatLike {
    function hope(address) external;
}

interface PotLike {
    function chi() external view returns (uint256);
    function rho() external view returns (uint256);
    function dsr() external view returns (uint256);
    function drip() external returns (uint256);
    function join(uint256) external;
    function exit(uint256) external;
}

interface DaiJoinLike {
    function vat() external view returns (address);
    function dai() external view returns (address);
    function join(address, uint256) external;
    function exit(address, uint256) external;
}

interface DaiLike {
    function transferFrom(address, address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}

contract SavingsDai {

    // --- ERC20 Data ---
    string  public constant name     = ""Savings Dai"";
    string  public constant symbol   = ""sDAI"";
    string  public constant version  = ""1"";
    uint8   public constant decimals = 18;
    uint256 public totalSupply;

    mapping (address => uint256)                      public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;
    mapping (address => uint256)                      public nonces;

    // --- Data ---
    VatLike     public immutable vat;
    DaiJoinLike public immutable daiJoin;
    DaiLike     public immutable dai;
    PotLike     public immutable pot;

    // --- Events ---
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);
    event Withdraw(address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares);

    // --- EIP712 niceties ---
    uint256 public immutable deploymentChainId;
    bytes32 private immutable _DOMAIN_SEPARATOR;
    bytes32 public constant PERMIT_TYPEHASH = keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");
    
    uint256 private constant RAY = 10 ** 27;

    constructor(address _daiJoin, address _pot) {
        daiJoin = DaiJoinLike(_daiJoin);
        vat = VatLike(daiJoin.vat());
        dai = DaiLike(daiJoin.dai());
        pot = PotLike(_pot);

        deploymentChainId = block.chainid;
        _DOMAIN_SEPARATOR = _calculateDomainSeparator(block.chainid);

        vat.hope(address(daiJoin));
        vat.hope(address(pot));

        dai.approve(address(daiJoin), type(uint256).max);
    }

    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {
        return keccak256(
            abi.encode(
                keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""),
                keccak256(bytes(name)),
                keccak256(bytes(version)),
                chainId,
                address(this)
            )
        );
    }

    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return block.chainid == deploymentChainId ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(block.chainid);
    }

    function _rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {
        assembly {
            switch x case 0 {switch n case 0 {z := RAY} default {z := 0}}
            default {
                switch mod(n, 2) case 0 { z := RAY } default { z := x }
                let half := div(RAY, 2)  // for rounding.
                for { n := div(n, 2) } n { n := div(n,2) } {
                    let xx := mul(x, x)
                    if iszero(eq(div(xx, x), x)) { revert(0,0) }
                    let xxRound := add(xx, half)
                    if lt(xxRound, xx) { revert(0,0) }
                    x := div(xxRound, RAY)
                    if mod(n,2) {
                        let zx := mul(z, x)
                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }
                        let zxRound := add(zx, half)
                        if lt(zxRound, zx) { revert(0,0) }
                        z := div(zxRound, RAY)
                    }
                }
            }
        }
    }

    function _divup(uint256 x, uint256 y) internal pure returns (uint256 z) {
        unchecked {
            z = x != 0 ? ((x - 1) / y) + 1 : 0;
        }
    }

    // --- ERC20 Mutations ---

    function transfer(address to, uint256 value) external returns (bool) {
        require(to != address(0) && to != address(this), ""SavingsDai/invalid-address"");
        uint256 balance = balanceOf[msg.sender];
        require(balance >= value, ""SavingsDai/insufficient-balance"");

        unchecked {
            balanceOf[msg.sender] = balance - value;
            balanceOf[to] += value;
        }

        emit Transfer(msg.sender, to, value);

        return true;
    }

    function transferFrom(address from, address to, uint256 value) external returns (bool) {
        require(to != address(0) && to != address(this), ""SavingsDai/invalid-address"");
        uint256 balance = balanceOf[from];
        require(balance >= value, ""SavingsDai/insufficient-balance"");

        if (from != msg.sender) {
            uint256 allowed = allowance[from][msg.sender];
            if (allowed != type(uint256).max) {
                require(allowed >= value, ""SavingsDai/insufficient-allowance"");

                unchecked {
                    allowance[from][msg.sender] = allowed - value;
                }
            }
        }

        unchecked {
            balanceOf[from] = balance - value;
            balanceOf[to] += value;
        }

        emit Transfer(from, to, value);

        return true;
    }

    function approve(address spender, uint256 value) external returns (bool) {
        allowance[msg.sender][spender] = value;

        emit Approval(msg.sender, spender, value);

        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {
        uint256 newValue = allowance[msg.sender][spender] + addedValue;
        allowance[msg.sender][spender] = newValue;

        emit Approval(msg.sender, spender, newValue);

        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {
        uint256 allowed = allowance[msg.sender][spender];
        require(allowed >= subtractedValue, ""SavingsDai/insufficient-allowance"");
        unchecked{
            allowed = allowed - subtractedValue;
        }
        allowance[msg.sender][spender] = allowed;

        emit Approval(msg.sender, spender, allowed);

        return true;
    }

    // --- Mint/Burn Internal ---

    function _mint(uint256 assets, uint256 shares, address receiver) internal {
        require(receiver != address(0) && receiver != address(this), ""SavingsDai/invalid-address"");

        dai.transferFrom(msg.sender, address(this), assets);
        daiJoin.join(address(this), assets);
        pot.join(shares);

        // note: we don't need an overflow check here b/c shares totalSupply will always be <= dai totalSupply
        unchecked {
            balanceOf[receiver] = balanceOf[receiver] + shares;
            totalSupply = totalSupply + shares;
        }

        emit Deposit(msg.sender, receiver, assets, shares);
    }

    function _burn(uint256 assets, uint256 shares, address receiver, address owner) internal {
        uint256 balance = balanceOf[owner];
        require(balance >= shares, ""SavingsDai/insufficient-balance"");

        if (owner != msg.sender) {
            uint256 allowed = allowance[owner][msg.sender];
            if (allowed != type(uint256).max) {
                require(allowed >= shares, ""SavingsDai/insufficient-allowance"");

                unchecked {
                    allowance[owner][msg.sender] = allowed - shares;
                }
            }
        }

        unchecked {
            balanceOf[owner] = balance - shares; // note: we don't need overflow checks b/c require(balance >= value) and balance <= totalSupply
            totalSupply      = totalSupply - shares;
        }

        pot.exit(shares);
        daiJoin.exit(receiver, assets);

        emit Withdraw(msg.sender, receiver, owner, assets, shares);
    }

    // --- ERC-4626 ---

    function asset() external view returns (address) {
        return address(dai);
    }

    function totalAssets() external view returns (uint256) {
        return convertToAssets(totalSupply);
    }

    function convertToShares(uint256 assets) public view returns (uint256) {
        uint256 rho = pot.rho();
        uint256 chi = (block.timestamp > rho) ? _rpow(pot.dsr(), block.timestamp - rho) * pot.chi() / RAY : pot.chi();
        return assets * RAY / chi;
    }

    function convertToAssets(uint256 shares) public view returns (uint256) {
        uint256 rho = pot.rho();
        uint256 chi = (block.timestamp > rho) ? _rpow(pot.dsr(), block.timestamp - rho) * pot.chi() / RAY : pot.chi();
        return shares * chi / RAY;
    }

    function maxDeposit(address) external pure returns (uint256) {
        return type(uint256).max;
    }

    function previewDeposit(uint256 assets) external view returns (uint256) {
        return convertToShares(assets);
    }

    function deposit(uint256 assets, address receiver) external returns (uint256 shares) {
        uint256 chi = (block.timestamp > pot.rho()) ? pot.drip() : pot.chi();
        shares = assets * RAY / chi;
        _mint(assets, shares, receiver);
    }

    function maxMint(address) external pure returns (uint256) {
        return type(uint256).max;
    }

    function previewMint(uint256 shares) external view returns (uint256) {
        uint256 rho = pot.rho();
        uint256 chi = (block.timestamp > rho) ? _rpow(pot.dsr(), block.timestamp - rho) * pot.chi() / RAY : pot.chi();
        return _divup(shares * chi, RAY);
    }

    function mint(uint256 shares, address receiver) external returns (uint256 assets) {
        uint256 chi = (block.timestamp > pot.rho()) ? pot.drip() : pot.chi();
        assets = _divup(shares * chi, RAY);
        _mint(assets, shares, receiver);
    }

    function maxWithdraw(address owner) external view returns (uint256) {
        return convertToAssets(balanceOf[owner]);
    }

    function previewWithdraw(uint256 assets) external view returns (uint256) {
        uint256 rho = pot.rho();
        uint256 chi = (block.timestamp > rho) ? _rpow(pot.dsr(), block.timestamp - rho) * pot.chi() / RAY : pot.chi();
        return _divup(assets * RAY, chi);
    }

    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares) {
        uint256 chi = (block.timestamp > pot.rho()) ? pot.drip() : pot.chi();
        shares = _divup(assets * RAY, chi);
        _burn(assets, shares, receiver, owner);
    }

    function maxRedeem(address owner) external view returns (uint256) {
        return balanceOf[owner];
    }

    function previewRedeem(uint256 shares) external view returns (uint256) {
        return convertToAssets(shares);
    }

    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets) {
        uint256 chi = (block.timestamp > pot.rho()) ? pot.drip() : pot.chi();
        assets = shares * chi / RAY;
        _burn(assets, shares, receiver, owner);
    }

    // --- Approve by signature ---

    function _isValidSignature(
        address signer,
        bytes32 digest,
        bytes memory signature
    ) internal view returns (bool) {
        if (signature.length == 65) {
            bytes32 r;
            bytes32 s;
            uint8 v;
            assembly {
                r := mload(add(signature, 0x20))
                s := mload(add(signature, 0x40))
                v := byte(0, mload(add(signature, 0x60)))
            }
            if (signer == ecrecover(digest, v, r, s)) {
                return true;
            }
        }

        (bool success, bytes memory result) = signer.staticcall(
            abi.encodeWithSelector(IERC1271.isValidSignature.selector, digest, signature)
        );
        return (success &&
            result.length == 32 &&
            abi.decode(result, (bytes4)) == IERC1271.isValidSignature.selector);
    }

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        bytes memory signature
    ) public {
        require(block.timestamp <= deadline, ""SavingsDai/permit-expired"");
        require(owner != address(0), ""SavingsDai/invalid-owner"");

        uint256 nonce;
        unchecked { nonce = nonces[owner]++; }

        bytes32 digest =
            keccak256(abi.encodePacked(
                ""\x19\x01"",
                block.chainid == deploymentChainId ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(block.chainid),
                keccak256(abi.encode(
                    PERMIT_TYPEHASH,
                    owner,
                    spender,
                    value,
                    nonce,
                    deadline
                ))
            ));

        require(_isValidSignature(owner, digest, signature), ""SavingsDai/invalid-permit"");

        allowance[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        permit(owner, spender, value, deadline, abi.encodePacked(r, s, v));
    }

}",True
0x9008d19f58aabd9ed0d60971565aa8510560ab41,"// File: language
Solidity

// File: settings
{'evmVersion': 'istanbul', 'libraries': {}, 'metadata': {'bytecodeHash': 'ipfs', 'useLiteralContent': True}, 'optimizer': {'enabled': True, 'runs': 1000000}, 'remappings': [], 'outputSelection': {'*': {'*': ['evm.bytecode', 'evm.deployedBytecode', 'abi']}}}

// File: sources
{'src/contracts/GPv2Settlement.sol': {'content': '// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport ""./GPv2VaultRelayer.sol"";\nimport ""./interfaces/GPv2Authentication.sol"";\nimport ""./interfaces/IERC20.sol"";\nimport ""./interfaces/IVault.sol"";\nimport ""./libraries/GPv2Interaction.sol"";\nimport ""./libraries/GPv2Order.sol"";\nimport ""./libraries/GPv2Trade.sol"";\nimport ""./libraries/GPv2Transfer.sol"";\nimport ""./libraries/SafeCast.sol"";\nimport ""./libraries/SafeMath.sol"";\nimport ""./mixins/GPv2Signing.sol"";\nimport ""./mixins/ReentrancyGuard.sol"";\nimport ""./mixins/StorageAccessible.sol"";\n\n/// @title Gnosis Protocol v2 Settlement Contract\n/// @author Gnosis Developers\ncontract GPv2Settlement is GPv2Signing, ReentrancyGuard, StorageAccessible {\n    using GPv2Order for bytes;\n    using GPv2Transfer for IVault;\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n\n    /// @dev The authenticator is used to determine who can call the settle function.\n    /// That is, only authorised solvers have the ability to invoke settlements.\n    /// Any valid authenticator implements an isSolver method called by the onlySolver\n    /// modifier below.\n    GPv2Authentication public immutable authenticator;\n\n    /// @dev The Balancer Vault the protocol uses for managing user funds.\n    IVault public immutable vault;\n\n    /// @dev The Balancer Vault relayer which can interact on behalf of users.\n    /// This contract is created during deployment\n    GPv2VaultRelayer public immutable vaultRelayer;\n\n    /// @dev Map each user order by UID to the amount that has been filled so\n    /// far. If this amount is larger than or equal to the amount traded in the\n    /// order (amount sold for sell orders, amount bought for buy orders) then\n    /// the order cannot be traded anymore. If the order is fill or kill, then\n    /// this value is only used to determine whether the order has already been\n    /// executed.\n    mapping(bytes => uint256) public filledAmount;\n\n    /// @dev Event emitted for each executed trade.\n    event Trade(\n        address indexed owner,\n        IERC20 sellToken,\n        IERC20 buyToken,\n        uint256 sellAmount,\n        uint256 buyAmount,\n        uint256 feeAmount,\n        bytes orderUid\n    );\n\n    /// @dev Event emitted for each executed interaction.\n    ///\n    /// For gas effeciency, only the interaction calldata selector (first 4\n    /// bytes) is included in the event. For interactions without calldata or\n    /// whose calldata is shorter than 4 bytes, the selector will be `0`.\n    event Interaction(address indexed target, uint256 value, bytes4 selector);\n\n    /// @dev Event emitted when a settlement complets\n    event Settlement(address indexed solver);\n\n    /// @dev Event emitted when an order is invalidated.\n    event OrderInvalidated(address indexed owner, bytes orderUid);\n\n    constructor(GPv2Authentication authenticator_, IVault vault_) {\n        authenticator = authenticator_;\n        vault = vault_;\n        vaultRelayer = new GPv2VaultRelayer(vault_);\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {\n        // NOTE: Include an empty receive function so that the settlement\n        // contract can receive Ether from contract interactions.\n    }\n\n    /// @dev This modifier is called by settle function to block any non-listed\n    /// senders from settling batches.\n    modifier onlySolver {\n        require(authenticator.isSolver(msg.sender), ""GPv2: not a solver"");\n        _;\n    }\n\n    /// @dev Modifier to ensure that an external function is only callable as a\n    /// settlement interaction.\n    modifier onlyInteraction {\n        require(address(this) == msg.sender, ""GPv2: not an interaction"");\n        _;\n    }\n\n    /// @dev Settle the specified orders at a clearing price. Note that it is\n    /// the responsibility of the caller to ensure that all GPv2 invariants are\n    /// upheld for the input settlement, otherwise this call will revert.\n    /// Namely:\n    /// - All orders are valid and signed\n    /// - Accounts have sufficient balance and approval.\n    /// - Settlement contract has sufficient balance to execute trades. Note\n    ///   this implies that the accumulated fees held in the contract can also\n    ///   be used for settlement. This is OK since:\n    ///   - Solvers need to be authorized\n    ///   - Misbehaving solvers will be slashed for abusing accumulated fees for\n    ///     settlement\n    ///   - Critically, user orders are entirely protected\n    ///\n    /// @param tokens An array of ERC20 tokens to be traded in the settlement.\n    /// Trades encode tokens as indices into this array.\n    /// @param clearingPrices An array of clearing prices where the `i`-th price\n    /// is for the `i`-th token in the [`tokens`] array.\n    /// @param trades Trades for signed orders.\n    /// @param interactions Smart contract interactions split into three\n    /// separate lists to be run before the settlement, during the settlement\n    /// and after the settlement respectively.\n    function settle(\n        IERC20[] calldata tokens,\n        uint256[] calldata clearingPrices,\n        GPv2Trade.Data[] calldata trades,\n        GPv2Interaction.Data[][3] calldata interactions\n    ) external nonReentrant onlySolver {\n        executeInteractions(interactions[0]);\n\n        (\n            GPv2Transfer.Data[] memory inTransfers,\n            GPv2Transfer.Data[] memory outTransfers\n        ) = computeTradeExecutions(tokens, clearingPrices, trades);\n\n        vaultRelayer.transferFromAccounts(inTransfers);\n\n        executeInteractions(interactions[1]);\n\n        vault.transferToAccounts(outTransfers);\n\n        executeInteractions(interactions[2]);\n\n        emit Settlement(msg.sender);\n    }\n\n    /// @dev Settle an order directly against Balancer V2 pools.\n    ///\n    /// @param swaps The Balancer V2 swap steps to use for trading.\n    /// @param tokens An array of ERC20 tokens to be traded in the settlement.\n    /// Swaps and the trade encode tokens as indices into this array.\n    /// @param trade The trade to match directly against Balancer liquidity. The\n    /// order will always be fully executed, so the trade\'s `executedAmount`\n    /// field is used to represent a swap limit amount.\n    function swap(\n        IVault.BatchSwapStep[] calldata swaps,\n        IERC20[] calldata tokens,\n        GPv2Trade.Data calldata trade\n    ) external nonReentrant onlySolver {\n        RecoveredOrder memory recoveredOrder = allocateRecoveredOrder();\n        GPv2Order.Data memory order = recoveredOrder.data;\n        recoverOrderFromTrade(recoveredOrder, tokens, trade);\n\n        IVault.SwapKind kind =\n            order.kind == GPv2Order.KIND_SELL\n                ? IVault.SwapKind.GIVEN_IN\n                : IVault.SwapKind.GIVEN_OUT;\n\n        IVault.FundManagement memory funds;\n        funds.sender = recoveredOrder.owner;\n        funds.fromInternalBalance =\n            order.sellTokenBalance == GPv2Order.BALANCE_INTERNAL;\n        funds.recipient = payable(recoveredOrder.receiver);\n        funds.toInternalBalance =\n            order.buyTokenBalance == GPv2Order.BALANCE_INTERNAL;\n\n        int256[] memory limits = new int256[](tokens.length);\n        uint256 limitAmount = trade.executedAmount;\n        // NOTE: Array allocation initializes elements to 0, so we only need to\n        // set the limits we care about. This ensures that the swap will respect\n        // the order\'s limit price.\n        if (order.kind == GPv2Order.KIND_SELL) {\n            require(limitAmount >= order.buyAmount, ""GPv2: limit too low"");\n            limits[trade.sellTokenIndex] = order.sellAmount.toInt256();\n            limits[trade.buyTokenIndex] = -limitAmount.toInt256();\n        } else {\n            require(limitAmount <= order.sellAmount, ""GPv2: limit too high"");\n            limits[trade.sellTokenIndex] = limitAmount.toInt256();\n            limits[trade.buyTokenIndex] = -order.buyAmount.toInt256();\n        }\n\n        GPv2Transfer.Data memory feeTransfer;\n        feeTransfer.account = recoveredOrder.owner;\n        feeTransfer.token = order.sellToken;\n        feeTransfer.amount = order.feeAmount;\n        feeTransfer.balance = order.sellTokenBalance;\n\n        int256[] memory tokenDeltas =\n            vaultRelayer.batchSwapWithFee(\n                kind,\n                swaps,\n                tokens,\n                funds,\n                limits,\n                // NOTE: Specify a deadline to ensure that an expire order\n                // cannot be used to trade.\n                order.validTo,\n                feeTransfer\n            );\n\n        bytes memory orderUid = recoveredOrder.uid;\n        uint256 executedSellAmount =\n            tokenDeltas[trade.sellTokenIndex].toUint256();\n        uint256 executedBuyAmount =\n            (-tokenDeltas[trade.buyTokenIndex]).toUint256();\n\n        // NOTE: Check that the orders were completely filled and update their\n        // filled amounts to avoid replaying them. The limit price and order\n        // validity have already been verified when executing the swap through\n        // the `limit` and `deadline` parameters.\n        require(filledAmount[orderUid] == 0, ""GPv2: order filled"");\n        if (order.kind == GPv2Order.KIND_SELL) {\n            require(\n                executedSellAmount == order.sellAmount,\n                ""GPv2: sell amount not respected""\n            );\n            filledAmount[orderUid] = order.sellAmount;\n        } else {\n            require(\n                executedBuyAmount == order.buyAmount,\n                ""GPv2: buy amount not respected""\n            );\n            filledAmount[orderUid] = order.buyAmount;\n        }\n\n        emit Trade(\n            recoveredOrder.owner,\n            order.sellToken,\n            order.buyToken,\n            executedSellAmount,\n            executedBuyAmount,\n            order.feeAmount,\n            orderUid\n        );\n        emit Settlement(msg.sender);\n    }\n\n    /// @dev Invalidate onchain an order that has been signed offline.\n    ///\n    /// @param orderUid The unique identifier of the order that is to be made\n    /// invalid after calling this function. The user that created the order\n    /// must be the the sender of this message. See [`extractOrderUidParams`]\n    /// for details on orderUid.\n    function invalidateOrder(bytes calldata orderUid) external {\n        (, address owner, ) = orderUid.extractOrderUidParams();\n        require(owner == msg.sender, ""GPv2: caller does not own order"");\n        filledAmount[orderUid] = uint256(-1);\n        emit OrderInvalidated(owner, orderUid);\n    }\n\n    /// @dev Free storage from the filled amounts of **expired** orders to claim\n    /// a gas refund. This method can only be called as an interaction.\n    ///\n    /// @param orderUids The unique identifiers of the expired order to free\n    /// storage for.\n    function freeFilledAmountStorage(bytes[] calldata orderUids)\n        external\n        onlyInteraction\n    {\n        freeOrderStorage(filledAmount, orderUids);\n    }\n\n    /// @dev Free storage from the pre signatures of **expired** orders to claim\n    /// a gas refund. This method can only be called as an interaction.\n    ///\n    /// @param orderUids The unique identifiers of the expired order to free\n    /// storage for.\n    function freePreSignatureStorage(bytes[] calldata orderUids)\n        external\n        onlyInteraction\n    {\n        freeOrderStorage(preSignature, orderUids);\n    }\n\n    /// @dev Process all trades one at a time returning the computed net in and\n    /// out transfers for the trades.\n    ///\n    /// This method reverts if processing of any single trade fails. See\n    /// [`computeTradeExecution`] for more details.\n    ///\n    /// @param tokens An array of ERC20 tokens to be traded in the settlement.\n    /// @param clearingPrices An array of token clearing prices.\n    /// @param trades Trades for signed orders.\n    /// @return inTransfers Array of in transfers of executed sell amounts.\n    /// @return outTransfers Array of out transfers of executed buy amounts.\n    function computeTradeExecutions(\n        IERC20[] calldata tokens,\n        uint256[] calldata clearingPrices,\n        GPv2Trade.Data[] calldata trades\n    )\n        internal\n        returns (\n            GPv2Transfer.Data[] memory inTransfers,\n            GPv2Transfer.Data[] memory outTransfers\n        )\n    {\n        RecoveredOrder memory recoveredOrder = allocateRecoveredOrder();\n\n        inTransfers = new GPv2Transfer.Data[](trades.length);\n        outTransfers = new GPv2Transfer.Data[](trades.length);\n\n        for (uint256 i = 0; i < trades.length; i++) {\n            GPv2Trade.Data calldata trade = trades[i];\n\n            recoverOrderFromTrade(recoveredOrder, tokens, trade);\n            computeTradeExecution(\n                recoveredOrder,\n                clearingPrices[trade.sellTokenIndex],\n                clearingPrices[trade.buyTokenIndex],\n                trade.executedAmount,\n                inTransfers[i],\n                outTransfers[i]\n            );\n        }\n    }\n\n    /// @dev Compute the in and out transfer amounts for a single trade.\n    /// This function reverts if:\n    /// - The order has expired\n    /// - The order\'s limit price is not respected\n    /// - The order gets over-filled\n    /// - The fee discount is larger than the executed fee\n    ///\n    /// @param recoveredOrder The recovered order to process.\n    /// @param sellPrice The price of the order\'s sell token.\n    /// @param buyPrice The price of the order\'s buy token.\n    /// @param executedAmount The portion of the order to execute. This will be\n    /// ignored for fill-or-kill orders.\n    /// @param inTransfer Memory location for computed executed sell amount\n    /// transfer.\n    /// @param outTransfer Memory location for computed executed buy amount\n    /// transfer.\n    function computeTradeExecution(\n        RecoveredOrder memory recoveredOrder,\n        uint256 sellPrice,\n        uint256 buyPrice,\n        uint256 executedAmount,\n        GPv2Transfer.Data memory inTransfer,\n        GPv2Transfer.Data memory outTransfer\n    ) internal {\n        GPv2Order.Data memory order = recoveredOrder.data;\n        bytes memory orderUid = recoveredOrder.uid;\n\n        // solhint-disable-next-line not-rely-on-time\n        require(order.validTo >= block.timestamp, ""GPv2: order expired"");\n\n        // NOTE: The following computation is derived from the equation:\n        // ```\n        // amount_x * price_x = amount_y * price_y\n        // ```\n        // Intuitively, if a chocolate bar is 0,50€ and a beer is 4€, 1 beer\n        // is roughly worth 8 chocolate bars (`1 * 4 = 8 * 0.5`). From this\n        // equation, we can derive:\n        // - The limit price for selling `x` and buying `y` is respected iff\n        // ```\n        // limit_x * price_x >= limit_y * price_y\n        // ```\n        // - The executed amount of token `y` given some amount of `x` and\n        //   clearing prices is:\n        // ```\n        // amount_y = amount_x * price_x / price_y\n        // ```\n\n        require(\n            order.sellAmount.mul(sellPrice) >= order.buyAmount.mul(buyPrice),\n            ""GPv2: limit price not respected""\n        );\n\n        uint256 executedSellAmount;\n        uint256 executedBuyAmount;\n        uint256 executedFeeAmount;\n        uint256 currentFilledAmount;\n\n        if (order.kind == GPv2Order.KIND_SELL) {\n            if (order.partiallyFillable) {\n                executedSellAmount = executedAmount;\n                executedFeeAmount = order.feeAmount.mul(executedSellAmount).div(\n                    order.sellAmount\n                );\n            } else {\n                executedSellAmount = order.sellAmount;\n                executedFeeAmount = order.feeAmount;\n            }\n\n            executedBuyAmount = executedSellAmount.mul(sellPrice).ceilDiv(\n                buyPrice\n            );\n\n            currentFilledAmount = filledAmount[orderUid].add(\n                executedSellAmount\n            );\n            require(\n                currentFilledAmount <= order.sellAmount,\n                ""GPv2: order filled""\n            );\n        } else {\n            if (order.partiallyFillable) {\n                executedBuyAmount = executedAmount;\n                executedFeeAmount = order.feeAmount.mul(executedBuyAmount).div(\n                    order.buyAmount\n                );\n            } else {\n                executedBuyAmount = order.buyAmount;\n                executedFeeAmount = order.feeAmount;\n            }\n\n            executedSellAmount = executedBuyAmount.mul(buyPrice).div(sellPrice);\n\n            currentFilledAmount = filledAmount[orderUid].add(executedBuyAmount);\n            require(\n                currentFilledAmount <= order.buyAmount,\n                ""GPv2: order filled""\n            );\n        }\n\n        executedSellAmount = executedSellAmount.add(executedFeeAmount);\n        filledAmount[orderUid] = currentFilledAmount;\n\n        emit Trade(\n            recoveredOrder.owner,\n            order.sellToken,\n            order.buyToken,\n            executedSellAmount,\n            executedBuyAmount,\n            executedFeeAmount,\n            orderUid\n        );\n\n        inTransfer.account = recoveredOrder.owner;\n        inTransfer.token = order.sellToken;\n        inTransfer.amount = executedSellAmount;\n        inTransfer.balance = order.sellTokenBalance;\n\n        outTransfer.account = recoveredOrder.receiver;\n        outTransfer.token = order.buyToken;\n        outTransfer.amount = executedBuyAmount;\n        outTransfer.balance = order.buyTokenBalance;\n    }\n\n    /// @dev Execute a list of arbitrary contract calls from this contract.\n    /// @param interactions The list of interactions to execute.\n    function executeInteractions(GPv2Interaction.Data[] calldata interactions)\n        internal\n    {\n        for (uint256 i; i < interactions.length; i++) {\n            GPv2Interaction.Data calldata interaction = interactions[i];\n\n            // To prevent possible attack on user funds, we explicitly disable\n            // any interactions with the vault relayer contract.\n            require(\n                interaction.target != address(vaultRelayer),\n                ""GPv2: forbidden interaction""\n            );\n            GPv2Interaction.execute(interaction);\n\n            emit Interaction(\n                interaction.target,\n                interaction.value,\n                GPv2Interaction.selector(interaction)\n            );\n        }\n    }\n\n    /// @dev Claims refund for the specified storage and order UIDs.\n    ///\n    /// This method reverts if any of the orders are still valid.\n    ///\n    /// @param orderUids Order refund data for freeing storage.\n    /// @param orderStorage Order storage mapped on a UID.\n    function freeOrderStorage(\n        mapping(bytes => uint256) storage orderStorage,\n        bytes[] calldata orderUids\n    ) internal {\n        for (uint256 i = 0; i < orderUids.length; i++) {\n            bytes calldata orderUid = orderUids[i];\n\n            (, , uint32 validTo) = orderUid.extractOrderUidParams();\n            // solhint-disable-next-line not-rely-on-time\n            require(validTo < block.timestamp, ""GPv2: order still valid"");\n\n            orderStorage[orderUid] = 0;\n        }\n    }\n}\n'}, 'src/contracts/GPv2VaultRelayer.sol': {'content': '// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport ""./interfaces/IERC20.sol"";\nimport ""./interfaces/IVault.sol"";\nimport ""./libraries/GPv2Transfer.sol"";\n\n/// @title Gnosis Protocol v2 Vault Relayer Contract\n/// @author Gnosis Developers\ncontract GPv2VaultRelayer {\n    using GPv2Transfer for IVault;\n\n    /// @dev The creator of the contract which has special permissions. This\n    /// value is set at creation time and cannot change.\n    address private immutable creator;\n\n    /// @dev The vault this relayer is for.\n    IVault private immutable vault;\n\n    constructor(IVault vault_) {\n        creator = msg.sender;\n        vault = vault_;\n    }\n\n    /// @dev Modifier that ensures that a function can only be called by the\n    /// creator of this contract.\n    modifier onlyCreator {\n        require(msg.sender == creator, ""GPv2: not creator"");\n        _;\n    }\n\n    /// @dev Transfers all sell amounts for the executed trades from their\n    /// owners to the caller.\n    ///\n    /// This function reverts if:\n    /// - The caller is not the creator of the vault relayer\n    /// - Any ERC20 transfer fails\n    ///\n    /// @param transfers The transfers to execute.\n    function transferFromAccounts(GPv2Transfer.Data[] calldata transfers)\n        external\n        onlyCreator\n    {\n        vault.transferFromAccounts(transfers, msg.sender);\n    }\n\n    /// @dev Performs a Balancer batched swap on behalf of a user and sends a\n    /// fee to the caller.\n    ///\n    /// This function reverts if:\n    /// - The caller is not the creator of the vault relayer\n    /// - The swap fails\n    /// - The fee transfer fails\n    ///\n    /// @param kind The Balancer swap kind, this can either be `GIVEN_IN` for\n    /// sell orders or `GIVEN_OUT` for buy orders.\n    /// @param swaps The swaps to perform.\n    /// @param tokens The tokens for the swaps. Swaps encode to and from tokens\n    /// as indices into this array.\n    /// @param funds The fund management settings, specifying the user the swap\n    /// is being performed for as well as the recipient of the proceeds.\n    /// @param limits Swap limits for encoding limit prices.\n    /// @param deadline The deadline for the swap.\n    /// @param feeTransfer The transfer data for the caller fee.\n    /// @return tokenDeltas The executed swap amounts.\n    function batchSwapWithFee(\n        IVault.SwapKind kind,\n        IVault.BatchSwapStep[] calldata swaps,\n        IERC20[] memory tokens,\n        IVault.FundManagement memory funds,\n        int256[] memory limits,\n        uint256 deadline,\n        GPv2Transfer.Data calldata feeTransfer\n    ) external onlyCreator returns (int256[] memory tokenDeltas) {\n        tokenDeltas = vault.batchSwap(\n            kind,\n            swaps,\n            tokens,\n            funds,\n            limits,\n            deadline\n        );\n        vault.fastTransferFromAccount(feeTransfer, msg.sender);\n    }\n}\n'}, 'src/contracts/interfaces/GPv2Authentication.sol': {'content': '// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\n\n/// @title Gnosis Protocol v2 Authentication Interface\n/// @author Gnosis Developers\ninterface GPv2Authentication {\n    /// @dev determines whether the provided address is an authenticated solver.\n    /// @param prospectiveSolver the address of prospective solver.\n    /// @return true when prospectiveSolver is an authenticated solver, otherwise false.\n    function isSolver(address prospectiveSolver) external view returns (bool);\n}\n'}, 'src/contracts/interfaces/GPv2EIP1271.sol': {'content': '// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\n\nlibrary GPv2EIP1271 {\n    /// @dev Value returned by a call to `isValidSignature` if the signature\n    /// was verified successfully. The value is defined in EIP-1271 as:\n    /// bytes4(keccak256(""isValidSignature(bytes32,bytes)""))\n    bytes4 internal constant MAGICVALUE = 0x1626ba7e;\n}\n\n/// @title EIP1271 Interface\n/// @dev Standardized interface for an implementation of smart contract\n/// signatures as described in EIP-1271. The code that follows is identical to\n/// the code in the standard with the exception of formatting and syntax\n/// changes to adapt the code to our Solidity version.\ninterface EIP1271Verifier {\n    /// @dev Should return whether the signature provided is valid for the\n    /// provided data\n    /// @param _hash      Hash of the data to be signed\n    /// @param _signature Signature byte array associated with _data\n    ///\n    /// MUST return the bytes4 magic value 0x1626ba7e when function passes.\n    /// MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for\n    /// solc > 0.5)\n    /// MUST allow external calls\n    ///\n    function isValidSignature(bytes32 _hash, bytes memory _signature)\n        external\n        view\n        returns (bytes4 magicValue);\n}\n'}, 'src/contracts/interfaces/IERC20.sol': {'content': ""// SPDX-License-Identifier: MIT\n\n// Vendored from OpenZeppelin contracts with minor modifications:\n// - Modified Solidity version\n// - Formatted code\n// - Added `name`, `symbol` and `decimals` function declarations\n// <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/token/ERC20/IERC20.sol>\n\npragma solidity ^0.7.6;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the number of decimals the token uses.\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n""}, 'src/contracts/interfaces/IVault.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport ""./IERC20.sol"";\n\n/**\n * @dev Minimal interface for the Vault core contract only containing methods\n * used by Gnosis Protocol V2. Original source:\n * <https://github.com/balancer-labs/balancer-core-v2/blob/v1.0.0/contracts/vault/interfaces/IVault.sol>\n */\ninterface IVault {\n    // Internal Balance\n    //\n    // Users can deposit tokens into the Vault, where they are allocated to their Internal Balance, and later\n    // transferred or withdrawn. It can also be used as a source of tokens when joining Pools, as a destination\n    // when exiting them, and as either when performing swaps. This usage of Internal Balance results in greatly reduced\n    // gas costs when compared to relying on plain ERC20 transfers, leading to large savings for frequent users.\n    //\n    // Internal Balance management features batching, which means a single contract call can be used to perform multiple\n    // operations of different kinds, with different senders and recipients, at once.\n\n    /**\n     * @dev Performs a set of user balance operations, which involve Internal Balance (deposit, withdraw or transfer)\n     * and plain ERC20 transfers using the Vault\'s allowance. This last feature is particularly useful for relayers, as\n     * it lets integrators reuse a user\'s Vault allowance.\n     *\n     * For each operation, if the caller is not `sender`, it must be an authorized relayer for them.\n     */\n    function manageUserBalance(UserBalanceOp[] memory ops) external payable;\n\n    /**\n     * @dev Data for `manageUserBalance` operations, which include the possibility for ETH to be sent and received\n     without manual WETH wrapping or unwrapping.\n     */\n    struct UserBalanceOp {\n        UserBalanceOpKind kind;\n        IERC20 asset;\n        uint256 amount;\n        address sender;\n        address payable recipient;\n    }\n\n    // There are four possible operations in `manageUserBalance`:\n    //\n    // - DEPOSIT_INTERNAL\n    // Increases the Internal Balance of the `recipient` account by transferring tokens from the corresponding\n    // `sender`. The sender must have allowed the Vault to use their tokens via `IERC20.approve()`.\n    //\n    // ETH can be used by passing the ETH sentinel value as the asset and forwarding ETH in the call: it will be wrapped\n    // and deposited as WETH. Any ETH amount remaining will be sent back to the caller (not the sender, which is\n    // relevant for relayers).\n    //\n    // Emits an `InternalBalanceChanged` event.\n    //\n    //\n    // - WITHDRAW_INTERNAL\n    // Decreases the Internal Balance of the `sender` account by transferring tokens to the `recipient`.\n    //\n    // ETH can be used by passing the ETH sentinel value as the asset. This will deduct WETH instead, unwrap it and send\n    // it to the recipient as ETH.\n    //\n    // Emits an `InternalBalanceChanged` event.\n    //\n    //\n    // - TRANSFER_INTERNAL\n    // Transfers tokens from the Internal Balance of the `sender` account to the Internal Balance of `recipient`.\n    //\n    // Reverts if the ETH sentinel value is passed.\n    //\n    // Emits an `InternalBalanceChanged` event.\n    //\n    //\n    // - TRANSFER_EXTERNAL\n    // Transfers tokens from `sender` to `recipient`, using the Vault\'s ERC20 allowance. This is typically used by\n    // relayers, as it lets them reuse a user\'s Vault allowance.\n    //\n    // Reverts if the ETH sentinel value is passed.\n    //\n    // Emits an `ExternalBalanceTransfer` event.\n\n    enum UserBalanceOpKind {\n        DEPOSIT_INTERNAL,\n        WITHDRAW_INTERNAL,\n        TRANSFER_INTERNAL,\n        TRANSFER_EXTERNAL\n    }\n\n    // Swaps\n    //\n    // Users can swap tokens with Pools by calling the `swap` and `batchSwap` functions. To do this,\n    // they need not trust Pool contracts in any way: all security checks are made by the Vault. They must however be\n    // aware of the Pools\' pricing algorithms in order to estimate the prices Pools will quote.\n    //\n    // The `swap` function executes a single swap, while `batchSwap` can perform multiple swaps in sequence.\n    // In each individual swap, tokens of one kind are sent from the sender to the Pool (this is the \'token in\'),\n    // and tokens of another kind are sent from the Pool to the recipient in exchange (this is the \'token out\').\n    // More complex swaps, such as one token in to multiple tokens out can be achieved by batching together\n    // individual swaps.\n    //\n    // There are two swap kinds:\n    //  - \'given in\' swaps, where the amount of tokens in (sent to the Pool) is known, and the Pool determines (via the\n    // `onSwap` hook) the amount of tokens out (to send to the recipient).\n    //  - \'given out\' swaps, where the amount of tokens out (received from the Pool) is known, and the Pool determines\n    // (via the `onSwap` hook) the amount of tokens in (to receive from the sender).\n    //\n    // Additionally, it is possible to chain swaps using a placeholder input amount, which the Vault replaces with\n    // the calculated output of the previous swap. If the previous swap was \'given in\', this will be the calculated\n    // tokenOut amount. If the previous swap was \'given out\', it will use the calculated tokenIn amount. These extended\n    // swaps are known as \'multihop\' swaps, since they \'hop\' through a number of intermediate tokens before arriving at\n    // the final intended token.\n    //\n    // In all cases, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into Internal\n    // Balance) after all individual swaps have been completed, and the net token balance change computed. This makes\n    // certain swap patterns, such as multihops, or swaps that interact with the same token pair in multiple Pools, cost\n    // much less gas than they would otherwise.\n    //\n    // It also means that under certain conditions it is possible to perform arbitrage by swapping with multiple\n    // Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (only\n    // updating the Pool\'s internal accounting).\n    //\n    // To protect users from front-running or the market changing rapidly, they supply a list of \'limits\' for each token\n    // involved in the swap, where either the maximum number of tokens to send (by passing a positive value) or the\n    // minimum amount of tokens to receive (by passing a negative value) is specified.\n    //\n    // Additionally, a \'deadline\' timestamp can also be provided, forcing the swap to fail if it occurs after\n    // this point in time (e.g. if the transaction failed to be included in a block promptly).\n    //\n    // If interacting with Pools that hold WETH, it is possible to both send and receive ETH directly: the Vault will do\n    // the wrapping and unwrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be\n    // passed in the `assets` array instead of the WETH address. Note that it is possible to combine ETH and WETH in the\n    // same swap. Any excess ETH will be sent back to the caller (not the sender, which is relevant for relayers).\n    //\n    // Finally, Internal Balance can be used when either sending or receiving tokens.\n\n    enum SwapKind {GIVEN_IN, GIVEN_OUT}\n\n    /**\n     * @dev Performs a swap with a single Pool.\n     *\n     * If the swap is \'given in\' (the number of tokens to send to the Pool is known), it returns the amount of tokens\n     * taken from the Pool, which must be greater than or equal to `limit`.\n     *\n     * If the swap is \'given out\' (the number of tokens to take from the Pool is known), it returns the amount of tokens\n     * sent to the Pool, which must be less than or equal to `limit`.\n     *\n     * Internal Balance usage and the recipient are determined by the `funds` struct.\n     *\n     * Emits a `Swap` event.\n     */\n    function swap(\n        SingleSwap memory singleSwap,\n        FundManagement memory funds,\n        uint256 limit,\n        uint256 deadline\n    ) external payable returns (uint256);\n\n    /**\n     * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\n     * the `kind` value.\n     *\n     * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\n     * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n    struct SingleSwap {\n        bytes32 poolId;\n        SwapKind kind;\n        IERC20 assetIn;\n        IERC20 assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n\n    /**\n     * @dev Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either\n     * the amount of tokens sent to or received from the Pool, depending on the `kind` value.\n     *\n     * Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the\n     * Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at\n     * the same index in the `assets` array.\n     *\n     * Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a\n     * Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or\n     * `amountOut` depending on the swap kind.\n     *\n     * Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out\n     * of the previous swap to be used as the amount in for the current one. In a \'given in\' swap, \'tokenIn\' must equal\n     * the previous swap\'s `tokenOut`. For a \'given out\' swap, `tokenOut` must equal the previous swap\'s `tokenIn`.\n     *\n     * The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses,\n     * or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and\n     * out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to\n     * or unwrapped from WETH by the Vault.\n     *\n     * Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies\n     * the minimum or maximum amount of each token the vault is allowed to transfer.\n     *\n     * `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the\n     * equivalent `swap` call.\n     *\n     * Emits `Swap` events.\n     */\n    function batchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IERC20[] memory assets,\n        FundManagement memory funds,\n        int256[] memory limits,\n        uint256 deadline\n    ) external payable returns (int256[] memory);\n\n    /**\n     * @dev Data for each individual swap executed by `batchSwap`. The asset in and out fields are indexes into the\n     * `assets` array passed to that function, and ETH assets are converted to WETH.\n     *\n     * If `amount` is zero, the multihop mechanism is used to determine the actual amount based on the amount in/out\n     * from the previous swap, depending on the swap kind.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n    struct BatchSwapStep {\n        bytes32 poolId;\n        uint256 assetInIndex;\n        uint256 assetOutIndex;\n        uint256 amount;\n        bytes userData;\n    }\n\n    /**\n     * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\n     * `recipient` account.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * If `fromInternalBalance` is true, the `sender`\'s Internal Balance will be preferred, performing an ERC20\n     * transfer for the difference between the requested amount and the User\'s Internal Balance (if any). The `sender`\n     * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\n     * `joinPool`.\n     *\n     * If `toInternalBalance` is true, tokens will be deposited to `recipient`\'s internal balance instead of\n     * transferred. This matches the behavior of `exitPool`.\n     *\n     * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\n     * revert.\n     */\n    struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address payable recipient;\n        bool toInternalBalance;\n    }\n}\n'}, 'src/contracts/libraries/GPv2Interaction.sol': {'content': '// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\n\n/// @title Gnosis Protocol v2 Interaction Library\n/// @author Gnosis Developers\nlibrary GPv2Interaction {\n    /// @dev Interaction data for performing arbitrary contract interactions.\n    /// Submitted to [`GPv2Settlement.settle`] for code execution.\n    struct Data {\n        address target;\n        uint256 value;\n        bytes callData;\n    }\n\n    /// @dev Execute an arbitrary contract interaction.\n    ///\n    /// @param interaction Interaction data.\n    function execute(Data calldata interaction) internal {\n        address target = interaction.target;\n        uint256 value = interaction.value;\n        bytes calldata callData = interaction.callData;\n\n        // NOTE: Use assembly to call the interaction instead of a low level\n        // call for two reasons:\n        // - We don\'t want to copy the return data, since we discard it for\n        // interactions.\n        // - Solidity will under certain conditions generate code to copy input\n        // calldata twice to memory (the second being a ""memcopy loop"").\n        // <https://github.com/gnosis/gp-v2-contracts/pull/417#issuecomment-775091258>\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            calldatacopy(freeMemoryPointer, callData.offset, callData.length)\n            if iszero(\n                call(\n                    gas(),\n                    target,\n                    value,\n                    freeMemoryPointer,\n                    callData.length,\n                    0,\n                    0\n                )\n            ) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    /// @dev Extracts the Solidity ABI selector for the specified interaction.\n    ///\n    /// @param interaction Interaction data.\n    /// @return result The 4 byte function selector of the call encoded in\n    /// this interaction.\n    function selector(Data calldata interaction)\n        internal\n        pure\n        returns (bytes4 result)\n    {\n        bytes calldata callData = interaction.callData;\n        if (callData.length >= 4) {\n            // NOTE: Read the first word of the interaction\'s calldata. The\n            // value does not need to be shifted since `bytesN` values are left\n            // aligned, and the value does not need to be masked since masking\n            // occurs when the value is accessed and not stored:\n            // <https://docs.soliditylang.org/en/v0.7.6/abi-spec.html#encoding-of-indexed-event-parameters>\n            // <https://docs.soliditylang.org/en/v0.7.6/assembly.html#access-to-external-variables-functions-and-libraries>\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                result := calldataload(callData.offset)\n            }\n        }\n    }\n}\n'}, 'src/contracts/libraries/GPv2Order.sol': {'content': '// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\n\nimport ""../interfaces/IERC20.sol"";\n\n/// @title Gnosis Protocol v2 Order Library\n/// @author Gnosis Developers\nlibrary GPv2Order {\n    /// @dev The complete data for a Gnosis Protocol order. This struct contains\n    /// all order parameters that are signed for submitting to GP.\n    struct Data {\n        IERC20 sellToken;\n        IERC20 buyToken;\n        address receiver;\n        uint256 sellAmount;\n        uint256 buyAmount;\n        uint32 validTo;\n        bytes32 appData;\n        uint256 feeAmount;\n        bytes32 kind;\n        bool partiallyFillable;\n        bytes32 sellTokenBalance;\n        bytes32 buyTokenBalance;\n    }\n\n    /// @dev The order EIP-712 type hash for the [`GPv2Order.Data`] struct.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\n    ///     ""Order("" +\n    ///         ""address sellToken,"" +\n    ///         ""address buyToken,"" +\n    ///         ""address receiver,"" +\n    ///         ""uint256 sellAmount,"" +\n    ///         ""uint256 buyAmount,"" +\n    ///         ""uint32 validTo,"" +\n    ///         ""bytes32 appData,"" +\n    ///         ""uint256 feeAmount,"" +\n    ///         ""string kind,"" +\n    ///         ""bool partiallyFillable"" +\n    ///         ""string sellTokenBalance"" +\n    ///         ""string buyTokenBalance"" +\n    ///     "")""\n    /// )\n    /// ```\n    bytes32 internal constant TYPE_HASH =\n        hex""d5a25ba2e97094ad7d83dc28a6572da797d6b3e7fc6663bd93efb789fc17e489"";\n\n    /// @dev The marker value for a sell order for computing the order struct\n    /// hash. This allows the EIP-712 compatible wallets to display a\n    /// descriptive string for the order kind (instead of 0 or 1).\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(""sell"")\n    /// ```\n    bytes32 internal constant KIND_SELL =\n        hex""f3b277728b3fee749481eb3e0b3b48980dbbab78658fc419025cb16eee346775"";\n\n    /// @dev The OrderKind marker value for a buy order for computing the order\n    /// struct hash.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(""buy"")\n    /// ```\n    bytes32 internal constant KIND_BUY =\n        hex""6ed88e868af0a1983e3886d5f3e95a2fafbd6c3450bc229e27342283dc429ccc"";\n\n    /// @dev The TokenBalance marker value for using direct ERC20 balances for\n    /// computing the order struct hash.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(""erc20"")\n    /// ```\n    bytes32 internal constant BALANCE_ERC20 =\n        hex""5a28e9363bb942b639270062aa6bb295f434bcdfc42c97267bf003f272060dc9"";\n\n    /// @dev The TokenBalance marker value for using Balancer Vault external\n    /// balances (in order to re-use Vault ERC20 approvals) for computing the\n    /// order struct hash.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(""external"")\n    /// ```\n    bytes32 internal constant BALANCE_EXTERNAL =\n        hex""abee3b73373acd583a130924aad6dc38cfdc44ba0555ba94ce2ff63980ea0632"";\n\n    /// @dev The TokenBalance marker value for using Balancer Vault internal\n    /// balances for computing the order struct hash.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(""internal"")\n    /// ```\n    bytes32 internal constant BALANCE_INTERNAL =\n        hex""4ac99ace14ee0a5ef932dc609df0943ab7ac16b7583634612f8dc35a4289a6ce"";\n\n    /// @dev Marker address used to indicate that the receiver of the trade\n    /// proceeds should the owner of the order.\n    ///\n    /// This is chosen to be `address(0)` for gas efficiency as it is expected\n    /// to be the most common case.\n    address internal constant RECEIVER_SAME_AS_OWNER = address(0);\n\n    /// @dev The byte length of an order unique identifier.\n    uint256 internal constant UID_LENGTH = 56;\n\n    /// @dev Returns the actual receiver for an order. This function checks\n    /// whether or not the [`receiver`] field uses the marker value to indicate\n    /// it is the same as the order owner.\n    ///\n    /// @return receiver The actual receiver of trade proceeds.\n    function actualReceiver(Data memory order, address owner)\n        internal\n        pure\n        returns (address receiver)\n    {\n        if (order.receiver == RECEIVER_SAME_AS_OWNER) {\n            receiver = owner;\n        } else {\n            receiver = order.receiver;\n        }\n    }\n\n    /// @dev Return the EIP-712 signing hash for the specified order.\n    ///\n    /// @param order The order to compute the EIP-712 signing hash for.\n    /// @param domainSeparator The EIP-712 domain separator to use.\n    /// @return orderDigest The 32 byte EIP-712 struct hash.\n    function hash(Data memory order, bytes32 domainSeparator)\n        internal\n        pure\n        returns (bytes32 orderDigest)\n    {\n        bytes32 structHash;\n\n        // NOTE: Compute the EIP-712 order struct hash in place. As suggested\n        // in the EIP proposal, noting that the order struct has 10 fields, and\n        // including the type hash `(12 + 1) * 32 = 416` bytes to hash.\n        // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#rationale-for-encodedata>\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let dataStart := sub(order, 32)\n            let temp := mload(dataStart)\n            mstore(dataStart, TYPE_HASH)\n            structHash := keccak256(dataStart, 416)\n            mstore(dataStart, temp)\n        }\n\n        // NOTE: Now that we have the struct hash, compute the EIP-712 signing\n        // hash using scratch memory past the free memory pointer. The signing\n        // hash is computed from `""\\x19\\x01"" || domainSeparator || structHash`.\n        // <https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html#layout-in-memory>\n        // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#specification>\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, ""\\x19\\x01"")\n            mstore(add(freeMemoryPointer, 2), domainSeparator)\n            mstore(add(freeMemoryPointer, 34), structHash)\n            orderDigest := keccak256(freeMemoryPointer, 66)\n        }\n    }\n\n    /// @dev Packs order UID parameters into the specified memory location. The\n    /// result is equivalent to `abi.encodePacked(...)` with the difference that\n    /// it allows re-using the memory for packing the order UID.\n    ///\n    /// This function reverts if the order UID buffer is not the correct size.\n    ///\n    /// @param orderUid The buffer pack the order UID parameters into.\n    /// @param orderDigest The EIP-712 struct digest derived from the order\n    /// parameters.\n    /// @param owner The address of the user who owns this order.\n    /// @param validTo The epoch time at which the order will stop being valid.\n    function packOrderUidParams(\n        bytes memory orderUid,\n        bytes32 orderDigest,\n        address owner,\n        uint32 validTo\n    ) internal pure {\n        require(orderUid.length == UID_LENGTH, ""GPv2: uid buffer overflow"");\n\n        // NOTE: Write the order UID to the allocated memory buffer. The order\n        // parameters are written to memory in **reverse order** as memory\n        // operations write 32-bytes at a time and we want to use a packed\n        // encoding. This means, for example, that after writing the value of\n        // `owner` to bytes `20:52`, writing the `orderDigest` to bytes `0:32`\n        // will **overwrite** bytes `20:32`. This is desirable as addresses are\n        // only 20 bytes and `20:32` should be `0`s:\n        //\n        //        |           1111111111222222222233333333334444444444555555\n        //   byte | 01234567890123456789012345678901234567890123456789012345\n        // -------+---------------------------------------------------------\n        //  field | [.........orderDigest..........][......owner.......][vT]\n        // -------+---------------------------------------------------------\n        // mstore |                         [000000000000000000000000000.vT]\n        //        |                     [00000000000.......owner.......]\n        //        | [.........orderDigest..........]\n        //\n        // Additionally, since Solidity `bytes memory` are length prefixed,\n        // 32 needs to be added to all the offsets.\n        //\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(add(orderUid, 56), validTo)\n            mstore(add(orderUid, 52), owner)\n            mstore(add(orderUid, 32), orderDigest)\n        }\n    }\n\n    /// @dev Extracts specific order information from the standardized unique\n    /// order id of the protocol.\n    ///\n    /// @param orderUid The unique identifier used to represent an order in\n    /// the protocol. This uid is the packed concatenation of the order digest,\n    /// the validTo order parameter and the address of the user who created the\n    /// order. It is used by the user to interface with the contract directly,\n    /// and not by calls that are triggered by the solvers.\n    /// @return orderDigest The EIP-712 signing digest derived from the order\n    /// parameters.\n    /// @return owner The address of the user who owns this order.\n    /// @return validTo The epoch time at which the order will stop being valid.\n    function extractOrderUidParams(bytes calldata orderUid)\n        internal\n        pure\n        returns (\n            bytes32 orderDigest,\n            address owner,\n            uint32 validTo\n        )\n    {\n        require(orderUid.length == UID_LENGTH, ""GPv2: invalid uid"");\n\n        // Use assembly to efficiently decode packed calldata.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            orderDigest := calldataload(orderUid.offset)\n            owner := shr(96, calldataload(add(orderUid.offset, 32)))\n            validTo := shr(224, calldataload(add(orderUid.offset, 52)))\n        }\n    }\n}\n'}, 'src/contracts/libraries/GPv2SafeERC20.sol': {'content': '// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\n\nimport ""../interfaces/IERC20.sol"";\n\n/// @title Gnosis Protocol v2 Safe ERC20 Transfer Library\n/// @author Gnosis Developers\n/// @dev Gas-efficient version of Openzeppelin\'s SafeERC20 contract that notably\n/// does not revert when calling a non-contract.\nlibrary GPv2SafeERC20 {\n    /// @dev Wrapper around a call to the ERC20 function `transfer` that reverts\n    /// also when the token returns `false`.\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        bytes4 selector_ = token.transfer.selector;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, selector_)\n            mstore(\n                add(freeMemoryPointer, 4),\n                and(to, 0xffffffffffffffffffffffffffffffffffffffff)\n            )\n            mstore(add(freeMemoryPointer, 36), value)\n\n            if iszero(call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        require(getLastTansferResult(token), ""GPv2: failed transfer"");\n    }\n\n    /// @dev Wrapper around a call to the ERC20 function `transferFrom` that\n    /// reverts also when the token returns `false`.\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        bytes4 selector_ = token.transferFrom.selector;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, selector_)\n            mstore(\n                add(freeMemoryPointer, 4),\n                and(from, 0xffffffffffffffffffffffffffffffffffffffff)\n            )\n            mstore(\n                add(freeMemoryPointer, 36),\n                and(to, 0xffffffffffffffffffffffffffffffffffffffff)\n            )\n            mstore(add(freeMemoryPointer, 68), value)\n\n            if iszero(call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        require(getLastTansferResult(token), ""GPv2: failed transferFrom"");\n    }\n\n    /// @dev Verifies that the last return was a successful `transfer*` call.\n    /// This is done by checking that the return data is either empty, or\n    /// is a valid ABI encoded boolean.\n    function getLastTansferResult(IERC20 token)\n        private\n        view\n        returns (bool success)\n    {\n        // NOTE: Inspecting previous return data requires assembly. Note that\n        // we write the return data to memory 0 in the case where the return\n        // data size is 32, this is OK since the first 64 bytes of memory are\n        // reserved by Solidy as a scratch space that can be used within\n        // assembly blocks.\n        // <https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html>\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            /// @dev Revert with an ABI encoded Solidity error with a message\n            /// that fits into 32-bytes.\n            ///\n            /// An ABI encoded Solidity error has the following memory layout:\n            ///\n            /// ------------+----------------------------------\n            ///  byte range | value\n            /// ------------+----------------------------------\n            ///  0x00..0x04 |        selector(""Error(string)"")\n            ///  0x04..0x24 |      string offset (always 0x20)\n            ///  0x24..0x44 |                    string length\n            ///  0x44..0x64 | string value, padded to 32-bytes\n            function revertWithMessage(length, message) {\n                mstore(0x00, ""\\x08\\xc3\\x79\\xa0"")\n                mstore(0x04, 0x20)\n                mstore(0x24, length)\n                mstore(0x44, message)\n                revert(0x00, 0x64)\n            }\n\n            switch returndatasize()\n                // Non-standard ERC20 transfer without return.\n                case 0 {\n                    // NOTE: When the return data size is 0, verify that there\n                    // is code at the address. This is done in order to maintain\n                    // compatibility with Solidity calling conventions.\n                    // <https://docs.soliditylang.org/en/v0.7.6/control-structures.html#external-function-calls>\n                    if iszero(extcodesize(token)) {\n                        revertWithMessage(20, ""GPv2: not a contract"")\n                    }\n\n                    success := 1\n                }\n                // Standard ERC20 transfer returning boolean success value.\n                case 32 {\n                    returndatacopy(0, 0, returndatasize())\n\n                    // NOTE: For ABI encoding v1, any non-zero value is accepted\n                    // as `true` for a boolean. In order to stay compatible with\n                    // OpenZeppelin\'s `SafeERC20` library which is known to work\n                    // with the existing ERC20 implementation we care about,\n                    // make sure we return success for any non-zero return value\n                    // from the `transfer*` call.\n                    success := iszero(iszero(mload(0)))\n                }\n                default {\n                    revertWithMessage(31, ""GPv2: malformed transfer result"")\n                }\n        }\n    }\n}\n'}, 'src/contracts/libraries/GPv2Trade.sol': {'content': '// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\n\nimport ""../interfaces/IERC20.sol"";\nimport ""../mixins/GPv2Signing.sol"";\nimport ""./GPv2Order.sol"";\n\n/// @title Gnosis Protocol v2 Trade Library.\n/// @author Gnosis Developers\nlibrary GPv2Trade {\n    using GPv2Order for GPv2Order.Data;\n    using GPv2Order for bytes;\n\n    /// @dev A struct representing a trade to be executed as part a batch\n    /// settlement.\n    struct Data {\n        uint256 sellTokenIndex;\n        uint256 buyTokenIndex;\n        address receiver;\n        uint256 sellAmount;\n        uint256 buyAmount;\n        uint32 validTo;\n        bytes32 appData;\n        uint256 feeAmount;\n        uint256 flags;\n        uint256 executedAmount;\n        bytes signature;\n    }\n\n    /// @dev Extracts the order data and signing scheme for the specified trade.\n    ///\n    /// @param trade The trade.\n    /// @param tokens The list of tokens included in the settlement. The token\n    /// indices in the trade parameters map to tokens in this array.\n    /// @param order The memory location to extract the order data to.\n    function extractOrder(\n        Data calldata trade,\n        IERC20[] calldata tokens,\n        GPv2Order.Data memory order\n    ) internal pure returns (GPv2Signing.Scheme signingScheme) {\n        order.sellToken = tokens[trade.sellTokenIndex];\n        order.buyToken = tokens[trade.buyTokenIndex];\n        order.receiver = trade.receiver;\n        order.sellAmount = trade.sellAmount;\n        order.buyAmount = trade.buyAmount;\n        order.validTo = trade.validTo;\n        order.appData = trade.appData;\n        order.feeAmount = trade.feeAmount;\n        (\n            order.kind,\n            order.partiallyFillable,\n            order.sellTokenBalance,\n            order.buyTokenBalance,\n            signingScheme\n        ) = extractFlags(trade.flags);\n    }\n\n    /// @dev Decodes trade flags.\n    ///\n    /// Trade flags are used to tightly encode information on how to decode\n    /// an order. Examples that directly affect the structure of an order are\n    /// the kind of order (either a sell or a buy order) as well as whether the\n    /// order is partially fillable or if it is a ""fill-or-kill"" order. It also\n    /// encodes the signature scheme used to validate the order. As the most\n    /// likely values are fill-or-kill sell orders by an externally owned\n    /// account, the flags are chosen such that `0x00` represents this kind of\n    /// order. The flags byte uses the following format:\n    ///\n    /// ```\n    /// bit | 31 ...   | 6 | 5 | 4 | 3 | 2 | 1 | 0 |\n    /// ----+----------+---+---+-------+---+---+\n    ///     | reserved | *   * | * | *   * | * | * |\n    ///                  |   |   |   |   |   |   |\n    ///                  |   |   |   |   |   |   +---- order kind bit, 0 for a sell order\n    ///                  |   |   |   |   |   |         and 1 for a buy order\n    ///                  |   |   |   |   |   |\n    ///                  |   |   |   |   |   +-------- order fill bit, 0 for fill-or-kill\n    ///                  |   |   |   |   |             and 1 for a partially fillable order\n    ///                  |   |   |   |   |\n    ///                  |   |   |   +---+------------ use internal sell token balance bit:\n    ///                  |   |   |                     0x: ERC20 token balance\n    ///                  |   |   |                     10: external Balancer Vault balance\n    ///                  |   |   |                     11: internal Balancer Vault balance\n    ///                  |   |   |\n    ///                  |   |   +-------------------- use buy token balance bit\n    ///                  |   |                         0: ERC20 token balance\n    ///                  |   |                         1: internal Balancer Vault balance\n    ///                  |   |\n    ///                  +---+------------------------ signature scheme bits:\n    ///                                                00: EIP-712\n    ///                                                01: eth_sign\n    ///                                                10: EIP-1271\n    ///                                                11: pre_sign\n    /// ```\n    function extractFlags(uint256 flags)\n        internal\n        pure\n        returns (\n            bytes32 kind,\n            bool partiallyFillable,\n            bytes32 sellTokenBalance,\n            bytes32 buyTokenBalance,\n            GPv2Signing.Scheme signingScheme\n        )\n    {\n        if (flags & 0x01 == 0) {\n            kind = GPv2Order.KIND_SELL;\n        } else {\n            kind = GPv2Order.KIND_BUY;\n        }\n        partiallyFillable = flags & 0x02 != 0;\n        if (flags & 0x08 == 0) {\n            sellTokenBalance = GPv2Order.BALANCE_ERC20;\n        } else if (flags & 0x04 == 0) {\n            sellTokenBalance = GPv2Order.BALANCE_EXTERNAL;\n        } else {\n            sellTokenBalance = GPv2Order.BALANCE_INTERNAL;\n        }\n        if (flags & 0x10 == 0) {\n            buyTokenBalance = GPv2Order.BALANCE_ERC20;\n        } else {\n            buyTokenBalance = GPv2Order.BALANCE_INTERNAL;\n        }\n\n        // NOTE: Take advantage of the fact that Solidity will revert if the\n        // following expression does not produce a valid enum value. This means\n        // we check here that the leading reserved bits must be 0.\n        signingScheme = GPv2Signing.Scheme(flags >> 5);\n    }\n}\n'}, 'src/contracts/libraries/GPv2Transfer.sol': {'content': '// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport ""../interfaces/IERC20.sol"";\nimport ""../interfaces/IVault.sol"";\nimport ""./GPv2Order.sol"";\nimport ""./GPv2SafeERC20.sol"";\n\n/// @title Gnosis Protocol v2 Transfers\n/// @author Gnosis Developers\nlibrary GPv2Transfer {\n    using GPv2SafeERC20 for IERC20;\n\n    /// @dev Transfer data.\n    struct Data {\n        address account;\n        IERC20 token;\n        uint256 amount;\n        bytes32 balance;\n    }\n\n    /// @dev Ether marker address used to indicate an Ether transfer.\n    address internal constant BUY_ETH_ADDRESS =\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Execute the specified transfer from the specified account to a\n    /// recipient. The recipient will either receive internal Vault balances or\n    /// ERC20 token balances depending on whether the account is using internal\n    /// balances or not.\n    ///\n    /// This method is used for transferring fees to the settlement contract\n    /// when settling a single order directly with Balancer.\n    ///\n    /// Note that this method is subtly different from `transferFromAccounts`\n    /// with a single transfer with respect to how it deals with internal\n    /// balances. Specifically, this method will perform an **internal balance\n    /// transfer to the settlement contract instead of a withdrawal to the\n    /// external balance of the settlement contract** for trades that specify\n    /// trading with internal balances. This is done as a gas optimization in\n    /// the single order ""fast-path"".\n    ///\n    /// @param vault The Balancer vault to use.\n    /// @param transfer The transfer to perform specifying the sender account.\n    /// @param recipient The recipient for the transfer.\n    function fastTransferFromAccount(\n        IVault vault,\n        Data calldata transfer,\n        address recipient\n    ) internal {\n        require(\n            address(transfer.token) != BUY_ETH_ADDRESS,\n            ""GPv2: cannot transfer native ETH""\n        );\n\n        if (transfer.balance == GPv2Order.BALANCE_ERC20) {\n            transfer.token.safeTransferFrom(\n                transfer.account,\n                recipient,\n                transfer.amount\n            );\n        } else {\n            IVault.UserBalanceOp[] memory balanceOps =\n                new IVault.UserBalanceOp[](1);\n\n            IVault.UserBalanceOp memory balanceOp = balanceOps[0];\n            balanceOp.kind = transfer.balance == GPv2Order.BALANCE_EXTERNAL\n                ? IVault.UserBalanceOpKind.TRANSFER_EXTERNAL\n                : IVault.UserBalanceOpKind.TRANSFER_INTERNAL;\n            balanceOp.asset = transfer.token;\n            balanceOp.amount = transfer.amount;\n            balanceOp.sender = transfer.account;\n            balanceOp.recipient = payable(recipient);\n\n            vault.manageUserBalance(balanceOps);\n        }\n    }\n\n    /// @dev Execute the specified transfers from the specified accounts to a\n    /// single recipient. The recipient will receive all transfers as ERC20\n    /// token balances, regardless of whether or not the accounts are using\n    /// internal Vault balances.\n    ///\n    /// This method is used for accumulating user balances into the settlement\n    /// contract.\n    ///\n    /// @param vault The Balancer vault to use.\n    /// @param transfers The batched transfers to perform specifying the\n    /// sender accounts.\n    /// @param recipient The single recipient for all the transfers.\n    function transferFromAccounts(\n        IVault vault,\n        Data[] calldata transfers,\n        address recipient\n    ) internal {\n        // NOTE: Allocate buffer of Vault balance operations large enough to\n        // hold all GP transfers. This is done to avoid re-allocations (which\n        // are gas inefficient) while still allowing all transfers to be batched\n        // into a single Vault call.\n        IVault.UserBalanceOp[] memory balanceOps =\n            new IVault.UserBalanceOp[](transfers.length);\n        uint256 balanceOpCount = 0;\n\n        for (uint256 i = 0; i < transfers.length; i++) {\n            Data calldata transfer = transfers[i];\n            require(\n                address(transfer.token) != BUY_ETH_ADDRESS,\n                ""GPv2: cannot transfer native ETH""\n            );\n\n            if (transfer.balance == GPv2Order.BALANCE_ERC20) {\n                transfer.token.safeTransferFrom(\n                    transfer.account,\n                    recipient,\n                    transfer.amount\n                );\n            } else {\n                IVault.UserBalanceOp memory balanceOp =\n                    balanceOps[balanceOpCount++];\n                balanceOp.kind = transfer.balance == GPv2Order.BALANCE_EXTERNAL\n                    ? IVault.UserBalanceOpKind.TRANSFER_EXTERNAL\n                    : IVault.UserBalanceOpKind.WITHDRAW_INTERNAL;\n                balanceOp.asset = transfer.token;\n                balanceOp.amount = transfer.amount;\n                balanceOp.sender = transfer.account;\n                balanceOp.recipient = payable(recipient);\n            }\n        }\n\n        if (balanceOpCount > 0) {\n            truncateBalanceOpsArray(balanceOps, balanceOpCount);\n            vault.manageUserBalance(balanceOps);\n        }\n    }\n\n    /// @dev Execute the specified transfers to their respective accounts.\n    ///\n    /// This method is used for paying out trade proceeds from the settlement\n    /// contract.\n    ///\n    /// @param vault The Balancer vault to use.\n    /// @param transfers The batched transfers to perform.\n    function transferToAccounts(IVault vault, Data[] memory transfers)\n        internal\n    {\n        IVault.UserBalanceOp[] memory balanceOps =\n            new IVault.UserBalanceOp[](transfers.length);\n        uint256 balanceOpCount = 0;\n\n        for (uint256 i = 0; i < transfers.length; i++) {\n            Data memory transfer = transfers[i];\n\n            if (address(transfer.token) == BUY_ETH_ADDRESS) {\n                require(\n                    transfer.balance != GPv2Order.BALANCE_INTERNAL,\n                    ""GPv2: unsupported internal ETH""\n                );\n                payable(transfer.account).transfer(transfer.amount);\n            } else if (transfer.balance == GPv2Order.BALANCE_ERC20) {\n                transfer.token.safeTransfer(transfer.account, transfer.amount);\n            } else {\n                IVault.UserBalanceOp memory balanceOp =\n                    balanceOps[balanceOpCount++];\n                balanceOp.kind = IVault.UserBalanceOpKind.DEPOSIT_INTERNAL;\n                balanceOp.asset = transfer.token;\n                balanceOp.amount = transfer.amount;\n                balanceOp.sender = address(this);\n                balanceOp.recipient = payable(transfer.account);\n            }\n        }\n\n        if (balanceOpCount > 0) {\n            truncateBalanceOpsArray(balanceOps, balanceOpCount);\n            vault.manageUserBalance(balanceOps);\n        }\n    }\n\n    /// @dev Truncate a Vault balance operation array to its actual size.\n    ///\n    /// This method **does not** check whether or not the new length is valid,\n    /// and specifying a size that is larger than the array\'s actual length is\n    /// undefined behaviour.\n    ///\n    /// @param balanceOps The memory array of balance operations to truncate.\n    /// @param newLength The new length to set.\n    function truncateBalanceOpsArray(\n        IVault.UserBalanceOp[] memory balanceOps,\n        uint256 newLength\n    ) private pure {\n        // NOTE: Truncate the vault transfers array to the specified length.\n        // This is done by setting the array\'s length which occupies the first\n        // word in memory pointed to by the `balanceOps` memory variable.\n        // <https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html>\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(balanceOps, newLength)\n        }\n    }\n}\n'}, 'src/contracts/libraries/SafeCast.sol': {'content': '// SPDX-License-Identifier: MIT\n\n// Vendored from OpenZeppelin contracts with minor modifications:\n// - Modified Solidity version\n// - Formatted code\n// - Shortened revert messages\n// - Removed unused methods\n// - Convert to `type(*).*` notation\n// <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/utils/SafeCast.sol>\n\npragma solidity ^0.7.6;\n\n/**\n * @dev Wrappers over Solidity\'s uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\'s recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, ""SafeCast: not positive"");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        require(\n            value <= uint256(type(int256).max),\n            ""SafeCast: int256 overflow""\n        );\n        return int256(value);\n    }\n}\n'}, 'src/contracts/libraries/SafeMath.sol': {'content': '// SPDX-License-Identifier: MIT\n\n// Vendored from OpenZeppelin contracts with minor modifications:\n// - Modified Solidity version\n// - Formatted code\n// - Shortened some revert messages\n// - Removed unused methods\n// - Added `ceilDiv` method\n// <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/math/SafeMath.sol>\n\npragma solidity ^0.7.6;\n\n/**\n * @dev Wrappers over Solidity\'s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\'s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\'s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, ""SafeMath: addition overflow"");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\'s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, ""SafeMath: subtraction overflow"");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\'s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, ""SafeMath: mul overflow"");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\'s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, ""SafeMath: division by 0"");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the ceiling integer division of two unsigned integers,\n     * reverting on division by zero. The result is rounded towards up the\n     * nearest integer, instead of truncating the fractional part.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     * - The sum of the dividend and divisor cannot overflow.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, ""SafeMath: ceiling division by 0"");\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n'}, 'src/contracts/mixins/GPv2Signing.sol': {'content': '// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\n\nimport ""../interfaces/GPv2EIP1271.sol"";\nimport ""../libraries/GPv2Order.sol"";\nimport ""../libraries/GPv2Trade.sol"";\n\n/// @title Gnosis Protocol v2 Signing Library.\n/// @author Gnosis Developers\nabstract contract GPv2Signing {\n    using GPv2Order for GPv2Order.Data;\n    using GPv2Order for bytes;\n\n    /// @dev Recovered trade data containing the extracted order and the\n    /// recovered owner address.\n    struct RecoveredOrder {\n        GPv2Order.Data data;\n        bytes uid;\n        address owner;\n        address receiver;\n    }\n\n    /// @dev Signing scheme used for recovery.\n    enum Scheme {Eip712, EthSign, Eip1271, PreSign}\n\n    /// @dev The EIP-712 domain type hash used for computing the domain\n    /// separator.\n    bytes32 private constant DOMAIN_TYPE_HASH =\n        keccak256(\n            ""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""\n        );\n\n    /// @dev The EIP-712 domain name used for computing the domain separator.\n    bytes32 private constant DOMAIN_NAME = keccak256(""Gnosis Protocol"");\n\n    /// @dev The EIP-712 domain version used for computing the domain separator.\n    bytes32 private constant DOMAIN_VERSION = keccak256(""v2"");\n\n    /// @dev Marker value indicating an order is pre-signed.\n    uint256 private constant PRE_SIGNED =\n        uint256(keccak256(""GPv2Signing.Scheme.PreSign""));\n\n    /// @dev The domain separator used for signing orders that gets mixed in\n    /// making signatures for different domains incompatible. This domain\n    /// separator is computed following the EIP-712 standard and has replay\n    /// protection mixed in so that signed orders are only valid for specific\n    /// GPv2 contracts.\n    bytes32 public immutable domainSeparator;\n\n    /// @dev Storage indicating whether or not an order has been signed by a\n    /// particular address.\n    mapping(bytes => uint256) public preSignature;\n\n    /// @dev Event that is emitted when an account either pre-signs an order or\n    /// revokes an existing pre-signature.\n    event PreSignature(address indexed owner, bytes orderUid, bool signed);\n\n    constructor() {\n        // NOTE: Currently, the only way to get the chain ID in solidity is\n        // using assembly.\n        uint256 chainId;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n\n        domainSeparator = keccak256(\n            abi.encode(\n                DOMAIN_TYPE_HASH,\n                DOMAIN_NAME,\n                DOMAIN_VERSION,\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    /// @dev Sets a presignature for the specified order UID.\n    ///\n    /// @param orderUid The unique identifier of the order to pre-sign.\n    function setPreSignature(bytes calldata orderUid, bool signed) external {\n        (, address owner, ) = orderUid.extractOrderUidParams();\n        require(owner == msg.sender, ""GPv2: cannot presign order"");\n        if (signed) {\n            preSignature[orderUid] = PRE_SIGNED;\n        } else {\n            preSignature[orderUid] = 0;\n        }\n        emit PreSignature(owner, orderUid, signed);\n    }\n\n    /// @dev Returns an empty recovered order with a pre-allocated buffer for\n    /// packing the unique identifier.\n    ///\n    /// @return recoveredOrder The empty recovered order data.\n    function allocateRecoveredOrder()\n        internal\n        pure\n        returns (RecoveredOrder memory recoveredOrder)\n    {\n        recoveredOrder.uid = new bytes(GPv2Order.UID_LENGTH);\n    }\n\n    /// @dev Extracts order data and recovers the signer from the specified\n    /// trade.\n    ///\n    /// @param recoveredOrder Memory location used for writing the recovered order data.\n    /// @param tokens The list of tokens included in the settlement. The token\n    /// indices in the trade parameters map to tokens in this array.\n    /// @param trade The trade data to recover the order data from.\n    function recoverOrderFromTrade(\n        RecoveredOrder memory recoveredOrder,\n        IERC20[] calldata tokens,\n        GPv2Trade.Data calldata trade\n    ) internal view {\n        GPv2Order.Data memory order = recoveredOrder.data;\n\n        Scheme signingScheme = GPv2Trade.extractOrder(trade, tokens, order);\n        (bytes32 orderDigest, address owner) =\n            recoverOrderSigner(order, signingScheme, trade.signature);\n\n        recoveredOrder.uid.packOrderUidParams(\n            orderDigest,\n            owner,\n            order.validTo\n        );\n        recoveredOrder.owner = owner;\n        recoveredOrder.receiver = order.actualReceiver(owner);\n    }\n\n    /// @dev The length of any signature from an externally owned account.\n    uint256 private constant ECDSA_SIGNATURE_LENGTH = 65;\n\n    /// @dev Recovers an order\'s signer from the specified order and signature.\n    ///\n    /// @param order The order to recover a signature for.\n    /// @param signingScheme The signing scheme.\n    /// @param signature The signature bytes.\n    /// @return orderDigest The computed order hash.\n    /// @return owner The recovered address from the specified signature.\n    function recoverOrderSigner(\n        GPv2Order.Data memory order,\n        Scheme signingScheme,\n        bytes calldata signature\n    ) internal view returns (bytes32 orderDigest, address owner) {\n        orderDigest = order.hash(domainSeparator);\n        if (signingScheme == Scheme.Eip712) {\n            owner = recoverEip712Signer(orderDigest, signature);\n        } else if (signingScheme == Scheme.EthSign) {\n            owner = recoverEthsignSigner(orderDigest, signature);\n        } else if (signingScheme == Scheme.Eip1271) {\n            owner = recoverEip1271Signer(orderDigest, signature);\n        } else {\n            // signingScheme == Scheme.PreSign\n            owner = recoverPreSigner(orderDigest, signature, order.validTo);\n        }\n    }\n\n    /// @dev Perform an ECDSA recover for the specified message and calldata\n    /// signature.\n    ///\n    /// The signature is encoded by tighyly packing the following struct:\n    /// ```\n    /// struct EncodedSignature {\n    ///     bytes32 r;\n    ///     bytes32 s;\n    ///     uint8 v;\n    /// }\n    /// ```\n    ///\n    /// @param message The signed message.\n    /// @param encodedSignature The encoded signature.\n    function ecdsaRecover(bytes32 message, bytes calldata encodedSignature)\n        internal\n        pure\n        returns (address signer)\n    {\n        require(\n            encodedSignature.length == ECDSA_SIGNATURE_LENGTH,\n            ""GPv2: malformed ecdsa signature""\n        );\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // NOTE: Use assembly to efficiently decode signature data.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // r = uint256(encodedSignature[0:32])\n            r := calldataload(encodedSignature.offset)\n            // s = uint256(encodedSignature[32:64])\n            s := calldataload(add(encodedSignature.offset, 32))\n            // v = uint8(encodedSignature[64])\n            v := shr(248, calldataload(add(encodedSignature.offset, 64)))\n        }\n\n        signer = ecrecover(message, v, r, s);\n        require(signer != address(0), ""GPv2: invalid ecdsa signature"");\n    }\n\n    /// @dev Decodes signature bytes originating from an EIP-712-encoded\n    /// signature.\n    ///\n    /// EIP-712 signs typed data. The specifications are described in the\n    /// related EIP (<https://eips.ethereum.org/EIPS/eip-712>).\n    ///\n    /// EIP-712 signatures are encoded as standard ECDSA signatures as described\n    /// in the corresponding decoding function [`ecdsaRecover`].\n    ///\n    /// @param orderDigest The EIP-712 signing digest derived from the order\n    /// parameters.\n    /// @param encodedSignature Calldata pointing to tightly packed signature\n    /// bytes.\n    /// @return owner The address of the signer.\n    function recoverEip712Signer(\n        bytes32 orderDigest,\n        bytes calldata encodedSignature\n    ) internal pure returns (address owner) {\n        owner = ecdsaRecover(orderDigest, encodedSignature);\n    }\n\n    /// @dev Decodes signature bytes originating from the output of the eth_sign\n    /// RPC call.\n    ///\n    /// The specifications are described in the Ethereum documentation\n    /// (<https://eth.wiki/json-rpc/API#eth_sign>).\n    ///\n    /// eth_sign signatures are encoded as standard ECDSA signatures as\n    /// described in the corresponding decoding function\n    /// [`ecdsaRecover`].\n    ///\n    /// @param orderDigest The EIP-712 signing digest derived from the order\n    /// parameters.\n    /// @param encodedSignature Calldata pointing to tightly packed signature\n    /// bytes.\n    /// @return owner The address of the signer.\n    function recoverEthsignSigner(\n        bytes32 orderDigest,\n        bytes calldata encodedSignature\n    ) internal pure returns (address owner) {\n        // The signed message is encoded as:\n        // `""\\x19Ethereum Signed Message:\\n"" || length || data`, where\n        // the length is a constant (32 bytes) and the data is defined as:\n        // `orderDigest`.\n        bytes32 ethsignDigest =\n            keccak256(\n                abi.encodePacked(\n                    ""\\x19Ethereum Signed Message:\\n32"",\n                    orderDigest\n                )\n            );\n\n        owner = ecdsaRecover(ethsignDigest, encodedSignature);\n    }\n\n    /// @dev Verifies the input calldata as an EIP-1271 contract signature and\n    /// returns the address of the signer.\n    ///\n    /// The encoded signature tightly packs the following struct:\n    ///\n    /// ```\n    /// struct EncodedEip1271Signature {\n    ///     address owner;\n    ///     bytes signature;\n    /// }\n    /// ```\n    ///\n    /// This function enforces that the encoded data stores enough bytes to\n    /// cover the full length of the decoded signature.\n    ///\n    /// @param encodedSignature The encoded EIP-1271 signature.\n    /// @param orderDigest The EIP-712 signing digest derived from the order\n    /// parameters.\n    /// @return owner The address of the signer.\n    function recoverEip1271Signer(\n        bytes32 orderDigest,\n        bytes calldata encodedSignature\n    ) internal view returns (address owner) {\n        // NOTE: Use assembly to read the verifier address from the encoded\n        // signature bytes.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // owner = address(encodedSignature[0:20])\n            owner := shr(96, calldataload(encodedSignature.offset))\n        }\n\n        // NOTE: Configure prettier to ignore the following line as it causes\n        // a panic in the Solidity plugin.\n        // prettier-ignore\n        bytes calldata signature = encodedSignature[20:];\n\n        require(\n            EIP1271Verifier(owner).isValidSignature(orderDigest, signature) ==\n                GPv2EIP1271.MAGICVALUE,\n            ""GPv2: invalid eip1271 signature""\n        );\n    }\n\n    /// @dev Verifies the order has been pre-signed. The signature is the\n    /// address of the signer of the order.\n    ///\n    /// @param orderDigest The EIP-712 signing digest derived from the order\n    /// parameters.\n    /// @param encodedSignature The pre-sign signature reprenting the order UID.\n    /// @param validTo The order expiry timestamp.\n    /// @return owner The address of the signer.\n    function recoverPreSigner(\n        bytes32 orderDigest,\n        bytes calldata encodedSignature,\n        uint32 validTo\n    ) internal view returns (address owner) {\n        require(encodedSignature.length == 20, ""GPv2: malformed presignature"");\n        // NOTE: Use assembly to read the owner address from the encoded\n        // signature bytes.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // owner = address(encodedSignature[0:20])\n            owner := shr(96, calldataload(encodedSignature.offset))\n        }\n\n        bytes memory orderUid = new bytes(GPv2Order.UID_LENGTH);\n        orderUid.packOrderUidParams(orderDigest, owner, validTo);\n\n        require(\n            preSignature[orderUid] == PRE_SIGNED,\n            ""GPv2: order not presigned""\n        );\n    }\n}\n'}, 'src/contracts/mixins/ReentrancyGuard.sol': {'content': '// SPDX-License-Identifier: MIT\n\n// Vendored from OpenZeppelin contracts with minor modifications:\n// - Modified Solidity version\n// - Formatted code\n// <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/utils/ReentrancyGuard.sol>\n\npragma solidity ^0.7.6;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n'}, 'src/contracts/mixins/StorageAccessible.sol': {'content': ""// SPDX-License-Identifier: LGPL-3.0-only\n\n// Vendored from Gnosis utility contracts with minor modifications:\n// - Modified Solidity version\n// - Formatted code\n// - Added linter directives to ignore low level call and assembly warnings\n// <https://github.com/gnosis/util-contracts/blob/v3.1.0-solc-7/contracts/StorageAccessible.sol>\n\npragma solidity ^0.7.6;\n\n/// @title ViewStorageAccessible - Interface on top of StorageAccessible base class to allow simulations from view functions\ninterface ViewStorageAccessible {\n    /**\n     * @dev Same as `simulateDelegatecall` on StorageAccessible. Marked as view so that it can be called from external contracts\n     * that want to run simulations from within view functions. Will revert if the invoked simulation attempts to change state.\n     */\n    function simulateDelegatecall(\n        address targetContract,\n        bytes memory calldataPayload\n    ) external view returns (bytes memory);\n\n    /**\n     * @dev Same as `getStorageAt` on StorageAccessible. This method allows reading aribtrary ranges of storage.\n     */\n    function getStorageAt(uint256 offset, uint256 length)\n        external\n        view\n        returns (bytes memory);\n}\n\n/// @title StorageAccessible - generic base contract that allows callers to access all internal storage.\ncontract StorageAccessible {\n    /**\n     * @dev Reads `length` bytes of storage in the currents contract\n     * @param offset - the offset in the current contract's storage in words to start reading from\n     * @param length - the number of words (32 bytes) of data to read\n     * @return the bytes that were read.\n     */\n    function getStorageAt(uint256 offset, uint256 length)\n        external\n        view\n        returns (bytes memory)\n    {\n        bytes memory result = new bytes(length * 32);\n        for (uint256 index = 0; index < length; index++) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                let word := sload(add(offset, index))\n                mstore(add(add(result, 0x20), mul(index, 0x20)), word)\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Performs a delegetecall on a targetContract in the context of self.\n     * Internally reverts execution to avoid side effects (making it static). Catches revert and returns encoded result as bytes.\n     * @param targetContract Address of the contract containing the code to execute.\n     * @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\n     */\n    function simulateDelegatecall(\n        address targetContract,\n        bytes memory calldataPayload\n    ) public returns (bytes memory response) {\n        bytes memory innerCall =\n            abi.encodeWithSelector(\n                this.simulateDelegatecallInternal.selector,\n                targetContract,\n                calldataPayload\n            );\n        // solhint-disable-next-line avoid-low-level-calls\n        (, response) = address(this).call(innerCall);\n        bool innerSuccess = response[response.length - 1] == 0x01;\n        setLength(response, response.length - 1);\n        if (innerSuccess) {\n            return response;\n        } else {\n            revertWith(response);\n        }\n    }\n\n    /**\n     * @dev Performs a delegetecall on a targetContract in the context of self.\n     * Internally reverts execution to avoid side effects (making it static). Returns encoded result as revert message\n     * concatenated with the success flag of the inner call as a last byte.\n     * @param targetContract Address of the contract containing the code to execute.\n     * @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\n     */\n    function simulateDelegatecallInternal(\n        address targetContract,\n        bytes memory calldataPayload\n    ) external returns (bytes memory response) {\n        bool success;\n        // solhint-disable-next-line avoid-low-level-calls\n        (success, response) = targetContract.delegatecall(calldataPayload);\n        revertWith(abi.encodePacked(response, success));\n    }\n\n    function revertWith(bytes memory response) internal pure {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            revert(add(response, 0x20), mload(response))\n        }\n    }\n\n    function setLength(bytes memory buffer, uint256 length) internal pure {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(buffer, length)\n        }\n    }\n}\n""}}",True
0x252b9f56359901a0bde52d0675b1f1130d86f471,"/**
 * PANDO token 
 * 
*/

// SPDX-License-Identifier: MIT

pragma solidity ^0.5.9;

library SafeMath
{
  	function mul(uint256 a, uint256 b) internal pure returns (uint256)
    	{
		uint256 c = a * b;
		assert(a == 0 || c / a == b);

		return c;
  	}

  	function div(uint256 a, uint256 b) internal pure returns (uint256)
	{
		uint256 c = a / b;

		return c;
  	}

  	function sub(uint256 a, uint256 b) internal pure returns (uint256)
	{
		assert(b <= a);

		return a - b;
  	}

  	function add(uint256 a, uint256 b) internal pure returns (uint256)
	{
		uint256 c = a + b;
		assert(c >= a);

		return c;
  	}
}

contract OwnerHelper
{
  	address public owner;

  	event ChangeOwner(address indexed _from, address indexed _to);

  	modifier onlyOwner
	{
		require(msg.sender == owner);
		_;
  	}
  	
  	constructor() public
	{
		owner = msg.sender;
  	}
  	
  	function transferOwnership(address _to) onlyOwner public
  	{
    	require(_to != owner);
    	require(_to != address(0x0));

        address from = owner;
      	owner = _to;
  	    
      	emit ChangeOwner(from, _to);
  	}
}


contract ERC20Interface
{
    event Transfer( address indexed _from, address indexed _to, uint _value);
    event Approval( address indexed _owner, address indexed _spender, uint _value);
    
    function totalSupply() view public returns (uint _supply);
    function balanceOf( address _who ) public view returns (uint _value);
    function transfer( address _to, uint _value) public returns (bool _success);
    function approve( address _spender, uint _value ) public returns (bool _success);
    function allowance( address _owner, address _spender ) public view returns (uint _allowance);
    function transferFrom( address _from, address _to, uint _value) public returns (bool _success);
}

contract PandoToken is ERC20Interface, OwnerHelper
{
    using SafeMath for uint;
    
    string public name;
    uint public decimals;
    string public symbol;

    // Founder
    address private founder;
    
    // Total
    uint public totalTokenSupply;
    uint public burnTokenSupply;

    mapping (address => uint) public balances;
    mapping (address => mapping ( address => uint )) public approvals;
    mapping (address => bool) private blackAddress; // unLock : false, Lock : true
    
    bool public tokenLock = false;

    // Token Total
    uint constant private E18 = 1000000000000000000;

    event Burn(address indexed _from, uint _tokens);
    event TokenUnlock(address indexed _to, uint _tokens);

    constructor(string memory _name, string memory _symbol, address _founder, uint _totalTokenSupply) public {
        name        = _name;
        decimals    = 18;
        symbol      = _symbol;

        founder = _founder;
        totalTokenSupply  = _totalTokenSupply * E18;
        burnTokenSupply     = 0;

        balances[founder] = totalTokenSupply;
        emit Transfer(address(0), founder, totalTokenSupply);
    }

    // ERC - 20 Interface -----
    modifier notLocked {
        require(isTransferable() == true);
        _;
    }

    function lock(address who) onlyOwner public {
        
        blackAddress[who] = true;
    }
    
    function unlock(address who) onlyOwner public {
        
        blackAddress[who] = false;
    }
    
    function isLocked(address who) public view returns(bool) {
        
        return blackAddress[who];
    }

    function totalSupply() view public returns (uint) 
    {
        return totalTokenSupply;
    }
    
    function balanceOf(address _who) view public returns (uint) 
    {
        return balances[_who];
    }
    
    function transfer(address _to, uint _value) notLocked public returns (bool) 
    {
        require(balances[msg.sender] >= _value);
        
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        
        emit Transfer(msg.sender, _to, _value);
        
        return true;
    }
    
    function approve(address _spender, uint _value) notLocked public returns (bool)
    {
        require(balances[msg.sender] >= _value);
        
        approvals[msg.sender][_spender] = _value;
        
        emit Approval(msg.sender, _spender, _value);
        
        return true; 
    }
    
    function allowance(address _owner, address _spender) view public returns (uint) 
    {
        return approvals[_owner][_spender];
    }

    function transferFrom(address _from, address _to, uint _value) notLocked public returns (bool) 
    {
        require(balances[_from] >= _value);
        require(approvals[_from][msg.sender] >= _value);
        
        approvals[_from][msg.sender] = approvals[_from][msg.sender].sub(_value);
        balances[_from] = balances[_from].sub(_value);
        balances[_to]  = balances[_to].add(_value);
        
        emit Transfer(_from, _to, _value);
        
        return true;
    }
    
    // Lock Function -----
    
    function isTransferable() private view returns (bool)
    {
        if(tokenLock == false) {

            if (blackAddress[msg.sender]) // true is Locked
            {
                return false;
            } else {
                return true;
            }
        }
        else if(msg.sender == owner)
        {
            return true;
        }
        
        return false;
    }
    
    function setTokenUnlock() onlyOwner public
    {
        require(tokenLock == true);
        
        tokenLock = false;
    }
    
    function setTokenLock() onlyOwner public
    {
        require(tokenLock == false);
        
        tokenLock = true;
    }

    function withdrawTokens(address _contract, uint _value) onlyOwner public
    {

        if(_contract == address(0x0))
        {
            uint eth = _value.mul(10 ** decimals);
            msg.sender.transfer(eth);
        }
        else
        {
            uint tokens = _value.mul(10 ** decimals);
            ERC20Interface(_contract).transfer(msg.sender, tokens);
            
            emit Transfer(address(0x0), msg.sender, tokens);
        }
    }

    function burnToken(uint _value) onlyOwner public
    {
        uint tokens = _value.mul(10 ** decimals);
        
        require(balances[msg.sender] >= tokens);
        
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        
        burnTokenSupply = burnTokenSupply.add(tokens);
        totalTokenSupply = totalTokenSupply.sub(tokens);
        
        emit Burn(msg.sender, tokens);
    }    
    
    function close() onlyOwner public
    {
        selfdestruct(msg.sender);
    }
    
}",True
0xcb238fd45d1b1603dcc3b8026a662d00b8c075c1,"// File: language
Solidity

// File: sources
{'src/ino/INO.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.23;\n\nimport {INOWritable} from ""./writable/INOWritable.sol"";\nimport {INOReadable} from ""./readable/INOReadable.sol"";\n\n/**\n * @title INO\n * @notice Initial NFT Offering contract.\n * @dev Constructor replaced by the `initialize` function in {INOWritable}.\n */\ncontract INO is\n    INOWritable, // 21 inherited component\n    INOReadable // 7 inherited components\n{}\n'}, 'src/ino/writable/INOWritable.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.23;\n\nimport {IINOWritable} from ""./IINOWritable.sol"";\nimport {INFT} from ""../nft/interfaces/INFT.sol"";\n\nimport {INOWritableInternal} from ""./INOWritableInternal.sol"";\n\nimport {INORestricted} from ""./restricted/INORestricted.sol"";\n\nimport {SaleStorage} from ""../../common/SaleStorage.sol"";\nimport {INOStorage} from ""../INOStorage.sol"";\n\n// import struct\nimport {BuyPermission, Phase} from ""../../common/SaleStruct.sol"";\nimport {FreeAllocation} from ""../INOStruct.sol"";\nimport {UserAllocationFee} from ""../../common/UserAllocationStruct.sol"";\n\n/**\n * @title INO\n * @notice Initial NFT Offering contract.\n * @dev This contract is used to deploy the NFT collection to mint/sale and handle the sale.\n */\ncontract INOWritable is\n    IINOWritable, // 1 inherited component\n    INOWritableInternal, // 6 inherited components\n    INORestricted // 13 inherited components\n{\n    function buyAndMintWithERC20(\n        uint256 spendNow,\n        UserAllocationFee calldata allocation,\n        bytes32[] calldata proof,\n        BuyPermission calldata permission\n    ) external override {\n        SaleStorage.SetUp memory saleSetUp = SaleStorage.layout().setUp;\n\n        if (saleSetUp.paymentToken == address(0)) {\n            revert INO_UseInstead(""buyAndMintWithNative"");\n        }\n\n        _mintAndUpdateStorage(\n            spendNow,\n            allocation,\n            proof,\n            SaleStorage.layout().ledger.summedMaxPhaseCap\n        );\n\n        /**\n         * @dev transfer selected {paymentToken} to receiver wallet via permit2\n         * read from storage as there is not point to pass `setUp`s as parameters, cost a bit more BUT\n         * better dev experience\n         */\n        _permit2ApproveAndTransfer(\n            saleSetUp.permit2,\n            msg.sender, // allow delegate to spend\n            INOStorage.layout().setUp.paymentReceiver,\n            saleSetUp.paymentToken,\n            spendNow,\n            permission\n        );\n    }\n\n    /// @inheritdoc IINOWritable\n    function buyAndMintWithNative(\n        UserAllocationFee calldata allocation,\n        bytes32[] calldata proof\n    ) external payable override {\n        uint256 spendNow = msg.value;\n        if (SaleStorage.layout().setUp.paymentToken != address(0)) {\n            revert INO_UseInstead(""buyAndMintWithERC20"");\n        }\n\n        _mintAndUpdateStorage(\n            spendNow,\n            allocation,\n            proof,\n            SaleStorage.layout().ledger.summedMaxPhaseCap\n        );\n\n        // transfer ETH to receiver wallet\n        (bool ok, bytes memory data) = INOStorage\n            .layout()\n            .setUp\n            .paymentReceiver\n            .call{value: msg.value}(""""); // delegate can also spend on behalf of the user\n        if (!ok) {\n            revert INO_NativePaymentFailed(data);\n        }\n    }\n\n    function freeMint(\n        FreeAllocation calldata allocation,\n        bytes32[] calldata proof\n    ) external override {\n        _checkFreeMintParams(allocation, proof);\n\n        _updateStorageOnFreeMint(\n            allocation.phaseId,\n            allocation.account,\n            allocation.toMint\n        );\n        _updateMintedAmount(allocation.phaseId, allocation.toMint);\n\n        INFT(INOStorage.layout().collection).mint(\n            allocation.account, // allow a delegate wallet to mint on behalf of the user\n            allocation.toMint // mint whole free allocation in once\n        );\n    }\n}\n'}, 'src/ino/readable/INOReadable.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.23;\n\nimport {SaleReadable} from ""../../common/readable/SaleReadable.sol"";\n\nimport {IINOReadable} from ""./IINOReadable.sol"";\n\nimport {INOStorage} from ""../INOStorage.sol"";\n\n/**\n * @title INOReadable\n * @notice Initial NFT Offering contract.\n * @dev Constructor replaced by the `initialize` function in {INOWritable}.\n */\ncontract INOReadable is\n    IINOReadable, // 1 inherited component\n    SaleReadable // 5 inherited components\n{\n    /// @inheritdoc IINOReadable\n    function phaseMaxMint(\n        string calldata phaseId\n    ) public view override returns (uint256) {\n        return INOStorage.layout().phaseMaxMint[phaseId];\n    }\n\n    /// @inheritdoc IINOReadable\n    function inoSetUp()\n        public\n        view\n        override\n        returns (INOStorage.SetUp memory)\n    {\n        return INOStorage.layout().setUp;\n    }\n\n    /// @inheritdoc IINOReadable\n    function mintedInPhase(\n        string calldata phaseId\n    ) public view override returns (uint256) {\n        return INOStorage.layout().mintedInPhase[phaseId];\n    }\n\n    /// @inheritdoc IINOReadable\n    function nftCollection() public view override returns (address) {\n        return INOStorage.layout().collection;\n    }\n\n    function nftCollectionData()\n        public\n        view\n        override\n        returns (INOStorage.NFTCollectionData memory)\n    {\n        return INOStorage.layout().nftData;\n    }\n\n    /// @inheritdoc IINOReadable\n    function totalMinted() public view override returns (uint256) {\n        return INOStorage.layout().totalMinted;\n    }\n}\n'}, 'src/ino/writable/IINOWritable.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.23;\n\n// import struct\nimport {BuyPermission} from ""../../common/SaleStruct.sol"";\nimport {UserAllocationFee} from ""../../common/UserAllocationStruct.sol"";\nimport {FreeAllocation} from ""../INOStruct.sol"";\n\n/**\n * @title IINOWritable\n * @notice Defines external and public functions for {INOWritable}.\n */\ninterface IINOWritable {\n    /**\n     * @notice Buy and mint NFTs with ERC20 tokens. If {SaleStorage.SetUp.paymentToken} is not set,\n     *         this function will revert and tell the user to use {buyAndMintWithNative} instead.\n     *\n     * @param spendNow Amount of ERC20 tokens to spend now.\n     * @param allocation Allocation data of an `acount`.\n     * @param proof Merkle tree proof of an `acount`\'s allocation.\n     * @param permission Permission data of an `acount`.\n     */\n    function buyAndMintWithERC20(\n        uint256 spendNow,\n        UserAllocationFee calldata allocation,\n        bytes32[] calldata proof,\n        BuyPermission calldata permission\n    ) external;\n\n    /**\n     * @notice Buy and mint NFTs with blockchain\'s native currency (ETH, BNB, MATIC, etc...). If\n     *         {SaleStorage.SetUp.paymentToken} is set, this function will revert and tell the user to use\n     *         {buyAndMintWithERC20} instead.\n     *\n     * @param allocation Allocation data of an `acount`.\n     * @param proof Merkle tree proof of an `acount`\'s allocation.\n     */\n    function buyAndMintWithNative(\n        UserAllocationFee calldata allocation,\n        bytes32[] calldata proof\n    ) external payable;\n\n    /**\n     * @notice Allows whitelisted addresses to mint NFTs for free/giveaways.\n     *\n     * @param allocation Allocation data of an `acount`.\n     * @param proof Merkle tree proof of an `acount`\'s allocation.\n     */\n    function freeMint(\n        FreeAllocation calldata allocation,\n        bytes32[] calldata proof\n    ) external;\n}\n'}, 'src/ino/nft/interfaces/INFT.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.23;\n\nimport {INOStorage} from ""../../INOStorage.sol"";\n\n/**\n * @title INFT\n * @notice Define external and public functions used by NFTs listed in INOs.\n */\ninterface INFT {\n    /// @dev Removes default royalty information.\n    function deleteDefaultRoyalty() external;\n\n    /**\n     * @notice Initialize a clones NFT to sell & mint for an INO.\n     * @dev Need to be public as childs override it while calling {super.initialize()}.\n     *\n     * @param data The NFT collection data.\n     * @param initialOwner The initial owner of the NFT collection.\n     * @param ino_ The linked INO contract address.\n     */\n    function initialize(\n        INOStorage.NFTCollectionData calldata data,\n        address initialOwner,\n        address ino_\n    ) external;\n\n    /**\n     * @notice Mint tokens, restricted to the INO contract.\n     *\n     * @dev    If the implementing token uses _safeMint(), or a feeRecipient with a malicious receive()\n     *         hook is specified, the token or fee recipients may be able to execute another mint in the\n     *         same transaction via a separate INO contract.\n     *         This is dangerous if an implementing token does not correctly update the minterNumMinted\n     *         and currentTotalSupply values before transferring minted tokens, as INO references these\n     *         values to enforce token limits on a per-wallet and per-stage basis.\n     *\n     *         ERC721A tracks these values automatically, but this note and nonReentrant modifier are left\n     *         here to encourage best-practices when referencing this contract.\n     *\n     * @param minter The address to mint to.\n     * @param quantity The number of tokens to mint.\n     */\n    function mint(address minter, uint256 quantity) external;\n\n    /**\n     * @notice Mint all unsold NFTs to `receiver`.\n     */\n    function postmintAllUnsold(address receiver) external;\n\n    /// @notice Mints `toMint` to `receiver` and reduces the max supply if does not mint all left.\n    function postmintAndReduceSupply(\n        address receiver,\n        uint256 toMint\n    ) external returns (uint256 reducedBy);\n\n    /**\n     * @notice Allow NFT collection owner to mint NFTs to his wallet BEFORE the INO starts. Mostly used to\n     *         reward the team behind the project. Can also be used if airdrops/giveaway are introduced\n     *         after the INO contract has been deployed.\n     * @dev Can not be called even if INO is paused.\n     */\n    function premint(address receiver, uint256 amount) external;\n\n    /**\n     * @notice BE CAREFUL: once max supply is reduced it can never be increased again.\n     * @dev Can only reduce the max supply between `totalSupply()` and `maxSupply()`.\n     */\n    function reduceSupplyTo(uint256 newMaxSupply) external;\n\n    /// @dev Resets royalty information for the token id back to the global default.\n    function resetTokenRoyalty(uint256 tokenId) external;\n\n    /**\n     * @dev Sets the royalty information that all ids in this contract will default to.\n     *\n     * @param receiver Address receiving royalties.\n     * @param feeNumerator Royalties in basis points.\n     */\n    function setDefaultRoyalty(address receiver, uint96 feeNumerator) external;\n\n    function setTokenRoyalty(\n        uint256 tokenId,\n        address receiver,\n        uint96 feeNumerator\n    ) external;\n\n    /**\n     * @notice Returns a set of mint stats for the address.\n     *\n     * @dev NOTE: Implementing contracts should always update these numbers before transferring any tokens\n     *            with _safeMint() to mitigate consequences of malicious onERC721Received() hooks.\n     *\n     * @param minter The minter address.\n     *\n     * @return minterNumMinted The number of tokens minted by `minter`.\n     * @return currentTotalSupply The current total supply of NFT.\n     * @return maxSupply The maximum supply of NFT.\n     */\n    function getMintStats(\n        address minter\n    )\n        external\n        view\n        returns (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        );\n}\n'}, 'src/ino/writable/INOWritableInternal.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.23;\n\nimport {MerkleProof} from ""openzeppelin-contracts/utils/cryptography/MerkleProof.sol"";\n\nimport {SaleWritableInternal} from ""../../common/writable/SaleWritableInternal.sol"";\nimport {IINOWritable} from ""./IINOWritable.sol"";\nimport {IINOWritableInternal} from ""./IINOWritableInternal.sol"";\nimport {INFT} from ""../nft/interfaces/INFT.sol"";\n\nimport {SaleStorage} from ""../../common/SaleStorage.sol"";\nimport {INOStorage} from ""../INOStorage.sol"";\n\n// import struct\nimport {Phase} from ""../../common/SaleStruct.sol"";\nimport {FreeAllocation} from ""../INOStruct.sol"";\nimport {UserAllocationFee} from ""../../common/UserAllocationStruct.sol"";\n\n/**\n * @title INO\n * @notice Initial NFT Offering contract.\n * @notice Defines internal functions for `INOWritable`.\n */\ncontract INOWritableInternal is\n    SaleWritableInternal, // 4 inherited components\n    IINOWritableInternal // 1 inherited component\n{\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n    //////////////////////////////////////// PARAMS CHECKS ////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n    function _checkBuyAndMintParams(\n        uint256 toMint,\n        uint256 reserveNow,\n        UserAllocationFee calldata allocation,\n        uint256 summedMaxPhaseCap,\n        uint256 maxPhaseCap,\n        bytes32[] calldata proof\n    ) internal {\n        _checkMaxMintInPhase(allocation.usrData.base.phaseId, toMint);\n        _checkMaxMintWholeINO(toMint);\n\n        _checkBuyReserveParams(\n            reserveNow,\n            allocation,\n            allocation.usrData.base.phaseId,\n            summedMaxPhaseCap,\n            maxPhaseCap,\n            proof\n        );\n    }\n\n    function _checkFreeMintParams(\n        FreeAllocation calldata allocation,\n        bytes32[] calldata proof\n    ) internal {\n        _checkMaxMintInPhase(allocation.phaseId, allocation.toMint);\n        _checkMaxMintWholeINO(allocation.toMint);\n\n        // both replace {_checkBuyReserveParams} call\n        _requireOpenedSaleAndPhase(allocation.phaseId);\n        _checkValidFreeAllocation(allocation, proof);\n    }\n\n    function _checkMaxMintInPhase(\n        string calldata phaseId,\n        uint256 toMint\n    ) internal view {\n        uint256 maxMintInPhase = INOStorage.layout().phaseMaxMint[phaseId];\n\n        uint256 mintedInPhase = INOStorage.layout().mintedInPhase[phaseId];\n        uint256 newTotal = mintedInPhase + toMint;\n\n        if (newTotal > maxMintInPhase) {\n            revert INO_MaxMintInPhaseReached(\n                maxMintInPhase,\n                newTotal - maxMintInPhase\n            );\n        }\n    }\n\n    function _checkMaxMintWholeINO(uint256 toMint) internal view {\n        uint256 maxMint = INOStorage.layout().nftData.maxCap;\n        uint256 minted = INOStorage.layout().totalMinted;\n        uint256 newTotal = minted + toMint;\n\n        if (newTotal > maxMint) {\n            revert INO_MaxMintINOReached(maxMint, newTotal - maxMint);\n        }\n    }\n\n    /// @dev Different params from `SaleWritableInternal._requireValidAllocation` BUT same logic\n    function _checkValidFreeAllocation(\n        FreeAllocation calldata allocation,\n        bytes32[] calldata proof\n    ) internal view returns (bool) {\n        if (\n            !MerkleProof.verify(\n                proof,\n                SaleStorage\n                    .layout()\n                    .phases\n                    .data[allocation.phaseId]\n                    .merkleRoot,\n                keccak256(abi.encode(address(this), block.chainid, allocation))\n            )\n        ) revert SaleWritableInternal_AllocationNotFound();\n\n        return true;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n    /////////////////////////////////////// STORAGE UPDATE ///////////////////////////////////////\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n    function _mintAndUpdateStorage(\n        uint256 spendNow,\n        UserAllocationFee calldata allocation,\n        bytes32[] calldata proof,\n        uint256 summedMaxPhaseCap\n    ) internal {\n        string calldata phaseId = allocation.usrData.base.phaseId;\n        uint256 unitPrice = allocation.usrData.base.saleTokenPerPaymentToken;\n        /**\n         * @custom:audit When backend creates the allocation, `maxAllocation` will be a multiple of\n         *               `saleTokenPerPaymentToken` to avoid round down issue. In any case,\n         *               the most important is that `spendNow` is a multiple of `saleTokenPerPaymentToken`.\n         */\n        uint256 maxAllocation = allocation.usrData.base.maxAllocation;\n        /// @dev save the allocation of the user wallet (not the delegate wallet)\n        uint256 bought = SaleStorage.layout().ledger.allocationReservedByIn[\n            allocation.usrData.account\n        ][phaseId];\n\n        /**\n         * @dev Solidity round down towards zero:\n         *               - CAN NOT over-mint due to round up issue\n         *               - CAN under-mint due to round down issue\n         *\n         * e.g.:\n         * - maxAllocation = 100 ether\n         * - saleTokenPerPaymentToken = 3 ether\n         * user will mint 33 NFTs max, instead of 33.3333333333 NFTs.\n         *\n         * @dev To avoid under-mint issue, only allow a round down to happen if this transaction is the last one to mint all NFTs\n         *      left allocated to the user in this phase.\n         */\n        // if not the last mint\n        if (bought + spendNow != maxAllocation) {\n            if (spendNow % unitPrice != 0) {\n                revert INO_OnlyUseMultipleOf(unitPrice);\n            }\n        }\n\n        uint256 toMint = spendNow / unitPrice;\n\n        _checkBuyAndMintParams(\n            toMint,\n            spendNow,\n            allocation,\n            summedMaxPhaseCap,\n            SaleStorage.layout().phases.data[phaseId].maxPhaseCap,\n            proof\n        );\n        _updateStorageOnBuy( /// @custom:audit CEI pattern\n            spendNow,\n            phaseId,\n            allocation.usrData.account,\n            SaleStorage.layout().phases.data[phaseId].maxPhaseCap,\n            toMint\n        );\n\n        // allow a delegate wallet to mint on behalf of the user\n        INFT(INOStorage.layout().collection).mint(\n            allocation.usrData.account,\n            toMint\n        );\n    }\n\n    function _updateMintedAmount(\n        string calldata phaseId,\n        uint256 toMint\n    ) internal {\n        INOStorage.layout().mintedInPhase[phaseId] += toMint;\n        INOStorage.layout().totalMinted += toMint;\n    }\n\n    /// @custom:audit when total raised reached, it will close the phase and/or the whole sale\n    function _updateStorageOnBuy(\n        uint256 toSpend,\n        string calldata phaseId,\n        address buyer,\n        uint256 maxMintPhaseCap,\n        uint256 toMint\n    ) internal {\n        SaleWritableInternal._updateStorageOnBuy(\n            toSpend,\n            phaseId,\n            buyer,\n            maxMintPhaseCap\n        );\n        _updateMintedAmount(phaseId, toMint);\n    }\n\n    function _updateStorageOnFreeMint(\n        string calldata phaseId,\n        address buyer,\n        uint256 toMint\n    ) internal {\n        SaleStorage.Ledger storage ledger = SaleStorage.layout().ledger;\n        uint256 freeAllocationMintedBy = ledger.freeAllocationMintedBy[buyer][\n            phaseId\n        ];\n\n        // avoids replay attack & whole allocation minted in one tx in {freeMint}\n        if (freeAllocationMintedBy > 0) {\n            revert SaleWritable_AllocationExceeded(toMint, toMint);\n        }\n\n        ledger.freeAllocationMintedBy[buyer][phaseId] += toMint;\n    }\n}\n'}, 'src/ino/writable/restricted/INORestricted.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.23;\n\nimport {Clones} from ""openzeppelin-contracts/proxy/Clones.sol"";\n\nimport {INFT} from ""../../nft/interfaces/INFT.sol"";\nimport {IINORestricted} from ""./IINORestricted.sol"";\nimport {IINORestrictedInternal} from ""./IINORestrictedInternal.sol"";\n\nimport {RestrictedWritable} from ""../../../common/writable/restricted/RestrictedWritable.sol"";\n\n// import struct\nimport {Status, Phase} from ""../../../common/SaleStruct.sol"";\nimport {INOPhase} from ""../../INOStruct.sol"";\n\n// storage\nimport {INOStorage} from ""../../INOStorage.sol"";\nimport {SaleStorage} from ""../../../common/SaleStorage.sol"";\n\n/**\n * @title IRestrictedWritable\n * @notice Only the owner of the contract can call these methods.\n */\ncontract INORestricted is\n    IINORestricted,\n    IINORestrictedInternal,\n    RestrictedWritable\n{\n    /// @inheritdoc IINORestricted\n    function initialize(\n        SaleStorage.SetUp calldata saleSetUp,\n        address owner,\n        INOStorage.SetUp calldata inoSetUp,\n        string[] calldata phaseIds,\n        INOPhase[] calldata phases\n    ) external override initializer {\n        if (inoSetUp.paymentReceiver == address(0)) {\n            revert INORestricted_Init_PaymentReceiverIsZeroAddr();\n        }\n        if (inoSetUp.projectWallet == address(0)) {\n            revert INORestricted_Init_ProjectWalletIsZeroAddr();\n        }\n\n        // inherited from {RestrictedWritable.}\n        _initializeSale(saleSetUp);\n        _setOwnerRights(owner);\n\n        INOStorage.layout().setUp = inoSetUp;\n\n        // inherited from {RestrictedWritable.}\n        _updateSetINOPhases(phaseIds, phases);\n\n        emit INO_Initialized(saleSetUp, owner, inoSetUp, phaseIds, phases);\n    }\n\n    /// @inheritdoc IINORestricted\n    function deployNftToSell(\n        address nftToClone,\n        INOStorage.NFTCollectionData calldata data\n    )\n        external\n        override\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        reinitializer(2)\n        returns (address collection)\n    {\n        _requireSaleNotStarted();\n        _checkValidClone(nftToClone);\n        _checkNFTData(data);\n\n        collection = _clone(nftToClone, data);\n\n        INOStorage.layout().nftData = data;\n        INOStorage.layout().collection = collection;\n\n        INFT(collection).initialize(data, _msgSender(), address(this));\n\n        emit INO_DeployedNftToSell(collection, data);\n    }\n\n    function updatePhaseMaxMintAndMerkleRoot(\n        string calldata phaseId,\n        uint256 phaseMaxMint,\n        bytes32 merkleRoot\n    ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n        /// @custom:audit verifies underneath the phase is not completed\n        updatePhaseMerkleRoot(phaseId, merkleRoot);\n\n        emit INO_PhaseMaxMintUpdated(\n            phaseId,\n            INOStorage.layout().phaseMaxMint[phaseId],\n            phaseMaxMint\n        );\n\n        INOStorage.layout().phaseMaxMint[phaseId] = phaseMaxMint;\n    }\n\n    /// @inheritdoc IINORestricted\n    function updateSetPhase(\n        string calldata phaseId_,\n        INOPhase calldata phase_\n    ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n        _isSaleNot(Status.COMPLETED);\n\n        emit INO_SinglePhaseUpdate(\n            phaseId_,\n            SaleStorage.layout().phases.data[phaseId_],\n            phase_\n        );\n\n        _updateSetINOPhase(phaseId_, phase_);\n    } // TODO: gas report + testnet txs\n\n    /// @inheritdoc IINORestricted\n    function updateSetPhases(\n        string[] calldata phaseIdentifiers_,\n        INOPhase[] calldata phases_\n    ) public override onlyRole(DEFAULT_ADMIN_ROLE) {\n        _isSaleNot(Status.COMPLETED);\n\n        // inherited from {RestrictedWritable}\n        _updateSetINOPhases(phaseIdentifiers_, phases_);\n\n        emit INO_BatchPhaseUpdate(phaseIdentifiers_, phases_);\n    }\n\n    function _clone(\n        address nftToClone,\n        INOStorage.NFTCollectionData calldata data\n    ) internal returns (address) {\n        bytes32 salt = keccak256(\n            abi.encode(msg.sender, data, block.timestamp)\n        );\n        return Clones.cloneDeterministic(nftToClone, salt);\n    }\n\n    function _updateSetINOPhase(\n        string calldata phaseId_,\n        INOPhase calldata phase_\n    ) internal {\n        // inherited from {RestrictedWritable}\n        _setPhase(\n            SaleStorage.layout().ledger.summedMaxPhaseCap,\n            SaleStorage.layout().phases.data[phaseId_].maxPhaseCap,\n            phase_.base,\n            phaseId_\n        );\n\n        INOStorage.layout().phaseMaxMint[phaseId_] = phase_.phaseMaxMint;\n    }\n\n    function _updateSetINOPhases(\n        string[] calldata phaseIdentifiers_,\n        INOPhase[] calldata phases_\n    ) internal {\n        if (phaseIdentifiers_.length != phases_.length) {\n            revert RestrictedWritableInternal_DifferentArraysLength();\n        }\n\n        uint256 length = phaseIdentifiers_.length;\n\n        //slither-disable-next-line uninitialized-local\n        for (uint256 i; i < length; ++i) {\n            /// @dev less¬ gas efficient, but more readable\n            _updateSetINOPhase(phaseIdentifiers_[i], phases_[i]);\n        }\n    }\n\n    function _requireSaleNotStarted() internal view {\n        Status current = SaleStorage.layout().ledger.status;\n        if (current != Status.NOT_STARTED) {\n            revert INORestricted_SaleStarted(current);\n        }\n    }\n\n    /// @dev Check name, symbol, and max cap of the NFT collection.\n    function _checkNFTData(\n        INOStorage.NFTCollectionData calldata data\n    ) internal pure {\n        if (bytes(data.name).length < 2) {\n            revert INORestricted_Deploy_Name2CharsMin();\n        }\n        if (bytes(data.symbol).length < 1) {\n            revert INORestricted_Deploy_Symbole1CharMin();\n        }\n        if (data.maxCap == 0) {\n            revert INORestricted_Deploy_MaxCapNotSet();\n        }\n    }\n\n    function _checkValidClone(address clone) internal pure {\n        if (clone == address(0)) {\n            revert INORestricted_Deploy_NftToCloneIsZeroAddr();\n        }\n    }\n}\n'}, 'src/common/SaleStorage.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.23;\n\n// import struct\nimport {Status, Phase} from ""./SaleStruct.sol"";\n\n/**\n * @author https://github.com/Theo6890\n * @title SaleStorage\n * @notice Mapps the storage layout of the {Sale} contract.\n * @dev Diamond proxy (ERC-2535) storage style.\n */\nlibrary SaleStorage {\n    /**\n     * @notice Struct reprensenting the main setup of the Sale.\n     *\n     * @param paymentToken Address of the default token used to reserve allocation through the Sale.\n     *                     If `address(0)`, it means native token of the chain (ETH, BNB, etc...).\n     * @param permit2 Official address of the {Permit2} library deployed by Uniswap.\n     */\n    struct SetUp {\n        address paymentToken;\n        address permit2;\n    }\n\n    /**\n     * @notice Struct reprensenting the setup of each phase of the Sale.\n     * @dev Status of the phase is the only value that can be updated by Sale contract itself due to user\'s\n     *      interactions with the contract.\n     *\n     * @param ids List of all phases identifiers.\n     * @param data Mapping of data of each phases.\n     */\n    struct Phases {\n        string[] ids;\n        mapping(string => Phase) data;\n    }\n\n    /**\n     * @notice Struct reprensenting data of the Sale which are always updated by user\'s interactions with\n     *         the Sale contract.\n     *\n     * @param status Enum representing the current status of the Sale.\n     * @param summedMaxPhaseCap Sum of maximum cap of each phase expressed in {SetUp.paymentToken}.\n     * @param totalRaised Total amount of paymentToken raised for this Sale,\n     *                    expressed in {SetUp.paymentToken}.\n     * @param raisedInPhase Amount of paymentToken raised for each phase, expressed in {SetUp.paymentToken}.\n     * @param allocationReservedByIn Amount of paymentToken paid by phase by each user,\n     *                               expressed in {SetUp.paymentToken}.\n     */\n    struct Ledger {\n        Status status;\n        uint256 summedMaxPhaseCap;\n        uint256 totalRaised;\n        mapping(string => uint256) raisedInPhase;\n        mapping(address => mapping(string => uint256)) allocationReservedByIn;\n        mapping(address => mapping(string => uint256)) freeAllocationMintedBy;\n    }\n\n    /**\n     * @notice Struct reprensenting the whole storage layout of the Sale contract.\n     *\n     * @param setUp reprensenting the main setup of the Sale.\n     * @param phases reprensenting the setup of each phase of the Sale.\n     * @param ledger reprensenting data of the Sale which are always updated by user\'s interactions with\n     *        the Sale contract.\n     */\n    struct SaleStruct {\n        SetUp setUp;\n        Phases phases;\n        Ledger ledger;\n    }\n\n    /// @notice Storage position of {SaleStruct} in {Sale} contract.\n    bytes32 public constant Sale_STORAGE = keccak256(""common.storage"");\n\n    /**\n     * @return igoStruct Whole storage of {Sale} contract.\n     */\n    function layout() internal pure returns (SaleStruct storage igoStruct) {\n        bytes32 position = Sale_STORAGE;\n        assembly {\n            igoStruct.slot := position\n        }\n    }\n}\n'}, 'src/ino/INOStorage.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.23;\n\n/**\n * @title INOStorage\n * @notice Mapps the storage layout of the {INO} contract.\n * @dev Diamond proxy (ERC-2535) storage style.\n */\nlibrary INOStorage {\n    /**\n     * @notice Struct reprensenting the main setup of the INO.\n     *\n     * @param paymentReceiver The address which will receive the funds from the INO.\n     * @param projectWallet The address of the project issuing NFTs - transfer ownership once sale closed.\n     */\n    struct SetUp {\n        address paymentReceiver;\n        address projectWallet;\n    }\n\n    /**\n     * @notice Struct reprensenting the data of the NFT collection to be deployed through INO.\n     *\n     * @param name The name of the NFTs to be minted during the INO.\n     * @param symbol The symbol of the NFTs to be minted during the INO.\n     * @param uri The base URI of the NFTs to be minted during the INO - only used for reveal on minint,\n     *        otherwise the uri will be an empty string (blackbox and reveal date cases).\n     * @param maxCap The maximum number of NFTs to be minted during and after (if not sold out) the INO.\n     * @param startTokenId The first token id to be minted during the INO.\n     */\n    struct NFTCollectionData {\n        string name;\n        string symbol;\n        string uri;\n        uint256 maxCap;\n        uint256 startTokenId;\n    }\n\n    /**\n     * @notice Struct reprensenting the whole storage layout of the INO contract.\n     *\n     * @param setUp Struct reprensenting the main setup of the INO - modified by owner interactions only.\n     * @param nftData Struct reprensenting the data of the NFT collection to be deployed through INO\n     *                - modified by owner interactions only.\n     * @param collection The address of the NFT collection to be deployed and minted through INO - modified\n     *                   by owner interactions only.\n     * @param phaseMaxMint Maximum number of NFTs to be minted in a specific phase - modified by owner\n     *                     interactions only.\n     * @param mintedInPhase Number of NFTs minted in a specific phase - modified by INO contract\n     *                      interaction.\n     * @param totalMinted Total number of NFTs minted in the whole INO - modified by INO contract\n     *                    interaction.\n     */\n    struct INOStruct {\n        // modified by owner interactions only\n        SetUp setUp;\n        NFTCollectionData nftData;\n        address collection;\n        mapping(string => uint256) phaseMaxMint;\n        // modified by INO contract interaction\n        mapping(string => uint256) mintedInPhase;\n        uint256 totalMinted;\n    }\n\n    /// @notice Storage position of {INOStruct} in {INO} contract.\n    bytes32 public constant INO_STORAGE = keccak256(""ino.storage"");\n\n    /**\n     * @return inoStruct Whole storage of {INO} contract.\n     */\n    function layout() internal pure returns (INOStruct storage inoStruct) {\n        bytes32 position = INO_STORAGE;\n        assembly {\n            inoStruct.slot := position\n        }\n    }\n}\n'}, 'src/common/SaleStruct.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.23;\n\n/**\n * @notice Shared enum representing the different status of a phase or the whole IGO.\n *\n * @custom:value NOT_STARTED IGO/Phase created but not started; allocations/buyAndMint are allowed.\n * @custom:value OPENED IGO/Phase started according to start date; allocations/buyAndMint are allowed.\n * @custom:value COMPLETED IGO/Phase everything has been sold or time has been elapsed;\n *               allocations/buyAndMint can\'t be reserved anymore.\n * @custom:value PAUSED IGO/Phase has been paused by the owner; allocations/buyAndMint can\'t be\n *               reserved until further notice.\n */\nenum Status {\n    NOT_STARTED,\n    OPENED,\n    COMPLETED,\n    PAUSED\n}\n\n/**\n * @notice Struct representing an allocation of a wallet for a specific phase of a sale.\n *\n * @param phaseId Phase identifier of the in the current sale, e.g. ""vpr-social-task"",\n *        ""sale-public-phase-1"", ""ino-public"" etc...\n * @param maxAllocation Maximum amount to spend in {SaleStorage.SetUp.paymentToken}.\n * @param saleTokenPerPaymentToken Price per token/nft of the project behind the Sale, expressed in\n *        {SaleStorage.SetUp.paymentToken}.\n */\nstruct Allocation {\n    string phaseId;\n    uint256 maxAllocation;\n    uint256 saleTokenPerPaymentToken;\n}\n\n/**\n * @notice Struct representing a buy permission signed by `msg.sender` for\n *         {SaleWritable.reserveAllocation} function to use with {Permit2} library.\n *\n * @dev Compulsory to interact with {Permit2.permitTransferFrom} in\n *      {SaleWritableInternal._reserveAllocation}.\n *\n * @param signature {Permit2} signature to transfer tokens from the buyer to {SaleVesting}.\n * @param deadline Seadline on the permit signature.\n * @param nonce Unique value for every token owner\'s signature to prevent signature replays.\n */\nstruct BuyPermission {\n    bytes signature;\n    uint256 deadline;\n    uint256 nonce;\n}\n\n/**\n * @notice Shared struct representing the data of a phase.\n *\n * @param status Enum representing the current status of the phase.\n * @param merkleRoot Merkle root of the merkle tree containing whitelisted data.\n * @param startAt Timestamp at which the phase will be opened to reserve allocation.\n * @param endAt Timestamp at which the phase will not accept allocation reservation anymore.\n * @param maxPhaseCap Maximum amount of {SaleStorage.SetUp.paymentToken} for this phase.\n */\nstruct Phase {\n    Status status;\n    // contains wallet and allocation per wallet\n    bytes32 merkleRoot;\n    uint128 startAt;\n    uint128 endAt;\n    uint256 maxPhaseCap;\n}\n'}, 'src/ino/INOStruct.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.23;\n\nimport {Phase} from ""../common/SaleStruct.sol"";\n\n/**\n * @notice Struct representing a free allocation and user based for a specific phase of a sale.\n *         Whitelisted addresses will mint NFTs for free.\n *\n * @param phaseId Phase identifier of the current sale.\n * @param toMint Amount of NFT to be minted.\n * @param account Wallet address of the buyer.\n */\nstruct FreeAllocation {\n    string phaseId;\n    uint256 toMint;\n    address account;\n}\n\n/**\n * @notice Struct representing a phase of an INO sale.\n *\n * @param base Phase struct from {SaleStruct} shared with IGO sales.\n * @param phaseMaxMint Maximum amount of NFTs that can be minted in this phase.\n */\nstruct INOPhase {\n    Phase base;\n    uint256 phaseMaxMint;\n}\n'}, 'src/common/UserAllocationStruct.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.23;\n\nimport {Allocation} from ""../common/SaleStruct.sol"";\n\n/**\n * @notice Struct representing a user based allocation for a specific phase of a sale.\n *\n * @dev Backend is in charge of generating an allocation, which will depends on the sale type:\n *      - IGO: allocation based on the tier from which wallet is part of,\n *      - VPR IGO: off-chain backend lottery + allocation based on off-chain actions, e.g.\n *          * social task: +50% from base price,\n *          * in-game tasks: +33% from base price,\n *          * etc...\n *      - INO: allocation based on SFUND/SFNTS staked-farmed.\n *\n * @param base User based allocation data.\n * @param account Wallet address of the buyer.\n */\nstruct UserAllocation {\n    Allocation base;\n    address account;\n}\n\n/**\n * @notice Struct representing a user based allocation with a refund fee.\n *\n * @param usrData User based allocation data.\n * @param refundFee Fee to be paid by the buyer in case of refund, expressed in\n *        {SaleStorage.SetUp.paymentToken} - decimals defined in {IGOVesting.decimals}.\n */\nstruct UserAllocationFee {\n    UserAllocation usrData;\n    uint256 refundFee;\n}\n'}, 'src/common/readable/SaleReadable.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.23;\n\nimport {ISaleReadable} from ""../readable/ISaleReadable.sol"";\nimport {IRestrictedWritableInternal} from ""../writable/restricted/IRestrictedWritableInternal.sol"";\nimport {ISaleWritableInternal} from ""../writable/ISaleWritableInternal.sol"";\n\nimport {SaleStorage} from ""../SaleStorage.sol"";\n\n// import struct\nimport {Status, Phase} from ""../SaleStruct.sol"";\n\n/**\n * @title SaleReadable\n * @notice Read-only contract of {Sale} data.\n */\ncontract SaleReadable is\n    ISaleReadable, // 1 inherited component\n    ISaleWritableInternal, // 1 inherited component\n    IRestrictedWritableInternal // 1 inherited component\n{\n    /// @inheritdoc ISaleReadable\n    function freeAllocationMintedBy(\n        address account,\n        string calldata phaseId\n    ) external view override returns (uint256) {\n        return\n            SaleStorage.layout().ledger.freeAllocationMintedBy[account][\n                phaseId\n            ];\n    }\n\n    /// @inheritdoc ISaleReadable\n    function summedMaxPhaseCap() external view override returns (uint256) {\n        return SaleStorage.layout().ledger.summedMaxPhaseCap;\n    }\n\n    /// @inheritdoc ISaleReadable\n    function allocationReservedByIn(\n        address account,\n        string calldata phaseId\n    ) external view override returns (uint256) {\n        return\n            SaleStorage.layout().ledger.allocationReservedByIn[account][\n                phaseId\n            ];\n    }\n\n    /// @inheritdoc ISaleReadable\n    function phase(\n        string memory phaseId\n    ) external view override returns (Phase memory phase_) {\n        phase_ = SaleStorage.layout().phases.data[phaseId];\n    }\n\n    /// @inheritdoc ISaleReadable\n    function phaseIds()\n        external\n        view\n        override\n        returns (string[] memory phaseIds_)\n    {\n        phaseIds_ = SaleStorage.layout().phases.ids;\n    }\n\n    /// @inheritdoc ISaleReadable\n    function raisedInPhase(\n        string memory phaseId\n    ) external view override returns (uint256) {\n        return SaleStorage.layout().ledger.raisedInPhase[phaseId];\n    }\n\n    /// @inheritdoc ISaleReadable\n    function saleStatus() external view override returns (Status) {\n        return SaleStorage.layout().ledger.status;\n    }\n\n    /// @inheritdoc ISaleReadable\n    function setUp()\n        external\n        view\n        override\n        returns (address paymentToken, address permit2)\n    {\n        SaleStorage.SetUp memory setUp_ = SaleStorage.layout().setUp;\n        paymentToken = setUp_.paymentToken;\n        permit2 = setUp_.permit2;\n    }\n\n    /// @inheritdoc ISaleReadable\n    function totalRaised() external view override returns (uint256) {\n        return SaleStorage.layout().ledger.totalRaised;\n    }\n}\n'}, 'src/ino/readable/IINOReadable.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.23;\n\nimport {INOStorage} from ""../INOStorage.sol"";\n\ninterface IINOReadable {\n    /**\n     * @param phaseId The ID of the phase to get the max mintable amount.\n     * @return phaseMaxMint The maximum amount of NFTs that can be minted in the phase.\n     */\n    function phaseMaxMint(\n        string calldata phaseId\n    ) external view returns (uint256);\n\n    /**\n     * @return \n            - `paymentReceiver` address of the wallet to receive the payments\n            - `projectWallet` address of the project which will receive\n              the NFT owner rights after the INO ends.\n     */\n    function inoSetUp() external view returns (INOStorage.SetUp memory);\n\n    /// @dev Amount of NFTs minted by users in a specific phase.\n    function mintedInPhase(\n        string calldata phaseId\n    ) external view returns (uint256);\n\n    /// @dev Address of the NFT collection contract to mint when buying.\n    function nftCollection() external view returns (address);\n\n    function nftCollectionData()\n        external\n        view\n        returns (INOStorage.NFTCollectionData memory);\n\n    /// @dev Amount of NFTs minted by users in the whole INO.\n    function totalMinted() external view returns (uint256);\n}\n'}, 'lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin\'s JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, ""MerkleProof: invalid multiproof"");\n\n        // The xxxPos values are ""pointers"" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s ""pop"".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the ""main queue"". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the ""main queue"" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, ""MerkleProof: invalid multiproof"");\n\n        // The xxxPos values are ""pointers"" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s ""pop"".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the ""main queue"". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the ""main queue"" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n'}, 'src/common/writable/SaleWritableInternal.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.23;\n\nimport {ISignatureTransfer} from ""permit2/interfaces/ISignatureTransfer.sol"";\nimport {MerkleProof} from ""openzeppelin-contracts/utils/cryptography/MerkleProof.sol"";\n\nimport {RestrictedWritableInternal} from ""./restricted/RestrictedWritableInternal.sol"";\nimport {ISaleWritableInternal} from ""./ISaleWritableInternal.sol"";\n\nimport {SaleStorage} from ""../SaleStorage.sol"";\n\n// struct import\nimport {Status, Phase, BuyPermission} from ""../SaleStruct.sol"";\nimport {UserAllocationFee} from ""../UserAllocationStruct.sol"";\n\n/**\n * @title SaleWritableInternal\n * @notice Defines internal functions for `SaleWritable`.\n */\ncontract SaleWritableInternal is\n    ISaleWritableInternal, // 1 inherited component\n    RestrictedWritableInternal // 2 inherited components\n{\n    function _checkBuyReserveParams(\n        uint256 reserveNow,\n        UserAllocationFee calldata allocation,\n        string calldata phaseId,\n        uint256 summedMaxPhaseCap,\n        uint256 maxPhaseCap,\n        bytes32[] calldata proof\n    ) internal {\n        _requireAllocationNotExceededInPhase(\n            reserveNow,\n            allocation.usrData.account,\n            allocation.usrData.base.maxAllocation,\n            phaseId\n        );\n        _requireSummedMaxPhaseCapNotExceeded(reserveNow, summedMaxPhaseCap);\n        _requireOpenedSaleAndPhase(allocation.usrData.base.phaseId);\n        _requirePhaseCapNotExceeded(phaseId, maxPhaseCap, reserveNow);\n        _requireValidAllocation(allocation, proof);\n    }\n\n    /**\n     * @notice Update storage of the Sale when an allocation is reserved on-chain: total raised, total raised\n     *      in phase, allocation reserved by buyer in phase, etc...\n     *\n     * @param amount Amount of tokens spent in this transaction, expressed in \n     *        {SaleStorage.SetUp.paymentToken}.\n     * @param phaseId Phase linked to current allocation used by buyer.\n     * @param buyer Wallet buying tokens.\n     * @param maxPhaseCap Maximum amount of tokens to be sold in this phase, expressed in \n              {SaleStorage.SetUp.paymentToken}.\n     */\n    function _updateStorageOnBuy(\n        uint256 amount,\n        string calldata phaseId,\n        address buyer,\n        uint256 maxPhaseCap\n    ) internal virtual {\n        SaleStorage.Ledger storage ledger = SaleStorage.layout().ledger;\n\n        // update raised amount\n        ledger.totalRaised += amount;\n        ledger.raisedInPhase[phaseId] += amount;\n        ledger.allocationReservedByIn[buyer][phaseId] += amount;\n        // close whole SALE if sold out\n        if (ledger.totalRaised == ledger.summedMaxPhaseCap) _closeSale();\n        // close PHASE if sold out\n        if (ledger.raisedInPhase[phaseId] == maxPhaseCap) {\n            _closePhase(phaseId);\n        }\n    }\n\n    /// @notice Verify phase is opened. If the sale has not been opened before the phase, open it.\n    function _requireOpenedSaleAndPhase(string memory phaseId) internal {\n        // manually close phase if maxPhaseCap is NOT reached - TEMPORARY solution\n        if (\n            block.timestamp >= SaleStorage.layout().phases.data[phaseId].endAt\n        ) {\n            revert(""Phase closed""); // string instead custom error as temporary solution\n        }\n\n        Phase memory phase = SaleStorage.layout().phases.data[phaseId];\n        Status saleStatus = SaleStorage.layout().ledger.status;\n\n        // open phase if necessary\n        if (\n            phase.status == Status.NOT_STARTED &&\n            block.timestamp >= phase.startAt &&\n            block.timestamp < phase.endAt\n        ) {\n            if (saleStatus == Status.NOT_STARTED) _openSale();\n            _openPhase(phaseId);\n            return;\n        }\n        // revert if phase can not be opened\n        if (phase.status != Status.OPENED) {\n            revert SaleWritableInternal_PhaseNotOpened(phaseId, phase.status);\n        }\n        // revert if sale can not be opened\n        if (saleStatus != Status.OPENED) {\n            revert SaleWritableInternal_SaleNotOpened(saleStatus);\n        }\n    }\n\n    /**\n     * @notice Ensure a wallet can not spend more than their allocation for the given phase.\n     *\n     * @param toSpend Amount of tokens to spend in this transaction, expressed in\n     *        {SaleStorage.SetUp.paymentToken}.\n     * @param buyer Wallet buying tokens.\n     * @param allocated Maximum amount of tokens this wallet can spend in this phase, expressed in\n     *        {SaleStorage.SetUp.paymentToken}.\n     */\n    function _requireAllocationNotExceededInPhase(\n        uint256 toSpend,\n        address buyer,\n        uint256 allocated,\n        string calldata phaseId\n    ) internal view {\n        uint256 totalAfterPurchase = toSpend +\n            SaleStorage.layout().ledger.allocationReservedByIn[buyer][phaseId];\n\n        // avoids replay attack\n        if (totalAfterPurchase > allocated) {\n            revert SaleWritable_AllocationExceeded(\n                allocated,\n                totalAfterPurchase - allocated\n            );\n        }\n    }\n\n    /**\n     * @notice Verify `summedMaxPhaseCap` will not be exceeded after purchase.\n     *\n     * @param toSpend Amount of tokens to spend in this transaction, expressed in\n     *        {SaleStorage.SetUp.paymentToken}.\n     * @param summedMaxPhaseCap Total amount of tokens to be sold in this Sale, expressed in\n     *        {SaleStorage.SetUp.paymentToken}.\n     */\n    function _requireSummedMaxPhaseCapNotExceeded(\n        uint256 toSpend,\n        uint256 summedMaxPhaseCap\n    ) internal view {\n        uint256 totalAfterPurchase = toSpend +\n            SaleStorage.layout().ledger.totalRaised;\n        if (totalAfterPurchase > summedMaxPhaseCap) {\n            revert SaleWritable_SummedMaxPhaseCapExceeded(\n                summedMaxPhaseCap,\n                // by how much`summedMaxPhaseCap` is exceeded\n                totalAfterPurchase - summedMaxPhaseCap\n            );\n        }\n    }\n\n    /**\n     * @notice Verify `maxPhaseCap` will not be exceeded after purchase.\n     *\n     * @param phaseId Phase linked to current allocation used by buyer.\n     * @param maxPhaseCap Maximum amount of tokens to be sold in this phase, expressed in\n     *        {SaleStorage.SetUp.paymentToken}.\n     * @param toSpend Amount of tokens to spend in this transaction, expressed in\n     *        {SaleStorage.SetUp.paymentToken}.\n     */\n    function _requirePhaseCapNotExceeded(\n        string calldata phaseId,\n        uint256 maxPhaseCap,\n        uint256 toSpend\n    ) internal view {\n        uint256 raisedAfterPurchase = toSpend +\n            SaleStorage.layout().ledger.raisedInPhase[phaseId];\n        if (raisedAfterPurchase > maxPhaseCap) {\n            revert SaleWritable_MaxPhaseCapExceeded(\n                phaseId,\n                maxPhaseCap,\n                // by how much `maxPhaseCap` is exceeded\n                raisedAfterPurchase - maxPhaseCap\n            );\n        }\n    }\n\n    /**\n     * @notice Verify allocation is valid.\n     *\n     * @param allocation Allocation to verify.\n     * @param proof Merkle proof of the allocation.\n     */\n    function _requireValidAllocation(\n        UserAllocationFee calldata allocation,\n        bytes32[] calldata proof\n    ) internal view {\n        if (\n            !MerkleProof.verify(\n                proof,\n                SaleStorage\n                    .layout()\n                    .phases\n                    .data[allocation.usrData.base.phaseId]\n                    .merkleRoot,\n                keccak256(abi.encode(address(this), block.chainid, allocation))\n            )\n        ) revert SaleWritableInternal_AllocationNotFound();\n    }\n\n    /**\n     * @notice ERC20 permit and transfer in one call.\n     * @param permit2 Address of the permit2 contract.\n     * @param from address to transfer tokens from.\n     * @param to address to transfer tokens to.\n     * @param token address of the token to transfer.\n     * @param amount amount of tokens to transfer.\n     * @param permission BuyPermission struct containing permit signature and deadline.\n     */\n    function _permit2ApproveAndTransfer(\n        address permit2,\n        address from,\n        address to,\n        address token,\n        uint256 amount,\n        BuyPermission calldata permission\n    ) internal {\n        /// @dev declare {Permit2.permitTransferFrom} parameters\n        ISignatureTransfer.TokenPermissions memory permitted;\n        ISignatureTransfer.PermitTransferFrom memory permit;\n        ISignatureTransfer.SignatureTransferDetails memory transferDetails;\n\n        /// @dev configure {Permit2.permitTransferFrom} parameters using IGO and allocation parameters\n        permitted = ISignatureTransfer.TokenPermissions({\n            token: token,\n            amount: amount\n        });\n        permit = ISignatureTransfer.PermitTransferFrom({\n            permitted: permitted,\n            nonce: permission.nonce,\n            deadline: permission.deadline\n        });\n        transferDetails = ISignatureTransfer.SignatureTransferDetails({\n            to: to,\n            requestedAmount: amount\n        });\n\n        /// @dev {Permit2} library call\n        ISignatureTransfer(permit2).permitTransferFrom(\n            permit,\n            transferDetails,\n            from,\n            permission.signature\n        );\n    }\n}\n'}, 'src/ino/writable/IINOWritableInternal.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.23;\n\n// import struct\nimport {Status} from ""../../common/SaleStruct.sol"";\n\n/**\n * @title IINOWritableInternal\n * @notice Defines enum, struct, event and errors for INO.\n */\ninterface IINOWritableInternal {\n    error INO_IncorrectNativeAmount(uint256 sent, uint256 price);\n    error INO_IncorrectERC20Amount(uint256 sent, uint256 price);\n    error INO_MaxMintINOReached(uint256 maxMint, uint256 exceedBy);\n    error INO_MaxMintInPhaseReached(uint256 maxMintInPhase, uint256 exceedBy);\n    error INO_NativePaymentFailed(bytes data);\n    error INO_OnlyUseMultipleOf(uint256 multiple);\n    error INO_UseInstead(string);\n}\n'}, 'lib/openzeppelin-contracts/contracts/proxy/Clones.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as ""clones"".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        require(instance != address(0), ""ERC1167: create failed"");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        require(instance != address(0), ""ERC1167: create2 failed"");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n'}, 'src/ino/writable/restricted/IINORestricted.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.23;\n\n// import struct\nimport {Phase} from ""../../../common/SaleStruct.sol"";\nimport {INOPhase} from ""../../INOStruct.sol"";\n\n// storage\nimport {INOStorage} from ""../../INOStorage.sol"";\nimport {SaleStorage} from ""../../../common/SaleStorage.sol"";\n\n/**\n * @title IINORestricted\n * @notice Only the owner of the contract can call these methods.\n */\ninterface IINORestricted {\n    /**\n     * @notice Some projects will only do the sale through INO and will handle the NFT minting themselves.\n     *         Others will do the mint and sale through INO. This function is used to deploy the NFT\n     *         collection for the second case.\n     * @dev Use {reinitializer(2)} as {initialize} is called first.\n     *\n     * @param nftToClone The address of the NFT to use as an NFT base.\n     * @param data Data of the NFT collection to be deployed.\n     */\n    function deployNftToSell(\n        address nftToClone,\n        INOStorage.NFTCollectionData calldata data\n    ) external returns (address collection);\n\n    /**\n     * @notice Use a single token for the whole INO (never changed once set here).\n     *\n     * @param saleSetUp Data of the sale to be deployed - common logic shared between IGOs and INOs.\n     * @param owner Owner of the INO.\n     * @param inoSetUp Data of the INO to be deployed.\n     * @param phaseIds Default list of phase identifiers - can be empty array `new string[](0)`\n     * @param phases Default list of phases - can be empty array `new INOPhase[](0)`\n     */\n    function initialize(\n        SaleStorage.SetUp calldata saleSetUp,\n        address owner,\n        INOStorage.SetUp calldata inoSetUp,\n        string[] calldata phaseIds,\n        INOPhase[] calldata phases\n    ) external;\n\n    /**\n     * @dev Update or create a phase with all its data.\n     *\n     * @param phaseId_ Identifier of phase to set or update.\n     * @param phase_ Struct {INOPhase} containing INO phase\'s data to be saved.\n     */\n    function updateSetPhase(\n        string calldata phaseId_,\n        INOPhase calldata phase_\n    ) external;\n\n    /**\n     * @dev Update or create multiple phases with all their data.\n     *\n     * @param phaseIdentifiers_ Array of identifiers of `phases`.\n     * @param phases_ Array of struct {INOPhase} containing phases\' data to be saved.\n     */\n    function updateSetPhases(\n        string[] calldata phaseIdentifiers_,\n        INOPhase[] calldata phases_\n    ) external;\n\n    function updatePhaseMaxMintAndMerkleRoot(\n        string calldata phaseId,\n        uint256 phaseMaxMint,\n        bytes32 merkleRoot\n    ) external;\n}\n'}, 'src/ino/writable/restricted/IINORestrictedInternal.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.23;\n\nimport {INOStorage} from ""../../INOStorage.sol"";\nimport {SaleStorage} from ""../../../common/SaleStorage.sol"";\n\n// import struct\nimport {Status, Phase} from ""../../../common/SaleStruct.sol"";\nimport {INOPhase} from ""../../INOStruct.sol"";\n\n/**\n * @title IINORestrictedInternal\n */\ninterface IINORestrictedInternal {\n    error INORestricted_Init_PaymentReceiverIsZeroAddr();\n    error INORestricted_Init_ProjectWalletIsZeroAddr();\n\n    error INORestricted_SaleStarted(Status current);\n    error INORestricted_Deploy_MaxCapNotSet();\n    error INORestricted_Deploy_Name2CharsMin();\n    error INORestricted_Deploy_NftToCloneIsZeroAddr();\n    // error INORestricted_Deploy_SaleAlreadyStarted();\n    error INORestricted_Deploy_Symbole1CharMin();\n\n    event INO_DeployedNftToSell(\n        address indexed collection,\n        INOStorage.NFTCollectionData indexed data\n    );\n    event INO_Initialized(\n        SaleStorage.SetUp indexed saleSetUp,\n        address indexed owner,\n        INOStorage.SetUp indexed igoSetUp,\n        string[] phaseIds_,\n        INOPhase[] phases\n    );\n    event INO_PhaseMaxMintUpdated(\n        string indexed phaseId,\n        uint256 indexed oldPhaseMaxMint,\n        uint256 indexed newPhaseMaxMint\n    );\n    event INO_SinglePhaseUpdate(\n        string indexed phaseId,\n        Phase indexed oldData,\n        INOPhase indexed newData\n    );\n    event INO_BatchPhaseUpdate(\n        string[] indexed phaseId,\n        INOPhase[] indexed phase\n    );\n}\n'}, 'src/common/writable/restricted/RestrictedWritable.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.23;\n\nimport {IERC20} from ""openzeppelin-contracts/token/ERC20/IERC20.sol"";\n\nimport {SafeERC20} from ""openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol"";\n\nimport {Initializable} from ""openzeppelin-contracts/proxy/utils/Initializable.sol"";\n\nimport {IRestrictedWritable} from ""./IRestrictedWritable.sol"";\n\nimport {IGOStorage} from ""../../../igo/IGOStorage.sol"";\nimport {SaleStorage} from ""../../SaleStorage.sol"";\n\nimport {RestrictedWritableInternal} from ""./RestrictedWritableInternal.sol"";\n\n// import struct\nimport {Status, Phase} from ""../../SaleStruct.sol"";\n\n/**\n * @title RestrictedWritable\n */\ncontract RestrictedWritable is\n    IRestrictedWritable, // 1 inherited component\n    RestrictedWritableInternal, // 2 inherited component\n    Initializable // 1 inherited component\n{\n    using SafeERC20 for IERC20;\n\n    /// @inheritdoc IRestrictedWritable\n    function closeSale() external override onlyRole(DEFAULT_ADMIN_ROLE) {\n        _closeSale();\n        emit SaleClosed();\n    }\n\n    function openSale() external override onlyRole(DEFAULT_ADMIN_ROLE) {\n        _isSale(Status.NOT_STARTED);\n        _openSale();\n\n        emit SaleOpened();\n    }\n\n    function pauseSale() external override onlyRole(DEFAULT_ADMIN_ROLE) {\n        _isSale(Status.OPENED);\n        SaleStorage.layout().ledger.status = Status.PAUSED;\n\n        emit SalePaused();\n    }\n\n    function resumeSale() external override onlyRole(DEFAULT_ADMIN_ROLE) {\n        _isSale(Status.PAUSED);\n        SaleStorage.layout().ledger.status = Status.OPENED;\n\n        emit SaleResumed();\n    }\n\n    /// @inheritdoc IRestrictedWritable\n    function recoverLostERC20(\n        address token,\n        address to\n    ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (token == address(0)) revert RestrictedWritable_TokenIsZeroAddr();\n        if (to == address(0)) revert RestrictedWritable_ReceiverIsZeroAddr();\n\n        uint256 amount = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(to, amount);\n\n        emit RecoveredLostERC20(token, to, amount);\n    }\n\n    function closePhases(\n        string[] calldata phaseIds\n    ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n        for (uint256 i = 0; i < phaseIds.length; i++) {\n            if (\n                block.timestamp >=\n                SaleStorage.layout().phases.data[phaseIds[i]].endAt\n            ) {\n                _closePhase(phaseIds[i]);\n            }\n        }\n    }\n\n    //////////////////////////// PHASE SINGLE UPDATE ////////////////////////////\n    /// @inheritdoc IRestrictedWritable\n    function openPhase(\n        string calldata phaseId\n    ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n        _isPhase(Status.NOT_STARTED, phaseId);\n        _openPhase(phaseId);\n\n        emit PhaseOpened(phaseId);\n    }\n\n    function pausePhase(\n        string calldata phaseId\n    ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n        _isPhase(Status.OPENED, phaseId);\n        SaleStorage.layout().phases.data[phaseId].status = Status.PAUSED;\n\n        emit PhasePaused(phaseId);\n    }\n\n    function resumePhase(\n        string calldata phaseId\n    ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n        _isPhase(Status.PAUSED, phaseId);\n        SaleStorage.layout().phases.data[phaseId].status = Status.OPENED;\n\n        emit PhaseResumed(phaseId);\n    }\n\n    function updatePhaseEndDate(\n        string calldata phaseId,\n        uint128 endAt\n    ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n        _isPhaseNot(Status.COMPLETED, phaseId);\n\n        if (endAt <= block.timestamp) {\n            revert RestrictedWritable_EndInPast();\n        }\n\n        if (endAt <= SaleStorage.layout().phases.data[phaseId].startAt) {\n            revert RestrictedWritable_EndBeforeStart();\n        }\n\n        emit PhaseEndDateUpdated(\n            phaseId,\n            SaleStorage.layout().phases.data[phaseId].endAt,\n            endAt\n        );\n\n        SaleStorage.layout().phases.data[phaseId].endAt = endAt;\n    }\n\n    /// @inheritdoc IRestrictedWritable\n    function updatePhaseMaxCapAndMerkleRoot(\n        string calldata phaseId,\n        uint256 maxPhaseCap,\n        bytes32 merkleRoot\n    ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n        /// @custom:audit verifies underneath the phase is not completed\n        updatePhaseMerkleRoot(phaseId, merkleRoot);\n\n        uint256 summedMaxPhaseCap = SaleStorage\n            .layout()\n            .ledger\n            .summedMaxPhaseCap;\n\n        summedMaxPhaseCap -= SaleStorage\n            .layout()\n            .phases\n            .data[phaseId]\n            .maxPhaseCap;\n        summedMaxPhaseCap += maxPhaseCap;\n\n        emit PhaseMaxCapUpdated(\n            phaseId,\n            SaleStorage.layout().phases.data[phaseId].maxPhaseCap,\n            maxPhaseCap\n        );\n        SaleStorage.layout().phases.data[phaseId].maxPhaseCap = maxPhaseCap;\n        SaleStorage.layout().ledger.summedMaxPhaseCap = summedMaxPhaseCap;\n    }\n\n    /// @inheritdoc IRestrictedWritable\n    function updatePhaseMerkleRoot(\n        string calldata phaseId,\n        bytes32 merkleRoot\n    ) public override onlyRole(DEFAULT_ADMIN_ROLE) {\n        _isPhaseNot(Status.COMPLETED, phaseId);\n        if (merkleRoot == bytes32(0)) {\n            revert RestrictedWritable_EmptyMerkleRoot();\n        }\n\n        emit PhaseMerkleRootUpdated(\n            phaseId,\n            SaleStorage.layout().phases.data[phaseId].merkleRoot,\n            merkleRoot\n        );\n        SaleStorage.layout().phases.data[phaseId].merkleRoot = merkleRoot;\n    }\n\n    /// @inheritdoc IRestrictedWritable\n    function updatePhaseStartDate(\n        string calldata phaseId,\n        uint128 startAt\n    ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n        _isPhase(Status.NOT_STARTED, phaseId);\n\n        if (startAt >= SaleStorage.layout().phases.data[phaseId].endAt) {\n            revert RestrictedWritable_StartAfterEnd();\n        }\n\n        emit PhaseStartDateUpdated(\n            phaseId,\n            SaleStorage.layout().phases.data[phaseId].startAt,\n            startAt\n        );\n\n        SaleStorage.layout().phases.data[phaseId].startAt = startAt;\n    }\n}\n'}, 'src/common/readable/ISaleReadable.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.23;\n\n// import struct\nimport {Status, Phase} from ""../SaleStruct.sol"";\n\n/**\n * @title ISaleReadable\n * @notice Interface made for read-only data from {Sale}.\n */\ninterface ISaleReadable {\n    /**\n     * @param account Address of the user.\n     * @param phaseId Identifier of the phase.\n     *\n     * @return amount Amount of paymentToken paid by phase by each user,\n     *                               expressed in {SetUp.paymentToken}.\n     */\n    function freeAllocationMintedBy(\n        address account,\n        string calldata phaseId\n    ) external view returns (uint256);\n\n    /**\n     * @return Total Sum of maximum cap of each phase, expressed in {SetUp.paymentToken}.\n     */\n    function summedMaxPhaseCap() external view returns (uint256);\n\n    /**\n     * @param account Address of the user.\n     * @param phaseId Identifier of the phase.\n     *\n     * @return Amount of {SaleStorage.SetUp.paymentToken} paid by `account` for the phase `phaseId`.\n     *         If `address(0)` is returned, it means native (ETH, BNB, MATCI, etc...).\n     */\n    function allocationReservedByIn(\n        address account,\n        string calldata phaseId\n    ) external view returns (uint256);\n\n    /**\n     * @param phaseId Identifier of the phase.\n     * @return phase_ Phase struct representing the data of the phase `phaseId`.\n     */\n    function phase(\n        string memory phaseId\n    ) external view returns (Phase memory phase_);\n\n    /// @return phaseIds_ List of all phases identifiers.\n    function phaseIds() external view returns (string[] memory phaseIds_);\n\n    /**\n     * @param phaseId Identifier of the phase.\n     *\n     * @return Amount of {SaleStorage.SetUp.paymentToken} raised for the phase `phaseId`.\n     *         If `address(0)` is returned, it means native (ETH, BNB, MATCI, etc...).\n     */\n    function raisedInPhase(\n        string memory phaseId\n    ) external view returns (uint256);\n\n    /// @return Enum representing the current status of the Sale.\n    function saleStatus() external view returns (Status);\n\n    /**\n     * @return paymentToken Address of the default token used to reserve allocation through the Sale.\n     *         If `address(0)` is returned, it means native (ETH, BNB, MATCI, etc...).\n     * @return permit2 Address of Permit2 contract.\n     */\n    function setUp()\n        external\n        view\n        returns (address paymentToken, address permit2);\n\n    /// @return Total amount of {SaleStorage.SetUp.paymentToken} raised for this Sale.\n    function totalRaised() external view returns (uint256);\n}\n'}, 'src/common/writable/restricted/IRestrictedWritableInternal.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.23;\n\nimport {Status} from ""../../SaleStruct.sol"";\n\n/**\n * @title IRestrictedWritableInternal\n * @notice Defines event and error used in {RestrictedWritableInternal} & {RestrictedWritable}.\n */\ninterface IRestrictedWritableInternal {\n    // @notice Thrown when `phaseIds` and `phases` arrays have different lengths.\n    error RestrictedWritableInternal_DifferentArraysLength();\n    // @notice Thrown when a phase {IGOStruct.Phase} is empty is {RestrictedWritableInternal._setPhases}.\n    error RestrictedWritableInternal_EmptyPhase();\n\n    //////////////////////////// THROWN ON Sale INITIALIZATION ////////////////////////////\n    error RestrictedWritable_Init_OwnerIsZeroAddr();\n    error RestrictedWritable_Init_PaymentTokenIsZeroAddr();\n    error RestrictedWritable_Init_Permit2IsZeroAddr();\n\n    //////////////////////////// THROWN AT ANY TIME ////////////////////////////\n    /// @dev Thrown when merkle root is equal to bytes32(0).\n    error RestrictedWritable_EmptyMerkleRoot();\n    // @notice Thrown when a phase {IGOStruct.Phase} is empty is {RestrictedWritable.updateSetPhase}.\n    error RestrictedWritable_EmptyPhase();\n    error RestrictedWritable_EndInPast();\n    /// @dev Thrown when a new phase is created with a status different from `NOT_STARTED`.\n    error RestrictedWritable_NewPhaseStatus();\n    /// @dev Thrown when the phase status is equal to `avoid`.\n    error RestrictedWritable_PhaseMatched(Status avoid, Status phaseStatus);\n    error RestrictedWritable_PhaseMaxCapIsZero();\n    error RestrictedWritable_PhaseMerkleRootIsZero();\n    /// @dev Thrown when the phase status is not equal to the one expected.\n    error RestrictedWritable_PhaseNotMatched(Status expected, Status current);\n    error RestrictedWritable_PhaseStartGteEnd();\n    error RestrictedWritable_ReceiverIsZeroAddr();\n    /// @dev Thrown when the sale status is equal to `avoid`.\n    error RestrictedWritable_SaleMatched(Status avoid, Status saleStatus);\n    /// @dev Thrown when the sale status is not equal to the one expected.\n    error RestrictedWritable_SaleNotMatched(Status expected, Status current);\n    error RestrictedWritable_StartAfterEnd();\n    error RestrictedWritable_EndBeforeStart();\n    error RestrictedWritable_TokenIsZeroAddr();\n\n    event PhaseEndDateUpdated(\n        string indexed phaseId,\n        uint256 indexed oldEndDate,\n        uint256 indexed newEndDate\n    );\n    event PhaseMaxCapUpdated(\n        string indexed phaseId,\n        uint256 indexed oldMaxCap,\n        uint256 indexed newMaxCap\n    );\n    event PhaseMerkleRootUpdated(\n        string indexed phaseId,\n        bytes32 indexed oldMerkleRoot,\n        bytes32 indexed newMerkleRoot\n    );\n    event PhaseOpened(string indexed phaseName);\n    event PhasePaused(string indexed phaseName);\n    event PhaseResumed(string indexed phaseName);\n    event PhaseStartDateUpdated(\n        string indexed phaseId,\n        uint256 indexed oldStartDate,\n        uint256 indexed newStartDate\n    );\n    event RecoveredLostERC20(\n        address indexed token,\n        address indexed to,\n        uint256 indexed amount\n    );\n    event SaleClosed();\n    event SaleOpened();\n    event SalePaused();\n    event SaleResumed();\n}\n'}, 'src/common/writable/ISaleWritableInternal.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.23;\n\n// import struct\nimport {Status} from ""../SaleStruct.sol"";\n\n/**\n * @title ISaleWritableInternal\n * @notice Internal interface of `SaleWritable` which defines events  and errors.\n */\ninterface ISaleWritableInternal {\n    /// @notice Thrown when the buyer tries to spend more than {Allocation.maxAllocation}.\n    error SaleWritable_AllocationExceeded(\n        uint256 allocation,\n        uint256 exceedsBy\n    );\n    /// @notice Thrown when the grand total to be raised for this Sale is exceeded.\n    error SaleWritable_SummedMaxPhaseCapExceeded(\n        uint256 summedMaxPhaseCap,\n        uint256 exceedsBy\n    );\n    /// @notice Thrown when the cap (maximum amount) of the current phase is exceeded.\n    error SaleWritable_MaxPhaseCapExceeded(\n        string phaseId,\n        uint256 maxPhaseCap,\n        uint256 exceedsBy\n    );\n\n    /// @notice Thrown when `msg.sender` is not the buyer.\n    error SaleWritableInternal_AccountNotAuthorized();\n    /// @notice Thrown when the allocation is not found in the merkle proof.\n    error SaleWritableInternal_AllocationNotFound();\n    /// @notice Thrown when the phase is not opened.\n    error SaleWritableInternal_PhaseNotOpened(string phaseId, Status current);\n    /// @notice Thrown when the Sale is not opened.\n    error SaleWritableInternal_SaleNotOpened(Status current);\n}\n'}, 'lib/permit2/src/interfaces/ISignatureTransfer.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IEIP712} from ""./IEIP712.sol"";\n\n/// @title SignatureTransfer\n/// @notice Handles ERC20 token transfers through signature based actions\n/// @dev Requires user\'s token approval on the Permit2 contract\ninterface ISignatureTransfer is IEIP712 {\n    /// @notice Thrown when the requested amount for a transfer is larger than the permissioned amount\n    /// @param maxAmount The maximum amount a spender can request to transfer\n    error InvalidAmount(uint256 maxAmount);\n\n    /// @notice Thrown when the number of tokens permissioned to a spender does not match the number of tokens being transferred\n    /// @dev If the spender does not need to transfer the number of tokens permitted, the spender can request amount 0 to be transferred\n    error LengthMismatch();\n\n    /// @notice Emits an event when the owner successfully invalidates an unordered nonce.\n    event UnorderedNonceInvalidation(address indexed owner, uint256 word, uint256 mask);\n\n    /// @notice The token and amount details for a transfer signed in the permit transfer signature\n    struct TokenPermissions {\n        // ERC20 token address\n        address token;\n        // the maximum amount that can be spent\n        uint256 amount;\n    }\n\n    /// @notice The signed permit message for a single token transfer\n    struct PermitTransferFrom {\n        TokenPermissions permitted;\n        // a unique value for every token owner\'s signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice Specifies the recipient address and amount for batched transfers.\n    /// @dev Recipients and amounts correspond to the index of the signed token permissions array.\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount.\n    struct SignatureTransferDetails {\n        // recipient address\n        address to;\n        // spender requested amount\n        uint256 requestedAmount;\n    }\n\n    /// @notice Used to reconstruct the signed permit message for multiple token transfers\n    /// @dev Do not need to pass in spender address as it is required that it is msg.sender\n    /// @dev Note that a user still signs over a spender address\n    struct PermitBatchTransferFrom {\n        // the tokens and corresponding amounts permitted for a transfer\n        TokenPermissions[] permitted;\n        // a unique value for every token owner\'s signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice A map from token owner address and a caller specified word index to a bitmap. Used to set bits in the bitmap to prevent against signature replay protection\n    /// @dev Uses unordered nonces so that permit messages do not need to be spent in a certain order\n    /// @dev The mapping is indexed first by the token owner, then by an index specified in the nonce\n    /// @dev It returns a uint256 bitmap\n    /// @dev The index, or wordPosition is capped at type(uint248).max\n    function nonceBitmap(address, uint256) external view returns (uint256);\n\n    /// @notice Transfers a token using a signed permit message\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender\'s requested transfer details for the permitted token\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers a token using a signed permit message\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender\'s requested transfer details for the permitted token\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Invalidates the bits specified in mask for the bitmap at the word position\n    /// @dev The wordPos is maxed at type(uint248).max\n    /// @param wordPos A number to index the nonceBitmap at\n    /// @param mask A bitmap masked against msg.sender\'s current bitmap at the word position\n    function invalidateUnorderedNonces(uint256 wordPos, uint256 mask) external;\n}\n'}, 'src/common/writable/restricted/RestrictedWritableInternal.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.23;\n\nimport {AccessControlEnumerable} from ""openzeppelin-contracts/access/AccessControlEnumerable.sol"";\n\nimport {IRestrictedWritableInternal} from ""./IRestrictedWritableInternal.sol"";\n\nimport {SaleStorage} from ""../../SaleStorage.sol"";\n\n// import struct\nimport {Status, Phase} from ""../../SaleStruct.sol"";\n\n/**\n * @title RestrictedWritableInternal\n * @notice Defines the internal functions of `RestrictedWritable` contract.\n */\ncontract RestrictedWritableInternal is\n    IRestrictedWritableInternal, // 1 inherited component\n    AccessControlEnumerable // 8 inherited component\n{\n    function _checkPhaseData(\n        uint256 oldMaxPhaseCap,\n        Phase calldata phase_\n    ) internal view {\n        if (oldMaxPhaseCap == 0) {\n            // if it is a new phase phase MUST be NOT_STARTED\n            if (phase_.status != Status.NOT_STARTED) {\n                revert RestrictedWritable_NewPhaseStatus();\n            }\n        }\n        if (phase_.merkleRoot == bytes32(0)) {\n            revert RestrictedWritable_PhaseMerkleRootIsZero();\n        }\n        /**\n         * @dev Phase can start in the past as we can have a phase that is already started BUT contract has\n         *      been deployed later due to unexpected reasons.\n         */\n        if (phase_.startAt >= phase_.endAt) {\n            revert RestrictedWritable_PhaseStartGteEnd();\n        }\n\n        if (phase_.endAt <= block.timestamp) {\n            revert RestrictedWritable_EndInPast();\n        }\n\n        if (phase_.maxPhaseCap == 0) {\n            revert RestrictedWritable_PhaseMaxCapIsZero();\n        }\n    }\n\n    /// @param phaseId Phase identifier to close.\n    function _closePhase(string memory phaseId) internal {\n        SaleStorage.layout().phases.data[phaseId].status = Status.COMPLETED;\n    }\n\n    function _closeSale() internal {\n        SaleStorage.layout().ledger.status = Status.COMPLETED;\n    }\n\n    function _initializeSale(SaleStorage.SetUp calldata saleSetUp) internal {\n        if (saleSetUp.permit2 == address(0))\n            revert RestrictedWritable_Init_Permit2IsZeroAddr();\n\n        SaleStorage.layout().setUp = saleSetUp;\n    }\n\n    function _openPhase(string memory phaseId) internal {\n        SaleStorage.layout().phases.data[phaseId].status = Status.OPENED;\n    }\n\n    function _openSale() internal {\n        SaleStorage.layout().ledger.status = Status.OPENED;\n    }\n\n    function _setOwnerRights(address owner) internal {\n        if (owner == address(0)) {\n            revert RestrictedWritable_Init_OwnerIsZeroAddr();\n        }\n\n        _grantRole(DEFAULT_ADMIN_ROLE, owner);\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    function _checkTimestampsForUpdatedPhase(\n        uint128 oldStartAt,\n        uint128 oldEndAt,\n        uint128 startAt,\n        uint128 endAt,\n        string calldata phaseId_\n    ) internal view {\n        // if startAt is changed, existing phase should be in NOT_STARTED state\n        if (oldStartAt != startAt) {\n            _isPhase(Status.NOT_STARTED, phaseId_);\n        }\n\n        // if endAt is changed, existing phase should not be in COMPLETED state\n        if (oldEndAt != endAt) {\n            _isPhaseNot(Status.COMPLETED, phaseId_);\n        }\n    }\n\n    /**\n     * @notice Set the data of phase or update it if it already exists.\n     *\n     * @param summedMaxPhaseCap The sum of all max amount to raise per phase before updating this phase,\n     *                          expressed in {SaleStorage.SetUp.paymentToken}\n     * @param oldMaxPhaseCap The max amount to raise for the phase before updating it,\n     *                       expressed in {SaleStorage.SetUp.paymentToken}.\n     * @param phase_ The phase\'s data to save.\n     * @param phaseId_ The phase identifier.\n     */\n    function _setPhase(\n        uint256 summedMaxPhaseCap,\n        uint256 oldMaxPhaseCap,\n        Phase calldata phase_,\n        string calldata phaseId_\n    ) internal {\n        _checkPhaseData(oldMaxPhaseCap, phase_);\n\n        if (oldMaxPhaseCap != 0) {\n            _checkTimestampsForUpdatedPhase(\n                SaleStorage.layout().phases.data[phaseId_].startAt,\n                SaleStorage.layout().phases.data[phaseId_].endAt,\n                phase_.startAt,\n                phase_.endAt,\n                phaseId_\n            );\n        }\n\n        summedMaxPhaseCap -= oldMaxPhaseCap;\n        summedMaxPhaseCap += phase_.maxPhaseCap;\n\n        // if phase does not exist, push to ids\n        if (oldMaxPhaseCap == 0)\n            SaleStorage.layout().phases.ids.push(phaseId_);\n        SaleStorage.layout().phases.data[phaseId_] = phase_;\n\n        SaleStorage.layout().ledger.summedMaxPhaseCap = summedMaxPhaseCap;\n    }\n\n    function _isPhase(Status expected, string calldata phaseId) internal view {\n        Status phaseStatus = SaleStorage.layout().phases.data[phaseId].status;\n\n        if (phaseStatus != expected) {\n            revert RestrictedWritable_PhaseNotMatched(expected, phaseStatus);\n        }\n    }\n\n    /// @dev If **phase status** is NOT equals `avoid` it passes silently, otherwise it reverts.\n    function _isPhaseNot(Status avoid, string calldata phaseId) internal view {\n        Status phaseStatus = SaleStorage.layout().phases.data[phaseId].status;\n\n        if (phaseStatus == avoid) {\n            revert RestrictedWritable_PhaseMatched(avoid, phaseStatus);\n        }\n    }\n\n    function _isSale(Status expected) internal view {\n        Status current = SaleStorage.layout().ledger.status;\n        if (current != expected) {\n            revert RestrictedWritable_SaleNotMatched(expected, current);\n        }\n    }\n\n    /// @dev If **sale status** is NOT equals `avoid` it passes silently, otherwise it reverts.\n    function _isSaleNot(Status avoid) internal view {\n        Status current = SaleStorage.layout().ledger.status;\n        if (current == avoid) {\n            revert RestrictedWritable_SaleMatched(avoid, current);\n        }\n    }\n}\n'}, 'lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol': {'content': ""// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n""}, 'lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport ""../IERC20.sol"";\nimport ""../extensions/IERC20Permit.sol"";\nimport ""../../../utils/Address.sol"";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            ""SafeERC20: approve from non-zero to non-zero allowance""\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, ""SafeERC20: decreased allowance below zero"");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\n     * 0 before setting it to a non-zero value.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, ""SafeERC20: permit did not succeed"");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, ""SafeERC20: low-level call failed"");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), ""SafeERC20: ERC20 operation did not succeed"");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n'}, 'lib/openzeppelin-contracts/contracts/proxy/utils/Initializable.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport ""../../utils/Address.sol"";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it\'s common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each ""step"" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(""MyToken"", ""MTK"");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(""MyToken"");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            ""Initializable: contract is already initialized""\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, ""Initializable: contract is already initialized"");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, ""Initializable: contract is not initializing"");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, ""Initializable: contract is initializing"");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n'}, 'src/common/writable/restricted/IRestrictedWritable.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.23;\n\nimport {IGOStorage} from ""../../../igo/IGOStorage.sol"";\nimport {SaleStorage} from ""../../SaleStorage.sol"";\n\n// import struct\nimport {Phase} from ""../../SaleStruct.sol"";\n\n/**\n * @title IRestrictedWritable\n * @notice Only the owner of the contract can call these methods.\n */\ninterface IRestrictedWritable {\n    //////////////////////////// SHARED Sale DATA ////////////////////////////\n    /**\n     * @notice Close the sale for good.\n     * @dev Can be closed at any point in time AND NOT reversible.\n     */\n    function closeSale() external;\n\n    function openSale() external;\n\n    function pauseSale() external;\n\n    function resumeSale() external;\n\n    /// @dev Retrieve any ERC20 sent to the contract by mistake.\n    function recoverLostERC20(address token, address to) external;\n\n    function closePhases(string[] calldata phaseIds) external;\n\n    // TODO: UX choice to make here, do we need both phase single field update and phase batch update?\n    //////////////////////////// PHASE SINGLE UPDATE ////////////////////////////\n    /**\n     * @custom:audit phase can be opened even if it does not exists but as only the owner can update this\n     * method we make the asumption that the owner will always be aware of this to save gast costs and it\n     * can be paused at any time to update its data so it does not pose a security risk.\n     */\n    function openPhase(string calldata phaseId) external;\n\n    function pausePhase(string calldata phaseId) external;\n\n    function resumePhase(string calldata phaseId) external;\n\n    function updatePhaseEndDate(\n        string calldata phaseId,\n        uint128 endAt\n    ) external;\n\n    /**\n     * @notice Update `maxPhaseCap` which is the maximum amount of tokens that can be sold in a phase\n     *         and the merkle root of a phase to update a single or multiple wallet allocation,\n     *         refund fee, etc.\n     * @dev `maxPhaseCap` is expressed in {SaleStorage.SetUp.paymentToken}.\n     *\n     * @param phaseId Identifier of the phase.\n     * @param merkleRoot New merkle root to be saved for this phase.\n     */\n    function updatePhaseMaxCapAndMerkleRoot(\n        string calldata phaseId,\n        uint256 maxPhaseCap,\n        bytes32 merkleRoot\n    ) external;\n\n    /**\n     * @notice Update the merkle root of a phase to update a single or multiple wallet allocation,\n     *         refund fee, payment token etc.\n     *\n     * @param phaseId Identifier of the phase.\n     * @param merkleRoot New merkle root to be saved for this phase.\n     */\n    function updatePhaseMerkleRoot(\n        string calldata phaseId,\n        bytes32 merkleRoot\n    ) external;\n\n    function updatePhaseStartDate(\n        string calldata phaseId,\n        uint128 startAt\n    ) external;\n}\n'}, 'src/igo/IGOStorage.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.23;\n\n/**\n * @author https://github.com/Theo6890\n * @title IGOStorage\n * @notice Mapps the storage layout of the {IGO} contract.\n * @dev Diamond proxy (ERC-2535) storage style.\n */\nlibrary IGOStorage {\n    /**\n     * @notice Struct reprensenting the main setup of the IGO.\n     *\n     * @param vestingContract Address of the {IGOVesting} contract.\n     * @param refundFeeDecimals Number of decimals used for {IIGOWritableInternal.Allocation.refundFee}.\n     */\n    struct SetUp {\n        address vestingContract;\n        uint256 refundFeeDecimals;\n    }\n\n    /**\n     * @notice Struct reprensenting the whole storage layout of the IGO contract.\n     *\n     * @param setUp Struct reprensenting the main setup of the IGO.\n     */\n    struct IGOStruct {\n        SetUp setUp;\n    }\n\n    /// @notice Storage position of {IGOStruct} in {IGO} contract.\n    bytes32 public constant IGO_STORAGE = keccak256(""igo.storage"");\n\n    /**\n     * @return igoStruct Whole storage of {IGO} contract.\n     */\n    function layout() internal pure returns (IGOStruct storage igoStruct) {\n        bytes32 position = IGO_STORAGE;\n        assembly {\n            igoStruct.slot := position\n        }\n    }\n}\n'}, 'lib/permit2/src/interfaces/IEIP712.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IEIP712 {\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n'}, 'lib/openzeppelin-contracts/contracts/access/AccessControlEnumerable.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport ""./IAccessControlEnumerable.sol"";\nimport ""./AccessControl.sol"";\nimport ""../utils/structs/EnumerableSet.sol"";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n}\n'}, 'lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol': {'content': ""// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n""}, 'lib/openzeppelin-contracts/contracts/utils/Address.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, ""Address: insufficient balance"");\n\n        (bool success, ) = recipient.call{value: amount}("""");\n        require(success, ""Address: unable to send value, recipient may have reverted"");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, ""Address: low-level call failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, ""Address: insufficient balance for call"");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, ""Address: low-level static call failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, ""Address: low-level delegate call failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), ""Address: call to non-contract"");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n'}, 'lib/openzeppelin-contracts/contracts/access/IAccessControlEnumerable.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport ""./IAccessControl.sol"";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n'}, 'lib/openzeppelin-contracts/contracts/access/AccessControl.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport ""./IAccessControl.sol"";\nimport ""../utils/Context.sol"";\nimport ""../utils/Strings.sol"";\nimport ""../utils/introspection/ERC165.sol"";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn\'t allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(""MY_ROLE"");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role\'s admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        ""AccessControl: account "",\n                        Strings.toHexString(account),\n                        "" is missing role "",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), ""AccessControl: can only renounce roles for self"");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn\'t perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n'}, 'lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol': {'content': ""// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n""}, 'lib/openzeppelin-contracts/contracts/access/IAccessControl.sol': {'content': ""// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n""}, 'lib/openzeppelin-contracts/contracts/utils/Context.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n'}, 'lib/openzeppelin-contracts/contracts/utils/Strings.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport ""./math/Math.sol"";\nimport ""./math/SignedMath.sol"";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = ""0123456789abcdef"";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? ""-"" : """", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = ""0"";\n        buffer[1] = ""x"";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, ""Strings: hex length insufficient"");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n'}, 'lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport ""./IERC165.sol"";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n'}, 'lib/openzeppelin-contracts/contracts/utils/math/Math.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, ""Math: mulDiv overflow"");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s ""Hacker\'s Delight"" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the ""msb"" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n'}, 'lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book ""Hacker\'s Delight""\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n'}, 'lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n'}}

// File: settings
{'remappings': ['forge-std/=lib/forge-std/src/', 'hardhat/=node_modules/hardhat/', 'murky/=lib/murky/', 'permit2/=lib/permit2/src/', 'solmate/=lib/solmate/', 'vesting-schedule/=lib/vesting-schedule/src/', 'layer0/=lib/layer-zero-examples/contracts/', 'seadrop/=lib/seadrop/', 'ERC721A/=lib/ERC721A/contracts/', 'chainlink/=lib/chainlink-brownie-contracts/contracts/src/v0.8/', '@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/', 'openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/', 'openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/', 'permit2-test/=lib/permit2/test/', '@ensdomains/=lib/vesting-schedule/node_modules/@ensdomains/', '@prb/test/=lib/vesting-schedule/lib/prb-test/src/', '@uniswap/=lib/layer-zero-examples/node_modules/@uniswap/', 'ERC721A-Upgradeable/=lib/seadrop/lib/ERC721A-Upgradeable/contracts/', 'chainlink-brownie-contracts/=lib/chainlink-brownie-contracts/contracts/src/v0.6/vendor/@arbitrum/nitro-contracts/src/', 'create2-helpers/=lib/seadrop/lib/create2-helpers/', 'create2-scripts/=lib/seadrop/lib/create2-helpers/script/', 'decubate-vesting-refund/=lib/decubate-vesting-refund/src/', 'ds-test/=lib/forge-std/lib/ds-test/src/', 'erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/', 'eth-gas-reporter/=node_modules/eth-gas-reporter/', 'forge-gas-snapshot/=lib/permit2/lib/forge-gas-snapshot/src/', 'hardhat-deploy/=lib/layer-zero-examples/node_modules/hardhat-deploy/', 'layer-zero-examples/=lib/layer-zero-examples/contracts/', 'layerzero-v1/=lib/layerzero-v1/contracts/', 'layerzero-v2/=lib/layerzero-v2/', 'openzeppelin-foundry-upgrades/=lib/openzeppelin-foundry-upgrades/src/', 'openzeppelin/=lib/openzeppelin-contracts-upgradeable/contracts/', 'operator-filter-registry/=lib/seadrop/lib/operator-filter-registry/', 'prb-test/=lib/vesting-schedule/lib/prb-test/src/', 'solidity-bytes-utils/=lib/solidity-bytes-utils/contracts/', 'solidity-stringutils/=lib/openzeppelin-foundry-upgrades/lib/solidity-stringutils/', 'utility-contracts/=lib/utility-contracts/'], 'optimizer': {'enabled': True, 'runs': 200}, 'metadata': {'useLiteralContent': False, 'bytecodeHash': 'ipfs', 'appendCBOR': True}, 'outputSelection': {'*': {'*': ['evm.bytecode', 'evm.deployedBytecode', 'devdoc', 'userdoc', 'metadata', 'abi']}}, 'evmVersion': 'paris', 'viaIR': True, 'libraries': {}}",True
0xba12222222228d8ba445958a75a0704d566bf2c8,"// File: language
Solidity

// File: sources
{'contracts/vault/Vault.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport ""./interfaces/IAuthorizer.sol"";\nimport ""./interfaces/IWETH.sol"";\n\nimport ""./VaultAuthorization.sol"";\nimport ""./FlashLoans.sol"";\nimport ""./Swaps.sol"";\n\n/**\n * @dev The `Vault` is Balancer V2\'s core contract. A single instance of it exists for the entire network, and it is the\n * entity used to interact with Pools by Liquidity Providers who join and exit them, Traders who swap, and Asset\n * Managers who withdraw and deposit tokens.\n *\n * The `Vault`\'s source code is split among a number of sub-contracts, with the goal of improving readability and making\n * understanding the system easier. Most sub-contracts have been marked as `abstract` to explicitly indicate that only\n * the full `Vault` is meant to be deployed.\n *\n * Roughly speaking, these are the contents of each sub-contract:\n *\n *  - `AssetManagers`: Pool token Asset Manager registry, and Asset Manager interactions.\n *  - `Fees`: set and compute protocol fees.\n *  - `FlashLoans`: flash loan transfers and fees.\n *  - `PoolBalances`: Pool joins and exits.\n *  - `PoolRegistry`: Pool registration, ID management, and basic queries.\n *  - `PoolTokens`: Pool token registration and registration, and balance queries.\n *  - `Swaps`: Pool swaps.\n *  - `UserBalance`: manage user balances (Internal Balance operations and external balance transfers)\n *  - `VaultAuthorization`: access control, relayers and signature validation.\n *\n * Additionally, the different Pool specializations are handled by the `GeneralPoolsBalance`,\n * `MinimalSwapInfoPoolsBalance` and `TwoTokenPoolsBalance` sub-contracts, which in turn make use of the\n * `BalanceAllocation` library.\n *\n * The most important goal of the `Vault` is to make token swaps use as little gas as possible. This is reflected in a\n * multitude of design decisions, from minor things like the format used to store Pool IDs, to major features such as\n * the different Pool specialization settings.\n *\n * Finally, the large number of tasks carried out by the Vault means its bytecode is very large, close to exceeding\n * the contract size limit imposed by EIP 170 (https://eips.ethereum.org/EIPS/eip-170). Manual tuning of the source code\n * was required to improve code generation and bring the bytecode size below this limit. This includes extensive\n * utilization of `internal` functions (particularly inside modifiers), usage of named return arguments, dedicated\n * storage access methods, dynamic revert reason generation, and usage of inline assembly, to name a few.\n */\ncontract Vault is VaultAuthorization, FlashLoans, Swaps {\n    constructor(\n        IAuthorizer authorizer,\n        IWETH weth,\n        uint256 pauseWindowDuration,\n        uint256 bufferPeriodDuration\n    ) VaultAuthorization(authorizer) AssetHelpers(weth) TemporarilyPausable(pauseWindowDuration, bufferPeriodDuration) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function setPaused(bool paused) external override nonReentrant authenticate {\n        _setPaused(paused);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function WETH() external view override returns (IWETH) {\n        return _WETH();\n    }\n}\n'}, 'contracts/vault/interfaces/IAuthorizer.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\ninterface IAuthorizer {\n    /**\n     * @dev Returns true if `account` can perform the action described by `actionId` in the contract `where`.\n     */\n    function canPerform(\n        bytes32 actionId,\n        address account,\n        address where\n    ) external view returns (bool);\n}\n'}, 'contracts/vault/interfaces/IWETH.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\nimport ""../../lib/openzeppelin/IERC20.sol"";\n\n/**\n * @dev Interface for the WETH token contract used internally for wrapping and unwrapping, to support\n * sending and receiving ETH in joins, swaps, and internal balance deposits and withdrawals.\n */\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n\n    function withdraw(uint256 amount) external;\n}\n'}, 'contracts/vault/VaultAuthorization.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport ""../lib/helpers/BalancerErrors.sol"";\nimport ""../lib/helpers/Authentication.sol"";\nimport ""../lib/helpers/TemporarilyPausable.sol"";\nimport ""../lib/helpers/BalancerErrors.sol"";\nimport ""../lib/helpers/SignaturesValidator.sol"";\nimport ""../lib/openzeppelin/ReentrancyGuard.sol"";\n\nimport ""./interfaces/IVault.sol"";\nimport ""./interfaces/IAuthorizer.sol"";\n\n/**\n * @dev Manages access control of Vault permissioned functions by relying on the Authorizer and signature validation.\n *\n * Additionally handles relayer access and approval.\n */\nabstract contract VaultAuthorization is\n    IVault,\n    ReentrancyGuard,\n    Authentication,\n    SignaturesValidator,\n    TemporarilyPausable\n{\n    // Ideally, we\'d store the type hashes as immutable state variables to avoid computing the hash at runtime, but\n    // unfortunately immutable variables cannot be used in assembly, so we just keep the precomputed hashes instead.\n\n    // _JOIN_TYPE_HASH = keccak256(""JoinPool(bytes calldata,address sender,uint256 nonce,uint256 deadline)"");\n    bytes32 private constant _JOIN_TYPE_HASH = 0x3f7b71252bd19113ff48c19c6e004a9bcfcca320a0d74d58e85877cbd7dcae58;\n\n    // _EXIT_TYPE_HASH = keccak256(""ExitPool(bytes calldata,address sender,uint256 nonce,uint256 deadline)"");\n    bytes32 private constant _EXIT_TYPE_HASH = 0x8bbc57f66ea936902f50a71ce12b92c43f3c5340bb40c27c4e90ab84eeae3353;\n\n    // _SWAP_TYPE_HASH = keccak256(""Swap(bytes calldata,address sender,uint256 nonce,uint256 deadline)"");\n    bytes32 private constant _SWAP_TYPE_HASH = 0xe192dcbc143b1e244ad73b813fd3c097b832ad260a157340b4e5e5beda067abe;\n\n    // _BATCH_SWAP_TYPE_HASH = keccak256(""BatchSwap(bytes calldata,address sender,uint256 nonce,uint256 deadline)"");\n    bytes32 private constant _BATCH_SWAP_TYPE_HASH = 0x9bfc43a4d98313c6766986ffd7c916c7481566d9f224c6819af0a53388aced3a;\n\n    // _SET_RELAYER_TYPE_HASH =\n    //     keccak256(""SetRelayerApproval(bytes calldata,address sender,uint256 nonce,uint256 deadline)"");\n    bytes32\n        private constant _SET_RELAYER_TYPE_HASH = 0xa3f865aa351e51cfeb40f5178d1564bb629fe9030b83caf6361d1baaf5b90b5a;\n\n    IAuthorizer private _authorizer;\n    mapping(address => mapping(address => bool)) private _approvedRelayers;\n\n    /**\n     * @dev Reverts unless `user` is the caller, or the caller is approved by the Authorizer to call this function (that\n     * is, it is a relayer for that function), and either:\n     *  a) `user` approved the caller as a relayer (via `setRelayerApproval`), or\n     *  b) a valid signature from them was appended to the calldata.\n     *\n     * Should only be applied to external functions.\n     */\n    modifier authenticateFor(address user) {\n        _authenticateFor(user);\n        _;\n    }\n\n    constructor(IAuthorizer authorizer)\n        // The Vault is a singleton, so it simply uses its own address to disambiguate action identifiers.\n        Authentication(bytes32(uint256(address(this))))\n        SignaturesValidator(""Balancer V2 Vault"")\n    {\n        _setAuthorizer(authorizer);\n    }\n\n    function setAuthorizer(IAuthorizer newAuthorizer) external override nonReentrant authenticate {\n        _setAuthorizer(newAuthorizer);\n    }\n\n    function _setAuthorizer(IAuthorizer newAuthorizer) private {\n        emit AuthorizerChanged(newAuthorizer);\n        _authorizer = newAuthorizer;\n    }\n\n    function getAuthorizer() external view override returns (IAuthorizer) {\n        return _authorizer;\n    }\n\n    function setRelayerApproval(\n        address sender,\n        address relayer,\n        bool approved\n    ) external override nonReentrant whenNotPaused authenticateFor(sender) {\n        _approvedRelayers[sender][relayer] = approved;\n        emit RelayerApprovalChanged(relayer, sender, approved);\n    }\n\n    function hasApprovedRelayer(address user, address relayer) external view override returns (bool) {\n        return _hasApprovedRelayer(user, relayer);\n    }\n\n    /**\n     * @dev Reverts unless `user` is the caller, or the caller is approved by the Authorizer to call the entry point\n     * function (that is, it is a relayer for that function) and either:\n     *  a) `user` approved the caller as a relayer (via `setRelayerApproval`), or\n     *  b) a valid signature from them was appended to the calldata.\n     */\n    function _authenticateFor(address user) internal {\n        if (msg.sender != user) {\n            // In this context, \'permission to call a function\' means \'being a relayer for a function\'.\n            _authenticateCaller();\n\n            // Being a relayer is not sufficient: `user` must have also approved the caller either via\n            // `setRelayerApproval`, or by providing a signature appended to the calldata.\n            if (!_hasApprovedRelayer(user, msg.sender)) {\n                _validateSignature(user, Errors.USER_DOESNT_ALLOW_RELAYER);\n            }\n        }\n    }\n\n    /**\n     * @dev Returns true if `user` approved `relayer` to act as a relayer for them.\n     */\n    function _hasApprovedRelayer(address user, address relayer) internal view returns (bool) {\n        return _approvedRelayers[user][relayer];\n    }\n\n    function _canPerform(bytes32 actionId, address user) internal view override returns (bool) {\n        // Access control is delegated to the Authorizer.\n        return _authorizer.canPerform(actionId, user, address(this));\n    }\n\n    function _typeHash() internal pure override returns (bytes32 hash) {\n        // This is a simple switch-case statement, trivially written in Solidity by chaining else-if statements, but the\n        // assembly implementation results in much denser bytecode.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // The function selector is located at the first 4 bytes of calldata. We copy the first full calldata\n            // 256 word, and then perform a logical shift to the right, moving the selector to the least significant\n            // 4 bytes.\n            let selector := shr(224, calldataload(0))\n\n            // With the selector in the least significant 4 bytes, we can use 4 byte literals with leading zeros,\n            // resulting in dense bytecode (PUSH4 opcodes).\n            switch selector\n                case 0xb95cac28 {\n                    hash := _JOIN_TYPE_HASH\n                }\n                case 0x8bdb3913 {\n                    hash := _EXIT_TYPE_HASH\n                }\n                case 0x52bbbe29 {\n                    hash := _SWAP_TYPE_HASH\n                }\n                case 0x945bcec9 {\n                    hash := _BATCH_SWAP_TYPE_HASH\n                }\n                case 0xfa6e671d {\n                    hash := _SET_RELAYER_TYPE_HASH\n                }\n                default {\n                    hash := 0x0000000000000000000000000000000000000000000000000000000000000000\n                }\n        }\n    }\n}\n'}, 'contracts/vault/FlashLoans.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// This flash loan provider was based on the Aave protocol\'s open source\n// implementation and terminology and interfaces are intentionally kept\n// similar\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport ""../lib/helpers/BalancerErrors.sol"";\nimport ""../lib/openzeppelin/IERC20.sol"";\nimport ""../lib/openzeppelin/ReentrancyGuard.sol"";\nimport ""../lib/openzeppelin/SafeERC20.sol"";\n\nimport ""./Fees.sol"";\nimport ""./interfaces/IFlashLoanRecipient.sol"";\n\n/**\n * @dev Handles Flash Loans through the Vault. Calls the `receiveFlashLoan` hook on the flash loan recipient\n * contract, which implements the `IFlashLoanRecipient` interface.\n */\nabstract contract FlashLoans is Fees, ReentrancyGuard, TemporarilyPausable {\n    using SafeERC20 for IERC20;\n\n    function flashLoan(\n        IFlashLoanRecipient recipient,\n        IERC20[] memory tokens,\n        uint256[] memory amounts,\n        bytes memory userData\n    ) external override nonReentrant whenNotPaused {\n        InputHelpers.ensureInputLengthMatch(tokens.length, amounts.length);\n\n        uint256[] memory feeAmounts = new uint256[](tokens.length);\n        uint256[] memory preLoanBalances = new uint256[](tokens.length);\n\n        // Used to ensure `tokens` is sorted in ascending order, which ensures token uniqueness.\n        IERC20 previousToken = IERC20(0);\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            IERC20 token = tokens[i];\n            uint256 amount = amounts[i];\n\n            _require(token > previousToken, token == IERC20(0) ? Errors.ZERO_TOKEN : Errors.UNSORTED_TOKENS);\n            previousToken = token;\n\n            preLoanBalances[i] = token.balanceOf(address(this));\n            feeAmounts[i] = _calculateFlashLoanFeeAmount(amount);\n\n            _require(preLoanBalances[i] >= amount, Errors.INSUFFICIENT_FLASH_LOAN_BALANCE);\n            token.safeTransfer(address(recipient), amount);\n        }\n\n        recipient.receiveFlashLoan(tokens, amounts, feeAmounts, userData);\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            IERC20 token = tokens[i];\n            uint256 preLoanBalance = preLoanBalances[i];\n\n            // Checking for loan repayment first (without accounting for fees) makes for simpler debugging, and results\n            // in more accurate revert reasons if the flash loan protocol fee percentage is zero.\n            uint256 postLoanBalance = token.balanceOf(address(this));\n            _require(postLoanBalance >= preLoanBalance, Errors.INVALID_POST_LOAN_BALANCE);\n\n            // No need for checked arithmetic since we know the loan was fully repaid.\n            uint256 receivedFeeAmount = postLoanBalance - preLoanBalance;\n            _require(receivedFeeAmount >= feeAmounts[i], Errors.INSUFFICIENT_FLASH_LOAN_FEE_AMOUNT);\n\n            _payFeeAmount(token, receivedFeeAmount);\n            emit FlashLoan(recipient, token, amounts[i], receivedFeeAmount);\n        }\n    }\n}\n'}, 'contracts/vault/Swaps.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport ""../lib/math/Math.sol"";\nimport ""../lib/helpers/BalancerErrors.sol"";\nimport ""../lib/helpers/InputHelpers.sol"";\nimport ""../lib/openzeppelin/EnumerableMap.sol"";\nimport ""../lib/openzeppelin/EnumerableSet.sol"";\nimport ""../lib/openzeppelin/IERC20.sol"";\nimport ""../lib/openzeppelin/ReentrancyGuard.sol"";\nimport ""../lib/openzeppelin/SafeCast.sol"";\nimport ""../lib/openzeppelin/SafeERC20.sol"";\n\nimport ""./PoolBalances.sol"";\nimport ""./interfaces/IPoolSwapStructs.sol"";\nimport ""./interfaces/IGeneralPool.sol"";\nimport ""./interfaces/IMinimalSwapInfoPool.sol"";\nimport ""./balances/BalanceAllocation.sol"";\n\n/**\n * Implements the Vault\'s high-level swap functionality.\n *\n * Users can swap tokens with Pools by calling the `swap` and `batchSwap` functions. They need not trust the Pool\n * contracts to do this: all security checks are made by the Vault.\n *\n * The `swap` function executes a single swap, while `batchSwap` can perform multiple swaps in sequence.\n * In each individual swap, tokens of one kind are sent from the sender to the Pool (this is the \'token in\'),\n * and tokens of another kind are sent from the Pool to the recipient in exchange (this is the \'token out\').\n * More complex swaps, such as one \'token in\' to multiple tokens out can be achieved by batching together\n * individual swaps.\n */\nabstract contract Swaps is ReentrancyGuard, PoolBalances {\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableMap for EnumerableMap.IERC20ToBytes32Map;\n\n    using Math for int256;\n    using Math for uint256;\n    using SafeCast for uint256;\n    using BalanceAllocation for bytes32;\n\n    function swap(\n        SingleSwap memory singleSwap,\n        FundManagement memory funds,\n        uint256 limit,\n        uint256 deadline\n    )\n        external\n        payable\n        override\n        nonReentrant\n        whenNotPaused\n        authenticateFor(funds.sender)\n        returns (uint256 amountCalculated)\n    {\n        // The deadline is timestamp-based: it should not be relied upon for sub-minute accuracy.\n        // solhint-disable-next-line not-rely-on-time\n        _require(block.timestamp <= deadline, Errors.SWAP_DEADLINE);\n\n        // This revert reason is for consistency with `batchSwap`: an equivalent `swap` performed using that function\n        // would result in this error.\n        _require(singleSwap.amount > 0, Errors.UNKNOWN_AMOUNT_IN_FIRST_SWAP);\n\n        IERC20 tokenIn = _translateToIERC20(singleSwap.assetIn);\n        IERC20 tokenOut = _translateToIERC20(singleSwap.assetOut);\n        _require(tokenIn != tokenOut, Errors.CANNOT_SWAP_SAME_TOKEN);\n\n        // Initializing each struct field one-by-one uses less gas than setting all at once.\n        IPoolSwapStructs.SwapRequest memory poolRequest;\n        poolRequest.poolId = singleSwap.poolId;\n        poolRequest.kind = singleSwap.kind;\n        poolRequest.tokenIn = tokenIn;\n        poolRequest.tokenOut = tokenOut;\n        poolRequest.amount = singleSwap.amount;\n        poolRequest.userData = singleSwap.userData;\n        poolRequest.from = funds.sender;\n        poolRequest.to = funds.recipient;\n        // The lastChangeBlock field is left uninitialized.\n\n        uint256 amountIn;\n        uint256 amountOut;\n\n        (amountCalculated, amountIn, amountOut) = _swapWithPool(poolRequest);\n        _require(singleSwap.kind == SwapKind.GIVEN_IN ? amountOut >= limit : amountIn <= limit, Errors.SWAP_LIMIT);\n\n        _receiveAsset(singleSwap.assetIn, amountIn, funds.sender, funds.fromInternalBalance);\n        _sendAsset(singleSwap.assetOut, amountOut, funds.recipient, funds.toInternalBalance);\n\n        // If the asset in is ETH, then `amountIn` ETH was wrapped into WETH.\n        _handleRemainingEth(_isETH(singleSwap.assetIn) ? amountIn : 0);\n    }\n\n    function batchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory funds,\n        int256[] memory limits,\n        uint256 deadline\n    )\n        external\n        payable\n        override\n        nonReentrant\n        whenNotPaused\n        authenticateFor(funds.sender)\n        returns (int256[] memory assetDeltas)\n    {\n        // The deadline is timestamp-based: it should not be relied upon for sub-minute accuracy.\n        // solhint-disable-next-line not-rely-on-time\n        _require(block.timestamp <= deadline, Errors.SWAP_DEADLINE);\n\n        InputHelpers.ensureInputLengthMatch(assets.length, limits.length);\n\n        // Perform the swaps, updating the Pool token balances and computing the net Vault asset deltas.\n        assetDeltas = _swapWithPools(swaps, assets, funds, kind);\n\n        // Process asset deltas, by either transferring assets from the sender (for positive deltas) or to the recipient\n        // (for negative deltas).\n        uint256 wrappedEth = 0;\n        for (uint256 i = 0; i < assets.length; ++i) {\n            IAsset asset = assets[i];\n            int256 delta = assetDeltas[i];\n            _require(delta <= limits[i], Errors.SWAP_LIMIT);\n\n            if (delta > 0) {\n                uint256 toReceive = uint256(delta);\n                _receiveAsset(asset, toReceive, funds.sender, funds.fromInternalBalance);\n\n                if (_isETH(asset)) {\n                    wrappedEth = wrappedEth.add(toReceive);\n                }\n            } else if (delta < 0) {\n                uint256 toSend = uint256(-delta);\n                _sendAsset(asset, toSend, funds.recipient, funds.toInternalBalance);\n            }\n        }\n\n        // Handle any used and remaining ETH.\n        _handleRemainingEth(wrappedEth);\n    }\n\n    // For `_swapWithPools` to handle both \'given in\' and \'given out\' swaps, it internally tracks the \'given\' amount\n    // (supplied by the caller), and the \'calculated\' amount (returned by the Pool in response to the swap request).\n\n    /**\n     * @dev Given the two swap tokens and the swap kind, returns which one is the \'given\' token (the token whose\n     * amount is supplied by the caller).\n     */\n    function _tokenGiven(\n        SwapKind kind,\n        IERC20 tokenIn,\n        IERC20 tokenOut\n    ) private pure returns (IERC20) {\n        return kind == SwapKind.GIVEN_IN ? tokenIn : tokenOut;\n    }\n\n    /**\n     * @dev Given the two swap tokens and the swap kind, returns which one is the \'calculated\' token (the token whose\n     * amount is calculated by the Pool).\n     */\n    function _tokenCalculated(\n        SwapKind kind,\n        IERC20 tokenIn,\n        IERC20 tokenOut\n    ) private pure returns (IERC20) {\n        return kind == SwapKind.GIVEN_IN ? tokenOut : tokenIn;\n    }\n\n    /**\n     * @dev Returns an ordered pair (amountIn, amountOut) given the \'given\' and \'calculated\' amounts, and the swap kind.\n     */\n    function _getAmounts(\n        SwapKind kind,\n        uint256 amountGiven,\n        uint256 amountCalculated\n    ) private pure returns (uint256 amountIn, uint256 amountOut) {\n        if (kind == SwapKind.GIVEN_IN) {\n            (amountIn, amountOut) = (amountGiven, amountCalculated);\n        } else {\n            // SwapKind.GIVEN_OUT\n            (amountIn, amountOut) = (amountCalculated, amountGiven);\n        }\n    }\n\n    /**\n     * @dev Performs all `swaps`, calling swap hooks on the Pool contracts and updating their balances. Does not cause\n     * any transfer of tokens - instead it returns the net Vault token deltas: positive if the Vault should receive\n     * tokens, and negative if it should send them.\n     */\n    function _swapWithPools(\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory funds,\n        SwapKind kind\n    ) private returns (int256[] memory assetDeltas) {\n        assetDeltas = new int256[](assets.length);\n\n        // These variables could be declared inside the loop, but that causes the compiler to allocate memory on each\n        // loop iteration, increasing gas costs.\n        BatchSwapStep memory batchSwapStep;\n        IPoolSwapStructs.SwapRequest memory poolRequest;\n\n        // These store data about the previous swap here to implement multihop logic across swaps.\n        IERC20 previousTokenCalculated;\n        uint256 previousAmountCalculated;\n\n        for (uint256 i = 0; i < swaps.length; ++i) {\n            batchSwapStep = swaps[i];\n\n            bool withinBounds = batchSwapStep.assetInIndex < assets.length &&\n                batchSwapStep.assetOutIndex < assets.length;\n            _require(withinBounds, Errors.OUT_OF_BOUNDS);\n\n            IERC20 tokenIn = _translateToIERC20(assets[batchSwapStep.assetInIndex]);\n            IERC20 tokenOut = _translateToIERC20(assets[batchSwapStep.assetOutIndex]);\n            _require(tokenIn != tokenOut, Errors.CANNOT_SWAP_SAME_TOKEN);\n\n            // Sentinel value for multihop logic\n            if (batchSwapStep.amount == 0) {\n                // When the amount given is zero, we use the calculated amount for the previous swap, as long as the\n                // current swap\'s given token is the previous calculated token. This makes it possible to swap a\n                // given amount of token A for token B, and then use the resulting token B amount to swap for token C.\n                _require(i > 0, Errors.UNKNOWN_AMOUNT_IN_FIRST_SWAP);\n                bool usingPreviousToken = previousTokenCalculated == _tokenGiven(kind, tokenIn, tokenOut);\n                _require(usingPreviousToken, Errors.MALCONSTRUCTED_MULTIHOP_SWAP);\n                batchSwapStep.amount = previousAmountCalculated;\n            }\n\n            // Initializing each struct field one-by-one uses less gas than setting all at once\n            poolRequest.poolId = batchSwapStep.poolId;\n            poolRequest.kind = kind;\n            poolRequest.tokenIn = tokenIn;\n            poolRequest.tokenOut = tokenOut;\n            poolRequest.amount = batchSwapStep.amount;\n            poolRequest.userData = batchSwapStep.userData;\n            poolRequest.from = funds.sender;\n            poolRequest.to = funds.recipient;\n            // The lastChangeBlock field is left uninitialized\n\n            uint256 amountIn;\n            uint256 amountOut;\n            (previousAmountCalculated, amountIn, amountOut) = _swapWithPool(poolRequest);\n\n            previousTokenCalculated = _tokenCalculated(kind, tokenIn, tokenOut);\n\n            // Accumulate Vault deltas across swaps\n            assetDeltas[batchSwapStep.assetInIndex] = assetDeltas[batchSwapStep.assetInIndex].add(amountIn.toInt256());\n            assetDeltas[batchSwapStep.assetOutIndex] = assetDeltas[batchSwapStep.assetOutIndex].sub(\n                amountOut.toInt256()\n            );\n        }\n    }\n\n    /**\n     * @dev Performs a swap according to the parameters specified in `request`, calling the Pool\'s contract hook and\n     * updating the Pool\'s balance.\n     *\n     * Returns the amount of tokens going into or out of the Vault as a result of this swap, depending on the swap kind.\n     */\n    function _swapWithPool(IPoolSwapStructs.SwapRequest memory request)\n        private\n        returns (\n            uint256 amountCalculated,\n            uint256 amountIn,\n            uint256 amountOut\n        )\n    {\n        // Get the calculated amount from the Pool and update its balances\n        address pool = _getPoolAddress(request.poolId);\n        PoolSpecialization specialization = _getPoolSpecialization(request.poolId);\n\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\n            amountCalculated = _processTwoTokenPoolSwapRequest(request, IMinimalSwapInfoPool(pool));\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\n            amountCalculated = _processMinimalSwapInfoPoolSwapRequest(request, IMinimalSwapInfoPool(pool));\n        } else {\n            // PoolSpecialization.GENERAL\n            amountCalculated = _processGeneralPoolSwapRequest(request, IGeneralPool(pool));\n        }\n\n        (amountIn, amountOut) = _getAmounts(request.kind, request.amount, amountCalculated);\n        emit Swap(request.poolId, request.tokenIn, request.tokenOut, amountIn, amountOut);\n    }\n\n    function _processTwoTokenPoolSwapRequest(IPoolSwapStructs.SwapRequest memory request, IMinimalSwapInfoPool pool)\n        private\n        returns (uint256 amountCalculated)\n    {\n        // For gas efficiency reasons, this function uses low-level knowledge of how Two Token Pool balances are\n        // stored internally, instead of using getters and setters for all operations.\n\n        (\n            bytes32 tokenABalance,\n            bytes32 tokenBBalance,\n            TwoTokenPoolBalances storage poolBalances\n        ) = _getTwoTokenPoolSharedBalances(request.poolId, request.tokenIn, request.tokenOut);\n\n        // We have the two Pool balances, but we don\'t know which one is \'token in\' or \'token out\'.\n        bytes32 tokenInBalance;\n        bytes32 tokenOutBalance;\n\n        // In Two Token Pools, token A has a smaller address than token B\n        if (request.tokenIn < request.tokenOut) {\n            // in is A, out is B\n            tokenInBalance = tokenABalance;\n            tokenOutBalance = tokenBBalance;\n        } else {\n            // in is B, out is A\n            tokenOutBalance = tokenABalance;\n            tokenInBalance = tokenBBalance;\n        }\n\n        // Perform the swap request and compute the new balances for \'token in\' and \'token out\' after the swap\n        (tokenInBalance, tokenOutBalance, amountCalculated) = _callMinimalSwapInfoPoolOnSwapHook(\n            request,\n            pool,\n            tokenInBalance,\n            tokenOutBalance\n        );\n\n        // We check the token ordering again to create the new shared cash packed struct\n        poolBalances.sharedCash = request.tokenIn < request.tokenOut\n            ? BalanceAllocation.toSharedCash(tokenInBalance, tokenOutBalance) // in is A, out is B\n            : BalanceAllocation.toSharedCash(tokenOutBalance, tokenInBalance); // in is B, out is A\n    }\n\n    function _processMinimalSwapInfoPoolSwapRequest(\n        IPoolSwapStructs.SwapRequest memory request,\n        IMinimalSwapInfoPool pool\n    ) private returns (uint256 amountCalculated) {\n        bytes32 tokenInBalance = _getMinimalSwapInfoPoolBalance(request.poolId, request.tokenIn);\n        bytes32 tokenOutBalance = _getMinimalSwapInfoPoolBalance(request.poolId, request.tokenOut);\n\n        // Perform the swap request and compute the new balances for \'token in\' and \'token out\' after the swap\n        (tokenInBalance, tokenOutBalance, amountCalculated) = _callMinimalSwapInfoPoolOnSwapHook(\n            request,\n            pool,\n            tokenInBalance,\n            tokenOutBalance\n        );\n\n        _minimalSwapInfoPoolsBalances[request.poolId][request.tokenIn] = tokenInBalance;\n        _minimalSwapInfoPoolsBalances[request.poolId][request.tokenOut] = tokenOutBalance;\n    }\n\n    /**\n     * @dev Calls the onSwap hook for a Pool that implements IMinimalSwapInfoPool: both Minimal Swap Info and Two Token\n     * Pools do this.\n     */\n    function _callMinimalSwapInfoPoolOnSwapHook(\n        IPoolSwapStructs.SwapRequest memory request,\n        IMinimalSwapInfoPool pool,\n        bytes32 tokenInBalance,\n        bytes32 tokenOutBalance\n    )\n        internal\n        returns (\n            bytes32 newTokenInBalance,\n            bytes32 newTokenOutBalance,\n            uint256 amountCalculated\n        )\n    {\n        uint256 tokenInTotal = tokenInBalance.total();\n        uint256 tokenOutTotal = tokenOutBalance.total();\n        request.lastChangeBlock = Math.max(tokenInBalance.lastChangeBlock(), tokenOutBalance.lastChangeBlock());\n\n        // Perform the swap request callback, and compute the new balances for \'token in\' and \'token out\' after the swap\n        amountCalculated = pool.onSwap(request, tokenInTotal, tokenOutTotal);\n        (uint256 amountIn, uint256 amountOut) = _getAmounts(request.kind, request.amount, amountCalculated);\n\n        newTokenInBalance = tokenInBalance.increaseCash(amountIn);\n        newTokenOutBalance = tokenOutBalance.decreaseCash(amountOut);\n    }\n\n    function _processGeneralPoolSwapRequest(IPoolSwapStructs.SwapRequest memory request, IGeneralPool pool)\n        private\n        returns (uint256 amountCalculated)\n    {\n        bytes32 tokenInBalance;\n        bytes32 tokenOutBalance;\n\n        // We access both token indexes without checking existence, because we will do it manually immediately after.\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[request.poolId];\n        uint256 indexIn = poolBalances.unchecked_indexOf(request.tokenIn);\n        uint256 indexOut = poolBalances.unchecked_indexOf(request.tokenOut);\n\n        if (indexIn == 0 || indexOut == 0) {\n            // The tokens might not be registered because the Pool itself is not registered. We check this to provide a\n            // more accurate revert reason.\n            _ensureRegisteredPool(request.poolId);\n            _revert(Errors.TOKEN_NOT_REGISTERED);\n        }\n\n        // EnumerableMap stores indices *plus one* to use the zero index as a sentinel value - because these are valid,\n        // we can undo this.\n        indexIn -= 1;\n        indexOut -= 1;\n\n        uint256 tokenAmount = poolBalances.length();\n        uint256[] memory currentBalances = new uint256[](tokenAmount);\n\n        request.lastChangeBlock = 0;\n        for (uint256 i = 0; i < tokenAmount; i++) {\n            // Because the iteration is bounded by `tokenAmount`, and no tokens are registered or deregistered here, we\n            // know `i` is a valid token index and can use `unchecked_valueAt` to save storage reads.\n            bytes32 balance = poolBalances.unchecked_valueAt(i);\n\n            currentBalances[i] = balance.total();\n            request.lastChangeBlock = Math.max(request.lastChangeBlock, balance.lastChangeBlock());\n\n            if (i == indexIn) {\n                tokenInBalance = balance;\n            } else if (i == indexOut) {\n                tokenOutBalance = balance;\n            }\n        }\n\n        // Perform the swap request callback and compute the new balances for \'token in\' and \'token out\' after the swap\n        amountCalculated = pool.onSwap(request, currentBalances, indexIn, indexOut);\n        (uint256 amountIn, uint256 amountOut) = _getAmounts(request.kind, request.amount, amountCalculated);\n        tokenInBalance = tokenInBalance.increaseCash(amountIn);\n        tokenOutBalance = tokenOutBalance.decreaseCash(amountOut);\n\n        // Because no tokens were registered or deregistered between now or when we retrieved the indexes for\n        // \'token in\' and \'token out\', we can use `unchecked_setAt` to save storage reads.\n        poolBalances.unchecked_setAt(indexIn, tokenInBalance);\n        poolBalances.unchecked_setAt(indexOut, tokenOutBalance);\n    }\n\n    // This function is not marked as `nonReentrant` because the underlying mechanism relies on reentrancy\n    function queryBatchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory funds\n    ) external override returns (int256[] memory) {\n        // In order to accurately \'simulate\' swaps, this function actually does perform the swaps, including calling the\n        // Pool hooks and updating balances in storage. However, once it computes the final Vault Deltas, it\n        // reverts unconditionally, returning this array as the revert data.\n        //\n        // By wrapping this reverting call, we can decode the deltas \'returned\' and return them as a normal Solidity\n        // function would. The only caveat is the function becomes non-view, but off-chain clients can still call it\n        // via eth_call to get the expected result.\n        //\n        // This technique was inspired by the work from the Gnosis team in the Gnosis Safe contract:\n        // https://github.com/gnosis/safe-contracts/blob/v1.2.0/contracts/GnosisSafe.sol#L265\n        //\n        // Most of this function is implemented using inline assembly, as the actual work it needs to do is not\n        // significant, and Solidity is not particularly well-suited to generate this behavior, resulting in a large\n        // amount of generated bytecode.\n\n        if (msg.sender != address(this)) {\n            // We perform an external call to ourselves, forwarding the same calldata. In this call, the else clause of\n            // the preceding if statement will be executed instead.\n\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = address(this).call(msg.data);\n\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                // This call should always revert to decode the actual asset deltas from the revert reason\n                switch success\n                    case 0 {\n                        // Note we are manually writing the memory slot 0. We can safely overwrite whatever is\n                        // stored there as we take full control of the execution and then immediately return.\n\n                        // We copy the first 4 bytes to check if it matches with the expected signature, otherwise\n                        // there was another revert reason and we should forward it.\n                        returndatacopy(0, 0, 0x04)\n                        let error := and(mload(0), 0xffffffff00000000000000000000000000000000000000000000000000000000)\n\n                        // If the first 4 bytes don\'t match with the expected signature, we forward the revert reason.\n                        if eq(eq(error, 0xfa61cc1200000000000000000000000000000000000000000000000000000000), 0) {\n                            returndatacopy(0, 0, returndatasize())\n                            revert(0, returndatasize())\n                        }\n\n                        // The returndata contains the signature, followed by the raw memory representation of an array:\n                        // length + data. We need to return an ABI-encoded representation of this array.\n                        // An ABI-encoded array contains an additional field when compared to its raw memory\n                        // representation: an offset to the location of the length. The offset itself is 32 bytes long,\n                        // so the smallest value we  can use is 32 for the data to be located immediately after it.\n                        mstore(0, 32)\n\n                        // We now copy the raw memory array from returndata into memory. Since the offset takes up 32\n                        // bytes, we start copying at address 0x20. We also get rid of the error signature, which takes\n                        // the first four bytes of returndata.\n                        let size := sub(returndatasize(), 0x04)\n                        returndatacopy(0x20, 0x04, size)\n\n                        // We finally return the ABI-encoded array, which has a total length equal to that of the array\n                        // (returndata), plus the 32 bytes for the offset.\n                        return(0, add(size, 32))\n                    }\n                    default {\n                        // This call should always revert, but we fail nonetheless if that didn\'t happen\n                        invalid()\n                    }\n            }\n        } else {\n            int256[] memory deltas = _swapWithPools(swaps, assets, funds, kind);\n\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                // We will return a raw representation of the array in memory, which is composed of a 32 byte length,\n                // followed by the 32 byte int256 values. Because revert expects a size in bytes, we multiply the array\n                // length (stored at `deltas`) by 32.\n                let size := mul(mload(deltas), 32)\n\n                // We send one extra value for the error signature ""QueryError(int256[])"" which is 0xfa61cc12.\n                // We store it in the previous slot to the `deltas` array. We know there will be at least one available\n                // slot due to how the memory scratch space works.\n                // We can safely overwrite whatever is stored in this slot as we will revert immediately after that.\n                mstore(sub(deltas, 0x20), 0x00000000000000000000000000000000000000000000000000000000fa61cc12)\n                let start := sub(deltas, 0x04)\n\n                // When copying from `deltas` into returndata, we copy an additional 36 bytes to also return the array\'s\n                // length and the error signature.\n                revert(start, add(size, 36))\n            }\n        }\n    }\n}\n'}, 'contracts/lib/openzeppelin/IERC20.sol': {'content': ""// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n""}, 'contracts/lib/helpers/BalancerErrors.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\n// solhint-disable\n\n/**\n * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\n * supported.\n */\nfunction _require(bool condition, uint256 errorCode) pure {\n    if (!condition) _revert(errorCode);\n}\n\n/**\n * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\n */\nfunction _revert(uint256 errorCode) pure {\n    // We\'re going to dynamically create a revert string based on the error code, with the following format:\n    // \'BAL#{errorCode}\'\n    // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).\n    //\n    // We don\'t have revert strings embedded in the contract to save bytecode size: it takes much less space to store a\n    // number (8 to 16 bits) than the individual string characters.\n    //\n    // The dynamic string creation algorithm that follows could be implemented in Solidity, but assembly allows for a\n    // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a\n    // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.\n    assembly {\n        // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-999\n        // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for\n        // the \'0\' character.\n\n        let units := add(mod(errorCode, 10), 0x30)\n\n        errorCode := div(errorCode, 10)\n        let tenths := add(mod(errorCode, 10), 0x30)\n\n        errorCode := div(errorCode, 10)\n        let hundreds := add(mod(errorCode, 10), 0x30)\n\n        // With the individual characters, we can now construct the full string. The ""BAL#"" part is a known constant\n        // (0x42414c23): we simply shift this by 24 (to provide space for the 3 bytes of the error code), and add the\n        // characters to it, each shifted by a multiple of 8.\n        // The revert reason is then shifted left by 200 bits (256 minus the length of the string, 7 characters * 8 bits\n        // per character = 56) to locate it in the most significant part of the 256 slot (the beginning of a byte\n        // array).\n\n        let revertReason := shl(200, add(0x42414c23000000, add(add(units, shl(8, tenths)), shl(16, hundreds))))\n\n        // We can now encode the reason in memory, which can be safely overwritten as we\'re about to revert. The encoded\n        // message will have the following layout:\n        // [ revert reason identifier ] [ string location offset ] [ string length ] [ string contents ]\n\n        // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(string) function. We\n        // also write zeroes to the next 28 bytes of memory, but those are about to be overwritten.\n        mstore(0x0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n        // Next is the offset to the location of the string, which will be placed immediately after (20 bytes away).\n        mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\n        // The string length is fixed: 7 characters.\n        mstore(0x24, 7)\n        // Finally, the string itself is stored.\n        mstore(0x44, revertReason)\n\n        // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of\n        // the encoded message is therefore 4 + 32 + 32 + 32 = 100.\n        revert(0, 100)\n    }\n}\n\nlibrary Errors {\n    // Math\n    uint256 internal constant ADD_OVERFLOW = 0;\n    uint256 internal constant SUB_OVERFLOW = 1;\n    uint256 internal constant SUB_UNDERFLOW = 2;\n    uint256 internal constant MUL_OVERFLOW = 3;\n    uint256 internal constant ZERO_DIVISION = 4;\n    uint256 internal constant DIV_INTERNAL = 5;\n    uint256 internal constant X_OUT_OF_BOUNDS = 6;\n    uint256 internal constant Y_OUT_OF_BOUNDS = 7;\n    uint256 internal constant PRODUCT_OUT_OF_BOUNDS = 8;\n    uint256 internal constant INVALID_EXPONENT = 9;\n\n    // Input\n    uint256 internal constant OUT_OF_BOUNDS = 100;\n    uint256 internal constant UNSORTED_ARRAY = 101;\n    uint256 internal constant UNSORTED_TOKENS = 102;\n    uint256 internal constant INPUT_LENGTH_MISMATCH = 103;\n    uint256 internal constant ZERO_TOKEN = 104;\n\n    // Shared pools\n    uint256 internal constant MIN_TOKENS = 200;\n    uint256 internal constant MAX_TOKENS = 201;\n    uint256 internal constant MAX_SWAP_FEE_PERCENTAGE = 202;\n    uint256 internal constant MIN_SWAP_FEE_PERCENTAGE = 203;\n    uint256 internal constant MINIMUM_BPT = 204;\n    uint256 internal constant CALLER_NOT_VAULT = 205;\n    uint256 internal constant UNINITIALIZED = 206;\n    uint256 internal constant BPT_IN_MAX_AMOUNT = 207;\n    uint256 internal constant BPT_OUT_MIN_AMOUNT = 208;\n    uint256 internal constant EXPIRED_PERMIT = 209;\n\n    // Pools\n    uint256 internal constant MIN_AMP = 300;\n    uint256 internal constant MAX_AMP = 301;\n    uint256 internal constant MIN_WEIGHT = 302;\n    uint256 internal constant MAX_STABLE_TOKENS = 303;\n    uint256 internal constant MAX_IN_RATIO = 304;\n    uint256 internal constant MAX_OUT_RATIO = 305;\n    uint256 internal constant MIN_BPT_IN_FOR_TOKEN_OUT = 306;\n    uint256 internal constant MAX_OUT_BPT_FOR_TOKEN_IN = 307;\n    uint256 internal constant NORMALIZED_WEIGHT_INVARIANT = 308;\n    uint256 internal constant INVALID_TOKEN = 309;\n    uint256 internal constant UNHANDLED_JOIN_KIND = 310;\n    uint256 internal constant ZERO_INVARIANT = 311;\n\n    // Lib\n    uint256 internal constant REENTRANCY = 400;\n    uint256 internal constant SENDER_NOT_ALLOWED = 401;\n    uint256 internal constant PAUSED = 402;\n    uint256 internal constant PAUSE_WINDOW_EXPIRED = 403;\n    uint256 internal constant MAX_PAUSE_WINDOW_DURATION = 404;\n    uint256 internal constant MAX_BUFFER_PERIOD_DURATION = 405;\n    uint256 internal constant INSUFFICIENT_BALANCE = 406;\n    uint256 internal constant INSUFFICIENT_ALLOWANCE = 407;\n    uint256 internal constant ERC20_TRANSFER_FROM_ZERO_ADDRESS = 408;\n    uint256 internal constant ERC20_TRANSFER_TO_ZERO_ADDRESS = 409;\n    uint256 internal constant ERC20_MINT_TO_ZERO_ADDRESS = 410;\n    uint256 internal constant ERC20_BURN_FROM_ZERO_ADDRESS = 411;\n    uint256 internal constant ERC20_APPROVE_FROM_ZERO_ADDRESS = 412;\n    uint256 internal constant ERC20_APPROVE_TO_ZERO_ADDRESS = 413;\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_ALLOWANCE = 414;\n    uint256 internal constant ERC20_DECREASED_ALLOWANCE_BELOW_ZERO = 415;\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_BALANCE = 416;\n    uint256 internal constant ERC20_BURN_EXCEEDS_ALLOWANCE = 417;\n    uint256 internal constant SAFE_ERC20_CALL_FAILED = 418;\n    uint256 internal constant ADDRESS_INSUFFICIENT_BALANCE = 419;\n    uint256 internal constant ADDRESS_CANNOT_SEND_VALUE = 420;\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_INT256 = 421;\n    uint256 internal constant GRANT_SENDER_NOT_ADMIN = 422;\n    uint256 internal constant REVOKE_SENDER_NOT_ADMIN = 423;\n    uint256 internal constant RENOUNCE_SENDER_NOT_ALLOWED = 424;\n    uint256 internal constant BUFFER_PERIOD_EXPIRED = 425;\n\n    // Vault\n    uint256 internal constant INVALID_POOL_ID = 500;\n    uint256 internal constant CALLER_NOT_POOL = 501;\n    uint256 internal constant SENDER_NOT_ASSET_MANAGER = 502;\n    uint256 internal constant USER_DOESNT_ALLOW_RELAYER = 503;\n    uint256 internal constant INVALID_SIGNATURE = 504;\n    uint256 internal constant EXIT_BELOW_MIN = 505;\n    uint256 internal constant JOIN_ABOVE_MAX = 506;\n    uint256 internal constant SWAP_LIMIT = 507;\n    uint256 internal constant SWAP_DEADLINE = 508;\n    uint256 internal constant CANNOT_SWAP_SAME_TOKEN = 509;\n    uint256 internal constant UNKNOWN_AMOUNT_IN_FIRST_SWAP = 510;\n    uint256 internal constant MALCONSTRUCTED_MULTIHOP_SWAP = 511;\n    uint256 internal constant INTERNAL_BALANCE_OVERFLOW = 512;\n    uint256 internal constant INSUFFICIENT_INTERNAL_BALANCE = 513;\n    uint256 internal constant INVALID_ETH_INTERNAL_BALANCE = 514;\n    uint256 internal constant INVALID_POST_LOAN_BALANCE = 515;\n    uint256 internal constant INSUFFICIENT_ETH = 516;\n    uint256 internal constant UNALLOCATED_ETH = 517;\n    uint256 internal constant ETH_TRANSFER = 518;\n    uint256 internal constant CANNOT_USE_ETH_SENTINEL = 519;\n    uint256 internal constant TOKENS_MISMATCH = 520;\n    uint256 internal constant TOKEN_NOT_REGISTERED = 521;\n    uint256 internal constant TOKEN_ALREADY_REGISTERED = 522;\n    uint256 internal constant TOKENS_ALREADY_SET = 523;\n    uint256 internal constant TOKENS_LENGTH_MUST_BE_2 = 524;\n    uint256 internal constant NONZERO_TOKEN_BALANCE = 525;\n    uint256 internal constant BALANCE_TOTAL_OVERFLOW = 526;\n    uint256 internal constant POOL_NO_TOKENS = 527;\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_BALANCE = 528;\n\n    // Fees\n    uint256 internal constant SWAP_FEE_PERCENTAGE_TOO_HIGH = 600;\n    uint256 internal constant FLASH_LOAN_FEE_PERCENTAGE_TOO_HIGH = 601;\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_FEE_AMOUNT = 602;\n}\n'}, 'contracts/lib/helpers/Authentication.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\nimport ""./BalancerErrors.sol"";\nimport ""./IAuthentication.sol"";\n\n/**\n * @dev Building block for performing access control on external functions.\n *\n * This contract is used via the `authenticate` modifier (or the `_authenticateCaller` function), which can be applied\n * to external functions to only make them callable by authorized accounts.\n *\n * Derived contracts must implement the `_canPerform` function, which holds the actual access control logic.\n */\nabstract contract Authentication is IAuthentication {\n    bytes32 private immutable _actionIdDisambiguator;\n\n    /**\n     * @dev The main purpose of the `actionIdDisambiguator` is to prevent accidental function selector collisions in\n     * multi contract systems.\n     *\n     * There are two main uses for it:\n     *  - if the contract is a singleton, any unique identifier can be used to make the associated action identifiers\n     *    unique. The contract\'s own address is a good option.\n     *  - if the contract belongs to a family that shares action identifiers for the same functions, an identifier\n     *    shared by the entire family (and no other contract) should be used instead.\n     */\n    constructor(bytes32 actionIdDisambiguator) {\n        _actionIdDisambiguator = actionIdDisambiguator;\n    }\n\n    /**\n     * @dev Reverts unless the caller is allowed to call this function. Should only be applied to external functions.\n     */\n    modifier authenticate() {\n        _authenticateCaller();\n        _;\n    }\n\n    /**\n     * @dev Reverts unless the caller is allowed to call the entry point function.\n     */\n    function _authenticateCaller() internal view {\n        bytes32 actionId = getActionId(msg.sig);\n        _require(_canPerform(actionId, msg.sender), Errors.SENDER_NOT_ALLOWED);\n    }\n\n    function getActionId(bytes4 selector) public view override returns (bytes32) {\n        // Each external function is dynamically assigned an action identifier as the hash of the disambiguator and the\n        // function selector. Disambiguation is necessary to avoid potential collisions in the function selectors of\n        // multiple contracts.\n        return keccak256(abi.encodePacked(_actionIdDisambiguator, selector));\n    }\n\n    function _canPerform(bytes32 actionId, address user) internal view virtual returns (bool);\n}\n'}, 'contracts/lib/helpers/TemporarilyPausable.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\nimport ""./BalancerErrors.sol"";\nimport ""./ITemporarilyPausable.sol"";\n\n/**\n * @dev Allows for a contract to be paused during an initial period after deployment, disabling functionality. Can be\n * used as an emergency switch in case a security vulnerability or threat is identified.\n *\n * The contract can only be paused during the Pause Window, a period that starts at deployment. It can also be\n * unpaused and repaused any number of times during this period. This is intended to serve as a safety measure: it lets\n * system managers react quickly to potentially dangerous situations, knowing that this action is reversible if careful\n * analysis later determines there was a false alarm.\n *\n * If the contract is paused when the Pause Window finishes, it will remain in the paused state through an additional\n * Buffer Period, after which it will be automatically unpaused forever. This is to ensure there is always enough time\n * to react to an emergency, even if the threat is discovered shortly before the Pause Window expires.\n *\n * Note that since the contract can only be paused within the Pause Window, unpausing during the Buffer Period is\n * irreversible.\n */\nabstract contract TemporarilyPausable is ITemporarilyPausable {\n    // The Pause Window and Buffer Period are timestamp-based: they should not be relied upon for sub-minute accuracy.\n    // solhint-disable not-rely-on-time\n\n    uint256 private constant _MAX_PAUSE_WINDOW_DURATION = 90 days;\n    uint256 private constant _MAX_BUFFER_PERIOD_DURATION = 30 days;\n\n    uint256 private immutable _pauseWindowEndTime;\n    uint256 private immutable _bufferPeriodEndTime;\n\n    bool private _paused;\n\n    constructor(uint256 pauseWindowDuration, uint256 bufferPeriodDuration) {\n        _require(pauseWindowDuration <= _MAX_PAUSE_WINDOW_DURATION, Errors.MAX_PAUSE_WINDOW_DURATION);\n        _require(bufferPeriodDuration <= _MAX_BUFFER_PERIOD_DURATION, Errors.MAX_BUFFER_PERIOD_DURATION);\n\n        uint256 pauseWindowEndTime = block.timestamp + pauseWindowDuration;\n\n        _pauseWindowEndTime = pauseWindowEndTime;\n        _bufferPeriodEndTime = pauseWindowEndTime + bufferPeriodDuration;\n    }\n\n    /**\n     * @dev Reverts if the contract is paused.\n     */\n    modifier whenNotPaused() {\n        _ensureNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Returns the current contract pause status, as well as the end times of the Pause Window and Buffer\n     * Period.\n     */\n    function getPausedState()\n        external\n        view\n        override\n        returns (\n            bool paused,\n            uint256 pauseWindowEndTime,\n            uint256 bufferPeriodEndTime\n        )\n    {\n        paused = !_isNotPaused();\n        pauseWindowEndTime = _getPauseWindowEndTime();\n        bufferPeriodEndTime = _getBufferPeriodEndTime();\n    }\n\n    /**\n     * @dev Sets the pause state to `paused`. The contract can only be paused until the end of the Pause Window, and\n     * unpaused until the end of the Buffer Period.\n     *\n     * Once the Buffer Period expires, this function reverts unconditionally.\n     */\n    function _setPaused(bool paused) internal {\n        if (paused) {\n            _require(block.timestamp < _getPauseWindowEndTime(), Errors.PAUSE_WINDOW_EXPIRED);\n        } else {\n            _require(block.timestamp < _getBufferPeriodEndTime(), Errors.BUFFER_PERIOD_EXPIRED);\n        }\n\n        _paused = paused;\n        emit PausedStateChanged(paused);\n    }\n\n    /**\n     * @dev Reverts if the contract is paused.\n     */\n    function _ensureNotPaused() internal view {\n        _require(_isNotPaused(), Errors.PAUSED);\n    }\n\n    /**\n     * @dev Returns true if the contract is unpaused.\n     *\n     * Once the Buffer Period expires, the gas cost of calling this function is reduced dramatically, as storage is no\n     * longer accessed.\n     */\n    function _isNotPaused() internal view returns (bool) {\n        // After the Buffer Period, the (inexpensive) timestamp check short-circuits the storage access.\n        return block.timestamp > _getBufferPeriodEndTime() || !_paused;\n    }\n\n    // These getters lead to reduced bytecode size by inlining the immutable variables in a single place.\n\n    function _getPauseWindowEndTime() private view returns (uint256) {\n        return _pauseWindowEndTime;\n    }\n\n    function _getBufferPeriodEndTime() private view returns (uint256) {\n        return _bufferPeriodEndTime;\n    }\n}\n'}, 'contracts/lib/helpers/SignaturesValidator.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\nimport ""./BalancerErrors.sol"";\nimport ""./ISignaturesValidator.sol"";\nimport ""../openzeppelin/EIP712.sol"";\n\n/**\n * @dev Utility for signing Solidity function calls.\n *\n * This contract relies on the fact that Solidity contracts can be called with extra calldata, and enables\n * meta-transaction schemes by appending an EIP712 signature of the original calldata at the end.\n *\n * Derived contracts must implement the `_typeHash` function to map function selectors to EIP712 structs.\n */\nabstract contract SignaturesValidator is ISignaturesValidator, EIP712 {\n    // The appended data consists of a deadline, plus the [v,r,s] signature. For simplicity, we use a full 256 bit slot\n    // for each of these values, even if \'v\' is typically an 8 bit value.\n    uint256 internal constant _EXTRA_CALLDATA_LENGTH = 4 * 32;\n\n    // Replay attack prevention for each user.\n    mapping(address => uint256) internal _nextNonce;\n\n    constructor(string memory name) EIP712(name, ""1"") {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function getDomainSeparator() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    function getNextNonce(address user) external view override returns (uint256) {\n        return _nextNonce[user];\n    }\n\n    /**\n     * @dev Reverts with `errorCode` unless a valid signature for `user` was appended to the calldata.\n     */\n    function _validateSignature(address user, uint256 errorCode) internal {\n        uint256 nextNonce = _nextNonce[user]++;\n        _require(_isSignatureValid(user, nextNonce), errorCode);\n    }\n\n    function _isSignatureValid(address user, uint256 nonce) private view returns (bool) {\n        uint256 deadline = _deadline();\n\n        // The deadline is timestamp-based: it should not be relied upon for sub-minute accuracy.\n        // solhint-disable-next-line not-rely-on-time\n        if (deadline < block.timestamp) {\n            return false;\n        }\n\n        bytes32 typeHash = _typeHash();\n        if (typeHash == bytes32(0)) {\n            // Prevent accidental signature validation for functions that don\'t have an associated type hash.\n            return false;\n        }\n\n        // All type hashes have this format: (bytes calldata, address sender, uint256 nonce, uint256 deadline).\n        bytes32 structHash = keccak256(abi.encode(typeHash, keccak256(_calldata()), msg.sender, nonce, deadline));\n        bytes32 digest = _hashTypedDataV4(structHash);\n        (uint8 v, bytes32 r, bytes32 s) = _signature();\n\n        address recoveredAddress = ecrecover(digest, v, r, s);\n\n        // ecrecover returns the zero address on recover failure, so we need to handle that explicitly.\n        return recoveredAddress != address(0) && recoveredAddress == user;\n    }\n\n    /**\n     * @dev Returns the EIP712 type hash for the current entry point function, which can be identified by its function\n     * selector (available as `msg.sig`).\n     *\n     * The type hash must conform to the following format:\n     *  <name>(bytes calldata, address sender, uint256 nonce, uint256 deadline)\n     *\n     * If 0x00, all signatures will be considered invalid.\n     */\n    function _typeHash() internal view virtual returns (bytes32);\n\n    /**\n     * @dev Extracts the signature deadline from extra calldata.\n     *\n     * This function returns bogus data if no signature is included.\n     */\n    function _deadline() internal pure returns (uint256) {\n        // The deadline is the first extra argument at the end of the original calldata.\n        return uint256(_decodeExtraCalldataWord(0));\n    }\n\n    /**\n     * @dev Extracts the signature parameters from extra calldata.\n     *\n     * This function returns bogus data if no signature is included. This is not a security risk, as that data would not\n     * be considered a valid signature in the first place.\n     */\n    function _signature()\n        internal\n        pure\n        returns (\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        )\n    {\n        // v, r and s are appended after the signature deadline, in that order.\n        v = uint8(uint256(_decodeExtraCalldataWord(0x20)));\n        r = _decodeExtraCalldataWord(0x40);\n        s = _decodeExtraCalldataWord(0x60);\n    }\n\n    /**\n     * @dev Returns the original calldata, without the extra bytes containing the signature.\n     *\n     * This function returns bogus data if no signature is included.\n     */\n    function _calldata() internal pure returns (bytes memory result) {\n        result = msg.data; // A calldata to memory assignment results in memory allocation and copy of contents.\n        if (result.length > _EXTRA_CALLDATA_LENGTH) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                // We simply overwrite the array length with the reduced one.\n                mstore(result, sub(calldatasize(), _EXTRA_CALLDATA_LENGTH))\n            }\n        }\n    }\n\n    /**\n     * @dev Returns a 256 bit word from \'extra\' calldata, at some offset from the expected end of the original calldata.\n     *\n     * This function returns bogus data if no signature is included.\n     */\n    function _decodeExtraCalldataWord(uint256 offset) private pure returns (bytes32 result) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            result := calldataload(add(sub(calldatasize(), _EXTRA_CALLDATA_LENGTH), offset))\n        }\n    }\n}\n'}, 'contracts/lib/openzeppelin/ReentrancyGuard.sol': {'content': '// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport ""../helpers/BalancerErrors.sol"";\n\n// Based on the ReentrancyGuard library from OpenZeppelin contracts, altered to reduce bytecode size.\n// Modifier code is inlined by the compiler, which causes its code to appear multiple times in the codebase. By using\n// private functions, we achieve the same end result with slightly higher runtime gas costs but reduced bytecode size.\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _enterNonReentrant();\n        _;\n        _exitNonReentrant();\n    }\n\n    function _enterNonReentrant() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        _require(_status != _ENTERED, Errors.REENTRANCY);\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _exitNonReentrant() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n'}, 'contracts/vault/interfaces/IVault.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma experimental ABIEncoderV2;\n\nimport ""../../lib/openzeppelin/IERC20.sol"";\n\nimport ""./IWETH.sol"";\nimport ""./IAsset.sol"";\nimport ""./IAuthorizer.sol"";\nimport ""./IFlashLoanRecipient.sol"";\nimport ""../ProtocolFeesCollector.sol"";\n\nimport ""../../lib/helpers/ISignaturesValidator.sol"";\nimport ""../../lib/helpers/ITemporarilyPausable.sol"";\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Full external interface for the Vault core contract - no external or public methods exist in the contract that\n * don\'t override one of these declarations.\n */\ninterface IVault is ISignaturesValidator, ITemporarilyPausable {\n    // Generalities about the Vault:\n    //\n    // - Whenever documentation refers to \'tokens\', it strictly refers to ERC20-compliant token contracts. Tokens are\n    // transferred out of the Vault by calling the `IERC20.transfer` function, and transferred in by calling\n    // `IERC20.transferFrom`. In these cases, the sender must have previously allowed the Vault to use their tokens by\n    // calling `IERC20.approve`. The only deviation from the ERC20 standard that is supported is functions not returning\n    // a boolean value: in these scenarios, a non-reverting call is assumed to be successful.\n    //\n    // - All non-view functions in the Vault are non-reentrant: calling them while another one is mid-execution (e.g.\n    // while execution control is transferred to a token contract during a swap) will result in a revert. View\n    // functions can be called in a re-reentrant way, but doing so might cause them to return inconsistent results.\n    // Contracts calling view functions in the Vault must make sure the Vault has not already been entered.\n    //\n    // - View functions revert if referring to either unregistered Pools, or unregistered tokens for registered Pools.\n\n    // Authorizer\n    //\n    // Some system actions are permissioned, like setting and collecting protocol fees. This permissioning system exists\n    // outside of the Vault in the Authorizer contract: the Vault simply calls the Authorizer to check if the caller\n    // can perform a given action.\n\n    /**\n     * @dev Returns the Vault\'s Authorizer.\n     */\n    function getAuthorizer() external view returns (IAuthorizer);\n\n    /**\n     * @dev Sets a new Authorizer for the Vault. The caller must be allowed by the current Authorizer to do this.\n     *\n     * Emits an `AuthorizerChanged` event.\n     */\n    function setAuthorizer(IAuthorizer newAuthorizer) external;\n\n    /**\n     * @dev Emitted when a new authorizer is set by `setAuthorizer`.\n     */\n    event AuthorizerChanged(IAuthorizer indexed newAuthorizer);\n\n    // Relayers\n    //\n    // Additionally, it is possible for an account to perform certain actions on behalf of another one, using their\n    // Vault ERC20 allowance and Internal Balance. These accounts are said to be \'relayers\' for these Vault functions,\n    // and are expected to be smart contracts with sound authentication mechanisms. For an account to be able to wield\n    // this power, two things must occur:\n    //  - The Authorizer must grant the account the permission to be a relayer for the relevant Vault function. This\n    //    means that Balancer governance must approve each individual contract to act as a relayer for the intended\n    //    functions.\n    //  - Each user must approve the relayer to act on their behalf.\n    // This double protection means users cannot be tricked into approving malicious relayers (because they will not\n    // have been allowed by the Authorizer via governance), nor can malicious relayers approved by a compromised\n    // Authorizer or governance drain user funds, since they would also need to be approved by each individual user.\n\n    /**\n     * @dev Returns true if `user` has approved `relayer` to act as a relayer for them.\n     */\n    function hasApprovedRelayer(address user, address relayer) external view returns (bool);\n\n    /**\n     * @dev Allows `relayer` to act as a relayer for `sender` if `approved` is true, and disallows it otherwise.\n     *\n     * Emits a `RelayerApprovalChanged` event.\n     */\n    function setRelayerApproval(\n        address sender,\n        address relayer,\n        bool approved\n    ) external;\n\n    /**\n     * @dev Emitted every time a relayer is approved or disapproved by `setRelayerApproval`.\n     */\n    event RelayerApprovalChanged(address indexed relayer, address indexed sender, bool approved);\n\n    // Internal Balance\n    //\n    // Users can deposit tokens into the Vault, where they are allocated to their Internal Balance, and later\n    // transferred or withdrawn. It can also be used as a source of tokens when joining Pools, as a destination\n    // when exiting them, and as either when performing swaps. This usage of Internal Balance results in greatly reduced\n    // gas costs when compared to relying on plain ERC20 transfers, leading to large savings for frequent users.\n    //\n    // Internal Balance management features batching, which means a single contract call can be used to perform multiple\n    // operations of different kinds, with different senders and recipients, at once.\n\n    /**\n     * @dev Returns `user`\'s Internal Balance for a set of tokens.\n     */\n    function getInternalBalance(address user, IERC20[] memory tokens) external view returns (uint256[] memory);\n\n    /**\n     * @dev Performs a set of user balance operations, which involve Internal Balance (deposit, withdraw or transfer)\n     * and plain ERC20 transfers using the Vault\'s allowance. This last feature is particularly useful for relayers, as\n     * it lets integrators reuse a user\'s Vault allowance.\n     *\n     * For each operation, if the caller is not `sender`, it must be an authorized relayer for them.\n     */\n    function manageUserBalance(UserBalanceOp[] memory ops) external payable;\n\n    /**\n     * @dev Data for `manageUserBalance` operations, which include the possibility for ETH to be sent and received\n     without manual WETH wrapping or unwrapping.\n     */\n    struct UserBalanceOp {\n        UserBalanceOpKind kind;\n        IAsset asset;\n        uint256 amount;\n        address sender;\n        address payable recipient;\n    }\n\n    // There are four possible operations in `manageUserBalance`:\n    //\n    // - DEPOSIT_INTERNAL\n    // Increases the Internal Balance of the `recipient` account by transferring tokens from the corresponding\n    // `sender`. The sender must have allowed the Vault to use their tokens via `IERC20.approve()`.\n    //\n    // ETH can be used by passing the ETH sentinel value as the asset and forwarding ETH in the call: it will be wrapped\n    // and deposited as WETH. Any ETH amount remaining will be sent back to the caller (not the sender, which is\n    // relevant for relayers).\n    //\n    // Emits an `InternalBalanceChanged` event.\n    //\n    //\n    // - WITHDRAW_INTERNAL\n    // Decreases the Internal Balance of the `sender` account by transferring tokens to the `recipient`.\n    //\n    // ETH can be used by passing the ETH sentinel value as the asset. This will deduct WETH instead, unwrap it and send\n    // it to the recipient as ETH.\n    //\n    // Emits an `InternalBalanceChanged` event.\n    //\n    //\n    // - TRANSFER_INTERNAL\n    // Transfers tokens from the Internal Balance of the `sender` account to the Internal Balance of `recipient`.\n    //\n    // Reverts if the ETH sentinel value is passed.\n    //\n    // Emits an `InternalBalanceChanged` event.\n    //\n    //\n    // - TRANSFER_EXTERNAL\n    // Transfers tokens from `sender` to `recipient`, using the Vault\'s ERC20 allowance. This is typically used by\n    // relayers, as it lets them reuse a user\'s Vault allowance.\n    //\n    // Reverts if the ETH sentinel value is passed.\n    //\n    // Emits an `ExternalBalanceTransfer` event.\n\n    enum UserBalanceOpKind { DEPOSIT_INTERNAL, WITHDRAW_INTERNAL, TRANSFER_INTERNAL, TRANSFER_EXTERNAL }\n\n    /**\n     * @dev Emitted when a user\'s Internal Balance changes, either from calls to `manageUserBalance`, or through\n     * interacting with Pools using Internal Balance.\n     *\n     * Because Internal Balance works exclusively with ERC20 tokens, ETH deposits and withdrawals will use the WETH\n     * address.\n     */\n    event InternalBalanceChanged(address indexed user, IERC20 indexed token, int256 delta);\n\n    /**\n     * @dev Emitted when a user\'s Vault ERC20 allowance is used by the Vault to transfer tokens to an external account.\n     */\n    event ExternalBalanceTransfer(IERC20 indexed token, address indexed sender, address recipient, uint256 amount);\n\n    // Pools\n    //\n    // There are three specialization settings for Pools, which allow for cheaper swaps at the cost of reduced\n    // functionality:\n    //\n    //  - General: no specialization, suited for all Pools. IGeneralPool is used for swap request callbacks, passing the\n    // balance of all tokens in the Pool. These Pools have the largest swap costs (because of the extra storage reads),\n    // which increase with the number of registered tokens.\n    //\n    //  - Minimal Swap Info: IMinimalSwapInfoPool is used instead of IGeneralPool, which saves gas by only passing the\n    // balance of the two tokens involved in the swap. This is suitable for some pricing algorithms, like the weighted\n    // constant product one popularized by Balancer V1. Swap costs are smaller compared to general Pools, and are\n    // independent of the number of registered tokens.\n    //\n    //  - Two Token: only allows two tokens to be registered. This achieves the lowest possible swap gas cost. Like\n    // minimal swap info Pools, these are called via IMinimalSwapInfoPool.\n\n    enum PoolSpecialization { GENERAL, MINIMAL_SWAP_INFO, TWO_TOKEN }\n\n    /**\n     * @dev Registers the caller account as a Pool with a given specialization setting. Returns the Pool\'s ID, which\n     * is used in all Pool-related functions. Pools cannot be deregistered, nor can the Pool\'s specialization be\n     * changed.\n     *\n     * The caller is expected to be a smart contract that implements either `IGeneralPool` or `IMinimalSwapInfoPool`,\n     * depending on the chosen specialization setting. This contract is known as the Pool\'s contract.\n     *\n     * Note that the same contract may register itself as multiple Pools with unique Pool IDs, or in other words,\n     * multiple Pools may share the same contract.\n     *\n     * Emits a `PoolRegistered` event.\n     */\n    function registerPool(PoolSpecialization specialization) external returns (bytes32);\n\n    /**\n     * @dev Emitted when a Pool is registered by calling `registerPool`.\n     */\n    event PoolRegistered(bytes32 indexed poolId, address indexed poolAddress, PoolSpecialization specialization);\n\n    /**\n     * @dev Returns a Pool\'s contract address and specialization setting.\n     */\n    function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\n\n    /**\n     * @dev Registers `tokens` for the `poolId` Pool. Must be called by the Pool\'s contract.\n     *\n     * Pools can only interact with tokens they have registered. Users join a Pool by transferring registered tokens,\n     * exit by receiving registered tokens, and can only swap registered tokens.\n     *\n     * Each token can only be registered once. For Pools with the Two Token specialization, `tokens` must have a length\n     * of two, that is, both tokens must be registered in the same `registerTokens` call, and they must be sorted in\n     * ascending order.\n     *\n     * The `tokens` and `assetManagers` arrays must have the same length, and each entry in these indicates the Asset\n     * Manager for the corresponding token. Asset Managers can manage a Pool\'s tokens via `managePoolBalance`,\n     * depositing and withdrawing them directly, and can even set their balance to arbitrary amounts. They are therefore\n     * expected to be highly secured smart contracts with sound design principles, and the decision to register an\n     * Asset Manager should not be made lightly.\n     *\n     * Pools can choose not to assign an Asset Manager to a given token by passing in the zero address. Once an Asset\n     * Manager is set, it cannot be changed except by deregistering the associated token and registering again with a\n     * different Asset Manager.\n     *\n     * Emits a `TokensRegistered` event.\n     */\n    function registerTokens(\n        bytes32 poolId,\n        IERC20[] memory tokens,\n        address[] memory assetManagers\n    ) external;\n\n    /**\n     * @dev Emitted when a Pool registers tokens by calling `registerTokens`.\n     */\n    event TokensRegistered(bytes32 indexed poolId, IERC20[] tokens, address[] assetManagers);\n\n    /**\n     * @dev Deregisters `tokens` for the `poolId` Pool. Must be called by the Pool\'s contract.\n     *\n     * Only registered tokens (via `registerTokens`) can be deregistered. Additionally, they must have zero total\n     * balance. For Pools with the Two Token specialization, `tokens` must have a length of two, that is, both tokens\n     * must be deregistered in the same `deregisterTokens` call.\n     *\n     * A deregistered token can be re-registered later on, possibly with a different Asset Manager.\n     *\n     * Emits a `TokensDeregistered` event.\n     */\n    function deregisterTokens(bytes32 poolId, IERC20[] memory tokens) external;\n\n    /**\n     * @dev Emitted when a Pool deregisters tokens by calling `deregisterTokens`.\n     */\n    event TokensDeregistered(bytes32 indexed poolId, IERC20[] tokens);\n\n    /**\n     * @dev Returns detailed information for a Pool\'s registered token.\n     *\n     * `cash` is the number of tokens the Vault currently holds for the Pool. `managed` is the number of tokens\n     * withdrawn and held outside the Vault by the Pool\'s token Asset Manager. The Pool\'s total balance for `token`\n     * equals the sum of `cash` and `managed`.\n     *\n     * Internally, `cash` and `managed` are stored using 112 bits. No action can ever cause a Pool\'s token `cash`,\n     * `managed` or `total` balance to be greater than 2^112 - 1.\n     *\n     * `lastChangeBlock` is the number of the block in which `token`\'s total balance was last modified (via either a\n     * join, exit, swap, or Asset Manager update). This value is useful to avoid so-called \'sandwich attacks\', for\n     * example when developing price oracles. A change of zero (e.g. caused by a swap with amount zero) is considered a\n     * change for this purpose, and will update `lastChangeBlock`.\n     *\n     * `assetManager` is the Pool\'s token Asset Manager.\n     */\n    function getPoolTokenInfo(bytes32 poolId, IERC20 token)\n        external\n        view\n        returns (\n            uint256 cash,\n            uint256 managed,\n            uint256 lastChangeBlock,\n            address assetManager\n        );\n\n    /**\n     * @dev Returns a Pool\'s registered tokens, the total balance for each, and the latest block when *any* of\n     * the tokens\' `balances` changed.\n     *\n     * The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all\n     * Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order.\n     *\n     * If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same\n     * order as passed to `registerTokens`.\n     *\n     * Total balances include both tokens held by the Vault and those withdrawn by the Pool\'s Asset Managers. These are\n     * the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo`\n     * instead.\n     */\n    function getPoolTokens(bytes32 poolId)\n        external\n        view\n        returns (\n            IERC20[] memory tokens,\n            uint256[] memory balances,\n            uint256 lastChangeBlock\n        );\n\n    /**\n     * @dev Called by users to join a Pool, which transfers tokens from `sender` into the Pool\'s balance. This will\n     * trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized\n     * Pool shares.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount\n     * to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces\n     * these maximums.\n     *\n     * If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable\n     * this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the\n     * WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent\n     * back to the caller (not the sender, which is important for relayers).\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be\n     * sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final\n     * `assets` array might not be sorted. Pools with no registered tokens cannot be joined.\n     *\n     * If `fromInternalBalance` is true, the caller\'s Internal Balance will be preferred: ERC20 transfers will only\n     * be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be\n     * withdrawn from Internal Balance: attempting to do so will trigger a revert.\n     *\n     * This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool\'s contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed\n     * directly to the Pool\'s contract, as is `recipient`.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     */\n    function joinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        JoinPoolRequest memory request\n    ) external payable;\n\n    struct JoinPoolRequest {\n        IAsset[] assets;\n        uint256[] maxAmountsIn;\n        bytes userData;\n        bool fromInternalBalance;\n    }\n\n    /**\n     * @dev Called by users to exit a Pool, which transfers tokens from the Pool\'s balance to `recipient`. This will\n     * trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized\n     * Pool shares. The amount of tokens that can be withdrawn is limited by the Pool\'s `cash` balance (see\n     * `getPoolTokenInfo`).\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum\n     * token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault:\n     * it just enforces these minimums.\n     *\n     * If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To\n     * enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead\n     * of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit.\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must\n     * be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the\n     * final `assets` array might not be sorted. Pools with no registered tokens cannot be exited.\n     *\n     * If `toInternalBalance` is true, the tokens will be deposited to `recipient`\'s Internal Balance. Otherwise,\n     * an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to\n     * do so will trigger a revert.\n     *\n     * `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the\n     * `tokens` array. This array must match the Pool\'s registered tokens.\n     *\n     * This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool\'s contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and\n     * passed directly to the Pool\'s contract.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     */\n    function exitPool(\n        bytes32 poolId,\n        address sender,\n        address payable recipient,\n        ExitPoolRequest memory request\n    ) external;\n\n    struct ExitPoolRequest {\n        IAsset[] assets;\n        uint256[] minAmountsOut;\n        bytes userData;\n        bool toInternalBalance;\n    }\n\n    /**\n     * @dev Emitted when a user joins or exits a Pool by calling `joinPool` or `exitPool`, respectively.\n     */\n    event PoolBalanceChanged(\n        bytes32 indexed poolId,\n        address indexed liquidityProvider,\n        IERC20[] tokens,\n        int256[] deltas,\n        uint256[] protocolFeeAmounts\n    );\n\n    enum PoolBalanceChangeKind { JOIN, EXIT }\n\n    // Swaps\n    //\n    // Users can swap tokens with Pools by calling the `swap` and `batchSwap` functions. To do this,\n    // they need not trust Pool contracts in any way: all security checks are made by the Vault. They must however be\n    // aware of the Pools\' pricing algorithms in order to estimate the prices Pools will quote.\n    //\n    // The `swap` function executes a single swap, while `batchSwap` can perform multiple swaps in sequence.\n    // In each individual swap, tokens of one kind are sent from the sender to the Pool (this is the \'token in\'),\n    // and tokens of another kind are sent from the Pool to the recipient in exchange (this is the \'token out\').\n    // More complex swaps, such as one token in to multiple tokens out can be achieved by batching together\n    // individual swaps.\n    //\n    // There are two swap kinds:\n    //  - \'given in\' swaps, where the amount of tokens in (sent to the Pool) is known, and the Pool determines (via the\n    // `onSwap` hook) the amount of tokens out (to send to the recipient).\n    //  - \'given out\' swaps, where the amount of tokens out (received from the Pool) is known, and the Pool determines\n    // (via the `onSwap` hook) the amount of tokens in (to receive from the sender).\n    //\n    // Additionally, it is possible to chain swaps using a placeholder input amount, which the Vault replaces with\n    // the calculated output of the previous swap. If the previous swap was \'given in\', this will be the calculated\n    // tokenOut amount. If the previous swap was \'given out\', it will use the calculated tokenIn amount. These extended\n    // swaps are known as \'multihop\' swaps, since they \'hop\' through a number of intermediate tokens before arriving at\n    // the final intended token.\n    //\n    // In all cases, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into Internal\n    // Balance) after all individual swaps have been completed, and the net token balance change computed. This makes\n    // certain swap patterns, such as multihops, or swaps that interact with the same token pair in multiple Pools, cost\n    // much less gas than they would otherwise.\n    //\n    // It also means that under certain conditions it is possible to perform arbitrage by swapping with multiple\n    // Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (only\n    // updating the Pool\'s internal accounting).\n    //\n    // To protect users from front-running or the market changing rapidly, they supply a list of \'limits\' for each token\n    // involved in the swap, where either the maximum number of tokens to send (by passing a positive value) or the\n    // minimum amount of tokens to receive (by passing a negative value) is specified.\n    //\n    // Additionally, a \'deadline\' timestamp can also be provided, forcing the swap to fail if it occurs after\n    // this point in time (e.g. if the transaction failed to be included in a block promptly).\n    //\n    // If interacting with Pools that hold WETH, it is possible to both send and receive ETH directly: the Vault will do\n    // the wrapping and unwrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be\n    // passed in the `assets` array instead of the WETH address. Note that it is possible to combine ETH and WETH in the\n    // same swap. Any excess ETH will be sent back to the caller (not the sender, which is relevant for relayers).\n    //\n    // Finally, Internal Balance can be used when either sending or receiving tokens.\n\n    enum SwapKind { GIVEN_IN, GIVEN_OUT }\n\n    /**\n     * @dev Performs a swap with a single Pool.\n     *\n     * If the swap is \'given in\' (the number of tokens to send to the Pool is known), it returns the amount of tokens\n     * taken from the Pool, which must be greater than or equal to `limit`.\n     *\n     * If the swap is \'given out\' (the number of tokens to take from the Pool is known), it returns the amount of tokens\n     * sent to the Pool, which must be less than or equal to `limit`.\n     *\n     * Internal Balance usage and the recipient are determined by the `funds` struct.\n     *\n     * Emits a `Swap` event.\n     */\n    function swap(\n        SingleSwap memory singleSwap,\n        FundManagement memory funds,\n        uint256 limit,\n        uint256 deadline\n    ) external payable returns (uint256);\n\n    /**\n     * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\n     * the `kind` value.\n     *\n     * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\n     * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n    struct SingleSwap {\n        bytes32 poolId;\n        SwapKind kind;\n        IAsset assetIn;\n        IAsset assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n\n    /**\n     * @dev Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either\n     * the amount of tokens sent to or received from the Pool, depending on the `kind` value.\n     *\n     * Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the\n     * Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at\n     * the same index in the `assets` array.\n     *\n     * Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a\n     * Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or\n     * `amountOut` depending on the swap kind.\n     *\n     * Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out\n     * of the previous swap to be used as the amount in for the current one. In a \'given in\' swap, \'tokenIn\' must equal\n     * the previous swap\'s `tokenOut`. For a \'given out\' swap, `tokenOut` must equal the previous swap\'s `tokenIn`.\n     *\n     * The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses,\n     * or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and\n     * out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to\n     * or unwrapped from WETH by the Vault.\n     *\n     * Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies\n     * the minimum or maximum amount of each token the vault is allowed to transfer.\n     *\n     * `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the\n     * equivalent `swap` call.\n     *\n     * Emits `Swap` events.\n     */\n    function batchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory funds,\n        int256[] memory limits,\n        uint256 deadline\n    ) external payable returns (int256[] memory);\n\n    /**\n     * @dev Data for each individual swap executed by `batchSwap`. The asset in and out fields are indexes into the\n     * `assets` array passed to that function, and ETH assets are converted to WETH.\n     *\n     * If `amount` is zero, the multihop mechanism is used to determine the actual amount based on the amount in/out\n     * from the previous swap, depending on the swap kind.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n    struct BatchSwapStep {\n        bytes32 poolId;\n        uint256 assetInIndex;\n        uint256 assetOutIndex;\n        uint256 amount;\n        bytes userData;\n    }\n\n    /**\n     * @dev Emitted for each individual swap performed by `swap` or `batchSwap`.\n     */\n    event Swap(\n        bytes32 indexed poolId,\n        IERC20 indexed tokenIn,\n        IERC20 indexed tokenOut,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n\n    /**\n     * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\n     * `recipient` account.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * If `fromInternalBalance` is true, the `sender`\'s Internal Balance will be preferred, performing an ERC20\n     * transfer for the difference between the requested amount and the User\'s Internal Balance (if any). The `sender`\n     * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\n     * `joinPool`.\n     *\n     * If `toInternalBalance` is true, tokens will be deposited to `recipient`\'s internal balance instead of\n     * transferred. This matches the behavior of `exitPool`.\n     *\n     * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\n     * revert.\n     */\n    struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address payable recipient;\n        bool toInternalBalance;\n    }\n\n    /**\n     * @dev Simulates a call to `batchSwap`, returning an array of Vault asset deltas. Calls to `swap` cannot be\n     * simulated directly, but an equivalent `batchSwap` call can and will yield the exact same result.\n     *\n     * Each element in the array corresponds to the asset at the same index, and indicates the number of tokens (or ETH)\n     * the Vault would take from the sender (if positive) or send to the recipient (if negative). The arguments it\n     * receives are the same that an equivalent `batchSwap` call would receive.\n     *\n     * Unlike `batchSwap`, this function performs no checks on the sender or recipient field in the `funds` struct.\n     * This makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens,\n     * approve them for the Vault, or even know a user\'s address.\n     *\n     * Note that this function is not \'view\' (due to implementation details): the client code must explicitly execute\n     * eth_call instead of eth_sendTransaction.\n     */\n    function queryBatchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory funds\n    ) external returns (int256[] memory assetDeltas);\n\n    // Flash Loans\n\n    /**\n     * @dev Performs a \'flash loan\', sending tokens to `recipient`, executing the `receiveFlashLoan` hook on it,\n     * and then reverting unless the tokens plus a proportional protocol fee have been returned.\n     *\n     * The `tokens` and `amounts` arrays must have the same length, and each entry in these indicates the loan amount\n     * for each token contract. `tokens` must be sorted in ascending order.\n     *\n     * The \'userData\' field is ignored by the Vault, and forwarded as-is to `recipient` as part of the\n     * `receiveFlashLoan` call.\n     *\n     * Emits `FlashLoan` events.\n     */\n    function flashLoan(\n        IFlashLoanRecipient recipient,\n        IERC20[] memory tokens,\n        uint256[] memory amounts,\n        bytes memory userData\n    ) external;\n\n    /**\n     * @dev Emitted for each individual flash loan performed by `flashLoan`.\n     */\n    event FlashLoan(IFlashLoanRecipient indexed recipient, IERC20 indexed token, uint256 amount, uint256 feeAmount);\n\n    // Asset Management\n    //\n    // Each token registered for a Pool can be assigned an Asset Manager, which is able to freely withdraw the Pool\'s\n    // tokens from the Vault, deposit them, or assign arbitrary values to its `managed` balance (see\n    // `getPoolTokenInfo`). This makes them extremely powerful and dangerous. Even if an Asset Manager only directly\n    // controls one of the tokens in a Pool, a malicious manager could set that token\'s balance to manipulate the\n    // prices of the other tokens, and then drain the Pool with swaps. The risk of using Asset Managers is therefore\n    // not constrained to the tokens they are managing, but extends to the entire Pool\'s holdings.\n    //\n    // However, a properly designed Asset Manager smart contract can be safely used for the Pool\'s benefit,\n    // for example by lending unused tokens out for interest, or using them to participate in voting protocols.\n    //\n    // This concept is unrelated to the IAsset interface.\n\n    /**\n     * @dev Performs a set of Pool balance operations, which may be either withdrawals, deposits or updates.\n     *\n     * Pool Balance management features batching, which means a single contract call can be used to perform multiple\n     * operations of different kinds, with different Pools and tokens, at once.\n     *\n     * For each operation, the caller must be registered as the Asset Manager for `token` in `poolId`.\n     */\n    function managePoolBalance(PoolBalanceOp[] memory ops) external;\n\n    struct PoolBalanceOp {\n        PoolBalanceOpKind kind;\n        bytes32 poolId;\n        IERC20 token;\n        uint256 amount;\n    }\n\n    /**\n     * Withdrawals decrease the Pool\'s cash, but increase its managed balance, leaving the total balance unchanged.\n     *\n     * Deposits increase the Pool\'s cash, but decrease its managed balance, leaving the total balance unchanged.\n     *\n     * Updates don\'t affect the Pool\'s cash balance, but because the managed balance changes, it does alter the total.\n     * The external amount can be either increased or decreased by this call (i.e., reporting a gain or a loss).\n     */\n    enum PoolBalanceOpKind { WITHDRAW, DEPOSIT, UPDATE }\n\n    /**\n     * @dev Emitted when a Pool\'s token Asset Manager alters its balance via `managePoolBalance`.\n     */\n    event PoolBalanceManaged(\n        bytes32 indexed poolId,\n        address indexed assetManager,\n        IERC20 indexed token,\n        int256 cashDelta,\n        int256 managedDelta\n    );\n\n    // Protocol Fees\n    //\n    // Some operations cause the Vault to collect tokens in the form of protocol fees, which can then be withdrawn by\n    // permissioned accounts.\n    //\n    // There are two kinds of protocol fees:\n    //\n    //  - flash loan fees: charged on all flash loans, as a percentage of the amounts lent.\n    //\n    //  - swap fees: a percentage of the fees charged by Pools when performing swaps. For a number of reasons, including\n    // swap gas costs and interface simplicity, protocol swap fees are not charged on each individual swap. Rather,\n    // Pools are expected to keep track of how much they have charged in swap fees, and pay any outstanding debts to the\n    // Vault when they are joined or exited. This prevents users from joining a Pool with unpaid debt, as well as\n    // exiting a Pool in debt without first paying their share.\n\n    /**\n     * @dev Returns the current protocol fee module.\n     */\n    function getProtocolFeesCollector() external view returns (ProtocolFeesCollector);\n\n    /**\n     * @dev Safety mechanism to pause most Vault operations in the event of an emergency - typically detection of an\n     * error in some part of the system.\n     *\n     * The Vault can only be paused during an initial time period, after which pausing is forever disabled.\n     *\n     * While the contract is paused, the following features are disabled:\n     * - depositing and transferring internal balance\n     * - transferring external balance (using the Vault\'s allowance)\n     * - swaps\n     * - joining Pools\n     * - Asset Manager interactions\n     *\n     * Internal Balance can still be withdrawn, and Pools exited.\n     */\n    function setPaused(bool paused) external;\n\n    /**\n     * @dev Returns the Vault\'s WETH instance.\n     */\n    function WETH() external view returns (IWETH);\n    // solhint-disable-previous-line func-name-mixedcase\n}\n'}, 'contracts/lib/helpers/IAuthentication.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\ninterface IAuthentication {\n    /**\n     * @dev Returns the action identifier associated with the external function described by `selector`.\n     */\n    function getActionId(bytes4 selector) external view returns (bytes32);\n}\n'}, 'contracts/lib/helpers/ITemporarilyPausable.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Interface for the TemporarilyPausable helper.\n */\ninterface ITemporarilyPausable {\n    /**\n     * @dev Emitted every time the pause state changes by `_setPaused`.\n     */\n    event PausedStateChanged(bool paused);\n\n    /**\n     * @dev Returns the current paused state.\n     */\n    function getPausedState()\n        external\n        view\n        returns (\n            bool paused,\n            uint256 pauseWindowEndTime,\n            uint256 bufferPeriodEndTime\n        );\n}\n'}, 'contracts/lib/helpers/ISignaturesValidator.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Interface for the SignatureValidator helper, used to support meta-transactions.\n */\ninterface ISignaturesValidator {\n    /**\n     * @dev Returns the EIP712 domain separator.\n     */\n    function getDomainSeparator() external view returns (bytes32);\n\n    /**\n     * @dev Returns the next nonce used by an address to sign messages.\n     */\n    function getNextNonce(address user) external view returns (uint256);\n}\n'}, 'contracts/lib/openzeppelin/EIP712.sol': {'content': '// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as ""v4"", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _HASHED_NAME = keccak256(bytes(name));\n        _HASHED_VERSION = keccak256(bytes(version));\n        _TYPE_HASH = keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"");\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view virtual returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION, _getChainId(), address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(""Mail(address to,string contents)""),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return keccak256(abi.encodePacked(""\\x19\\x01"", _domainSeparatorV4(), structHash));\n    }\n\n    function _getChainId() private view returns (uint256 chainId) {\n        // Silence state mutability warning without generating bytecode.\n        // See https://github.com/ethereum/solidity/issues/10090#issuecomment-741789128 and\n        // https://github.com/ethereum/solidity/issues/2691\n        this;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n    }\n}\n'}, 'contracts/vault/interfaces/IAsset.sol': {'content': ""// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\n/**\n * @dev This is an empty interface used to represent either ERC20-conforming token contracts or ETH (using the zero\n * address sentinel value). We're just relying on the fact that `interface` can be used to declare new address-like\n * types.\n *\n * This concept is unrelated to a Pool's Asset Managers.\n */\ninterface IAsset {\n    // solhint-disable-previous-line no-empty-blocks\n}\n""}, 'contracts/vault/interfaces/IFlashLoanRecipient.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\n// Inspired by Aave Protocol\'s IFlashLoanReceiver.\n\nimport ""../../lib/openzeppelin/IERC20.sol"";\n\ninterface IFlashLoanRecipient {\n    /**\n     * @dev When `flashLoan` is called on the Vault, it invokes the `receiveFlashLoan` hook on the recipient.\n     *\n     * At the time of the call, the Vault will have transferred `amounts` for `tokens` to the recipient. Before this\n     * call returns, the recipient must have transferred `amounts` plus `feeAmounts` for each token back to the\n     * Vault, or else the entire flash loan will revert.\n     *\n     * `userData` is the same value passed in the `IVault.flashLoan` call.\n     */\n    function receiveFlashLoan(\n        IERC20[] memory tokens,\n        uint256[] memory amounts,\n        uint256[] memory feeAmounts,\n        bytes memory userData\n    ) external;\n}\n'}, 'contracts/vault/ProtocolFeesCollector.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport ""../lib/openzeppelin/IERC20.sol"";\nimport ""../lib/helpers/InputHelpers.sol"";\nimport ""../lib/helpers/Authentication.sol"";\nimport ""../lib/openzeppelin/ReentrancyGuard.sol"";\nimport ""../lib/openzeppelin/SafeERC20.sol"";\n\nimport ""./interfaces/IVault.sol"";\nimport ""./interfaces/IAuthorizer.sol"";\n\n/**\n * @dev This an auxiliary contract to the Vault, deployed by it during construction. It offloads some of the tasks the\n * Vault performs to reduce its overall bytecode size.\n *\n * The current values for all protocol fee percentages are stored here, and any tokens charged as protocol fees are\n * sent to this contract, where they may be withdrawn by authorized entities. All authorization tasks are delegated\n * to the Vault\'s own authorizer.\n */\ncontract ProtocolFeesCollector is Authentication, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // Absolute maximum fee percentages (1e18 = 100%, 1e16 = 1%).\n    uint256 private constant _MAX_PROTOCOL_SWAP_FEE_PERCENTAGE = 50e16; // 50%\n    uint256 private constant _MAX_PROTOCOL_FLASH_LOAN_FEE_PERCENTAGE = 1e16; // 1%\n\n    IVault public immutable vault;\n\n    // All fee percentages are 18-decimal fixed point numbers.\n\n    // The swap fee is charged whenever a swap occurs, as a percentage of the fee charged by the Pool. These are not\n    // actually charged on each individual swap: the `Vault` relies on the Pools being honest and reporting fees due\n    // when users join and exit them.\n    uint256 private _swapFeePercentage;\n\n    // The flash loan fee is charged whenever a flash loan occurs, as a percentage of the tokens lent.\n    uint256 private _flashLoanFeePercentage;\n\n    event SwapFeePercentageChanged(uint256 newSwapFeePercentage);\n    event FlashLoanFeePercentageChanged(uint256 newFlashLoanFeePercentage);\n\n    constructor(IVault _vault)\n        // The ProtocolFeesCollector is a singleton, so it simply uses its own address to disambiguate action\n        // identifiers.\n        Authentication(bytes32(uint256(address(this))))\n    {\n        vault = _vault;\n    }\n\n    function withdrawCollectedFees(\n        IERC20[] calldata tokens,\n        uint256[] calldata amounts,\n        address recipient\n    ) external nonReentrant authenticate {\n        InputHelpers.ensureInputLengthMatch(tokens.length, amounts.length);\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            IERC20 token = tokens[i];\n            uint256 amount = amounts[i];\n            token.safeTransfer(recipient, amount);\n        }\n    }\n\n    function setSwapFeePercentage(uint256 newSwapFeePercentage) external authenticate {\n        _require(newSwapFeePercentage <= _MAX_PROTOCOL_SWAP_FEE_PERCENTAGE, Errors.SWAP_FEE_PERCENTAGE_TOO_HIGH);\n        _swapFeePercentage = newSwapFeePercentage;\n        emit SwapFeePercentageChanged(newSwapFeePercentage);\n    }\n\n    function setFlashLoanFeePercentage(uint256 newFlashLoanFeePercentage) external authenticate {\n        _require(\n            newFlashLoanFeePercentage <= _MAX_PROTOCOL_FLASH_LOAN_FEE_PERCENTAGE,\n            Errors.FLASH_LOAN_FEE_PERCENTAGE_TOO_HIGH\n        );\n        _flashLoanFeePercentage = newFlashLoanFeePercentage;\n        emit FlashLoanFeePercentageChanged(newFlashLoanFeePercentage);\n    }\n\n    function getSwapFeePercentage() external view returns (uint256) {\n        return _swapFeePercentage;\n    }\n\n    function getFlashLoanFeePercentage() external view returns (uint256) {\n        return _flashLoanFeePercentage;\n    }\n\n    function getCollectedFeeAmounts(IERC20[] memory tokens) external view returns (uint256[] memory feeAmounts) {\n        feeAmounts = new uint256[](tokens.length);\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            feeAmounts[i] = tokens[i].balanceOf(address(this));\n        }\n    }\n\n    function getAuthorizer() external view returns (IAuthorizer) {\n        return _getAuthorizer();\n    }\n\n    function _canPerform(bytes32 actionId, address account) internal view override returns (bool) {\n        return _getAuthorizer().canPerform(actionId, account, address(this));\n    }\n\n    function _getAuthorizer() internal view returns (IAuthorizer) {\n        return vault.getAuthorizer();\n    }\n}\n'}, 'contracts/lib/helpers/InputHelpers.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\nimport ""../openzeppelin/IERC20.sol"";\n\nimport ""./BalancerErrors.sol"";\n\nimport ""../../vault/interfaces/IAsset.sol"";\n\nlibrary InputHelpers {\n    function ensureInputLengthMatch(uint256 a, uint256 b) internal pure {\n        _require(a == b, Errors.INPUT_LENGTH_MISMATCH);\n    }\n\n    function ensureInputLengthMatch(\n        uint256 a,\n        uint256 b,\n        uint256 c\n    ) internal pure {\n        _require(a == b && b == c, Errors.INPUT_LENGTH_MISMATCH);\n    }\n\n    function ensureArrayIsSorted(IAsset[] memory array) internal pure {\n        address[] memory addressArray;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            addressArray := array\n        }\n        ensureArrayIsSorted(addressArray);\n    }\n\n    function ensureArrayIsSorted(IERC20[] memory array) internal pure {\n        address[] memory addressArray;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            addressArray := array\n        }\n        ensureArrayIsSorted(addressArray);\n    }\n\n    function ensureArrayIsSorted(address[] memory array) internal pure {\n        if (array.length < 2) {\n            return;\n        }\n\n        address previous = array[0];\n        for (uint256 i = 1; i < array.length; ++i) {\n            address current = array[i];\n            _require(previous < current, Errors.UNSORTED_ARRAY);\n            previous = current;\n        }\n    }\n}\n'}, 'contracts/lib/openzeppelin/SafeERC20.sol': {'content': '// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport ""../helpers/BalancerErrors.sol"";\n\nimport ""./IERC20.sol"";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(address(token), abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(address(token), abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     *\n     * WARNING: `token` is assumed to be a contract: calls to EOAs will *not* revert.\n     */\n    function _callOptionalReturn(address token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves.\n        (bool success, bytes memory returndata) = token.call(data);\n\n        // If the low-level call didn\'t succeed we return whatever was returned from it.\n        assembly {\n            if eq(success, 0) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        // Finally we check the returndata size is either zero or true - note that this check will always pass for EOAs\n        _require(returndata.length == 0 || abi.decode(returndata, (bool)), Errors.SAFE_ERC20_CALL_FAILED);\n    }\n}\n'}, 'contracts/vault/Fees.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport ""../lib/math/FixedPoint.sol"";\nimport ""../lib/helpers/BalancerErrors.sol"";\nimport ""../lib/openzeppelin/IERC20.sol"";\nimport ""../lib/openzeppelin/ReentrancyGuard.sol"";\nimport ""../lib/openzeppelin/SafeERC20.sol"";\n\nimport ""./ProtocolFeesCollector.sol"";\nimport ""./VaultAuthorization.sol"";\nimport ""./interfaces/IVault.sol"";\n\n/**\n * @dev To reduce the bytecode size of the Vault, most of the protocol fee logic is not here, but in the\n * ProtocolFeesCollector contract.\n */\nabstract contract Fees is IVault {\n    using SafeERC20 for IERC20;\n\n    ProtocolFeesCollector private immutable _protocolFeesCollector;\n\n    constructor() {\n        _protocolFeesCollector = new ProtocolFeesCollector(IVault(this));\n    }\n\n    function getProtocolFeesCollector() public view override returns (ProtocolFeesCollector) {\n        return _protocolFeesCollector;\n    }\n\n    /**\n     * @dev Returns the protocol swap fee percentage.\n     */\n    function _getProtocolSwapFeePercentage() internal view returns (uint256) {\n        return getProtocolFeesCollector().getSwapFeePercentage();\n    }\n\n    /**\n     * @dev Returns the protocol fee amount to charge for a flash loan of `amount`.\n     */\n    function _calculateFlashLoanFeeAmount(uint256 amount) internal view returns (uint256) {\n        // Fixed point multiplication introduces error: we round up, which means in certain scenarios the charged\n        // percentage can be slightly higher than intended.\n        uint256 percentage = getProtocolFeesCollector().getFlashLoanFeePercentage();\n        return FixedPoint.mulUp(amount, percentage);\n    }\n\n    function _payFeeAmount(IERC20 token, uint256 amount) internal {\n        if (amount > 0) {\n            token.safeTransfer(address(getProtocolFeesCollector()), amount);\n        }\n    }\n}\n'}, 'contracts/lib/math/FixedPoint.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\nimport ""./LogExpMath.sol"";\nimport ""../helpers/BalancerErrors.sol"";\n\n/* solhint-disable private-vars-leading-underscore */\n\nlibrary FixedPoint {\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    uint256 internal constant MAX_POW_RELATIVE_ERROR = 10000; // 10^(-14)\n\n    // Minimum base for the power function when the exponent is \'free\' (larger than ONE).\n    uint256 internal constant MIN_POW_BASE_FREE_EXPONENT = 0.7e18;\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Fixed Point addition is the same as regular checked addition\n\n        uint256 c = a + b;\n        _require(c >= a, Errors.ADD_OVERFLOW);\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Fixed Point addition is the same as regular checked addition\n\n        _require(b <= a, Errors.SUB_OVERFLOW);\n        uint256 c = a - b;\n        return c;\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        _require(a == 0 || product / a == b, Errors.MUL_OVERFLOW);\n\n        return product / ONE;\n    }\n\n    function mulUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        _require(a == 0 || product / a == b, Errors.MUL_OVERFLOW);\n\n        if (product == 0) {\n            return 0;\n        } else {\n            // The traditional divUp formula is:\n            // divUp(x, y) := (x + y - 1) / y\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\n            // divUp(x, y) := (x - 1) / y + 1\n            // Note that this requires x != 0, which we already tested for.\n\n            return ((product - 1) / ONE) + 1;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        _require(b != 0, Errors.ZERO_DIVISION);\n\n        if (a == 0) {\n            return 0;\n        } else {\n            uint256 aInflated = a * ONE;\n            _require(aInflated / a == ONE, Errors.DIV_INTERNAL); // mul overflow\n\n            return aInflated / b;\n        }\n    }\n\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        _require(b != 0, Errors.ZERO_DIVISION);\n\n        if (a == 0) {\n            return 0;\n        } else {\n            uint256 aInflated = a * ONE;\n            _require(aInflated / a == ONE, Errors.DIV_INTERNAL); // mul overflow\n\n            // The traditional divUp formula is:\n            // divUp(x, y) := (x + y - 1) / y\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\n            // divUp(x, y) := (x - 1) / y + 1\n            // Note that this requires x != 0, which we already tested for.\n\n            return ((aInflated - 1) / b) + 1;\n        }\n    }\n\n    /**\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding down. The result is guaranteed to not be above\n     * the true value (that is, the error function expected - actual is always positive).\n     */\n    function powDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        uint256 raw = LogExpMath.pow(x, y);\n        uint256 maxError = add(mulUp(raw, MAX_POW_RELATIVE_ERROR), 1);\n\n        if (raw < maxError) {\n            return 0;\n        } else {\n            return sub(raw, maxError);\n        }\n    }\n\n    /**\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding up. The result is guaranteed to not be below\n     * the true value (that is, the error function expected - actual is always negative).\n     */\n    function powUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        uint256 raw = LogExpMath.pow(x, y);\n        uint256 maxError = add(mulUp(raw, MAX_POW_RELATIVE_ERROR), 1);\n\n        return add(raw, maxError);\n    }\n\n    /**\n     * @dev Returns the complement of a value (1 - x), capped to 0 if x is larger than 1.\n     *\n     * Useful when computing the complement for values with some level of relative error, as it strips this error and\n     * prevents intermediate negative values.\n     */\n    function complement(uint256 x) internal pure returns (uint256) {\n        return (x < ONE) ? (ONE - x) : 0;\n    }\n}\n'}, 'contracts/lib/math/LogExpMath.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General internal License for more details.\n\n// You should have received a copy of the GNU General internal License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\nimport ""../helpers/BalancerErrors.sol"";\n\n/* solhint-disable */\n\n/**\n * @dev Exponentiation and logarithm functions for 18 decimal fixed point numbers (both base and exponent/argument).\n *\n * Exponentiation and logarithm with arbitrary bases (x^y and log_x(y)) are implemented by conversion to natural\n * exponentiation and logarithm (where the base is Euler\'s number).\n *\n * @author Fernando Martinelli - @fernandomartinelli\n * @author Sergio Yuhjtman - @sergioyuhjtman\n * @author Daniel Fernandez - @dmf7z\n */\nlibrary LogExpMath {\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\n    // two numbers, and multiply by ONE when dividing them.\n\n    // All arguments and return values are 18 decimal fixed point numbers.\n    int256 constant ONE_18 = 1e18;\n\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\n    // case of ln36, 36 decimals.\n    int256 constant ONE_20 = 1e20;\n    int256 constant ONE_36 = 1e36;\n\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\n    //\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\n    // The smallest possible result is 10^(-18), which makes largest negative argument\n    // ln(10^(-18)) = -41.446531673892822312.\n    // We use 130.0 and -41.0 to have some safety margin.\n    int256 constant MAX_NATURAL_EXPONENT = 130e18;\n    int256 constant MIN_NATURAL_EXPONENT = -41e18;\n\n    // Bounds for ln_36\'s argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\n    // 256 bit integer.\n    int256 constant LN_36_LOWER_BOUND = ONE_18 - 1e17;\n    int256 constant LN_36_UPPER_BOUND = ONE_18 + 1e17;\n\n    uint256 constant MILD_EXPONENT_BOUND = 2**254 / uint256(ONE_20);\n\n    // 18 decimal constants\n    int256 constant x0 = 128000000000000000000; // 2ˆ7\n    int256 constant a0 = 38877084059945950922200000000000000000000000000000000000; // eˆ(x0) (no decimals)\n    int256 constant x1 = 64000000000000000000; // 2ˆ6\n    int256 constant a1 = 6235149080811616882910000000; // eˆ(x1) (no decimals)\n\n    // 20 decimal constants\n    int256 constant x2 = 3200000000000000000000; // 2ˆ5\n    int256 constant a2 = 7896296018268069516100000000000000; // eˆ(x2)\n    int256 constant x3 = 1600000000000000000000; // 2ˆ4\n    int256 constant a3 = 888611052050787263676000000; // eˆ(x3)\n    int256 constant x4 = 800000000000000000000; // 2ˆ3\n    int256 constant a4 = 298095798704172827474000; // eˆ(x4)\n    int256 constant x5 = 400000000000000000000; // 2ˆ2\n    int256 constant a5 = 5459815003314423907810; // eˆ(x5)\n    int256 constant x6 = 200000000000000000000; // 2ˆ1\n    int256 constant a6 = 738905609893065022723; // eˆ(x6)\n    int256 constant x7 = 100000000000000000000; // 2ˆ0\n    int256 constant a7 = 271828182845904523536; // eˆ(x7)\n    int256 constant x8 = 50000000000000000000; // 2ˆ-1\n    int256 constant a8 = 164872127070012814685; // eˆ(x8)\n    int256 constant x9 = 25000000000000000000; // 2ˆ-2\n    int256 constant a9 = 128402541668774148407; // eˆ(x9)\n    int256 constant x10 = 12500000000000000000; // 2ˆ-3\n    int256 constant a10 = 113314845306682631683; // eˆ(x10)\n    int256 constant x11 = 6250000000000000000; // 2ˆ-4\n    int256 constant a11 = 106449445891785942956; // eˆ(x11)\n\n    /**\n     * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\n     *\n     * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\n     */\n    function pow(uint256 x, uint256 y) internal pure returns (uint256) {\n        if (y == 0) {\n            // We solve the 0^0 indetermination by making it equal one.\n            return uint256(ONE_18);\n        }\n\n        if (x == 0) {\n            return 0;\n        }\n\n        // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\n        // arrive at that result. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\n        // x^y = exp(y * ln(x)).\n\n        // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\n        _require(x < 2**255, Errors.X_OUT_OF_BOUNDS);\n        int256 x_int256 = int256(x);\n\n        // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\n        // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\n\n        // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\n        _require(y < MILD_EXPONENT_BOUND, Errors.Y_OUT_OF_BOUNDS);\n        int256 y_int256 = int256(y);\n\n        int256 logx_times_y;\n        if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {\n            int256 ln_36_x = ln_36(x_int256);\n\n            // ln_36_x has 36 decimal places, so multiplying by y_int256 isn\'t as straightforward, since we can\'t just\n            // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\n            // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\n            // (downscaled) last 18 decimals.\n            logx_times_y = ((ln_36_x / ONE_18) * y_int256 + ((ln_36_x % ONE_18) * y_int256) / ONE_18);\n        } else {\n            logx_times_y = ln(x_int256) * y_int256;\n        }\n        logx_times_y /= ONE_18;\n\n        // Finally, we compute exp(y * ln(x)) to arrive at x^y\n        _require(\n            MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= MAX_NATURAL_EXPONENT,\n            Errors.PRODUCT_OUT_OF_BOUNDS\n        );\n\n        return uint256(exp(logx_times_y));\n    }\n\n    /**\n     * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\n     *\n     * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\n     */\n    function exp(int256 x) internal pure returns (int256) {\n        _require(x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT, Errors.INVALID_EXPONENT);\n\n        if (x < 0) {\n            // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\n            // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\n            // Fixed point division requires multiplying by ONE_18.\n            return ((ONE_18 * ONE_18) / exp(-x));\n        }\n\n        // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\n        // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\n        // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\n        // decomposition.\n        // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\n        // decomposition, which will be lower than the smallest x_n.\n        // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\n        // We mutate x by subtracting x_n, making it the remainder of the decomposition.\n\n        // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\n        // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\n        // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\n        // decomposition.\n\n        // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\n        // it and compute the accumulated product.\n\n        int256 firstAN;\n        if (x >= x0) {\n            x -= x0;\n            firstAN = a0;\n        } else if (x >= x1) {\n            x -= x1;\n            firstAN = a1;\n        } else {\n            firstAN = 1; // One with no decimal places\n        }\n\n        // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\n        // smaller terms.\n        x *= 100;\n\n        // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\n        // one. Recall that fixed point multiplication requires dividing by ONE_20.\n        int256 product = ONE_20;\n\n        if (x >= x2) {\n            x -= x2;\n            product = (product * a2) / ONE_20;\n        }\n        if (x >= x3) {\n            x -= x3;\n            product = (product * a3) / ONE_20;\n        }\n        if (x >= x4) {\n            x -= x4;\n            product = (product * a4) / ONE_20;\n        }\n        if (x >= x5) {\n            x -= x5;\n            product = (product * a5) / ONE_20;\n        }\n        if (x >= x6) {\n            x -= x6;\n            product = (product * a6) / ONE_20;\n        }\n        if (x >= x7) {\n            x -= x7;\n            product = (product * a7) / ONE_20;\n        }\n        if (x >= x8) {\n            x -= x8;\n            product = (product * a8) / ONE_20;\n        }\n        if (x >= x9) {\n            x -= x9;\n            product = (product * a9) / ONE_20;\n        }\n\n        // x10 and x11 are unnecessary here since we have high enough precision already.\n\n        // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\n        // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\n\n        int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\n        int256 term; // Each term in the sum, where the nth term is (x^n / n!).\n\n        // The first term is simply x.\n        term = x;\n        seriesSum += term;\n\n        // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\n        // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\n\n        term = ((term * x) / ONE_20) / 2;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 3;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 4;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 5;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 6;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 7;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 8;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 9;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 10;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 11;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 12;\n        seriesSum += term;\n\n        // 12 Taylor terms are sufficient for 18 decimal precision.\n\n        // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\n        // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\n        // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\n        // and then drop two digits to return an 18 decimal value.\n\n        return (((product * seriesSum) / ONE_20) * firstAN) / 100;\n    }\n\n    /**\n     * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    function ln(int256 a) internal pure returns (int256) {\n        // The real natural logarithm is not defined for negative numbers or zero.\n        _require(a > 0, Errors.OUT_OF_BOUNDS);\n\n        if (a < ONE_18) {\n            // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\n            // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\n            // Fixed point division requires multiplying by ONE_18.\n            return (-ln((ONE_18 * ONE_18) / a));\n        }\n\n        // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\n        // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\n        // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\n        // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\n        // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\n        // decomposition, which will be lower than the smallest a_n.\n        // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\n        // We mutate a by subtracting a_n, making it the remainder of the decomposition.\n\n        // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\n        // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\n        // ONE_18 to convert them to fixed point.\n        // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\n        // by it and compute the accumulated sum.\n\n        int256 sum = 0;\n        if (a >= a0 * ONE_18) {\n            a /= a0; // Integer, not fixed point division\n            sum += x0;\n        }\n\n        if (a >= a1 * ONE_18) {\n            a /= a1; // Integer, not fixed point division\n            sum += x1;\n        }\n\n        // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\n        sum *= 100;\n        a *= 100;\n\n        // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\n\n        if (a >= a2) {\n            a = (a * ONE_20) / a2;\n            sum += x2;\n        }\n\n        if (a >= a3) {\n            a = (a * ONE_20) / a3;\n            sum += x3;\n        }\n\n        if (a >= a4) {\n            a = (a * ONE_20) / a4;\n            sum += x4;\n        }\n\n        if (a >= a5) {\n            a = (a * ONE_20) / a5;\n            sum += x5;\n        }\n\n        if (a >= a6) {\n            a = (a * ONE_20) / a6;\n            sum += x6;\n        }\n\n        if (a >= a7) {\n            a = (a * ONE_20) / a7;\n            sum += x7;\n        }\n\n        if (a >= a8) {\n            a = (a * ONE_20) / a8;\n            sum += x8;\n        }\n\n        if (a >= a9) {\n            a = (a * ONE_20) / a9;\n            sum += x9;\n        }\n\n        if (a >= a10) {\n            a = (a * ONE_20) / a10;\n            sum += x10;\n        }\n\n        if (a >= a11) {\n            a = (a * ONE_20) / a11;\n            sum += x11;\n        }\n\n        // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\n        // that converges rapidly for values of `a` close to one - the same one used in ln_36.\n        // Let z = (a - 1) / (a + 1).\n        // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n        // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\n        // division by ONE_20.\n        int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);\n        int256 z_squared = (z * z) / ONE_20;\n\n        // num is the numerator of the series: the z^(2 * n + 1) term\n        int256 num = z;\n\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n        int256 seriesSum = num;\n\n        // In each step, the numerator is multiplied by z^2\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 3;\n\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 5;\n\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 7;\n\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 9;\n\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 11;\n\n        // 6 Taylor terms are sufficient for 36 decimal precision.\n\n        // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\n        seriesSum *= 2;\n\n        // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\n        // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\n        // value.\n\n        return (sum + seriesSum) / 100;\n    }\n\n    /**\n     * @dev Logarithm (log(arg, base), with signed 18 decimal fixed point base and argument argument.\n     */\n    function log(int256 arg, int256 base) internal pure returns (int256) {\n        // This performs a simple base change: log(arg, base) = ln(arg) / ln(base).\n\n        // Both logBase and logArg are computed as 36 decimal fixed point numbers, either by using ln_36, or by\n        // upscaling.\n\n        int256 logBase;\n        if (LN_36_LOWER_BOUND < base && base < LN_36_UPPER_BOUND) {\n            logBase = ln_36(base);\n        } else {\n            logBase = ln(base) * ONE_18;\n        }\n\n        int256 logArg;\n        if (LN_36_LOWER_BOUND < arg && arg < LN_36_UPPER_BOUND) {\n            logArg = ln_36(arg);\n        } else {\n            logArg = ln(arg) * ONE_18;\n        }\n\n        // When dividing, we multiply by ONE_18 to arrive at a result with 18 decimal places\n        return (logArg * ONE_18) / logBase;\n    }\n\n    /**\n     * @dev High precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\n     * for x close to one.\n     *\n     * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\n     */\n    function ln_36(int256 x) private pure returns (int256) {\n        // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\n        // worthwhile.\n\n        // First, we transform x to a 36 digit fixed point value.\n        x *= ONE_18;\n\n        // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\n        // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n        // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\n        // division by ONE_36.\n        int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);\n        int256 z_squared = (z * z) / ONE_36;\n\n        // num is the numerator of the series: the z^(2 * n + 1) term\n        int256 num = z;\n\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n        int256 seriesSum = num;\n\n        // In each step, the numerator is multiplied by z^2\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 3;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 5;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 7;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 9;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 11;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 13;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 15;\n\n        // 8 Taylor terms are sufficient for 36 decimal precision.\n\n        // All that remains is multiplying by 2 (non fixed point).\n        return seriesSum * 2;\n    }\n}\n'}, 'contracts/lib/math/Math.sol': {'content': '// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport ""../helpers/BalancerErrors.sol"";\n\n/**\n * @dev Wrappers over Solidity\'s arithmetic operations with added overflow checks.\n * Adapted from OpenZeppelin\'s SafeMath library\n */\nlibrary Math {\n    /**\n     * @dev Returns the addition of two unsigned integers of 256 bits, reverting on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        _require(c >= a, Errors.ADD_OVERFLOW);\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        _require((b >= 0 && c >= a) || (b < 0 && c < a), Errors.ADD_OVERFLOW);\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers of 256 bits, reverting on overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        _require(b <= a, Errors.SUB_OVERFLOW);\n        uint256 c = a - b;\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        _require((b >= 0 && c <= a) || (b < 0 && c > a), Errors.SUB_OVERFLOW);\n        return c;\n    }\n\n    /**\n     * @dev Returns the largest of two numbers of 256 bits.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers of 256 bits.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a * b;\n        _require(a == 0 || c / a == b, Errors.MUL_OVERFLOW);\n        return c;\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        _require(b != 0, Errors.ZERO_DIVISION);\n        return a / b;\n    }\n\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        _require(b != 0, Errors.ZERO_DIVISION);\n\n        if (a == 0) {\n            return 0;\n        } else {\n            return 1 + (a - 1) / b;\n        }\n    }\n}\n'}, 'contracts/lib/openzeppelin/EnumerableMap.sol': {'content': '// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n// Based on the EnumerableMap library from OpenZeppelin contracts, altered to include the following:\n//  * a map from IERC20 to bytes32\n//  * entries are stored in mappings instead of arrays, reducing implicit storage reads for out-of-bounds checks\n//  * unchecked_at and unchecked_valueAt, which allow for more gas efficient data reads in some scenarios\n//  * unchecked_indexOf and unchecked_setAt, which allow for more gas efficient data writes in some scenarios\n//\n// Additionally, the base private functions that work on bytes32 were removed and replaced with a native implementation\n// for IERC20 keys, to reduce bytecode size and runtime costs.\n\n// We\'re using non-standard casing for the unchecked functions to differentiate them, so we need to turn off that rule\n// solhint-disable func-name-mixedcase\n\nimport ""./IERC20.sol"";\n\nimport ""../helpers/BalancerErrors.sol"";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity\'s\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n */\nlibrary EnumerableMap {\n    // The original OpenZeppelin implementation uses a generic Map type with bytes32 keys: this was replaced with\n    // IERC20ToBytes32Map, which uses IERC20 keys natively, resulting in more dense bytecode.\n\n    struct IERC20ToBytes32MapEntry {\n        IERC20 _key;\n        bytes32 _value;\n    }\n\n    struct IERC20ToBytes32Map {\n        // Number of entries in the map\n        uint256 _length;\n        // Storage of map keys and values\n        mapping(uint256 => IERC20ToBytes32MapEntry) _entries;\n        // Position of the entry defined by a key in the `entries` array, plus 1\n        // because index 0 means a key is not in the map.\n        mapping(IERC20 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        IERC20ToBytes32Map storage map,\n        IERC20 key,\n        bytes32 value\n    ) internal returns (bool) {\n        // We read and store the key\'s index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        // Equivalent to !contains(map, key)\n        if (keyIndex == 0) {\n            uint256 previousLength = map._length;\n            map._entries[previousLength] = IERC20ToBytes32MapEntry({ _key: key, _value: value });\n            map._length = previousLength + 1;\n\n            // The entry is stored at previousLength, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            map._indexes[key] = previousLength + 1;\n            return true;\n        } else {\n            map._entries[keyIndex - 1]._value = value;\n            return false;\n        }\n    }\n\n    /**\n     * @dev Updates the value for an entry, given its key\'s index. The key index can be retrieved via\n     * {unchecked_indexOf}, and it should be noted that key indices may change when calling {set} or {remove}. O(1).\n     *\n     * This function performs one less storage read than {set}, but it should only be used when `index` is known to be\n     * within bounds.\n     */\n    function unchecked_setAt(\n        IERC20ToBytes32Map storage map,\n        uint256 index,\n        bytes32 value\n    ) internal {\n        map._entries[index]._value = value;\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(IERC20ToBytes32Map storage map, IERC20 key) internal returns (bool) {\n        // We read and store the key\'s index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        // Equivalent to contains(map, key)\n        if (keyIndex != 0) {\n            // To delete a key-value pair from the _entries pseudo-array in O(1), we swap the entry to delete with the\n            // one at the highest index, and then remove this last entry (sometimes called as \'swap and pop\').\n            // This modifies the order of the pseudo-array, as noted in {at}.\n\n            uint256 toDeleteIndex = keyIndex - 1;\n            uint256 lastIndex = map._length - 1;\n\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an \'if\' statement.\n\n            IERC20ToBytes32MapEntry storage lastEntry = map._entries[lastIndex];\n\n            // Move the last entry to the index where the entry to delete is\n            map._entries[toDeleteIndex] = lastEntry;\n            // Update the index for the moved entry\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved entry was stored\n            delete map._entries[lastIndex];\n            map._length = lastIndex;\n\n            // Delete the index for the deleted slot\n            delete map._indexes[key];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(IERC20ToBytes32Map storage map, IERC20 key) internal view returns (bool) {\n        return map._indexes[key] != 0;\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(IERC20ToBytes32Map storage map) internal view returns (uint256) {\n        return map._length;\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(IERC20ToBytes32Map storage map, uint256 index) internal view returns (IERC20, bytes32) {\n        _require(map._length > index, Errors.OUT_OF_BOUNDS);\n        return unchecked_at(map, index);\n    }\n\n    /**\n     * @dev Same as {at}, except this doesn\'t revert if `index` it outside of the map (i.e. if it is equal or larger\n     * than {length}). O(1).\n     *\n     * This function performs one less storage read than {at}, but should only be used when `index` is known to be\n     * within bounds.\n     */\n    function unchecked_at(IERC20ToBytes32Map storage map, uint256 index) internal view returns (IERC20, bytes32) {\n        IERC20ToBytes32MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n\n    /**\n     * @dev Same as {unchecked_At}, except it only returns the value and not the key (performing one less storage\n     * read). O(1).\n     */\n    function unchecked_valueAt(IERC20ToBytes32Map storage map, uint256 index) internal view returns (bytes32) {\n        return map._entries[index]._value;\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map. Reverts with `errorCode` otherwise.\n     */\n    function get(\n        IERC20ToBytes32Map storage map,\n        IERC20 key,\n        uint256 errorCode\n    ) internal view returns (bytes32) {\n        uint256 index = map._indexes[key];\n        _require(index > 0, errorCode);\n        return unchecked_valueAt(map, index - 1);\n    }\n\n    /**\n     * @dev Returns the index for `key` **plus one**. Does not revert if the key is not in the map, and returns 0\n     * instead.\n     */\n    function unchecked_indexOf(IERC20ToBytes32Map storage map, IERC20 key) internal view returns (uint256) {\n        return map._indexes[key];\n    }\n}\n'}, 'contracts/lib/openzeppelin/EnumerableSet.sol': {'content': '// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport ""../helpers/BalancerErrors.sol"";\n\n// Based on the EnumerableSet library from OpenZeppelin contracts, altered to remove the base private functions that\n// work on bytes32, replacing them with a native implementation for address values, to reduce bytecode size and runtime\n// costs.\n// The `unchecked_at` function was also added, which allows for more gas efficient data reads in some scenarios.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // The original OpenZeppelin implementation uses a generic Set type with bytes32 values: this was replaced with\n    // AddressSet, which uses address keys natively, resulting in more dense bytecode.\n\n    struct AddressSet {\n        // Storage of set values\n        address[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(address => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        if (!contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        // We read and store the value\'s index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as \'swap and pop\').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an \'if\' statement.\n\n            address lastValue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastValue;\n            // Update the index for the moved value\n            set._indexes[lastValue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        _require(set._values.length > index, Errors.OUT_OF_BOUNDS);\n        return unchecked_at(set, index);\n    }\n\n    /**\n     * @dev Same as {at}, except this doesn\'t revert if `index` it outside of the set (i.e. if it is equal or larger\n     * than {length}). O(1).\n     *\n     * This function performs one less storage read than {at}, but should only be used when `index` is known to be\n     * within bounds.\n     */\n    function unchecked_at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return set._values[index];\n    }\n}\n'}, 'contracts/lib/openzeppelin/SafeCast.sol': {'content': '// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport ""../helpers/BalancerErrors.sol"";\n\n/**\n * @dev Wrappers over Solidity\'s uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\'s recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        _require(value < 2**255, Errors.SAFE_CAST_VALUE_CANT_FIT_INT256);\n        return int256(value);\n    }\n}\n'}, 'contracts/vault/PoolBalances.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport ""../lib/math/Math.sol"";\nimport ""../lib/helpers/BalancerErrors.sol"";\nimport ""../lib/helpers/InputHelpers.sol"";\nimport ""../lib/openzeppelin/IERC20.sol"";\nimport ""../lib/openzeppelin/ReentrancyGuard.sol"";\nimport ""../lib/openzeppelin/SafeERC20.sol"";\n\nimport ""./Fees.sol"";\nimport ""./PoolTokens.sol"";\nimport ""./UserBalance.sol"";\nimport ""./interfaces/IBasePool.sol"";\n\n/**\n * @dev Stores the Asset Managers (by Pool and token), and implements the top level Asset Manager and Pool interfaces,\n * such as registering and deregistering tokens, joining and exiting Pools, and informational functions like `getPool`\n * and `getPoolTokens`, delegating to specialization-specific functions as needed.\n *\n * `managePoolBalance` handles all Asset Manager interactions.\n */\nabstract contract PoolBalances is Fees, ReentrancyGuard, PoolTokens, UserBalance {\n    using Math for uint256;\n    using SafeERC20 for IERC20;\n    using BalanceAllocation for bytes32;\n    using BalanceAllocation for bytes32[];\n\n    function joinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        JoinPoolRequest memory request\n    ) external payable override whenNotPaused {\n        // This function doesn\'t have the nonReentrant modifier: it is applied to `_joinOrExit` instead.\n\n        // Note that `recipient` is not actually payable in the context of a join - we cast it because we handle both\n        // joins and exits at once.\n        _joinOrExit(PoolBalanceChangeKind.JOIN, poolId, sender, payable(recipient), _toPoolBalanceChange(request));\n    }\n\n    function exitPool(\n        bytes32 poolId,\n        address sender,\n        address payable recipient,\n        ExitPoolRequest memory request\n    ) external override {\n        // This function doesn\'t have the nonReentrant modifier: it is applied to `_joinOrExit` instead.\n        _joinOrExit(PoolBalanceChangeKind.EXIT, poolId, sender, recipient, _toPoolBalanceChange(request));\n    }\n\n    // This has the exact same layout as JoinPoolRequest and ExitPoolRequest, except the `maxAmountsIn` and\n    // `minAmountsOut` are called `limits`. Internally we use this struct for both since these two functions are quite\n    // similar, but expose the others to callers for clarity.\n    struct PoolBalanceChange {\n        IAsset[] assets;\n        uint256[] limits;\n        bytes userData;\n        bool useInternalBalance;\n    }\n\n    /**\n     * @dev Converts a JoinPoolRequest into a PoolBalanceChange, with no runtime cost.\n     */\n    function _toPoolBalanceChange(JoinPoolRequest memory request)\n        private\n        pure\n        returns (PoolBalanceChange memory change)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            change := request\n        }\n    }\n\n    /**\n     * @dev Converts an ExitPoolRequest into a PoolBalanceChange, with no runtime cost.\n     */\n    function _toPoolBalanceChange(ExitPoolRequest memory request)\n        private\n        pure\n        returns (PoolBalanceChange memory change)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            change := request\n        }\n    }\n\n    /**\n     * @dev Implements both `joinPool` and `exitPool`, based on `kind`.\n     */\n    function _joinOrExit(\n        PoolBalanceChangeKind kind,\n        bytes32 poolId,\n        address sender,\n        address payable recipient,\n        PoolBalanceChange memory change\n    ) private nonReentrant withRegisteredPool(poolId) authenticateFor(sender) {\n        // This function uses a large number of stack variables (poolId, sender and recipient, balances, amounts, fees,\n        // etc.), which leads to \'stack too deep\' issues. It relies on private functions with seemingly arbitrary\n        // interfaces to work around this limitation.\n\n        InputHelpers.ensureInputLengthMatch(change.assets.length, change.limits.length);\n\n        // We first check that the caller passed the Pool\'s registered tokens in the correct order, and retrieve the\n        // current balance for each.\n        IERC20[] memory tokens = _translateToIERC20(change.assets);\n        bytes32[] memory balances = _validateTokensAndGetBalances(poolId, tokens);\n\n        // The bulk of the work is done here: the corresponding Pool hook is called, its final balances are computed,\n        // assets are transferred, and fees are paid.\n        (\n            bytes32[] memory finalBalances,\n            uint256[] memory amountsInOrOut,\n            uint256[] memory paidProtocolSwapFeeAmounts\n        ) = _callPoolBalanceChange(kind, poolId, sender, recipient, change, balances);\n\n        // All that remains is storing the new Pool balances.\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\n            _setTwoTokenPoolCashBalances(poolId, tokens[0], finalBalances[0], tokens[1], finalBalances[1]);\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\n            _setMinimalSwapInfoPoolBalances(poolId, tokens, finalBalances);\n        } else {\n            // PoolSpecialization.GENERAL\n            _setGeneralPoolBalances(poolId, finalBalances);\n        }\n\n        bool positive = kind == PoolBalanceChangeKind.JOIN; // Amounts in are positive, out are negative\n        emit PoolBalanceChanged(\n            poolId,\n            sender,\n            tokens,\n            // We can unsafely cast to int256 because balances are actually stored as uint112\n            _unsafeCastToInt256(amountsInOrOut, positive),\n            paidProtocolSwapFeeAmounts\n        );\n    }\n\n    /**\n     * @dev Calls the corresponding Pool hook to get the amounts in/out plus protocol fee amounts, and performs the\n     * associated token transfers and fee payments, returning the Pool\'s final balances.\n     */\n    function _callPoolBalanceChange(\n        PoolBalanceChangeKind kind,\n        bytes32 poolId,\n        address sender,\n        address payable recipient,\n        PoolBalanceChange memory change,\n        bytes32[] memory balances\n    )\n        private\n        returns (\n            bytes32[] memory finalBalances,\n            uint256[] memory amountsInOrOut,\n            uint256[] memory dueProtocolFeeAmounts\n        )\n    {\n        (uint256[] memory totalBalances, uint256 lastChangeBlock) = balances.totalsAndLastChangeBlock();\n\n        IBasePool pool = IBasePool(_getPoolAddress(poolId));\n        (amountsInOrOut, dueProtocolFeeAmounts) = kind == PoolBalanceChangeKind.JOIN\n            ? pool.onJoinPool(\n                poolId,\n                sender,\n                recipient,\n                totalBalances,\n                lastChangeBlock,\n                _getProtocolSwapFeePercentage(),\n                change.userData\n            )\n            : pool.onExitPool(\n                poolId,\n                sender,\n                recipient,\n                totalBalances,\n                lastChangeBlock,\n                _getProtocolSwapFeePercentage(),\n                change.userData\n            );\n\n        InputHelpers.ensureInputLengthMatch(balances.length, amountsInOrOut.length, dueProtocolFeeAmounts.length);\n\n        // The Vault ignores the `recipient` in joins and the `sender` in exits: it is up to the Pool to keep track of\n        // their participation.\n        finalBalances = kind == PoolBalanceChangeKind.JOIN\n            ? _processJoinPoolTransfers(sender, change, balances, amountsInOrOut, dueProtocolFeeAmounts)\n            : _processExitPoolTransfers(recipient, change, balances, amountsInOrOut, dueProtocolFeeAmounts);\n    }\n\n    /**\n     * @dev Transfers `amountsIn` from `sender`, checking that they are within their accepted limits, and pays\n     * accumulated protocol swap fees.\n     *\n     * Returns the Pool\'s final balances, which are the current balances plus `amountsIn` minus accumulated protocol\n     * swap fees.\n     */\n    function _processJoinPoolTransfers(\n        address sender,\n        PoolBalanceChange memory change,\n        bytes32[] memory balances,\n        uint256[] memory amountsIn,\n        uint256[] memory dueProtocolFeeAmounts\n    ) private returns (bytes32[] memory finalBalances) {\n        // We need to track how much of the received ETH was used and wrapped into WETH to return any excess.\n        uint256 wrappedEth = 0;\n\n        finalBalances = new bytes32[](balances.length);\n        for (uint256 i = 0; i < change.assets.length; ++i) {\n            uint256 amountIn = amountsIn[i];\n            _require(amountIn <= change.limits[i], Errors.JOIN_ABOVE_MAX);\n\n            // Receive assets from the sender - possibly from Internal Balance.\n            IAsset asset = change.assets[i];\n            _receiveAsset(asset, amountIn, sender, change.useInternalBalance);\n\n            if (_isETH(asset)) {\n                wrappedEth = wrappedEth.add(amountIn);\n            }\n\n            uint256 feeAmount = dueProtocolFeeAmounts[i];\n            _payFeeAmount(_translateToIERC20(asset), feeAmount);\n\n            // Compute the new Pool balances. Note that the fee amount might be larger than `amountIn`,\n            // resulting in an overall decrease of the Pool\'s balance for a token.\n            finalBalances[i] = (amountIn >= feeAmount) // This lets us skip checked arithmetic\n                ? balances[i].increaseCash(amountIn - feeAmount)\n                : balances[i].decreaseCash(feeAmount - amountIn);\n        }\n\n        // Handle any used and remaining ETH.\n        _handleRemainingEth(wrappedEth);\n    }\n\n    /**\n     * @dev Transfers `amountsOut` to `recipient`, checking that they are within their accepted limits, and pays\n     * accumulated protocol swap fees from the Pool.\n     *\n     * Returns the Pool\'s final balances, which are the current `balances` minus `amountsOut` and fees paid\n     * (`dueProtocolFeeAmounts`).\n     */\n    function _processExitPoolTransfers(\n        address payable recipient,\n        PoolBalanceChange memory change,\n        bytes32[] memory balances,\n        uint256[] memory amountsOut,\n        uint256[] memory dueProtocolFeeAmounts\n    ) private returns (bytes32[] memory finalBalances) {\n        finalBalances = new bytes32[](balances.length);\n        for (uint256 i = 0; i < change.assets.length; ++i) {\n            uint256 amountOut = amountsOut[i];\n            _require(amountOut >= change.limits[i], Errors.EXIT_BELOW_MIN);\n\n            // Send tokens to the recipient - possibly to Internal Balance\n            IAsset asset = change.assets[i];\n            _sendAsset(asset, amountOut, recipient, change.useInternalBalance);\n\n            uint256 feeAmount = dueProtocolFeeAmounts[i];\n            _payFeeAmount(_translateToIERC20(asset), feeAmount);\n\n            // Compute the new Pool balances. A Pool\'s token balance always decreases after an exit (potentially by 0).\n            finalBalances[i] = balances[i].decreaseCash(amountOut.add(feeAmount));\n        }\n    }\n\n    /**\n     * @dev Returns the total balance for `poolId`\'s `expectedTokens`.\n     *\n     * `expectedTokens` must exactly equal the token array returned by `getPoolTokens`: both arrays must have the same\n     * length, elements and order. Additionally, the Pool must have at least one registered token.\n     */\n    function _validateTokensAndGetBalances(bytes32 poolId, IERC20[] memory expectedTokens)\n        private\n        view\n        returns (bytes32[] memory)\n    {\n        (IERC20[] memory actualTokens, bytes32[] memory balances) = _getPoolTokens(poolId);\n        InputHelpers.ensureInputLengthMatch(actualTokens.length, expectedTokens.length);\n        _require(actualTokens.length > 0, Errors.POOL_NO_TOKENS);\n\n        for (uint256 i = 0; i < actualTokens.length; ++i) {\n            _require(actualTokens[i] == expectedTokens[i], Errors.TOKENS_MISMATCH);\n        }\n\n        return balances;\n    }\n\n    /**\n     * @dev Casts an array of uint256 to int256, setting the sign of the result according to the `positive` flag,\n     * without checking whether the values fit in the signed 256 bit range.\n     */\n    function _unsafeCastToInt256(uint256[] memory values, bool positive)\n        private\n        pure\n        returns (int256[] memory signedValues)\n    {\n        signedValues = new int256[](values.length);\n        for (uint256 i = 0; i < values.length; i++) {\n            signedValues[i] = positive ? int256(values[i]) : -int256(values[i]);\n        }\n    }\n}\n'}, 'contracts/vault/interfaces/IPoolSwapStructs.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport ""../../lib/openzeppelin/IERC20.sol"";\n\nimport ""./IVault.sol"";\n\ninterface IPoolSwapStructs {\n    // This is not really an interface - it just defines common structs used by other interfaces: IGeneralPool and\n    // IMinimalSwapInfoPool.\n    //\n    // This data structure represents a request for a token swap, where `kind` indicates the swap type (\'given in\' or\n    // \'given out\') which indicates whether or not the amount sent by the pool is known.\n    //\n    // The pool receives `tokenIn` and sends `tokenOut`. `amount` is the number of `tokenIn` tokens the pool will take\n    // in, or the number of `tokenOut` tokens the Pool will send out, depending on the given swap `kind`.\n    //\n    // All other fields are not strictly necessary for most swaps, but are provided to support advanced scenarios in\n    // some Pools.\n    //\n    // `poolId` is the ID of the Pool involved in the swap - this is useful for Pool contracts that implement more than\n    // one Pool.\n    //\n    // The meaning of `lastChangeBlock` depends on the Pool specialization:\n    //  - Two Token or Minimal Swap Info: the last block in which either `tokenIn` or `tokenOut` changed its total\n    //    balance.\n    //  - General: the last block in which *any* of the Pool\'s registered tokens changed its total balance.\n    //\n    // `from` is the origin address for the funds the Pool receives, and `to` is the destination address\n    // where the Pool sends the outgoing tokens.\n    //\n    // `userData` is extra data provided by the caller - typically a signature from a trusted party.\n    struct SwapRequest {\n        IVault.SwapKind kind;\n        IERC20 tokenIn;\n        IERC20 tokenOut;\n        uint256 amount;\n        // Misc data\n        bytes32 poolId;\n        uint256 lastChangeBlock;\n        address from;\n        address to;\n        bytes userData;\n    }\n}\n'}, 'contracts/vault/interfaces/IGeneralPool.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport ""./IBasePool.sol"";\n\n/**\n * @dev IPools with the General specialization setting should implement this interface.\n *\n * This is called by the Vault when a user calls `IVault.swap` or `IVault.batchSwap` to swap with this Pool.\n * Returns the number of tokens the Pool will grant to the user in a \'given in\' swap, or that the user will\n * grant to the pool in a \'given out\' swap.\n *\n * This can often be implemented by a `view` function, since many pricing algorithms don\'t need to track state\n * changes in swaps. However, contracts implementing this in non-view functions should check that the caller is\n * indeed the Vault.\n */\ninterface IGeneralPool is IBasePool {\n    function onSwap(\n        SwapRequest memory swapRequest,\n        uint256[] memory balances,\n        uint256 indexIn,\n        uint256 indexOut\n    ) external returns (uint256 amount);\n}\n'}, 'contracts/vault/interfaces/IMinimalSwapInfoPool.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport ""./IBasePool.sol"";\n\n/**\n * @dev Pool contracts with the MinimalSwapInfo or TwoToken specialization settings should implement this interface.\n *\n * This is called by the Vault when a user calls `IVault.swap` or `IVault.batchSwap` to swap with this Pool.\n * Returns the number of tokens the Pool will grant to the user in a \'given in\' swap, or that the user will grant\n * to the pool in a \'given out\' swap.\n *\n * This can often be implemented by a `view` function, since many pricing algorithms don\'t need to track state\n * changes in swaps. However, contracts implementing this in non-view functions should check that the caller is\n * indeed the Vault.\n */\ninterface IMinimalSwapInfoPool is IBasePool {\n    function onSwap(\n        SwapRequest memory swapRequest,\n        uint256 currentBalanceTokenIn,\n        uint256 currentBalanceTokenOut\n    ) external returns (uint256 amount);\n}\n'}, 'contracts/vault/balances/BalanceAllocation.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\nimport ""../../lib/math/Math.sol"";\n\n// This library is used to create a data structure that represents a token\'s balance for a Pool. \'cash\' is how many\n// tokens the Pool has sitting inside of the Vault. \'managed\' is how many tokens were withdrawn from the Vault by the\n// Pool\'s Asset Manager. \'total\' is the sum of these two, and represents the Pool\'s total token balance, including\n// tokens that are *not* inside of the Vault.\n//\n// \'cash\' is updated whenever tokens enter and exit the Vault, while \'managed\' is only updated if the reason tokens are\n// moving is due to an Asset Manager action. This is reflected in the different methods available: \'increaseCash\'\n// and \'decreaseCash\' for swaps and add/remove liquidity events, and \'cashToManaged\' and \'managedToCash\' for events\n// transferring funds to and from the Asset Manager.\n//\n// The Vault disallows the Pool\'s \'cash\' from becoming negative. In other words, it can never use any tokens that are\n// not inside the Vault.\n//\n// One of the goals of this library is to store the entire token balance in a single storage slot, which is why we use\n// 112 bit unsigned integers for \'cash\' and \'managed\'. For consistency, we also disallow any combination of \'cash\' and\n// \'managed\' that yields a \'total\' that doesn\'t fit in 112 bits.\n//\n// The remaining 32 bits of the slot are used to store the most recent block when the total balance changed. This\n// can be used to implement price oracles that are resilient to \'sandwich\' attacks.\n//\n// We could use a Solidity struct to pack these three values together in a single storage slot, but unfortunately\n// Solidity only allows for structs to live in either storage, calldata or memory. Because a memory struct still takes\n// up a slot in the stack (to store its memory location), and because the entire balance fits in a single stack slot\n// (two 112 bit values plus the 32 bit block), using memory is strictly less gas performant. Therefore, we do manual\n// packing and unpacking.\n//\n// Since we cannot define new types, we rely on bytes32 to represent these values instead, as it doesn\'t have any\n// associated arithmetic operations and therefore reduces the chance of misuse.\nlibrary BalanceAllocation {\n    using Math for uint256;\n\n    // The \'cash\' portion of the balance is stored in the least significant 112 bits of a 256 bit word, while the\n    // \'managed\' part uses the following 112 bits. The most significant 32 bits are used to store the block\n\n    /**\n     * @dev Returns the total amount of Pool tokens, including those that are not currently in the Vault (\'managed\').\n     */\n    function total(bytes32 balance) internal pure returns (uint256) {\n        // Since \'cash\' and \'managed\' are 112 bit values, we don\'t need checked arithmetic. Additionally, `toBalance`\n        // ensures that \'total\' always fits in 112 bits.\n        return cash(balance) + managed(balance);\n    }\n\n    /**\n     * @dev Returns the amount of Pool tokens currently in the Vault.\n     */\n    function cash(bytes32 balance) internal pure returns (uint256) {\n        uint256 mask = 2**(112) - 1;\n        return uint256(balance) & mask;\n    }\n\n    /**\n     * @dev Returns the amount of Pool tokens that are being managed by an Asset Manager.\n     */\n    function managed(bytes32 balance) internal pure returns (uint256) {\n        uint256 mask = 2**(112) - 1;\n        return uint256(balance >> 112) & mask;\n    }\n\n    /**\n     * @dev Returns the last block when the total balance changed.\n     */\n    function lastChangeBlock(bytes32 balance) internal pure returns (uint256) {\n        uint256 mask = 2**(32) - 1;\n        return uint256(balance >> 224) & mask;\n    }\n\n    /**\n     * @dev Returns the difference in \'managed\' between two balances.\n     */\n    function managedDelta(bytes32 newBalance, bytes32 oldBalance) internal pure returns (int256) {\n        // Because `managed` is a 112 bit value, we can safely perform unchecked arithmetic in 256 bits.\n        return int256(managed(newBalance)) - int256(managed(oldBalance));\n    }\n\n    /**\n     * @dev Returns the total balance for each entry in `balances`, as well as the latest block when the total\n     * balance of *any* of them last changed.\n     */\n    function totalsAndLastChangeBlock(bytes32[] memory balances)\n        internal\n        pure\n        returns (\n            uint256[] memory results,\n            uint256 lastChangeBlock_ // Avoid shadowing\n        )\n    {\n        results = new uint256[](balances.length);\n        lastChangeBlock_ = 0;\n\n        for (uint256 i = 0; i < results.length; i++) {\n            bytes32 balance = balances[i];\n            results[i] = total(balance);\n            lastChangeBlock_ = Math.max(lastChangeBlock_, lastChangeBlock(balance));\n        }\n    }\n\n    /**\n     * @dev Returns true if `balance`\'s \'total\' balance is zero. Costs less gas than computing \'total\' and comparing\n     * with zero.\n     */\n    function isZero(bytes32 balance) internal pure returns (bool) {\n        // We simply need to check the least significant 224 bytes of the word: the block does not affect this.\n        uint256 mask = 2**(224) - 1;\n        return (uint256(balance) & mask) == 0;\n    }\n\n    /**\n     * @dev Returns true if `balance`\'s \'total\' balance is not zero. Costs less gas than computing \'total\' and comparing\n     * with zero.\n     */\n    function isNotZero(bytes32 balance) internal pure returns (bool) {\n        return !isZero(balance);\n    }\n\n    /**\n     * @dev Packs together `cash` and `managed` amounts with a block to create a balance value.\n     *\n     * For consistency, this also checks that the sum of `cash` and `managed` (`total`) fits in 112 bits.\n     */\n    function toBalance(\n        uint256 _cash,\n        uint256 _managed,\n        uint256 _blockNumber\n    ) internal pure returns (bytes32) {\n        uint256 _total = _cash + _managed;\n\n        // Since both \'cash\' and \'managed\' are positive integers, by checking that their sum (\'total\') fits in 112 bits\n        // we are also indirectly checking that both \'cash\' and \'managed\' themselves fit in 112 bits.\n        _require(_total >= _cash && _total < 2**112, Errors.BALANCE_TOTAL_OVERFLOW);\n\n        // We assume the block fits in 32 bits - this is expected to hold for at least a few decades.\n        return _pack(_cash, _managed, _blockNumber);\n    }\n\n    /**\n     * @dev Increases a Pool\'s \'cash\' (and therefore its \'total\'). Called when Pool tokens are sent to the Vault (except\n     * for Asset Manager deposits).\n     *\n     * Updates the last total balance change block, even if `amount` is zero.\n     */\n    function increaseCash(bytes32 balance, uint256 amount) internal view returns (bytes32) {\n        uint256 newCash = cash(balance).add(amount);\n        uint256 currentManaged = managed(balance);\n        uint256 newLastChangeBlock = block.number;\n\n        return toBalance(newCash, currentManaged, newLastChangeBlock);\n    }\n\n    /**\n     * @dev Decreases a Pool\'s \'cash\' (and therefore its \'total\'). Called when Pool tokens are sent from the Vault\n     * (except for Asset Manager withdrawals).\n     *\n     * Updates the last total balance change block, even if `amount` is zero.\n     */\n    function decreaseCash(bytes32 balance, uint256 amount) internal view returns (bytes32) {\n        uint256 newCash = cash(balance).sub(amount);\n        uint256 currentManaged = managed(balance);\n        uint256 newLastChangeBlock = block.number;\n\n        return toBalance(newCash, currentManaged, newLastChangeBlock);\n    }\n\n    /**\n     * @dev Moves \'cash\' into \'managed\', leaving \'total\' unchanged. Called when an Asset Manager withdraws Pool tokens\n     * from the Vault.\n     */\n    function cashToManaged(bytes32 balance, uint256 amount) internal pure returns (bytes32) {\n        uint256 newCash = cash(balance).sub(amount);\n        uint256 newManaged = managed(balance).add(amount);\n        uint256 currentLastChangeBlock = lastChangeBlock(balance);\n\n        return toBalance(newCash, newManaged, currentLastChangeBlock);\n    }\n\n    /**\n     * @dev Moves \'managed\' into \'cash\', leaving \'total\' unchanged. Called when an Asset Manager deposits Pool tokens\n     * into the Vault.\n     */\n    function managedToCash(bytes32 balance, uint256 amount) internal pure returns (bytes32) {\n        uint256 newCash = cash(balance).add(amount);\n        uint256 newManaged = managed(balance).sub(amount);\n        uint256 currentLastChangeBlock = lastChangeBlock(balance);\n\n        return toBalance(newCash, newManaged, currentLastChangeBlock);\n    }\n\n    /**\n     * @dev Sets \'managed\' balance to an arbitrary value, changing \'total\'. Called when the Asset Manager reports\n     * profits or losses. It\'s the Manager\'s responsibility to provide a meaningful value.\n     *\n     * Updates the last total balance change block, even if `newManaged` is equal to the current \'managed\' value.\n     */\n    function setManaged(bytes32 balance, uint256 newManaged) internal view returns (bytes32) {\n        uint256 currentCash = cash(balance);\n        uint256 newLastChangeBlock = block.number;\n        return toBalance(currentCash, newManaged, newLastChangeBlock);\n    }\n\n    // Alternative mode for Pools with the Two Token specialization setting\n\n    // Instead of storing cash and external for each \'token in\' a single storage slot, Two Token Pools store the cash\n    // for both tokens in the same slot, and the managed for both in another one. This reduces the gas cost for swaps,\n    // because the only slot that needs to be updated is the one with the cash. However, it also means that managing\n    // balances is more cumbersome, as both tokens need to be read/written at the same time.\n    //\n    // The field with both cash balances packed is called sharedCash, and the one with external amounts is called\n    // sharedManaged. These two are collectively called the \'shared\' balance fields. In both of these, the portion\n    // that corresponds to token A is stored in the least significant 112 bits of a 256 bit word, while token B\'s part\n    // uses the next least significant 112 bits.\n    //\n    // Because only cash is written to during a swap, we store the last total balance change block with the\n    // packed cash fields. Typically Pools have a distinct block per token: in the case of Two Token Pools they\n    // are the same.\n\n    /**\n     * @dev Extracts the part of the balance that corresponds to token A. This function can be used to decode both\n     * shared cash and managed balances.\n     */\n    function _decodeBalanceA(bytes32 sharedBalance) private pure returns (uint256) {\n        uint256 mask = 2**(112) - 1;\n        return uint256(sharedBalance) & mask;\n    }\n\n    /**\n     * @dev Extracts the part of the balance that corresponds to token B. This function can be used to decode both\n     * shared cash and managed balances.\n     */\n    function _decodeBalanceB(bytes32 sharedBalance) private pure returns (uint256) {\n        uint256 mask = 2**(112) - 1;\n        return uint256(sharedBalance >> 112) & mask;\n    }\n\n    // To decode the last balance change block, we can simply use the `blockNumber` function.\n\n    /**\n     * @dev Unpacks the shared token A and token B cash and managed balances into the balance for token A.\n     */\n    function fromSharedToBalanceA(bytes32 sharedCash, bytes32 sharedManaged) internal pure returns (bytes32) {\n        // Note that we extract the block from the sharedCash field, which is the one that is updated by swaps.\n        // Both token A and token B use the same block\n        return toBalance(_decodeBalanceA(sharedCash), _decodeBalanceA(sharedManaged), lastChangeBlock(sharedCash));\n    }\n\n    /**\n     * @dev Unpacks the shared token A and token B cash and managed balances into the balance for token B.\n     */\n    function fromSharedToBalanceB(bytes32 sharedCash, bytes32 sharedManaged) internal pure returns (bytes32) {\n        // Note that we extract the block from the sharedCash field, which is the one that is updated by swaps.\n        // Both token A and token B use the same block\n        return toBalance(_decodeBalanceB(sharedCash), _decodeBalanceB(sharedManaged), lastChangeBlock(sharedCash));\n    }\n\n    /**\n     * @dev Returns the sharedCash shared field, given the current balances for token A and token B.\n     */\n    function toSharedCash(bytes32 tokenABalance, bytes32 tokenBBalance) internal pure returns (bytes32) {\n        // Both balances are assigned the same block  Since it is possible a single one of them has changed (for\n        // example, in an Asset Manager update), we keep the latest (largest) one.\n        uint32 newLastChangeBlock = uint32(Math.max(lastChangeBlock(tokenABalance), lastChangeBlock(tokenBBalance)));\n\n        return _pack(cash(tokenABalance), cash(tokenBBalance), newLastChangeBlock);\n    }\n\n    /**\n     * @dev Returns the sharedManaged shared field, given the current balances for token A and token B.\n     */\n    function toSharedManaged(bytes32 tokenABalance, bytes32 tokenBBalance) internal pure returns (bytes32) {\n        // We don\'t bother storing a last change block, as it is read from the shared cash field.\n        return _pack(managed(tokenABalance), managed(tokenBBalance), 0);\n    }\n\n    // Shared functions\n\n    /**\n     * @dev Packs together two uint112 and one uint32 into a bytes32\n     */\n    function _pack(\n        uint256 _leastSignificant,\n        uint256 _midSignificant,\n        uint256 _mostSignificant\n    ) private pure returns (bytes32) {\n        return bytes32((_mostSignificant << 224) + (_midSignificant << 112) + _leastSignificant);\n    }\n}\n'}, 'contracts/vault/PoolTokens.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport ""../lib/helpers/BalancerErrors.sol"";\nimport ""../lib/openzeppelin/ReentrancyGuard.sol"";\n\nimport ""./AssetManagers.sol"";\nimport ""./PoolRegistry.sol"";\nimport ""./balances/BalanceAllocation.sol"";\n\nabstract contract PoolTokens is ReentrancyGuard, PoolRegistry, AssetManagers {\n    using BalanceAllocation for bytes32;\n    using BalanceAllocation for bytes32[];\n\n    function registerTokens(\n        bytes32 poolId,\n        IERC20[] memory tokens,\n        address[] memory assetManagers\n    ) external override nonReentrant whenNotPaused onlyPool(poolId) {\n        InputHelpers.ensureInputLengthMatch(tokens.length, assetManagers.length);\n\n        // Validates token addresses and assigns Asset Managers\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            IERC20 token = tokens[i];\n            _require(token != IERC20(0), Errors.INVALID_TOKEN);\n\n            _poolAssetManagers[poolId][token] = assetManagers[i];\n        }\n\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\n            _require(tokens.length == 2, Errors.TOKENS_LENGTH_MUST_BE_2);\n            _registerTwoTokenPoolTokens(poolId, tokens[0], tokens[1]);\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\n            _registerMinimalSwapInfoPoolTokens(poolId, tokens);\n        } else {\n            // PoolSpecialization.GENERAL\n            _registerGeneralPoolTokens(poolId, tokens);\n        }\n\n        emit TokensRegistered(poolId, tokens, assetManagers);\n    }\n\n    function deregisterTokens(bytes32 poolId, IERC20[] memory tokens)\n        external\n        override\n        nonReentrant\n        whenNotPaused\n        onlyPool(poolId)\n    {\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\n            _require(tokens.length == 2, Errors.TOKENS_LENGTH_MUST_BE_2);\n            _deregisterTwoTokenPoolTokens(poolId, tokens[0], tokens[1]);\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\n            _deregisterMinimalSwapInfoPoolTokens(poolId, tokens);\n        } else {\n            // PoolSpecialization.GENERAL\n            _deregisterGeneralPoolTokens(poolId, tokens);\n        }\n\n        // The deregister calls above ensure the total token balance is zero. Therefore it is now safe to remove any\n        // associated Asset Managers, since they hold no Pool balance.\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            delete _poolAssetManagers[poolId][tokens[i]];\n        }\n\n        emit TokensDeregistered(poolId, tokens);\n    }\n\n    function getPoolTokens(bytes32 poolId)\n        external\n        view\n        override\n        withRegisteredPool(poolId)\n        returns (\n            IERC20[] memory tokens,\n            uint256[] memory balances,\n            uint256 lastChangeBlock\n        )\n    {\n        bytes32[] memory rawBalances;\n        (tokens, rawBalances) = _getPoolTokens(poolId);\n        (balances, lastChangeBlock) = rawBalances.totalsAndLastChangeBlock();\n    }\n\n    function getPoolTokenInfo(bytes32 poolId, IERC20 token)\n        external\n        view\n        override\n        withRegisteredPool(poolId)\n        returns (\n            uint256 cash,\n            uint256 managed,\n            uint256 lastChangeBlock,\n            address assetManager\n        )\n    {\n        bytes32 balance;\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\n\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\n            balance = _getTwoTokenPoolBalance(poolId, token);\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\n            balance = _getMinimalSwapInfoPoolBalance(poolId, token);\n        } else {\n            // PoolSpecialization.GENERAL\n            balance = _getGeneralPoolBalance(poolId, token);\n        }\n\n        cash = balance.cash();\n        managed = balance.managed();\n        lastChangeBlock = balance.lastChangeBlock();\n        assetManager = _poolAssetManagers[poolId][token];\n    }\n\n    /**\n     * @dev Returns all of `poolId`\'s registered tokens, along with their raw balances.\n     */\n    function _getPoolTokens(bytes32 poolId) internal view returns (IERC20[] memory tokens, bytes32[] memory balances) {\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\n            return _getTwoTokenPoolTokens(poolId);\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\n            return _getMinimalSwapInfoPoolTokens(poolId);\n        } else {\n            // PoolSpecialization.GENERAL\n            return _getGeneralPoolTokens(poolId);\n        }\n    }\n}\n'}, 'contracts/vault/UserBalance.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport ""../lib/helpers/BalancerErrors.sol"";\nimport ""../lib/math/Math.sol"";\nimport ""../lib/openzeppelin/IERC20.sol"";\nimport ""../lib/openzeppelin/ReentrancyGuard.sol"";\nimport ""../lib/openzeppelin/SafeCast.sol"";\nimport ""../lib/openzeppelin/SafeERC20.sol"";\n\nimport ""./AssetTransfersHandler.sol"";\nimport ""./VaultAuthorization.sol"";\n\n/**\n * Implement User Balance interactions, which combine Internal Balance and using the Vault\'s ERC20 allowance.\n *\n * Users can deposit tokens into the Vault, where they are allocated to their Internal Balance, and later\n * transferred or withdrawn. It can also be used as a source of tokens when joining Pools, as a destination\n * when exiting them, and as either when performing swaps. This usage of Internal Balance results in greatly reduced\n * gas costs when compared to relying on plain ERC20 transfers, leading to large savings for frequent users.\n *\n * Internal Balance management features batching, which means a single contract call can be used to perform multiple\n * operations of different kinds, with different senders and recipients, at once.\n */\nabstract contract UserBalance is ReentrancyGuard, AssetTransfersHandler, VaultAuthorization {\n    using Math for uint256;\n    using SafeCast for uint256;\n    using SafeERC20 for IERC20;\n\n    // Internal Balance for each token, for each account.\n    mapping(address => mapping(IERC20 => uint256)) private _internalTokenBalance;\n\n    function getInternalBalance(address user, IERC20[] memory tokens)\n        external\n        view\n        override\n        returns (uint256[] memory balances)\n    {\n        balances = new uint256[](tokens.length);\n        for (uint256 i = 0; i < tokens.length; i++) {\n            balances[i] = _getInternalBalance(user, tokens[i]);\n        }\n    }\n\n    function manageUserBalance(UserBalanceOp[] memory ops) external payable override nonReentrant {\n        // We need to track how much of the received ETH was used and wrapped into WETH to return any excess.\n        uint256 ethWrapped = 0;\n\n        // Cache for these checks so we only perform them once (if at all).\n        bool checkedCallerIsRelayer = false;\n        bool checkedNotPaused = false;\n\n        for (uint256 i = 0; i < ops.length; i++) {\n            UserBalanceOpKind kind;\n            IAsset asset;\n            uint256 amount;\n            address sender;\n            address payable recipient;\n\n            // This destructuring by calling `_validateUserBalanceOp` seems odd, but results in reduced bytecode size.\n            (kind, asset, amount, sender, recipient, checkedCallerIsRelayer) = _validateUserBalanceOp(\n                ops[i],\n                checkedCallerIsRelayer\n            );\n\n            if (kind == UserBalanceOpKind.WITHDRAW_INTERNAL) {\n                // Internal Balance withdrawals can always be performed by an authorized account.\n                _withdrawFromInternalBalance(asset, sender, recipient, amount);\n            } else {\n                // All other operations are blocked if the contract is paused.\n\n                // We cache the result of the pause check and skip it for other operations in this same transaction\n                // (if any).\n                if (!checkedNotPaused) {\n                    _ensureNotPaused();\n                    checkedNotPaused = true;\n                }\n\n                if (kind == UserBalanceOpKind.DEPOSIT_INTERNAL) {\n                    _depositToInternalBalance(asset, sender, recipient, amount);\n\n                    // Keep track of all ETH wrapped into WETH as part of a deposit.\n                    if (_isETH(asset)) {\n                        ethWrapped = ethWrapped.add(amount);\n                    }\n                } else {\n                    // Transfers don\'t support ETH.\n                    _require(!_isETH(asset), Errors.CANNOT_USE_ETH_SENTINEL);\n                    IERC20 token = _asIERC20(asset);\n\n                    if (kind == UserBalanceOpKind.TRANSFER_INTERNAL) {\n                        _transferInternalBalance(token, sender, recipient, amount);\n                    } else {\n                        // TRANSFER_EXTERNAL\n                        _transferToExternalBalance(token, sender, recipient, amount);\n                    }\n                }\n            }\n        }\n\n        // Handle any remaining ETH.\n        _handleRemainingEth(ethWrapped);\n    }\n\n    function _depositToInternalBalance(\n        IAsset asset,\n        address sender,\n        address recipient,\n        uint256 amount\n    ) private {\n        _increaseInternalBalance(recipient, _translateToIERC20(asset), amount);\n        _receiveAsset(asset, amount, sender, false);\n    }\n\n    function _withdrawFromInternalBalance(\n        IAsset asset,\n        address sender,\n        address payable recipient,\n        uint256 amount\n    ) private {\n        // A partial decrease of Internal Balance is disallowed: `sender` must have the full `amount`.\n        _decreaseInternalBalance(sender, _translateToIERC20(asset), amount, false);\n        _sendAsset(asset, amount, recipient, false);\n    }\n\n    function _transferInternalBalance(\n        IERC20 token,\n        address sender,\n        address recipient,\n        uint256 amount\n    ) private {\n        // A partial decrease of Internal Balance is disallowed: `sender` must have the full `amount`.\n        _decreaseInternalBalance(sender, token, amount, false);\n        _increaseInternalBalance(recipient, token, amount);\n    }\n\n    function _transferToExternalBalance(\n        IERC20 token,\n        address sender,\n        address recipient,\n        uint256 amount\n    ) private {\n        if (amount > 0) {\n            token.safeTransferFrom(sender, recipient, amount);\n            emit ExternalBalanceTransfer(token, sender, recipient, amount);\n        }\n    }\n\n    /**\n     * @dev Increases `account`\'s Internal Balance for `token` by `amount`.\n     */\n    function _increaseInternalBalance(\n        address account,\n        IERC20 token,\n        uint256 amount\n    ) internal override {\n        uint256 currentBalance = _getInternalBalance(account, token);\n        uint256 newBalance = currentBalance.add(amount);\n        _setInternalBalance(account, token, newBalance, amount.toInt256());\n    }\n\n    /**\n     * @dev Decreases `account`\'s Internal Balance for `token` by `amount`. If `allowPartial` is true, this function\n     * doesn\'t revert if `account` doesn\'t have enough balance, and sets it to zero and returns the deducted amount\n     * instead.\n     */\n    function _decreaseInternalBalance(\n        address account,\n        IERC20 token,\n        uint256 amount,\n        bool allowPartial\n    ) internal override returns (uint256 deducted) {\n        uint256 currentBalance = _getInternalBalance(account, token);\n        _require(allowPartial || (currentBalance >= amount), Errors.INSUFFICIENT_INTERNAL_BALANCE);\n\n        deducted = Math.min(currentBalance, amount);\n        // By construction, `deducted` is lower or equal to `currentBalance`, so we don\'t need to use checked\n        // arithmetic.\n        uint256 newBalance = currentBalance - deducted;\n        _setInternalBalance(account, token, newBalance, -(deducted.toInt256()));\n    }\n\n    /**\n     * @dev Sets `account`\'s Internal Balance for `token` to `newBalance`.\n     *\n     * Emits an `InternalBalanceChanged` event. This event includes `delta`, which is the amount the balance increased\n     * (if positive) or decreased (if negative). To avoid reading the current balance in order to compute the delta,\n     * this function relies on the caller providing it directly.\n     */\n    function _setInternalBalance(\n        address account,\n        IERC20 token,\n        uint256 newBalance,\n        int256 delta\n    ) private {\n        _internalTokenBalance[account][token] = newBalance;\n        emit InternalBalanceChanged(account, token, delta);\n    }\n\n    /**\n     * @dev Returns `account`\'s Internal Balance for `token`.\n     */\n    function _getInternalBalance(address account, IERC20 token) internal view returns (uint256) {\n        return _internalTokenBalance[account][token];\n    }\n\n    /**\n     * @dev Destructures a User Balance operation, validating that the contract caller is allowed to perform it.\n     */\n    function _validateUserBalanceOp(UserBalanceOp memory op, bool checkedCallerIsRelayer)\n        private\n        view\n        returns (\n            UserBalanceOpKind,\n            IAsset,\n            uint256,\n            address,\n            address payable,\n            bool\n        )\n    {\n        // The only argument we need to validate is `sender`, which can only be either the contract caller, or a\n        // relayer approved by `sender`.\n        address sender = op.sender;\n\n        if (sender != msg.sender) {\n            // We need to check both that the contract caller is a relayer, and that `sender` approved them.\n\n            // Because the relayer check is global (i.e. independent of `sender`), we cache that result and skip it for\n            // other operations in this same transaction (if any).\n            if (!checkedCallerIsRelayer) {\n                _authenticateCaller();\n                checkedCallerIsRelayer = true;\n            }\n\n            _require(_hasApprovedRelayer(sender, msg.sender), Errors.USER_DOESNT_ALLOW_RELAYER);\n        }\n\n        return (op.kind, op.asset, op.amount, sender, op.recipient, checkedCallerIsRelayer);\n    }\n}\n'}, 'contracts/vault/interfaces/IBasePool.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport ""./IVault.sol"";\nimport ""./IPoolSwapStructs.sol"";\n\n/**\n * @dev Interface for adding and removing liquidity that all Pool contracts should implement. Note that this is not\n * the complete Pool contract interface, as it is missing the swap hooks. Pool contracts should also inherit from\n * either IGeneralPool or IMinimalSwapInfoPool\n */\ninterface IBasePool is IPoolSwapStructs {\n    /**\n     * @dev Called by the Vault when a user calls `IVault.joinPool` to add liquidity to this Pool. Returns how many of\n     * each registered token the user should provide, as well as the amount of protocol fees the Pool owes to the Vault.\n     * The Vault will then take tokens from `sender` and add them to the Pool\'s balances, as well as collect\n     * the reported amount in protocol fees, which the pool should calculate based on `protocolSwapFeePercentage`.\n     *\n     * Protocol fees are reported and charged on join events so that the Pool is free of debt whenever new users join.\n     *\n     * `sender` is the account performing the join (from which tokens will be withdrawn), and `recipient` is the account\n     * designated to receive any benefits (typically pool shares). `currentBalances` contains the total balances\n     * for each token the Pool registered in the Vault, in the same order that `IVault.getPoolTokens` would return.\n     *\n     * `lastChangeBlock` is the last block in which *any* of the Pool\'s registered tokens last changed its total\n     * balance.\n     *\n     * `userData` contains any pool-specific instructions needed to perform the calculations, such as the type of\n     * join (e.g., proportional given an amount of pool shares, single-asset, multi-asset, etc.)\n     *\n     * Contracts implementing this function should check that the caller is indeed the Vault before performing any\n     * state-changing operations, such as minting pool shares.\n     */\n    function onJoinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external returns (uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts);\n\n    /**\n     * @dev Called by the Vault when a user calls `IVault.exitPool` to remove liquidity from this Pool. Returns how many\n     * tokens the Vault should deduct from the Pool\'s balances, as well as the amount of protocol fees the Pool owes\n     * to the Vault. The Vault will then take tokens from the Pool\'s balances and send them to `recipient`,\n     * as well as collect the reported amount in protocol fees, which the Pool should calculate based on\n     * `protocolSwapFeePercentage`.\n     *\n     * Protocol fees are charged on exit events to guarantee that users exiting the Pool have paid their share.\n     *\n     * `sender` is the account performing the exit (typically the pool shareholder), and `recipient` is the account\n     * to which the Vault will send the proceeds. `currentBalances` contains the total token balances for each token\n     * the Pool registered in the Vault, in the same order that `IVault.getPoolTokens` would return.\n     *\n     * `lastChangeBlock` is the last block in which *any* of the Pool\'s registered tokens last changed its total\n     * balance.\n     *\n     * `userData` contains any pool-specific instructions needed to perform the calculations, such as the type of\n     * exit (e.g., proportional given an amount of pool shares, single-asset, multi-asset, etc.)\n     *\n     * Contracts implementing this function should check that the caller is indeed the Vault before performing any\n     * state-changing operations, such as burning pool shares.\n     */\n    function onExitPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external returns (uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts);\n}\n'}, 'contracts/vault/AssetManagers.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport ""../lib/math/Math.sol"";\nimport ""../lib/helpers/BalancerErrors.sol"";\nimport ""../lib/helpers/InputHelpers.sol"";\nimport ""../lib/openzeppelin/IERC20.sol"";\nimport ""../lib/openzeppelin/SafeERC20.sol"";\nimport ""../lib/openzeppelin/ReentrancyGuard.sol"";\n\nimport ""./UserBalance.sol"";\nimport ""./balances/BalanceAllocation.sol"";\nimport ""./balances/GeneralPoolsBalance.sol"";\nimport ""./balances/MinimalSwapInfoPoolsBalance.sol"";\nimport ""./balances/TwoTokenPoolsBalance.sol"";\n\nabstract contract AssetManagers is\n    ReentrancyGuard,\n    GeneralPoolsBalance,\n    MinimalSwapInfoPoolsBalance,\n    TwoTokenPoolsBalance\n{\n    using Math for uint256;\n    using SafeERC20 for IERC20;\n\n    // Stores the Asset Manager for each token of each Pool.\n    mapping(bytes32 => mapping(IERC20 => address)) internal _poolAssetManagers;\n\n    function managePoolBalance(PoolBalanceOp[] memory ops) external override nonReentrant whenNotPaused {\n        // This variable could be declared inside the loop, but that causes the compiler to allocate memory on each\n        // loop iteration, increasing gas costs.\n        PoolBalanceOp memory op;\n\n        for (uint256 i = 0; i < ops.length; ++i) {\n            // By indexing the array only once, we don\'t spend extra gas in the same bounds check.\n            op = ops[i];\n\n            bytes32 poolId = op.poolId;\n            _ensureRegisteredPool(poolId);\n\n            IERC20 token = op.token;\n            _require(_isTokenRegistered(poolId, token), Errors.TOKEN_NOT_REGISTERED);\n            _require(_poolAssetManagers[poolId][token] == msg.sender, Errors.SENDER_NOT_ASSET_MANAGER);\n\n            PoolBalanceOpKind kind = op.kind;\n            uint256 amount = op.amount;\n            (int256 cashDelta, int256 managedDelta) = _performPoolManagementOperation(kind, poolId, token, amount);\n\n            emit PoolBalanceManaged(poolId, msg.sender, token, cashDelta, managedDelta);\n        }\n    }\n\n    /**\n     * @dev Performs the `kind` Asset Manager operation on a Pool.\n     *\n     * Withdrawals will transfer `amount` tokens to the caller, deposits will transfer `amount` tokens from the caller,\n     * and updates will set the managed balance to `amount`.\n     *\n     * Returns a tuple with the \'cash\' and \'managed\' balance deltas as a result of this call.\n     */\n    function _performPoolManagementOperation(\n        PoolBalanceOpKind kind,\n        bytes32 poolId,\n        IERC20 token,\n        uint256 amount\n    ) private returns (int256, int256) {\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\n\n        if (kind == PoolBalanceOpKind.WITHDRAW) {\n            return _withdrawPoolBalance(poolId, specialization, token, amount);\n        } else if (kind == PoolBalanceOpKind.DEPOSIT) {\n            return _depositPoolBalance(poolId, specialization, token, amount);\n        } else {\n            // PoolBalanceOpKind.UPDATE\n            return _updateManagedBalance(poolId, specialization, token, amount);\n        }\n    }\n\n    /**\n     * @dev Moves `amount` tokens from a Pool\'s \'cash\' to \'managed\' balance, and transfers them to the caller.\n     *\n     * Returns the \'cash\' and \'managed\' balance deltas as a result of this call, which will be complementary.\n     */\n    function _withdrawPoolBalance(\n        bytes32 poolId,\n        PoolSpecialization specialization,\n        IERC20 token,\n        uint256 amount\n    ) private returns (int256 cashDelta, int256 managedDelta) {\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\n            _twoTokenPoolCashToManaged(poolId, token, amount);\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\n            _minimalSwapInfoPoolCashToManaged(poolId, token, amount);\n        } else {\n            // PoolSpecialization.GENERAL\n            _generalPoolCashToManaged(poolId, token, amount);\n        }\n\n        if (amount > 0) {\n            token.safeTransfer(msg.sender, amount);\n        }\n\n        // Since \'cash\' and \'managed\' are stored as uint112, `amount` is guaranteed to also fit in 112 bits. It will\n        // therefore always fit in a 256 bit integer.\n        cashDelta = int256(-amount);\n        managedDelta = int256(amount);\n    }\n\n    /**\n     * @dev Moves `amount` tokens from a Pool\'s \'managed\' to \'cash\' balance, and transfers them from the caller.\n     *\n     * Returns the \'cash\' and \'managed\' balance deltas as a result of this call, which will be complementary.\n     */\n    function _depositPoolBalance(\n        bytes32 poolId,\n        PoolSpecialization specialization,\n        IERC20 token,\n        uint256 amount\n    ) private returns (int256 cashDelta, int256 managedDelta) {\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\n            _twoTokenPoolManagedToCash(poolId, token, amount);\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\n            _minimalSwapInfoPoolManagedToCash(poolId, token, amount);\n        } else {\n            // PoolSpecialization.GENERAL\n            _generalPoolManagedToCash(poolId, token, amount);\n        }\n\n        if (amount > 0) {\n            token.safeTransferFrom(msg.sender, address(this), amount);\n        }\n\n        // Since \'cash\' and \'managed\' are stored as uint112, `amount` is guaranteed to also fit in 112 bits. It will\n        // therefore always fit in a 256 bit integer.\n        cashDelta = int256(amount);\n        managedDelta = int256(-amount);\n    }\n\n    /**\n     * @dev Sets a Pool\'s \'managed\' balance to `amount`.\n     *\n     * Returns the \'cash\' and \'managed\' balance deltas as a result of this call (the \'cash\' delta will always be zero).\n     */\n    function _updateManagedBalance(\n        bytes32 poolId,\n        PoolSpecialization specialization,\n        IERC20 token,\n        uint256 amount\n    ) private returns (int256 cashDelta, int256 managedDelta) {\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\n            managedDelta = _setTwoTokenPoolManagedBalance(poolId, token, amount);\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\n            managedDelta = _setMinimalSwapInfoPoolManagedBalance(poolId, token, amount);\n        } else {\n            // PoolSpecialization.GENERAL\n            managedDelta = _setGeneralPoolManagedBalance(poolId, token, amount);\n        }\n\n        cashDelta = 0;\n    }\n\n    /**\n     * @dev Returns true if `token` is registered for `poolId`.\n     */\n    function _isTokenRegistered(bytes32 poolId, IERC20 token) private view returns (bool) {\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\n            return _isTwoTokenPoolTokenRegistered(poolId, token);\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\n            return _isMinimalSwapInfoPoolTokenRegistered(poolId, token);\n        } else {\n            // PoolSpecialization.GENERAL\n            return _isGeneralPoolTokenRegistered(poolId, token);\n        }\n    }\n}\n'}, 'contracts/vault/PoolRegistry.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport ""../lib/helpers/BalancerErrors.sol"";\nimport ""../lib/openzeppelin/ReentrancyGuard.sol"";\n\nimport ""./VaultAuthorization.sol"";\n\n/**\n * @dev Maintains the Pool ID data structure, implements Pool ID creation and registration, and defines useful modifiers\n * and helper functions for ensuring correct behavior when working with Pools.\n */\nabstract contract PoolRegistry is ReentrancyGuard, VaultAuthorization {\n    // Each pool is represented by their unique Pool ID. We use `bytes32` for them, for lack of a way to define new\n    // types.\n    mapping(bytes32 => bool) private _isPoolRegistered;\n\n    // We keep an increasing nonce to make Pool IDs unique. It is interpreted as a `uint80`, but storing it as a\n    // `uint256` results in reduced bytecode on reads and writes due to the lack of masking.\n    uint256 private _nextPoolNonce;\n\n    /**\n     * @dev Reverts unless `poolId` corresponds to a registered Pool.\n     */\n    modifier withRegisteredPool(bytes32 poolId) {\n        _ensureRegisteredPool(poolId);\n        _;\n    }\n\n    /**\n     * @dev Reverts unless `poolId` corresponds to a registered Pool, and the caller is the Pool\'s contract.\n     */\n    modifier onlyPool(bytes32 poolId) {\n        _ensurePoolIsSender(poolId);\n        _;\n    }\n\n    /**\n     * @dev Reverts unless `poolId` corresponds to a registered Pool.\n     */\n    function _ensureRegisteredPool(bytes32 poolId) internal view {\n        _require(_isPoolRegistered[poolId], Errors.INVALID_POOL_ID);\n    }\n\n    /**\n     * @dev Reverts unless `poolId` corresponds to a registered Pool, and the caller is the Pool\'s contract.\n     */\n    function _ensurePoolIsSender(bytes32 poolId) private view {\n        _ensureRegisteredPool(poolId);\n        _require(msg.sender == _getPoolAddress(poolId), Errors.CALLER_NOT_POOL);\n    }\n\n    function registerPool(PoolSpecialization specialization)\n        external\n        override\n        nonReentrant\n        whenNotPaused\n        returns (bytes32)\n    {\n        // Each Pool is assigned a unique ID based on an incrementing nonce. This assumes there will never be more than\n        // 2**80 Pools, and the nonce will not overflow.\n\n        bytes32 poolId = _toPoolId(msg.sender, specialization, uint80(_nextPoolNonce));\n\n        _require(!_isPoolRegistered[poolId], Errors.INVALID_POOL_ID); // Should never happen as Pool IDs are unique.\n        _isPoolRegistered[poolId] = true;\n\n        _nextPoolNonce += 1;\n\n        // Note that msg.sender is the pool\'s contract\n        emit PoolRegistered(poolId, msg.sender, specialization);\n        return poolId;\n    }\n\n    function getPool(bytes32 poolId)\n        external\n        view\n        override\n        withRegisteredPool(poolId)\n        returns (address, PoolSpecialization)\n    {\n        return (_getPoolAddress(poolId), _getPoolSpecialization(poolId));\n    }\n\n    /**\n     * @dev Creates a Pool ID.\n     *\n     * These are deterministically created by packing the Pool\'s contract address and its specialization setting into\n     * the ID. This saves gas by making this data easily retrievable from a Pool ID with no storage accesses.\n     *\n     * Since a single contract can register multiple Pools, a unique nonce must be provided to ensure Pool IDs are\n     * unique.\n     *\n     * Pool IDs have the following layout:\n     * | 20 bytes pool contract address | 2 bytes specialization setting | 10 bytes nonce |\n     * MSB                                                                              LSB\n     *\n     * 2 bytes for the specialization setting is a bit overkill: there only three of them, which means two bits would\n     * suffice. However, there\'s nothing else of interest to store in this extra space.\n     */\n    function _toPoolId(\n        address pool,\n        PoolSpecialization specialization,\n        uint80 nonce\n    ) internal pure returns (bytes32) {\n        bytes32 serialized;\n\n        serialized |= bytes32(uint256(nonce));\n        serialized |= bytes32(uint256(specialization)) << (10 * 8);\n        serialized |= bytes32(uint256(pool)) << (12 * 8);\n\n        return serialized;\n    }\n\n    /**\n     * @dev Returns the address of a Pool\'s contract.\n     *\n     * Due to how Pool IDs are created, this is done with no storage accesses and costs little gas.\n     */\n    function _getPoolAddress(bytes32 poolId) internal pure returns (address) {\n        // 12 byte logical shift left to remove the nonce and specialization setting. We don\'t need to mask,\n        // since the logical shift already sets the upper bits to zero.\n        return address(uint256(poolId) >> (12 * 8));\n    }\n\n    /**\n     * @dev Returns the specialization setting of a Pool.\n     *\n     * Due to how Pool IDs are created, this is done with no storage accesses and costs little gas.\n     */\n    function _getPoolSpecialization(bytes32 poolId) internal pure returns (PoolSpecialization specialization) {\n        // 10 byte logical shift left to remove the nonce, followed by a 2 byte mask to remove the address.\n        uint256 value = uint256(poolId >> (10 * 8)) & (2**(2 * 8) - 1);\n\n        // Casting a value into an enum results in a runtime check that reverts unless the value is within the enum\'s\n        // range. Passing an invalid Pool ID to this function would then result in an obscure revert with no reason\n        // string: we instead perform the check ourselves to help in error diagnosis.\n\n        // There are three Pool specialization settings: general, minimal swap info and two tokens, which correspond to\n        // values 0, 1 and 2.\n        _require(value < 3, Errors.INVALID_POOL_ID);\n\n        // Because we have checked that `value` is within the enum range, we can use assembly to skip the runtime check.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            specialization := value\n        }\n    }\n}\n'}, 'contracts/vault/balances/GeneralPoolsBalance.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\nimport ""../../lib/helpers/BalancerErrors.sol"";\nimport ""../../lib/openzeppelin/EnumerableMap.sol"";\nimport ""../../lib/openzeppelin/IERC20.sol"";\n\nimport ""./BalanceAllocation.sol"";\n\nabstract contract GeneralPoolsBalance {\n    using BalanceAllocation for bytes32;\n    using EnumerableMap for EnumerableMap.IERC20ToBytes32Map;\n\n    // Data for Pools with the General specialization setting\n    //\n    // These Pools use the IGeneralPool interface, which means the Vault must query the balance for *all* of their\n    // tokens in every swap. If we kept a mapping of token to balance plus a set (array) of tokens, it\'d be very gas\n    // intensive to read all token addresses just to then do a lookup on the balance mapping.\n    //\n    // Instead, we use our customized EnumerableMap, which lets us read the N balances in N+1 storage accesses (one for\n    // each token in the Pool), access the index of any \'token in\' a single read (required for the IGeneralPool call),\n    // and update an entry\'s value given its index.\n\n    // Map of token -> balance pairs for each Pool with this specialization. Many functions rely on storage pointers to\n    // a Pool\'s EnumerableMap to save gas when computing storage slots.\n    mapping(bytes32 => EnumerableMap.IERC20ToBytes32Map) internal _generalPoolsBalances;\n\n    /**\n     * @dev Registers a list of tokens in a General Pool.\n     *\n     * This function assumes `poolId` exists and corresponds to the General specialization setting.\n     *\n     * Requirements:\n     *\n     * - `tokens` must not be registered in the Pool\n     * - `tokens` must not contain duplicates\n     */\n    function _registerGeneralPoolTokens(bytes32 poolId, IERC20[] memory tokens) internal {\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[poolId];\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            // EnumerableMaps require an explicit initial value when creating a key-value pair: we use zero, the same\n            // value that is found in uninitialized storage, which corresponds to an empty balance.\n            bool added = poolBalances.set(tokens[i], 0);\n            _require(added, Errors.TOKEN_ALREADY_REGISTERED);\n        }\n    }\n\n    /**\n     * @dev Deregisters a list of tokens in a General Pool.\n     *\n     * This function assumes `poolId` exists and corresponds to the General specialization setting.\n     *\n     * Requirements:\n     *\n     * - `tokens` must be registered in the Pool\n     * - `tokens` must have zero balance in the Vault\n     * - `tokens` must not contain duplicates\n     */\n    function _deregisterGeneralPoolTokens(bytes32 poolId, IERC20[] memory tokens) internal {\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[poolId];\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            IERC20 token = tokens[i];\n            bytes32 currentBalance = _getGeneralPoolBalance(poolBalances, token);\n            _require(currentBalance.isZero(), Errors.NONZERO_TOKEN_BALANCE);\n\n            // We don\'t need to check remove\'s return value, since _getGeneralPoolBalance already checks that the token\n            // was registered.\n            poolBalances.remove(token);\n        }\n    }\n\n    /**\n     * @dev Sets the balances of a General Pool\'s tokens to `balances`.\n     *\n     * WARNING: this assumes `balances` has the same length and order as the Pool\'s tokens.\n     */\n    function _setGeneralPoolBalances(bytes32 poolId, bytes32[] memory balances) internal {\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[poolId];\n\n        for (uint256 i = 0; i < balances.length; ++i) {\n            // Since we assume all balances are properly ordered, we can simply use `unchecked_setAt` to avoid one less\n            // storage read per token.\n            poolBalances.unchecked_setAt(i, balances[i]);\n        }\n    }\n\n    /**\n     * @dev Transforms `amount` of `token`\'s balance in a General Pool from cash into managed.\n     *\n     * This function assumes `poolId` exists, corresponds to the General specialization setting, and that `token` is\n     * registered for that Pool.\n     */\n    function _generalPoolCashToManaged(\n        bytes32 poolId,\n        IERC20 token,\n        uint256 amount\n    ) internal {\n        _updateGeneralPoolBalance(poolId, token, BalanceAllocation.cashToManaged, amount);\n    }\n\n    /**\n     * @dev Transforms `amount` of `token`\'s balance in a General Pool from managed into cash.\n     *\n     * This function assumes `poolId` exists, corresponds to the General specialization setting, and that `token` is\n     * registered for that Pool.\n     */\n    function _generalPoolManagedToCash(\n        bytes32 poolId,\n        IERC20 token,\n        uint256 amount\n    ) internal {\n        _updateGeneralPoolBalance(poolId, token, BalanceAllocation.managedToCash, amount);\n    }\n\n    /**\n     * @dev Sets `token`\'s managed balance in a General Pool to `amount`.\n     *\n     * This function assumes `poolId` exists, corresponds to the General specialization setting, and that `token` is\n     * registered for that Pool.\n     *\n     * Returns the managed balance delta as a result of this call.\n     */\n    function _setGeneralPoolManagedBalance(\n        bytes32 poolId,\n        IERC20 token,\n        uint256 amount\n    ) internal returns (int256) {\n        return _updateGeneralPoolBalance(poolId, token, BalanceAllocation.setManaged, amount);\n    }\n\n    /**\n     * @dev Sets `token`\'s balance in a General Pool to the result of the `mutation` function when called with the\n     * current balance and `amount`.\n     *\n     * This function assumes `poolId` exists, corresponds to the General specialization setting, and that `token` is\n     * registered for that Pool.\n     *\n     * Returns the managed balance delta as a result of this call.\n     */\n    function _updateGeneralPoolBalance(\n        bytes32 poolId,\n        IERC20 token,\n        function(bytes32, uint256) returns (bytes32) mutation,\n        uint256 amount\n    ) private returns (int256) {\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[poolId];\n        bytes32 currentBalance = _getGeneralPoolBalance(poolBalances, token);\n\n        bytes32 newBalance = mutation(currentBalance, amount);\n        poolBalances.set(token, newBalance);\n\n        return newBalance.managedDelta(currentBalance);\n    }\n\n    /**\n     * @dev Returns an array with all the tokens and balances in a General Pool. The order may change when tokens are\n     * registered or deregistered.\n     *\n     * This function assumes `poolId` exists and corresponds to the General specialization setting.\n     */\n    function _getGeneralPoolTokens(bytes32 poolId)\n        internal\n        view\n        returns (IERC20[] memory tokens, bytes32[] memory balances)\n    {\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[poolId];\n        tokens = new IERC20[](poolBalances.length());\n        balances = new bytes32[](tokens.length);\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            // Because the iteration is bounded by `tokens.length`, which matches the EnumerableMap\'s length, we can use\n            // `unchecked_at` as we know `i` is a valid token index, saving storage reads.\n            (tokens[i], balances[i]) = poolBalances.unchecked_at(i);\n        }\n    }\n\n    /**\n     * @dev Returns the balance of a token in a General Pool.\n     *\n     * This function assumes `poolId` exists and corresponds to the General specialization setting.\n     *\n     * Requirements:\n     *\n     * - `token` must be registered in the Pool\n     */\n    function _getGeneralPoolBalance(bytes32 poolId, IERC20 token) internal view returns (bytes32) {\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[poolId];\n        return _getGeneralPoolBalance(poolBalances, token);\n    }\n\n    /**\n     * @dev Same as `_getGeneralPoolBalance` but using a Pool\'s storage pointer, which saves gas in repeated reads and\n     * writes.\n     */\n    function _getGeneralPoolBalance(EnumerableMap.IERC20ToBytes32Map storage poolBalances, IERC20 token)\n        private\n        view\n        returns (bytes32)\n    {\n        return poolBalances.get(token, Errors.TOKEN_NOT_REGISTERED);\n    }\n\n    /**\n     * @dev Returns true if `token` is registered in a General Pool.\n     *\n     * This function assumes `poolId` exists and corresponds to the General specialization setting.\n     */\n    function _isGeneralPoolTokenRegistered(bytes32 poolId, IERC20 token) internal view returns (bool) {\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[poolId];\n        return poolBalances.contains(token);\n    }\n}\n'}, 'contracts/vault/balances/MinimalSwapInfoPoolsBalance.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport ""../../lib/helpers/BalancerErrors.sol"";\nimport ""../../lib/openzeppelin/EnumerableSet.sol"";\nimport ""../../lib/openzeppelin/IERC20.sol"";\n\nimport ""./BalanceAllocation.sol"";\nimport ""../PoolRegistry.sol"";\n\nabstract contract MinimalSwapInfoPoolsBalance is PoolRegistry {\n    using BalanceAllocation for bytes32;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // Data for Pools with the Minimal Swap Info specialization setting\n    //\n    // These Pools use the IMinimalSwapInfoPool interface, and so the Vault must read the balance of the two tokens\n    // in the swap. The best solution is to use a mapping from token to balance, which lets us read or write any token\'s\n    // balance in a single storage access.\n    //\n    // We also keep a set of registered tokens. Because tokens with non-zero balance are by definition registered, in\n    // some balance getters we skip checking for token registration if a non-zero balance is found, saving gas by\n    // performing a single read instead of two.\n\n    mapping(bytes32 => mapping(IERC20 => bytes32)) internal _minimalSwapInfoPoolsBalances;\n    mapping(bytes32 => EnumerableSet.AddressSet) internal _minimalSwapInfoPoolsTokens;\n\n    /**\n     * @dev Registers a list of tokens in a Minimal Swap Info Pool.\n     *\n     * This function assumes `poolId` exists and corresponds to the Minimal Swap Info specialization setting.\n     *\n     * Requirements:\n     *\n     * - `tokens` must not be registered in the Pool\n     * - `tokens` must not contain duplicates\n     */\n    function _registerMinimalSwapInfoPoolTokens(bytes32 poolId, IERC20[] memory tokens) internal {\n        EnumerableSet.AddressSet storage poolTokens = _minimalSwapInfoPoolsTokens[poolId];\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            bool added = poolTokens.add(address(tokens[i]));\n            _require(added, Errors.TOKEN_ALREADY_REGISTERED);\n            // Note that we don\'t initialize the balance mapping: the default value of zero corresponds to an empty\n            // balance.\n        }\n    }\n\n    /**\n     * @dev Deregisters a list of tokens in a Minimal Swap Info Pool.\n     *\n     * This function assumes `poolId` exists and corresponds to the Minimal Swap Info specialization setting.\n     *\n     * Requirements:\n     *\n     * - `tokens` must be registered in the Pool\n     * - `tokens` must have zero balance in the Vault\n     * - `tokens` must not contain duplicates\n     */\n    function _deregisterMinimalSwapInfoPoolTokens(bytes32 poolId, IERC20[] memory tokens) internal {\n        EnumerableSet.AddressSet storage poolTokens = _minimalSwapInfoPoolsTokens[poolId];\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            IERC20 token = tokens[i];\n            _require(_minimalSwapInfoPoolsBalances[poolId][token].isZero(), Errors.NONZERO_TOKEN_BALANCE);\n\n            // For consistency with other Pool specialization settings, we explicitly reset the balance (which may have\n            // a non-zero last change block).\n            delete _minimalSwapInfoPoolsBalances[poolId][token];\n\n            bool removed = poolTokens.remove(address(token));\n            _require(removed, Errors.TOKEN_NOT_REGISTERED);\n        }\n    }\n\n    /**\n     * @dev Sets the balances of a Minimal Swap Info Pool\'s tokens to `balances`.\n     *\n     * WARNING: this assumes `balances` has the same length and order as the Pool\'s tokens.\n     */\n    function _setMinimalSwapInfoPoolBalances(\n        bytes32 poolId,\n        IERC20[] memory tokens,\n        bytes32[] memory balances\n    ) internal {\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            _minimalSwapInfoPoolsBalances[poolId][tokens[i]] = balances[i];\n        }\n    }\n\n    /**\n     * @dev Transforms `amount` of `token`\'s balance in a Minimal Swap Info Pool from cash into managed.\n     *\n     * This function assumes `poolId` exists, corresponds to the Minimal Swap Info specialization setting, and that\n     * `token` is registered for that Pool.\n     */\n    function _minimalSwapInfoPoolCashToManaged(\n        bytes32 poolId,\n        IERC20 token,\n        uint256 amount\n    ) internal {\n        _updateMinimalSwapInfoPoolBalance(poolId, token, BalanceAllocation.cashToManaged, amount);\n    }\n\n    /**\n     * @dev Transforms `amount` of `token`\'s balance in a Minimal Swap Info Pool from managed into cash.\n     *\n     * This function assumes `poolId` exists, corresponds to the Minimal Swap Info specialization setting, and that\n     * `token` is registered for that Pool.\n     */\n    function _minimalSwapInfoPoolManagedToCash(\n        bytes32 poolId,\n        IERC20 token,\n        uint256 amount\n    ) internal {\n        _updateMinimalSwapInfoPoolBalance(poolId, token, BalanceAllocation.managedToCash, amount);\n    }\n\n    /**\n     * @dev Sets `token`\'s managed balance in a Minimal Swap Info Pool to `amount`.\n     *\n     * This function assumes `poolId` exists, corresponds to the Minimal Swap Info specialization setting, and that\n     * `token` is registered for that Pool.\n     *\n     * Returns the managed balance delta as a result of this call.\n     */\n    function _setMinimalSwapInfoPoolManagedBalance(\n        bytes32 poolId,\n        IERC20 token,\n        uint256 amount\n    ) internal returns (int256) {\n        return _updateMinimalSwapInfoPoolBalance(poolId, token, BalanceAllocation.setManaged, amount);\n    }\n\n    /**\n     * @dev Sets `token`\'s balance in a Minimal Swap Info Pool to the result of the `mutation` function when called with\n     * the current balance and `amount`.\n     *\n     * This function assumes `poolId` exists, corresponds to the Minimal Swap Info specialization setting, and that\n     * `token` is registered for that Pool.\n     *\n     * Returns the managed balance delta as a result of this call.\n     */\n    function _updateMinimalSwapInfoPoolBalance(\n        bytes32 poolId,\n        IERC20 token,\n        function(bytes32, uint256) returns (bytes32) mutation,\n        uint256 amount\n    ) internal returns (int256) {\n        bytes32 currentBalance = _getMinimalSwapInfoPoolBalance(poolId, token);\n\n        bytes32 newBalance = mutation(currentBalance, amount);\n        _minimalSwapInfoPoolsBalances[poolId][token] = newBalance;\n\n        return newBalance.managedDelta(currentBalance);\n    }\n\n    /**\n     * @dev Returns an array with all the tokens and balances in a Minimal Swap Info Pool. The order may change when\n     * tokens are registered or deregistered.\n     *\n     * This function assumes `poolId` exists and corresponds to the Minimal Swap Info specialization setting.\n     */\n    function _getMinimalSwapInfoPoolTokens(bytes32 poolId)\n        internal\n        view\n        returns (IERC20[] memory tokens, bytes32[] memory balances)\n    {\n        EnumerableSet.AddressSet storage poolTokens = _minimalSwapInfoPoolsTokens[poolId];\n        tokens = new IERC20[](poolTokens.length());\n        balances = new bytes32[](tokens.length);\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            // Because the iteration is bounded by `tokens.length`, which matches the EnumerableSet\'s length, we can use\n            // `unchecked_at` as we know `i` is a valid token index, saving storage reads.\n            IERC20 token = IERC20(poolTokens.unchecked_at(i));\n            tokens[i] = token;\n            balances[i] = _minimalSwapInfoPoolsBalances[poolId][token];\n        }\n    }\n\n    /**\n     * @dev Returns the balance of a token in a Minimal Swap Info Pool.\n     *\n     * Requirements:\n     *\n     * - `poolId` must be a Minimal Swap Info Pool\n     * - `token` must be registered in the Pool\n     */\n    function _getMinimalSwapInfoPoolBalance(bytes32 poolId, IERC20 token) internal view returns (bytes32) {\n        bytes32 balance = _minimalSwapInfoPoolsBalances[poolId][token];\n\n        // A non-zero balance guarantees that the token is registered. If zero, we manually check if the token is\n        // registered in the Pool. Token registration implies that the Pool is registered as well, which lets us save\n        // gas by not performing the check.\n        bool tokenRegistered = balance.isNotZero() || _minimalSwapInfoPoolsTokens[poolId].contains(address(token));\n\n        if (!tokenRegistered) {\n            // The token might not be registered because the Pool itself is not registered. We check this to provide a\n            // more accurate revert reason.\n            _ensureRegisteredPool(poolId);\n            _revert(Errors.TOKEN_NOT_REGISTERED);\n        }\n\n        return balance;\n    }\n\n    /**\n     * @dev Returns true if `token` is registered in a Minimal Swap Info Pool.\n     *\n     * This function assumes `poolId` exists and corresponds to the Minimal Swap Info specialization setting.\n     */\n    function _isMinimalSwapInfoPoolTokenRegistered(bytes32 poolId, IERC20 token) internal view returns (bool) {\n        EnumerableSet.AddressSet storage poolTokens = _minimalSwapInfoPoolsTokens[poolId];\n        return poolTokens.contains(address(token));\n    }\n}\n'}, 'contracts/vault/balances/TwoTokenPoolsBalance.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport ""../../lib/helpers/BalancerErrors.sol"";\nimport ""../../lib/openzeppelin/IERC20.sol"";\n\nimport ""./BalanceAllocation.sol"";\nimport ""../PoolRegistry.sol"";\n\nabstract contract TwoTokenPoolsBalance is PoolRegistry {\n    using BalanceAllocation for bytes32;\n\n    // Data for Pools with the Two Token specialization setting\n    //\n    // These are similar to the Minimal Swap Info Pool case (because the Pool only has two tokens, and therefore there\n    // are only two balances to read), but there\'s a key difference in how data is stored. Keeping a set makes little\n    // sense, as it will only ever hold two tokens, so we can just store those two directly.\n    //\n    // The gas savings associated with using these Pools come from how token balances are stored: cash amounts for token\n    // A and token B are packed together, as are managed amounts. Because only cash changes in a swap, there\'s no need\n    // to write to this second storage slot. A single last change block number for both tokens is stored with the packed\n    // cash fields.\n\n    struct TwoTokenPoolBalances {\n        bytes32 sharedCash;\n        bytes32 sharedManaged;\n    }\n\n    // We could just keep a mapping from Pool ID to TwoTokenSharedBalances, but there\'s an issue: we wouldn\'t know to\n    // which tokens those balances correspond. This would mean having to also check which are registered with the Pool.\n    //\n    // What we do instead to save those storage reads is keep a nested mapping from the token pair hash to the balances\n    // struct. The Pool only has two tokens, so only a single entry of this mapping is set (the one that corresponds to\n    // that pair\'s hash).\n    //\n    // This has the trade-off of making Vault code that interacts with these Pools cumbersome: both balances must be\n    // accessed at the same time by using both token addresses, and some logic is needed to determine how the pair hash\n    // is computed. We do this by sorting the tokens, calling the token with the lowest numerical address value token A,\n    // and the other one token B. In functions where the token arguments could be either A or B, we use X and Y instead.\n    //\n    // If users query a token pair containing an unregistered token, the Pool will generate a hash for a mapping entry\n    // that was not set, and return zero balances. Non-zero balances are only possible if both tokens in the pair\n    // are registered with the Pool, which means we don\'t have to check the TwoTokenPoolTokens struct, and can save\n    // storage reads.\n\n    struct TwoTokenPoolTokens {\n        IERC20 tokenA;\n        IERC20 tokenB;\n        mapping(bytes32 => TwoTokenPoolBalances) balances;\n    }\n\n    mapping(bytes32 => TwoTokenPoolTokens) private _twoTokenPoolTokens;\n\n    /**\n     * @dev Registers tokens in a Two Token Pool.\n     *\n     * This function assumes `poolId` exists and corresponds to the Two Token specialization setting.\n     *\n     * Requirements:\n     *\n     * - `tokenX` and `tokenY` must not be the same\n     * - The tokens must be ordered: tokenX < tokenY\n     */\n    function _registerTwoTokenPoolTokens(\n        bytes32 poolId,\n        IERC20 tokenX,\n        IERC20 tokenY\n    ) internal {\n        // Not technically true since we didn\'t register yet, but this is consistent with the error messages of other\n        // specialization settings.\n        _require(tokenX != tokenY, Errors.TOKEN_ALREADY_REGISTERED);\n\n        _require(tokenX < tokenY, Errors.UNSORTED_TOKENS);\n\n        // A Two Token Pool with no registered tokens is identified by having zero addresses for tokens A and B.\n        TwoTokenPoolTokens storage poolTokens = _twoTokenPoolTokens[poolId];\n        _require(poolTokens.tokenA == IERC20(0) && poolTokens.tokenB == IERC20(0), Errors.TOKENS_ALREADY_SET);\n\n        // Since tokenX < tokenY, tokenX is A and tokenY is B\n        poolTokens.tokenA = tokenX;\n        poolTokens.tokenB = tokenY;\n\n        // Note that we don\'t initialize the balance mapping: the default value of zero corresponds to an empty\n        // balance.\n    }\n\n    /**\n     * @dev Deregisters tokens in a Two Token Pool.\n     *\n     * This function assumes `poolId` exists and corresponds to the Two Token specialization setting.\n     *\n     * Requirements:\n     *\n     * - `tokenX` and `tokenY` must be registered in the Pool\n     * - both tokens must have zero balance in the Vault\n     */\n    function _deregisterTwoTokenPoolTokens(\n        bytes32 poolId,\n        IERC20 tokenX,\n        IERC20 tokenY\n    ) internal {\n        (\n            bytes32 balanceA,\n            bytes32 balanceB,\n            TwoTokenPoolBalances storage poolBalances\n        ) = _getTwoTokenPoolSharedBalances(poolId, tokenX, tokenY);\n\n        _require(balanceA.isZero() && balanceB.isZero(), Errors.NONZERO_TOKEN_BALANCE);\n\n        delete _twoTokenPoolTokens[poolId];\n\n        // For consistency with other Pool specialization settings, we explicitly reset the packed cash field (which may\n        // have a non-zero last change block).\n        delete poolBalances.sharedCash;\n    }\n\n    /**\n     * @dev Sets the cash balances of a Two Token Pool\'s tokens.\n     *\n     * WARNING: this assumes `tokenA` and `tokenB` are the Pool\'s two registered tokens, and are in the correct order.\n     */\n    function _setTwoTokenPoolCashBalances(\n        bytes32 poolId,\n        IERC20 tokenA,\n        bytes32 balanceA,\n        IERC20 tokenB,\n        bytes32 balanceB\n    ) internal {\n        bytes32 pairHash = _getTwoTokenPairHash(tokenA, tokenB);\n        TwoTokenPoolBalances storage poolBalances = _twoTokenPoolTokens[poolId].balances[pairHash];\n        poolBalances.sharedCash = BalanceAllocation.toSharedCash(balanceA, balanceB);\n    }\n\n    /**\n     * @dev Transforms `amount` of `token`\'s balance in a Two Token Pool from cash into managed.\n     *\n     * This function assumes `poolId` exists, corresponds to the Two Token specialization setting, and that `token` is\n     * registered for that Pool.\n     */\n    function _twoTokenPoolCashToManaged(\n        bytes32 poolId,\n        IERC20 token,\n        uint256 amount\n    ) internal {\n        _updateTwoTokenPoolSharedBalance(poolId, token, BalanceAllocation.cashToManaged, amount);\n    }\n\n    /**\n     * @dev Transforms `amount` of `token`\'s balance in a Two Token Pool from managed into cash.\n     *\n     * This function assumes `poolId` exists, corresponds to the Two Token specialization setting, and that `token` is\n     * registered for that Pool.\n     */\n    function _twoTokenPoolManagedToCash(\n        bytes32 poolId,\n        IERC20 token,\n        uint256 amount\n    ) internal {\n        _updateTwoTokenPoolSharedBalance(poolId, token, BalanceAllocation.managedToCash, amount);\n    }\n\n    /**\n     * @dev Sets `token`\'s managed balance in a Two Token Pool to `amount`.\n     *\n     * This function assumes `poolId` exists, corresponds to the Two Token specialization setting, and that `token` is\n     * registered for that Pool.\n     *\n     * Returns the managed balance delta as a result of this call.\n     */\n    function _setTwoTokenPoolManagedBalance(\n        bytes32 poolId,\n        IERC20 token,\n        uint256 amount\n    ) internal returns (int256) {\n        return _updateTwoTokenPoolSharedBalance(poolId, token, BalanceAllocation.setManaged, amount);\n    }\n\n    /**\n     * @dev Sets `token`\'s balance in a Two Token Pool to the result of the `mutation` function when called with\n     * the current balance and `amount`.\n     *\n     * This function assumes `poolId` exists, corresponds to the Two Token specialization setting, and that `token` is\n     * registered for that Pool.\n     *\n     * Returns the managed balance delta as a result of this call.\n     */\n    function _updateTwoTokenPoolSharedBalance(\n        bytes32 poolId,\n        IERC20 token,\n        function(bytes32, uint256) returns (bytes32) mutation,\n        uint256 amount\n    ) private returns (int256) {\n        (\n            TwoTokenPoolBalances storage balances,\n            IERC20 tokenA,\n            bytes32 balanceA,\n            ,\n            bytes32 balanceB\n        ) = _getTwoTokenPoolBalances(poolId);\n\n        int256 delta;\n        if (token == tokenA) {\n            bytes32 newBalance = mutation(balanceA, amount);\n            delta = newBalance.managedDelta(balanceA);\n            balanceA = newBalance;\n        } else {\n            // token == tokenB\n            bytes32 newBalance = mutation(balanceB, amount);\n            delta = newBalance.managedDelta(balanceB);\n            balanceB = newBalance;\n        }\n\n        balances.sharedCash = BalanceAllocation.toSharedCash(balanceA, balanceB);\n        balances.sharedManaged = BalanceAllocation.toSharedManaged(balanceA, balanceB);\n\n        return delta;\n    }\n\n    /*\n     * @dev Returns an array with all the tokens and balances in a Two Token Pool. The order may change when\n     * tokens are registered or deregistered.\n     *\n     * This function assumes `poolId` exists and corresponds to the Two Token specialization setting.\n     */\n    function _getTwoTokenPoolTokens(bytes32 poolId)\n        internal\n        view\n        returns (IERC20[] memory tokens, bytes32[] memory balances)\n    {\n        (, IERC20 tokenA, bytes32 balanceA, IERC20 tokenB, bytes32 balanceB) = _getTwoTokenPoolBalances(poolId);\n\n        // Both tokens will either be zero (if unregistered) or non-zero (if registered), but we keep the full check for\n        // clarity.\n        if (tokenA == IERC20(0) || tokenB == IERC20(0)) {\n            return (new IERC20[](0), new bytes32[](0));\n        }\n\n        // Note that functions relying on this getter expect tokens to be properly ordered, so we use the (A, B)\n        // ordering.\n\n        tokens = new IERC20[](2);\n        tokens[0] = tokenA;\n        tokens[1] = tokenB;\n\n        balances = new bytes32[](2);\n        balances[0] = balanceA;\n        balances[1] = balanceB;\n    }\n\n    /**\n     * @dev Same as `_getTwoTokenPoolTokens`, except it returns the two tokens and balances directly instead of using\n     * an array, as well as a storage pointer to the `TwoTokenPoolBalances` struct, which can be used to update it\n     * without having to recompute the pair hash and storage slot.\n     */\n    function _getTwoTokenPoolBalances(bytes32 poolId)\n        private\n        view\n        returns (\n            TwoTokenPoolBalances storage poolBalances,\n            IERC20 tokenA,\n            bytes32 balanceA,\n            IERC20 tokenB,\n            bytes32 balanceB\n        )\n    {\n        TwoTokenPoolTokens storage poolTokens = _twoTokenPoolTokens[poolId];\n        tokenA = poolTokens.tokenA;\n        tokenB = poolTokens.tokenB;\n\n        bytes32 pairHash = _getTwoTokenPairHash(tokenA, tokenB);\n        poolBalances = poolTokens.balances[pairHash];\n\n        bytes32 sharedCash = poolBalances.sharedCash;\n        bytes32 sharedManaged = poolBalances.sharedManaged;\n\n        balanceA = BalanceAllocation.fromSharedToBalanceA(sharedCash, sharedManaged);\n        balanceB = BalanceAllocation.fromSharedToBalanceB(sharedCash, sharedManaged);\n    }\n\n    /**\n     * @dev Returns the balance of a token in a Two Token Pool.\n     *\n     * This function assumes `poolId` exists and corresponds to the General specialization setting.\n     *\n     * This function is convenient but not particularly gas efficient, and should be avoided during gas-sensitive\n     * operations, such as swaps. For those, _getTwoTokenPoolSharedBalances provides a more flexible interface.\n     *\n     * Requirements:\n     *\n     * - `token` must be registered in the Pool\n     */\n    function _getTwoTokenPoolBalance(bytes32 poolId, IERC20 token) internal view returns (bytes32) {\n        // We can\'t just read the balance of token, because we need to know the full pair in order to compute the pair\n        // hash and access the balance mapping. We therefore rely on `_getTwoTokenPoolBalances`.\n        (, IERC20 tokenA, bytes32 balanceA, IERC20 tokenB, bytes32 balanceB) = _getTwoTokenPoolBalances(poolId);\n\n        if (token == tokenA) {\n            return balanceA;\n        } else if (token == tokenB) {\n            return balanceB;\n        } else {\n            _revert(Errors.TOKEN_NOT_REGISTERED);\n        }\n    }\n\n    /**\n     * @dev Returns the balance of the two tokens in a Two Token Pool.\n     *\n     * The returned balances are those of token A and token B, where token A is the lowest of token X and token Y, and\n     * token B the other.\n     *\n     * This function also returns a storage pointer to the TwoTokenPoolBalances struct associated with the token pair,\n     * which can be used to update it without having to recompute the pair hash and storage slot.\n     *\n     * Requirements:\n     *\n     * - `poolId` must be a Minimal Swap Info Pool\n     * - `tokenX` and `tokenY` must be registered in the Pool\n     */\n    function _getTwoTokenPoolSharedBalances(\n        bytes32 poolId,\n        IERC20 tokenX,\n        IERC20 tokenY\n    )\n        internal\n        view\n        returns (\n            bytes32 balanceA,\n            bytes32 balanceB,\n            TwoTokenPoolBalances storage poolBalances\n        )\n    {\n        (IERC20 tokenA, IERC20 tokenB) = _sortTwoTokens(tokenX, tokenY);\n        bytes32 pairHash = _getTwoTokenPairHash(tokenA, tokenB);\n\n        poolBalances = _twoTokenPoolTokens[poolId].balances[pairHash];\n\n        // Because we\'re reading balances using the pair hash, if either token X or token Y is not registered then\n        // *both* balance entries will be zero.\n        bytes32 sharedCash = poolBalances.sharedCash;\n        bytes32 sharedManaged = poolBalances.sharedManaged;\n\n        // A non-zero balance guarantees that both tokens are registered. If zero, we manually check whether each\n        // token is registered in the Pool. Token registration implies that the Pool is registered as well, which\n        // lets us save gas by not performing the check.\n        bool tokensRegistered = sharedCash.isNotZero() ||\n            sharedManaged.isNotZero() ||\n            (_isTwoTokenPoolTokenRegistered(poolId, tokenA) && _isTwoTokenPoolTokenRegistered(poolId, tokenB));\n\n        if (!tokensRegistered) {\n            // The tokens might not be registered because the Pool itself is not registered. We check this to provide a\n            // more accurate revert reason.\n            _ensureRegisteredPool(poolId);\n            _revert(Errors.TOKEN_NOT_REGISTERED);\n        }\n\n        balanceA = BalanceAllocation.fromSharedToBalanceA(sharedCash, sharedManaged);\n        balanceB = BalanceAllocation.fromSharedToBalanceB(sharedCash, sharedManaged);\n    }\n\n    /**\n     * @dev Returns true if `token` is registered in a Two Token Pool.\n     *\n     * This function assumes `poolId` exists and corresponds to the Two Token specialization setting.\n     */\n    function _isTwoTokenPoolTokenRegistered(bytes32 poolId, IERC20 token) internal view returns (bool) {\n        TwoTokenPoolTokens storage poolTokens = _twoTokenPoolTokens[poolId];\n\n        // The zero address can never be a registered token.\n        return (token == poolTokens.tokenA || token == poolTokens.tokenB) && token != IERC20(0);\n    }\n\n    /**\n     * @dev Returns the hash associated with a given token pair.\n     */\n    function _getTwoTokenPairHash(IERC20 tokenA, IERC20 tokenB) private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(tokenA, tokenB));\n    }\n\n    /**\n     * @dev Sorts two tokens in ascending order, returning them as a (tokenA, tokenB) tuple.\n     */\n    function _sortTwoTokens(IERC20 tokenX, IERC20 tokenY) private pure returns (IERC20, IERC20) {\n        return tokenX < tokenY ? (tokenX, tokenY) : (tokenY, tokenX);\n    }\n}\n'}, 'contracts/vault/AssetTransfersHandler.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport ""../lib/math/Math.sol"";\nimport ""../lib/helpers/BalancerErrors.sol"";\nimport ""../lib/openzeppelin/IERC20.sol"";\nimport ""../lib/helpers/AssetHelpers.sol"";\nimport ""../lib/openzeppelin/SafeERC20.sol"";\nimport ""../lib/openzeppelin/Address.sol"";\n\nimport ""./interfaces/IWETH.sol"";\nimport ""./interfaces/IAsset.sol"";\nimport ""./interfaces/IVault.sol"";\n\nabstract contract AssetTransfersHandler is AssetHelpers {\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n\n    /**\n     * @dev Receives `amount` of `asset` from `sender`. If `fromInternalBalance` is true, it first withdraws as much\n     * as possible from Internal Balance, then transfers any remaining amount.\n     *\n     * If `asset` is ETH, `fromInternalBalance` must be false (as ETH cannot be held as internal balance), and the funds\n     * will be wrapped into WETH.\n     *\n     * WARNING: this function does not check that the contract caller has actually supplied any ETH - it is up to the\n     * caller of this function to check that this is true to prevent the Vault from using its own ETH (though the Vault\n     * typically doesn\'t hold any).\n     */\n    function _receiveAsset(\n        IAsset asset,\n        uint256 amount,\n        address sender,\n        bool fromInternalBalance\n    ) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        if (_isETH(asset)) {\n            _require(!fromInternalBalance, Errors.INVALID_ETH_INTERNAL_BALANCE);\n\n            // The ETH amount to receive is deposited into the WETH contract, which will in turn mint WETH for\n            // the Vault at a 1:1 ratio.\n\n            // A check for this condition is also introduced by the compiler, but this one provides a revert reason.\n            // Note we\'re checking for the Vault\'s total balance, *not* ETH sent in this transaction.\n            _require(address(this).balance >= amount, Errors.INSUFFICIENT_ETH);\n            _WETH().deposit{ value: amount }();\n        } else {\n            IERC20 token = _asIERC20(asset);\n\n            if (fromInternalBalance) {\n                // We take as many tokens from Internal Balance as possible: any remaining amounts will be transferred.\n                uint256 deductedBalance = _decreaseInternalBalance(sender, token, amount, true);\n                // Because `deductedBalance` will be always the lesser of the current internal balance\n                // and the amount to decrease, it is safe to perform unchecked arithmetic.\n                amount -= deductedBalance;\n            }\n\n            if (amount > 0) {\n                token.safeTransferFrom(sender, address(this), amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Sends `amount` of `asset` to `recipient`. If `toInternalBalance` is true, the asset is deposited as Internal\n     * Balance instead of being transferred.\n     *\n     * If `asset` is ETH, `toInternalBalance` must be false (as ETH cannot be held as internal balance), and the funds\n     * are instead sent directly after unwrapping WETH.\n     */\n    function _sendAsset(\n        IAsset asset,\n        uint256 amount,\n        address payable recipient,\n        bool toInternalBalance\n    ) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        if (_isETH(asset)) {\n            // Sending ETH is not as involved as receiving it: the only special behavior is it cannot be\n            // deposited to Internal Balance.\n            _require(!toInternalBalance, Errors.INVALID_ETH_INTERNAL_BALANCE);\n\n            // First, the Vault withdraws deposited ETH from the WETH contract, by burning the same amount of WETH\n            // from the Vault. This receipt will be handled by the Vault\'s `receive`.\n            _WETH().withdraw(amount);\n\n            // Then, the withdrawn ETH is sent to the recipient.\n            recipient.sendValue(amount);\n        } else {\n            IERC20 token = _asIERC20(asset);\n            if (toInternalBalance) {\n                _increaseInternalBalance(recipient, token, amount);\n            } else {\n                token.safeTransfer(recipient, amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Returns excess ETH back to the contract caller, assuming `amountUsed` has been spent. Reverts\n     * if the caller sent less ETH than `amountUsed`.\n     *\n     * Because the caller might not know exactly how much ETH a Vault action will require, they may send extra.\n     * Note that this excess value is returned *to the contract caller* (msg.sender). If caller and e.g. swap sender are\n     * not the same (because the caller is a relayer for the sender), then it is up to the caller to manage this\n     * returned ETH.\n     */\n    function _handleRemainingEth(uint256 amountUsed) internal {\n        _require(msg.value >= amountUsed, Errors.INSUFFICIENT_ETH);\n\n        uint256 excess = msg.value - amountUsed;\n        if (excess > 0) {\n            msg.sender.sendValue(excess);\n        }\n    }\n\n    /**\n     * @dev Enables the Vault to receive ETH. This is required for it to be able to unwrap WETH, which sends ETH to the\n     * caller.\n     *\n     * Any ETH sent to the Vault outside of the WETH unwrapping mechanism would be forever locked inside the Vault, so\n     * we prevent that from happening. Other mechanisms used to send ETH to the Vault (such as being the recipient of an\n     * ETH swap, Pool exit or withdrawal, contract self-destruction, or receiving the block mining reward) will result\n     * in locked funds, but are not otherwise a security or soundness issue. This check only exists as an attempt to\n     * prevent user error.\n     */\n    receive() external payable {\n        _require(msg.sender == address(_WETH()), Errors.ETH_TRANSFER);\n    }\n\n    // This contract uses virtual internal functions instead of inheriting from the modules that implement them (in\n    // this case UserBalance) in order to decouple it from the rest of the system and enable standalone testing by\n    // implementing these with mocks.\n\n    function _increaseInternalBalance(\n        address account,\n        IERC20 token,\n        uint256 amount\n    ) internal virtual;\n\n    function _decreaseInternalBalance(\n        address account,\n        IERC20 token,\n        uint256 amount,\n        bool capped\n    ) internal virtual returns (uint256);\n}\n'}, 'contracts/lib/helpers/AssetHelpers.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\nimport ""../openzeppelin/IERC20.sol"";\n\nimport ""../../vault/interfaces/IAsset.sol"";\nimport ""../../vault/interfaces/IWETH.sol"";\n\nabstract contract AssetHelpers {\n    // solhint-disable-next-line var-name-mixedcase\n    IWETH private immutable _weth;\n\n    // Sentinel value used to indicate WETH with wrapping/unwrapping semantics. The zero address is a good choice for\n    // multiple reasons: it is cheap to pass as a calldata argument, it is a known invalid token and non-contract, and\n    // it is an address Pools cannot register as a token.\n    address private constant _ETH = address(0);\n\n    constructor(IWETH weth) {\n        _weth = weth;\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function _WETH() internal view returns (IWETH) {\n        return _weth;\n    }\n\n    /**\n     * @dev Returns true if `asset` is the sentinel value that represents ETH.\n     */\n    function _isETH(IAsset asset) internal pure returns (bool) {\n        return address(asset) == _ETH;\n    }\n\n    /**\n     * @dev Translates `asset` into an equivalent IERC20 token address. If `asset` represents ETH, it will be translated\n     * to the WETH contract.\n     */\n    function _translateToIERC20(IAsset asset) internal view returns (IERC20) {\n        return _isETH(asset) ? _WETH() : _asIERC20(asset);\n    }\n\n    /**\n     * @dev Same as `_translateToIERC20(IAsset)`, but for an entire array.\n     */\n    function _translateToIERC20(IAsset[] memory assets) internal view returns (IERC20[] memory) {\n        IERC20[] memory tokens = new IERC20[](assets.length);\n        for (uint256 i = 0; i < assets.length; ++i) {\n            tokens[i] = _translateToIERC20(assets[i]);\n        }\n        return tokens;\n    }\n\n    /**\n     * @dev Interprets `asset` as an IERC20 token. This function should only be called on `asset` if `_isETH` previously\n     * returned false for it, that is, if `asset` is guaranteed not to be the ETH sentinel value.\n     */\n    function _asIERC20(IAsset asset) internal pure returns (IERC20) {\n        return IERC20(address(asset));\n    }\n}\n'}, 'contracts/lib/openzeppelin/Address.sol': {'content': '// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport ""../helpers/BalancerErrors.sol"";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        _require(address(this).balance >= amount, Errors.ADDRESS_INSUFFICIENT_BALANCE);\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }("""");\n        _require(success, Errors.ADDRESS_CANNOT_SEND_VALUE);\n    }\n}\n'}}

// File: settings
{'optimizer': {'enabled': True, 'runs': 1500}, 'outputSelection': {'*': {'*': ['evm.bytecode', 'evm.deployedBytecode', 'abi']}}, 'libraries': {}}",True
0x514910771af9ca656af840dff83e8264ecf986ca,"pragma solidity ^0.4.16;


/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
  function mul(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal constant returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}


/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/179
 */
contract ERC20Basic {
  uint256 public totalSupply;
  function balanceOf(address who) constant returns (uint256);
  function transfer(address to, uint256 value) returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}
/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) constant returns (uint256);
  function transferFrom(address from, address to, uint256 value) returns (bool);
  function approve(address spender, uint256 value) returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract ERC677 is ERC20 {
  function transferAndCall(address to, uint value, bytes data) returns (bool success);

  event Transfer(address indexed from, address indexed to, uint value, bytes data);
}

contract ERC677Receiver {
  function onTokenTransfer(address _sender, uint _value, bytes _data);
}

/**
 * @title Basic token
 * @dev Basic version of StandardToken, with no allowances. 
 */
contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address => uint256) balances;

  /**
  * @dev transfer token for a specified address
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  */
  function transfer(address _to, uint256 _value) returns (bool) {
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of. 
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }

}


/**
 * @title Standard ERC20 token
 *
 * @dev Implementation of the basic standard token.
 * @dev https://github.com/ethereum/EIPs/issues/20
 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
 */
contract StandardToken is ERC20, BasicToken {

  mapping (address => mapping (address => uint256)) allowed;


  /**
   * @dev Transfer tokens from one address to another
   * @param _from address The address which you want to send tokens from
   * @param _to address The address which you want to transfer to
   * @param _value uint256 the amount of tokens to be transferred
   */
  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {
    var _allowance = allowed[_from][msg.sender];

    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
    // require (_value <= _allowance);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = _allowance.sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
  
    /*
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until 
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   */
  function increaseApproval (address _spender, uint _addedValue) 
    returns (bool success) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  function decreaseApproval (address _spender, uint _subtractedValue) 
    returns (bool success) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}

contract ERC677Token is ERC677 {

  /**
  * @dev transfer token to a contract address with additional data if the recipient is a contact.
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  * @param _data The extra data to be passed to the receiving contract.
  */
  function transferAndCall(address _to, uint _value, bytes _data)
    public
    returns (bool success)
  {
    super.transfer(_to, _value);
    Transfer(msg.sender, _to, _value, _data);
    if (isContract(_to)) {
      contractFallback(_to, _value, _data);
    }
    return true;
  }


  // PRIVATE

  function contractFallback(address _to, uint _value, bytes _data)
    private
  {
    ERC677Receiver receiver = ERC677Receiver(_to);
    receiver.onTokenTransfer(msg.sender, _value, _data);
  }

  function isContract(address _addr)
    private
    returns (bool hasCode)
  {
    uint length;
    assembly { length := extcodesize(_addr) }
    return length > 0;
  }

}

contract LinkToken is StandardToken, ERC677Token {

  uint public constant totalSupply = 10**27;
  string public constant name = 'ChainLink Token';
  uint8 public constant decimals = 18;
  string public constant symbol = 'LINK';

  function LinkToken()
    public
  {
    balances[msg.sender] = totalSupply;
  }

  /**
  * @dev transfer token to a specified address with additional data if the recipient is a contract.
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  * @param _data The extra data to be passed to the receiving contract.
  */
  function transferAndCall(address _to, uint _value, bytes _data)
    public
    validRecipient(_to)
    returns (bool success)
  {
    return super.transferAndCall(_to, _value, _data);
  }

  /**
  * @dev transfer token to a specified address.
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  */
  function transfer(address _to, uint _value)
    public
    validRecipient(_to)
    returns (bool success)
  {
    return super.transfer(_to, _value);
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value)
    public
    validRecipient(_spender)
    returns (bool)
  {
    return super.approve(_spender,  _value);
  }

  /**
   * @dev Transfer tokens from one address to another
   * @param _from address The address which you want to send tokens from
   * @param _to address The address which you want to transfer to
   * @param _value uint256 the amount of tokens to be transferred
   */
  function transferFrom(address _from, address _to, uint256 _value)
    public
    validRecipient(_to)
    returns (bool)
  {
    return super.transferFrom(_from, _to, _value);
  }


  // MODIFIERS

  modifier validRecipient(address _recipient) {
    require(_recipient != address(0) && _recipient != address(this));
    _;
  }

}",True
0x808507121b80c02388fad14726482e061b8da827,"{""Address.sol"":{""content"":""// SPDX-License-Identifier: MIT\n\npragma solidity \u003e=0.6.2 \u003c0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \""Address: insufficient balance\"");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\""\"");\n        require(success, \""Address: unable to send value, recipient may have reverted\"");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \""Address: low-level call failed\"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \""Address: low-level call with value failed\"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \""Address: insufficient balance for call\"");\n        require(isContract(target), \""Address: call to non-contract\"");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \""Address: low-level static call failed\"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \""Address: static call to non-contract\"");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \""Address: low-level delegate call failed\"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \""Address: delegate call to non-contract\"");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n""},""IERC20.sol"":{""content"":""// SPDX-License-Identifier: MIT\n\npragma solidity \u003e=0.6.0 \u003c0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n""},""IPENDLE.sol"":{""content"":""// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \""Software\""), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \""AS IS\"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity 0.7.6;\n\nimport \""./IERC20.sol\"";\n\ninterface IPENDLE is IERC20 {\n    function initiateConfigChanges(\n        uint256 _emissionRateMultiplierNumerator,\n        uint256 _terminalInflationRateNumerator,\n        address _liquidityIncentivesRecipient,\n        bool _isBurningAllowed\n    ) external;\n\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n\n    function burn(uint256 amount) external returns (bool);\n\n    function applyConfigChanges() external;\n\n    function claimLiquidityEmissions() external returns (uint256 totalEmissions);\n\n    function isPendleToken() external view returns (bool);\n\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint256);\n\n    function startTime() external view returns (uint256);\n\n    function configChangesInitiated() external view returns (uint256);\n\n    function emissionRateMultiplierNumerator() external view returns (uint256);\n\n    function terminalInflationRateNumerator() external view returns (uint256);\n\n    function liquidityIncentivesRecipient() external view returns (address);\n\n    function isBurningAllowed() external view returns (bool);\n\n    function pendingEmissionRateMultiplierNumerator() external view returns (uint256);\n\n    function pendingTerminalInflationRateNumerator() external view returns (uint256);\n\n    function pendingLiquidityIncentivesRecipient() external view returns (address);\n\n    function pendingIsBurningAllowed() external view returns (bool);\n}\n""},""PENDLE.sol"":{""content"":""/* solhint-disable  const-name-snakecase*/\n// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \""Software\""), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \""AS IS\"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \""./IPENDLE.sol\"";\nimport \""./Permissions.sol\"";\nimport \""./Withdrawable.sol\"";\nimport \""./SafeMath.sol\"";\n\n/**\n * @notice The mechanics for delegating votes to other accounts is adapted from Compound\n *   https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol\n ***/\ncontract PENDLE is IPENDLE, Permissions, Withdrawable {\n    using SafeMath for uint256;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint256 votes;\n    }\n\n    bool public constant override isPendleToken = true;\n    string public constant name = \""Pendle\"";\n    string public constant symbol = \""PENDLE\"";\n    uint8 public constant decimals = 18;\n    uint256 public override totalSupply;\n\n    uint256 private constant TEAM_INVESTOR_ADVISOR_AMOUNT = 94917125 * 1e18;\n    uint256 private constant ECOSYSTEM_FUND_TOKEN_AMOUNT = 46 * 1_000_000 * 1e18;\n    uint256 private constant PUBLIC_SALES_TOKEN_AMOUNT = 16582875 * 1e18;\n    uint256 private constant INITIAL_LIQUIDITY_EMISSION = 1200000 * 1e18;\n    uint256 private constant CONFIG_DENOMINATOR = 1_000_000_000_000;\n    uint256 private constant CONFIG_CHANGES_TIME_LOCK = 7 days;\n    uint256 public override emissionRateMultiplierNumerator;\n    uint256 public override terminalInflationRateNumerator;\n    address public override liquidityIncentivesRecipient;\n    bool public override isBurningAllowed;\n    uint256 public override pendingEmissionRateMultiplierNumerator;\n    uint256 public override pendingTerminalInflationRateNumerator;\n    address public override pendingLiquidityIncentivesRecipient;\n    bool public override pendingIsBurningAllowed;\n    uint256 public override configChangesInitiated;\n    uint256 public override startTime;\n    uint256 public lastWeeklyEmission;\n    uint256 public lastWeekEmissionSent;\n\n    mapping(address =\u003e mapping(address =\u003e uint256)) internal allowances;\n    mapping(address =\u003e uint256) internal balances;\n    mapping(address =\u003e address) public delegates;\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping(address =\u003e mapping(uint32 =\u003e Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping(address =\u003e uint32) public numCheckpoints;\n\n    /// @notice The EIP-712 typehash for the contract\u0027s domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\""EIP712Domain(string name,uint256 chainId,address verifyingContract)\"");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH =\n        keccak256(\""Delegation(address delegatee,uint256 nonce,uint256 expiry)\"");\n\n    /// @notice A record of states for signing / validating signatures\n    mapping(address =\u003e uint256) public nonces;\n\n    /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(\n        address indexed delegator,\n        address indexed fromDelegate,\n        address indexed toDelegate\n    );\n\n    /// @notice An event thats emitted when a delegate account\u0027s vote balance changes\n    event DelegateVotesChanged(\n        address indexed delegate,\n        uint256 previousBalance,\n        uint256 newBalance\n    );\n\n    event PendingConfigChanges(\n        uint256 pendingEmissionRateMultiplierNumerator,\n        uint256 pendingTerminalInflationRateNumerator,\n        address pendingLiquidityIncentivesRecipient,\n        bool pendingIsBurningAllowed\n    );\n\n    event ConfigsChanged(\n        uint256 emissionRateMultiplierNumerator,\n        uint256 terminalInflationRateNumerator,\n        address liquidityIncentivesRecipient,\n        bool isBurningAllowed\n    );\n\n    /**\n     * @notice Construct a new PENDLE token\n     */\n    constructor(\n        address _governance,\n        address pendleTeamTokens,\n        address pendleEcosystemFund,\n        address salesMultisig,\n        address _liquidityIncentivesRecipient\n    ) Permissions(_governance) {\n        require(\n            pendleTeamTokens != address(0) \u0026\u0026\n                pendleEcosystemFund != address(0) \u0026\u0026\n                salesMultisig != address(0) \u0026\u0026\n                _liquidityIncentivesRecipient != address(0),\n            \""ZERO_ADDRESS\""\n        );\n        _mint(pendleTeamTokens, TEAM_INVESTOR_ADVISOR_AMOUNT);\n        _mint(pendleEcosystemFund, ECOSYSTEM_FUND_TOKEN_AMOUNT);\n        _mint(salesMultisig, PUBLIC_SALES_TOKEN_AMOUNT);\n        _mint(_liquidityIncentivesRecipient, INITIAL_LIQUIDITY_EMISSION * 26);\n        emissionRateMultiplierNumerator = (CONFIG_DENOMINATOR * 989) / 1000; // emission rate = 98.9% -\u003e 1.1% decay\n        terminalInflationRateNumerator = 379848538; // terminal inflation rate = 2% =\u003e weekly inflation = 0.0379848538%\n        liquidityIncentivesRecipient = _liquidityIncentivesRecipient;\n        startTime = block.timestamp;\n        lastWeeklyEmission = INITIAL_LIQUIDITY_EMISSION;\n        lastWeekEmissionSent = 26; // already done liquidity emissions for the first 26 weeks\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved\n     * @return Whether or not the approval succeeded\n     **/\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount) external override returns (bool) {\n        _transfer(msg.sender, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external override returns (bool) {\n        _transfer(src, dst, amount);\n        _approve(\n            src,\n            msg.sender,\n            allowances[src][msg.sender].sub(amount, \""TRANSFER_EXCEED_ALLOWANCE\"")\n        );\n        return true;\n    }\n\n    /**\n     * @dev Increases the allowance granted to spender by the caller.\n     * @param spender The address to increase the allowance from.\n     * @param addedValue The amount allowance to add.\n     * @return returns true if allowance has increased, otherwise false\n     **/\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Decreases the allowance granted to spender by the caller.\n     * @param spender The address to reduce the allowance from.\n     * @param subtractedValue The amount allowance to subtract.\n     * @return Returns true if allowance has decreased, otherwise false.\n     **/\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        override\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            allowances[msg.sender][spender].sub(subtractedValue, \""NEGATIVE_ALLOWANCE\"")\n        );\n        return true;\n    }\n\n    /**\n     * @dev Burns an amount of tokens from the msg.sender\n     * @param amount The amount to burn\n     * @return Returns true if the operation is successful\n     **/\n    function burn(uint256 amount) public override returns (bool) {\n        require(isBurningAllowed, \""BURNING_NOT_ALLOWED\"");\n        _burn(msg.sender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n     * @param account The address of the account holding the funds\n     * @param spender The address of the account spending the funds\n     * @return The number of tokens approved\n     **/\n    function allowance(address account, address spender) external view override returns (uint256) {\n        return allowances[account][spender];\n    }\n\n    /**\n     * @notice Get the number of tokens held by the `account`\n     * @param account The address of the account to get the balance of\n     * @return The number of tokens held\n     */\n    function balanceOf(address account) external view override returns (uint256) {\n        return balances[account];\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account) external view returns (uint256) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints \u003e 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n    function delegate(address delegatee) public {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        bytes32 domainSeparator =\n            keccak256(\n                abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this))\n            );\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n        bytes32 digest = keccak256(abi.encodePacked(\""\\x19\\x01\"", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \""INVALID_SIGNATURE\"");\n        require(nonce == nonces[signatory]++, \""INVALID_NONCE\"");\n        require(block.timestamp \u003c= expiry, \""SIGNATURE_EXPIRED\"");\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else\n                this function will revert to prevent misinformation\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint256 blockNumber)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        require(blockNumber \u003c block.number, \""NOT_YET_DETERMINED\"");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock \u003c= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock \u003e blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper \u003e lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock \u003c blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function _delegate(address delegator, address delegatee) internal {\n        address currentDelegate = delegates[delegator];\n        uint256 delegatorBalance = balances[delegator];\n        delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _transfer(\n        address src,\n        address dst,\n        uint256 amount\n    ) internal {\n        require(src != address(0), \""SENDER_ZERO_ADDR\"");\n        require(dst != address(0), \""RECEIVER_ZERO_ADDR\"");\n        require(dst != address(this), \""SEND_TO_TOKEN_CONTRACT\"");\n\n        balances[src] = balances[src].sub(amount, \""TRANSFER_EXCEED_BALANCE\"");\n        balances[dst] = balances[dst].add(amount);\n        emit Transfer(src, dst, amount);\n\n        _moveDelegates(delegates[src], delegates[dst], amount);\n    }\n\n    function _approve(\n        address src,\n        address dst,\n        uint256 amount\n    ) internal virtual {\n        require(src != address(0), \""OWNER_ZERO_ADDR\"");\n        require(dst != address(0), \""SPENDER_ZERO_ADDR\"");\n\n        allowances[src][dst] = amount;\n        emit Approval(src, dst, amount);\n    }\n\n    function _moveDelegates(\n        address srcRep,\n        address dstRep,\n        uint256 amount\n    ) internal {\n        if (srcRep != dstRep \u0026\u0026 amount \u003e 0) {\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint256 srcRepOld = srcRepNum \u003e 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint256 srcRepNew = srcRepOld.sub(amount);\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint256 dstRepOld = dstRepNum \u003e 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint256 dstRepNew = dstRepOld.add(amount);\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        address delegatee,\n        uint32 nCheckpoints,\n        uint256 oldVotes,\n        uint256 newVotes\n    ) internal {\n        uint32 blockNumber = safe32(block.number, \""BLOCK_NUM_EXCEED_32_BITS\"");\n\n        if (\n            nCheckpoints \u003e 0 \u0026\u0026 checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber\n        ) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n        require(n \u003c 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function getChainId() internal pure returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n\n    function initiateConfigChanges(\n        uint256 _emissionRateMultiplierNumerator,\n        uint256 _terminalInflationRateNumerator,\n        address _liquidityIncentivesRecipient,\n        bool _isBurningAllowed\n    ) external override onlyGovernance {\n        require(_liquidityIncentivesRecipient != address(0), \""ZERO_ADDRESS\"");\n        pendingEmissionRateMultiplierNumerator = _emissionRateMultiplierNumerator;\n        pendingTerminalInflationRateNumerator = _terminalInflationRateNumerator;\n        pendingLiquidityIncentivesRecipient = _liquidityIncentivesRecipient;\n        pendingIsBurningAllowed = _isBurningAllowed;\n        emit PendingConfigChanges(\n            _emissionRateMultiplierNumerator,\n            _terminalInflationRateNumerator,\n            _liquidityIncentivesRecipient,\n            _isBurningAllowed\n        );\n        configChangesInitiated = block.timestamp;\n    }\n\n    function applyConfigChanges() external override {\n        require(configChangesInitiated != 0, \""UNINITIATED_CONFIG_CHANGES\"");\n        require(\n            block.timestamp \u003e configChangesInitiated + CONFIG_CHANGES_TIME_LOCK,\n            \""TIMELOCK_IS_NOT_OVER\""\n        );\n\n        _mintLiquidityEmissions(); // We must settle the pending liquidity emissions first, to make sure the weeks in the past follow the old configs\n\n        emissionRateMultiplierNumerator = pendingEmissionRateMultiplierNumerator;\n        terminalInflationRateNumerator = pendingTerminalInflationRateNumerator;\n        liquidityIncentivesRecipient = pendingLiquidityIncentivesRecipient;\n        isBurningAllowed = pendingIsBurningAllowed;\n        configChangesInitiated = 0;\n        emit ConfigsChanged(\n            emissionRateMultiplierNumerator,\n            terminalInflationRateNumerator,\n            liquidityIncentivesRecipient,\n            isBurningAllowed\n        );\n    }\n\n    function claimLiquidityEmissions() external override returns (uint256 totalEmissions) {\n        require(msg.sender == liquidityIncentivesRecipient, \""NOT_INCENTIVES_RECIPIENT\"");\n        totalEmissions = _mintLiquidityEmissions();\n    }\n\n    function _mintLiquidityEmissions() internal returns (uint256 totalEmissions) {\n        uint256 _currentWeek = _getCurrentWeek();\n        if (_currentWeek \u003c= lastWeekEmissionSent) {\n            return 0;\n        }\n        for (uint256 i = lastWeekEmissionSent + 1; i \u003c= _currentWeek; i++) {\n            if (i \u003c= 259) {\n                lastWeeklyEmission = lastWeeklyEmission.mul(emissionRateMultiplierNumerator).div(\n                    CONFIG_DENOMINATOR\n                );\n            } else {\n                lastWeeklyEmission = totalSupply.mul(terminalInflationRateNumerator).div(\n                    CONFIG_DENOMINATOR\n                );\n            }\n            _mint(liquidityIncentivesRecipient, lastWeeklyEmission);\n            totalEmissions = totalEmissions.add(lastWeeklyEmission);\n        }\n        lastWeekEmissionSent = _currentWeek;\n    }\n\n    // get current 1-indexed week id\n    function _getCurrentWeek() internal view returns (uint256 weekId) {\n        weekId = (block.timestamp - startTime) / (7 days) + 1;\n    }\n\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \""MINT_TO_ZERO_ADDR\"");\n\n        totalSupply = totalSupply.add(amount);\n        balances[account] = balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \""BURN_FROM_ZERO_ADDRESS\"");\n\n        uint256 accountBalance = balances[account];\n        require(accountBalance \u003e= amount, \""BURN_EXCEED_BALANCE\"");\n        balances[account] = accountBalance.sub(amount);\n        totalSupply = totalSupply.sub(amount);\n\n        emit Transfer(account, address(0), amount);\n    }\n}\n""},""Permissions.sol"":{""content"":""// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \""Software\""), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \""AS IS\"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity 0.7.6;\n\nimport \""./IERC20.sol\"";\n\nabstract contract Permissions {\n    address public governance;\n    address public pendingGovernance;\n    address internal initializer;\n\n    event GovernanceClaimed(address newGovernance, address previousGovernance);\n\n    event TransferGovernancePending(address pendingGovernance);\n\n    constructor(address _governance) {\n        require(_governance != address(0), \""ZERO_ADDRESS\"");\n        initializer = msg.sender;\n        governance = _governance;\n    }\n\n    modifier initialized() {\n        require(initializer == address(0), \""NOT_INITIALIZED\"");\n        _;\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance, \""ONLY_GOVERNANCE\"");\n        _;\n    }\n\n    /**\n     * @dev Allows the pendingGovernance address to finalize the change governance process.\n     */\n    function claimGovernance() public {\n        require(pendingGovernance == msg.sender, \""WRONG_GOVERNANCE\"");\n        emit GovernanceClaimed(pendingGovernance, governance);\n        governance = pendingGovernance;\n        pendingGovernance = address(0);\n    }\n\n    /**\n     * @dev Allows the current governance to set the pendingGovernance address.\n     * @param _governance The address to transfer ownership to.\n     */\n    function transferGovernance(address _governance) public onlyGovernance {\n        require(_governance != address(0), \""ZERO_ADDRESS\"");\n        pendingGovernance = _governance;\n\n        emit TransferGovernancePending(pendingGovernance);\n    }\n}\n""},""SafeERC20.sol"":{""content"":""// SPDX-License-Identifier: MIT\n\npragma solidity \u003e=0.6.0 \u003c0.8.0;\n\nimport \""./IERC20.sol\"";\nimport \""./SafeMath.sol\"";\nimport \""./Address.sol\"";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \u0027safeIncreaseAllowance\u0027 and \u0027safeDecreaseAllowance\u0027\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \""SafeERC20: approve from non-zero to non-zero allowance\""\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \""SafeERC20: decreased allowance below zero\"");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\u0027s return data size checking mechanism, since\n        // we\u0027re implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \""SafeERC20: low-level call failed\"");\n        if (returndata.length \u003e 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \""SafeERC20: ERC20 operation did not succeed\"");\n        }\n    }\n}\n""},""SafeMath.sol"":{""content"":""// SPDX-License-Identifier: MIT\n\npragma solidity \u003e=0.6.0 \u003c0.8.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c \u003c a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b \u003e a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \""SafeMath: addition overflow\"");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \""SafeMath: subtraction overflow\"");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \""SafeMath: multiplication overflow\"");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003e 0, \""SafeMath: division by zero\"");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003e 0, \""SafeMath: modulo by zero\"");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        return a % b;\n    }\n}\n""},""Withdrawable.sol"":{""content"":""// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \""Software\""), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \""AS IS\"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity 0.7.6;\n\nimport \""./IERC20.sol\"";\nimport \""./SafeERC20.sol\"";\nimport \""./Permissions.sol\"";\n\nabstract contract Withdrawable is Permissions {\n    using SafeERC20 for IERC20;\n\n    event EtherWithdraw(uint256 amount, address sendTo);\n    event TokenWithdraw(IERC20 token, uint256 amount, address sendTo);\n\n    /**\n     * @dev Allows governance to withdraw Ether in a Pendle contract\n     *      in case of accidental ETH transfer into the contract.\n     * @param amount The amount of Ether to withdraw.\n     * @param sendTo The recipient address.\n     */\n    function withdrawEther(uint256 amount, address payable sendTo) external onlyGovernance {\n        (bool success, ) = sendTo.call{value: amount}(\""\"");\n        require(success, \""WITHDRAW_FAILED\"");\n        emit EtherWithdraw(amount, sendTo);\n    }\n\n    /**\n     * @dev Allows governance to withdraw all IERC20 compatible tokens in a Pendle\n     *      contract in case of accidental token transfer into the contract.\n     * @param token IERC20 The address of the token contract.\n     * @param amount The amount of IERC20 tokens to withdraw.\n     * @param sendTo The recipient address.\n     */\n    function withdrawToken(\n        IERC20 token,\n        uint256 amount,\n        address sendTo\n    ) external onlyGovernance {\n        token.safeTransfer(sendTo, amount);\n        emit TokenWithdraw(token, amount, sendTo);\n    }\n}\n""}}",True
0xd1f17b7a6bff962659ed608bcd6d318bb5fbb249,"/*
https://t.me/zuzaluinu
*/

// SPDX-License-Identifier: MIT
pragma solidity =0.8.16;
pragma experimental ABIEncoderV2;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _transferOwnership(_msgSender());
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(owner() == _msgSender(), ""Ownable: caller is not the owner"");
        _;
    }

    function renounceOwnership() public virtual onlyOwner { //Change
        _transferOwnership(address(0));
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

interface IERC20 {

    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface IERC20Metadata is IERC20 {

    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
}


contract ERC20 is Context, IERC20, IERC20Metadata {
    mapping(address => uint256) private _balances;

    mapping(address => mapping(address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function name() public view virtual override returns (string memory) {
        return _name;
    }

    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    function decimals() public view virtual override returns (uint8) {
        return 18;
    }

    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);

        uint256 currentAllowance = _allowances[sender][_msgSender()];
        require(currentAllowance >= amount, ""ERC20: transfer amount exceeds allowance"");
        unchecked {
            _approve(sender, _msgSender(), currentAllowance - amount);
        }

        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        uint256 currentAllowance = _allowances[_msgSender()][spender];
        require(currentAllowance >= subtractedValue, ""ERC20: decreased allowance below zero"");
        unchecked {
            _approve(_msgSender(), spender, currentAllowance - subtractedValue);
        }

        return true;
    }

    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal virtual {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _beforeTokenTransfer(sender, recipient, amount);

        uint256 senderBalance = _balances[sender];
        require(senderBalance >= amount, ""ERC20: transfer amount exceeds balance"");
        unchecked {
            _balances[sender] = senderBalance - amount;
        }
        _balances[recipient] += amount;

        emit Transfer(sender, recipient, amount);

        _afterTokenTransfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);

        _afterTokenTransfer(address(0), account, amount);
    }

    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}
}

library SafeMath {

    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            uint256 c = a + b;
            if (c < a) return (false, 0);
            return (true, c);
        }
    }

    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b > a) return (false, 0);
            return (true, a - b);
        }
    }

    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (a == 0) return (true, 0);
            uint256 c = a * b;
            if (c / a != b) return (false, 0);
            return (true, c);
        }
    }

    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a / b);
        }
    }

    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a % b);
        }
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return a % b;
    }

    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b <= a, errorMessage);
            return a - b;
        }
    }

    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a / b;
        }
    }

    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a % b;
        }
    }
}

interface IUniswapV2Factory {
    event PairCreated(
        address indexed token0,
        address indexed token1,
        address pair,
        uint256
    );

    function feeTo() external view returns (address);

    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB)
        external
        view
        returns (address pair);

    function allPairs(uint256) external view returns (address pair);

    function allPairsLength() external view returns (uint256);

    function createPair(address tokenA, address tokenB)
        external
        returns (address pair);

    function setFeeTo(address) external;

    function setFeeToSetter(address) external;
}

interface IUniswapV2Pair {
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
    event Transfer(address indexed from, address indexed to, uint256 value);

    function name() external pure returns (string memory);

    function symbol() external pure returns (string memory);

    function decimals() external pure returns (uint8);

    function totalSupply() external view returns (uint256);

    function balanceOf(address owner) external view returns (uint256);

    function allowance(address owner, address spender)
        external
        view
        returns (uint256);

    function approve(address spender, uint256 value) external returns (bool);

    function transfer(address to, uint256 value) external returns (bool);

    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);

    function PERMIT_TYPEHASH() external pure returns (bytes32);

    function nonces(address owner) external view returns (uint256);

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    event Mint(address indexed sender, uint256 amount0, uint256 amount1);

    event Swap(
        address indexed sender,
        uint256 amount0In,
        uint256 amount1In,
        uint256 amount0Out,
        uint256 amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    function MINIMUM_LIQUIDITY() external pure returns (uint256);

    function factory() external view returns (address);

    function token0() external view returns (address);

    function token1() external view returns (address);

    function getReserves()
        external
        view
        returns (
            uint112 reserve0,
            uint112 reserve1,
            uint32 blockTimestampLast
        );

    function price0CumulativeLast() external view returns (uint256);

    function price1CumulativeLast() external view returns (uint256);

    function kLast() external view returns (uint256);

    function mint(address to) external returns (uint256 liquidity);

    function swap(
        uint256 amount0Out,
        uint256 amount1Out,
        address to,
        bytes calldata data
    ) external;

    function skim(address to) external;

    function sync() external;

    function initialize(address, address) external;
}

interface IUniswapV2Router02 {
    function factory() external pure returns (address);

    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    )
        external
        returns (
            uint256 amountA,
            uint256 amountB,
            uint256 liquidity
        );

    function addLiquidityETH(
        address token,
        uint256 amountTokenDesired,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    )
        external
        payable
        returns (
            uint256 amountToken,
            uint256 amountETH,
            uint256 liquidity
        );

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;

    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable;

    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;
}

contract ZUZALU is ERC20, Ownable {
    using SafeMath for uint256;

    IUniswapV2Router02 public immutable uniswapV2Router;
    address public immutable uniswapV2Pair;
    address public constant deadAddress = address(0xdead);

    bool private swapping;

    address public marketingWallet;

    uint256 public maxTransactionAmount;
    uint256 public swapTokensAtAmount;
    uint256 public maxWallet;

    bool public tradingActive = false;
    bool public swapEnabled = false;

    uint256 public buyTotalFees;
    uint256 private buyMarketingFee;
    uint256 private buyLiquidityFee;

    uint256 public sellTotalFees;
    uint256 private sellMarketingFee;
    uint256 private sellLiquidityFee;

    uint256 private tokensForMarketing;
    uint256 private tokensForLiquidity;
    uint256 private previousFee;

    mapping(address => bool) private _isExcludedFromFees;
    mapping(address => bool) private _isExcludedMaxTransactionAmount;
    mapping(address => bool) private automatedMarketMakerPairs;

    event UpdateUniswapV2Router(
        address indexed newAddress,
        address indexed oldAddress
    );

    event ExcludeFromFees(address indexed account, bool isExcluded);

    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);

    event marketingWalletUpdated(
        address indexed newWallet,
        address indexed oldWallet
    );

    event SwapAndLiquify(
        uint256 tokensSwapped,
        uint256 ethReceived,
        uint256 tokensIntoLiquidity
    );

    constructor() ERC20(""Zuzalu Inu"", ""ZUZALU"") {
        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(
            0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D
        );

        excludeFromMaxTransaction(address(_uniswapV2Router), true);
        uniswapV2Router = _uniswapV2Router;

        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())
            .createPair(address(this), _uniswapV2Router.WETH());
        excludeFromMaxTransaction(address(uniswapV2Pair), true);
        _setAutomatedMarketMakerPair(address(uniswapV2Pair), true);

        uint256 _buyMarketingFee = 20;
        uint256 _buyLiquidityFee = 0;

        uint256 _sellMarketingFee = 50;
        uint256 _sellLiquidityFee = 0;

        uint256 totalSupply = 1000000000 * 1e18;

        maxTransactionAmount = 20000000 * 1e18;
        maxWallet = 30000000 * 1e18;
        swapTokensAtAmount = (totalSupply * 5) / 10000;

        buyMarketingFee = _buyMarketingFee;
        buyLiquidityFee = _buyLiquidityFee;
        buyTotalFees = buyMarketingFee + buyLiquidityFee;

        sellMarketingFee = _sellMarketingFee;
        sellLiquidityFee = _sellLiquidityFee;
        sellTotalFees = sellMarketingFee + sellLiquidityFee;
        previousFee = sellTotalFees;

        marketingWallet = address(0xfdcc43f76039ac7DDdFC21038Af326Af2795edc1);

        excludeFromFees(owner(), true);
        excludeFromFees(address(this), true);
        excludeFromFees(address(0xdead), true);

        excludeFromMaxTransaction(owner(), true);
        excludeFromMaxTransaction(address(this), true);
        excludeFromMaxTransaction(address(0xdead), true);

        _mint(msg.sender, totalSupply);
    }

    receive() external payable {}

    function enableTrading() external onlyOwner {
        tradingActive = true;
        swapEnabled = true;
    }

    function updateSwapTokensAtAmount(uint256 newAmount)
        external
        onlyOwner
        returns (bool)
    {
        require(
            newAmount >= (totalSupply() * 1) / 100000,
            ""Swap amount cannot be lower than 0.001% total supply.""
        );
        require(
            newAmount <= (totalSupply() * 5) / 1000,
            ""Swap amount cannot be higher than 0.5% total supply.""
        );
        swapTokensAtAmount = newAmount;
        return true;
    }

    function updateMaxWalletAndTxnAmount(uint256 newTxnNum, uint256 newMaxWalletNum) external onlyOwner {
        require(
            newTxnNum >= ((totalSupply() * 5) / 1000) / 1e18,
            ""Cannot set maxTxn lower than 0.5%""
        );
        require(
            newMaxWalletNum >= ((totalSupply() * 5) / 1000) / 1e18,
            ""Cannot set maxWallet lower than 0.5%""
        );
        maxWallet = newMaxWalletNum * (10**18);
        maxTransactionAmount = newTxnNum * (10**18);
    }

    function excludeFromMaxTransaction(address updAds, bool isEx)
        public
        onlyOwner
    {
        _isExcludedMaxTransactionAmount[updAds] = isEx;
    }

    function updateBuyFees(
        uint256 _marketingFee,
        uint256 _liquidityFee
    ) external onlyOwner {
        buyMarketingFee = _marketingFee;
        buyLiquidityFee = _liquidityFee;
        buyTotalFees = buyMarketingFee + buyLiquidityFee;
        require(buyTotalFees <= 20, ""Must keep fees at 20% or less"");
    }

    function updateSellFees(
        uint256 _marketingFee,
        uint256 _liquidityFee
    ) external onlyOwner {
        sellMarketingFee = _marketingFee;
        sellLiquidityFee = _liquidityFee;
        sellTotalFees = sellMarketingFee + sellLiquidityFee;
        previousFee = sellTotalFees;
        require(sellTotalFees <= 99, ""Must keep fees at 99% or less"");
    }

    function excludeFromFees(address account, bool excluded) public onlyOwner {
        _isExcludedFromFees[account] = excluded;
        emit ExcludeFromFees(account, excluded);
    }

    function setAutomatedMarketMakerPair(address pair, bool value)
        public
        onlyOwner
    {
        require(
            pair != uniswapV2Pair,
            ""The pair cannot be removed from automatedMarketMakerPairs""
        );

        _setAutomatedMarketMakerPair(pair, value);
    }

    function _setAutomatedMarketMakerPair(address pair, bool value) private {
        automatedMarketMakerPairs[pair] = value;

        emit SetAutomatedMarketMakerPair(pair, value);
    }

    function isExcludedFromFees(address account) public view returns (bool) {
        return _isExcludedFromFees[account];
    }

    function _transfer(
        address from,
        address to,
        uint256 amount
    ) internal override {
        require(from != address(0), ""ERC20: transfer from the zero address"");
        require(to != address(0), ""ERC20: transfer to the zero address"");

        if (amount == 0) {
            super._transfer(from, to, 0);
            return;
        }

                if (
                from != owner() &&
                to != owner() &&
                to != address(0) &&
                to != address(0xdead) &&
                !swapping
            ) {
                if (!tradingActive) {
                    require(
                        _isExcludedFromFees[from] || _isExcludedFromFees[to],
                        ""Trading is not active.""
                    );
                }

                //when buy
                if (
                    automatedMarketMakerPairs[from] &&
                    !_isExcludedMaxTransactionAmount[to]
                ) {
                    require(
                        amount <= maxTransactionAmount,
                        ""Buy transfer amount exceeds the maxTransactionAmount.""
                    );
                    require(
                        amount + balanceOf(to) <= maxWallet,
                        ""Max wallet exceeded""
                    );
                }
                //when sell
                else if (
                    automatedMarketMakerPairs[to] &&
                    !_isExcludedMaxTransactionAmount[from]
                ) {
                    require(
                        amount <= maxTransactionAmount,
                        ""Sell transfer amount exceeds the maxTransactionAmount.""
                    );
                } 
                
                else if (!_isExcludedMaxTransactionAmount[to]) {
                    require(
                        amount + balanceOf(to) <= maxWallet,
                        ""Max wallet exceeded""
                    );
                }
            }

        uint256 contractTokenBalance = balanceOf(address(this));

        bool canSwap = contractTokenBalance >= swapTokensAtAmount;

        if (
            canSwap &&
            swapEnabled &&
            !swapping &&
            !automatedMarketMakerPairs[from] &&
            !_isExcludedFromFees[from] &&
            !_isExcludedFromFees[to]
        ) {
            swapping = true;

            swapBack();

            swapping = false;
        }

        bool takeFee = !swapping;

        if (_isExcludedFromFees[from] || _isExcludedFromFees[to]) {
            takeFee = false;
        }

        uint256 fees = 0;

        if (takeFee) {
            // on sell
            if (automatedMarketMakerPairs[to] && sellTotalFees > 0) {
                fees = amount.mul(sellTotalFees).div(100);
                tokensForLiquidity += (fees * sellLiquidityFee) / sellTotalFees;
                tokensForMarketing += (fees * sellMarketingFee) / sellTotalFees;
            }
            // on buy
            else if (automatedMarketMakerPairs[from] && buyTotalFees > 0) {
                fees = amount.mul(buyTotalFees).div(100);
                tokensForLiquidity += (fees * buyLiquidityFee) / buyTotalFees;
                tokensForMarketing += (fees * buyMarketingFee) / buyTotalFees;
            }

            if (fees > 0) {
                super._transfer(from, address(this), fees);
            }

            amount -= fees;
        }

        super._transfer(from, to, amount);
        sellTotalFees = previousFee;

    }

    function swapTokensForEth(uint256 tokenAmount) private {

        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapV2Router.WETH();

        _approve(address(this), address(uniswapV2Router), tokenAmount);

        // make the swap
        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {

        _approve(address(this), address(uniswapV2Router), tokenAmount);

        uniswapV2Router.addLiquidityETH{value: ethAmount}(
            address(this),
            tokenAmount,
            0,
            0,
            deadAddress,
            block.timestamp
        );
    }

    function swapBack() private {
        uint256 contractBalance = balanceOf(address(this));
        uint256 totalTokensToSwap = tokensForLiquidity +
            tokensForMarketing;
        bool success;

        if (contractBalance == 0 || totalTokensToSwap == 0) {
            return;
        }

        if (contractBalance > swapTokensAtAmount * 20) {
            contractBalance = swapTokensAtAmount * 20;
        }

        uint256 liquidityTokens = (contractBalance * tokensForLiquidity) /
            totalTokensToSwap /
            2;
        uint256 amountToSwapForETH = contractBalance.sub(liquidityTokens);

        uint256 initialETHBalance = address(this).balance;

        swapTokensForEth(amountToSwapForETH);

        uint256 ethBalance = address(this).balance.sub(initialETHBalance);

        uint256 ethForMarketing = ethBalance.mul(tokensForMarketing).div(
            totalTokensToSwap
        );

        uint256 ethForLiquidity = ethBalance - ethForMarketing;

        tokensForLiquidity = 0;
        tokensForMarketing = 0;

        if (liquidityTokens > 0 && ethForLiquidity > 0) {
            addLiquidity(liquidityTokens, ethForLiquidity);
            emit SwapAndLiquify(
                amountToSwapForETH,
                ethForLiquidity,
                tokensForLiquidity
            );
        }

        (success, ) = address(marketingWallet).call{value: address(this).balance}("""");
    }
}",True
0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb,"pragma solidity ^0.4.8;
contract CryptoPunksMarket {

    // You can use this hash to verify the image file containing all the punks
    string public imageHash = ""ac39af4793119ee46bbff351d8cb6b5f23da60222126add4268e261199a2921b"";

    address owner;

    string public standard = 'CryptoPunks';
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    uint public nextPunkIndexToAssign = 0;

    bool public allPunksAssigned = false;
    uint public punksRemainingToAssign = 0;

    //mapping (address => uint) public addressToPunkIndex;
    mapping (uint => address) public punkIndexToAddress;

    /* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;

    struct Offer {
        bool isForSale;
        uint punkIndex;
        address seller;
        uint minValue;          // in ether
        address onlySellTo;     // specify to sell only to a specific person
    }

    struct Bid {
        bool hasBid;
        uint punkIndex;
        address bidder;
        uint value;
    }

    // A record of punks that are offered for sale at a specific minimum value, and perhaps to a specific person
    mapping (uint => Offer) public punksOfferedForSale;

    // A record of the highest punk bid
    mapping (uint => Bid) public punkBids;

    mapping (address => uint) public pendingWithdrawals;

    event Assign(address indexed to, uint256 punkIndex);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event PunkTransfer(address indexed from, address indexed to, uint256 punkIndex);
    event PunkOffered(uint indexed punkIndex, uint minValue, address indexed toAddress);
    event PunkBidEntered(uint indexed punkIndex, uint value, address indexed fromAddress);
    event PunkBidWithdrawn(uint indexed punkIndex, uint value, address indexed fromAddress);
    event PunkBought(uint indexed punkIndex, uint value, address indexed fromAddress, address indexed toAddress);
    event PunkNoLongerForSale(uint indexed punkIndex);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function CryptoPunksMarket() payable {
        //        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
        owner = msg.sender;
        totalSupply = 10000;                        // Update total supply
        punksRemainingToAssign = totalSupply;
        name = ""CRYPTOPUNKS"";                                   // Set the name for display purposes
        symbol = ""Ͼ"";                               // Set the symbol for display purposes
        decimals = 0;                                       // Amount of decimals for display purposes
    }

    function setInitialOwner(address to, uint punkIndex) {
        if (msg.sender != owner) throw;
        if (allPunksAssigned) throw;
        if (punkIndex >= 10000) throw;
        if (punkIndexToAddress[punkIndex] != to) {
            if (punkIndexToAddress[punkIndex] != 0x0) {
                balanceOf[punkIndexToAddress[punkIndex]]--;
            } else {
                punksRemainingToAssign--;
            }
            punkIndexToAddress[punkIndex] = to;
            balanceOf[to]++;
            Assign(to, punkIndex);
        }
    }

    function setInitialOwners(address[] addresses, uint[] indices) {
        if (msg.sender != owner) throw;
        uint n = addresses.length;
        for (uint i = 0; i < n; i++) {
            setInitialOwner(addresses[i], indices[i]);
        }
    }

    function allInitialOwnersAssigned() {
        if (msg.sender != owner) throw;
        allPunksAssigned = true;
    }

    function getPunk(uint punkIndex) {
        if (!allPunksAssigned) throw;
        if (punksRemainingToAssign == 0) throw;
        if (punkIndexToAddress[punkIndex] != 0x0) throw;
        if (punkIndex >= 10000) throw;
        punkIndexToAddress[punkIndex] = msg.sender;
        balanceOf[msg.sender]++;
        punksRemainingToAssign--;
        Assign(msg.sender, punkIndex);
    }

    // Transfer ownership of a punk to another user without requiring payment
    function transferPunk(address to, uint punkIndex) {
        if (!allPunksAssigned) throw;
        if (punkIndexToAddress[punkIndex] != msg.sender) throw;
        if (punkIndex >= 10000) throw;
        if (punksOfferedForSale[punkIndex].isForSale) {
            punkNoLongerForSale(punkIndex);
        }
        punkIndexToAddress[punkIndex] = to;
        balanceOf[msg.sender]--;
        balanceOf[to]++;
        Transfer(msg.sender, to, 1);
        PunkTransfer(msg.sender, to, punkIndex);
        // Check for the case where there is a bid from the new owner and refund it.
        // Any other bid can stay in place.
        Bid bid = punkBids[punkIndex];
        if (bid.bidder == to) {
            // Kill bid and refund value
            pendingWithdrawals[to] += bid.value;
            punkBids[punkIndex] = Bid(false, punkIndex, 0x0, 0);
        }
    }

    function punkNoLongerForSale(uint punkIndex) {
        if (!allPunksAssigned) throw;
        if (punkIndexToAddress[punkIndex] != msg.sender) throw;
        if (punkIndex >= 10000) throw;
        punksOfferedForSale[punkIndex] = Offer(false, punkIndex, msg.sender, 0, 0x0);
        PunkNoLongerForSale(punkIndex);
    }

    function offerPunkForSale(uint punkIndex, uint minSalePriceInWei) {
        if (!allPunksAssigned) throw;
        if (punkIndexToAddress[punkIndex] != msg.sender) throw;
        if (punkIndex >= 10000) throw;
        punksOfferedForSale[punkIndex] = Offer(true, punkIndex, msg.sender, minSalePriceInWei, 0x0);
        PunkOffered(punkIndex, minSalePriceInWei, 0x0);
    }

    function offerPunkForSaleToAddress(uint punkIndex, uint minSalePriceInWei, address toAddress) {
        if (!allPunksAssigned) throw;
        if (punkIndexToAddress[punkIndex] != msg.sender) throw;
        if (punkIndex >= 10000) throw;
        punksOfferedForSale[punkIndex] = Offer(true, punkIndex, msg.sender, minSalePriceInWei, toAddress);
        PunkOffered(punkIndex, minSalePriceInWei, toAddress);
    }

    function buyPunk(uint punkIndex) payable {
        if (!allPunksAssigned) throw;
        Offer offer = punksOfferedForSale[punkIndex];
        if (punkIndex >= 10000) throw;
        if (!offer.isForSale) throw;                // punk not actually for sale
        if (offer.onlySellTo != 0x0 && offer.onlySellTo != msg.sender) throw;  // punk not supposed to be sold to this user
        if (msg.value < offer.minValue) throw;      // Didn't send enough ETH
        if (offer.seller != punkIndexToAddress[punkIndex]) throw; // Seller no longer owner of punk

        address seller = offer.seller;

        punkIndexToAddress[punkIndex] = msg.sender;
        balanceOf[seller]--;
        balanceOf[msg.sender]++;
        Transfer(seller, msg.sender, 1);

        punkNoLongerForSale(punkIndex);
        pendingWithdrawals[seller] += msg.value;
        PunkBought(punkIndex, msg.value, seller, msg.sender);

        // Check for the case where there is a bid from the new owner and refund it.
        // Any other bid can stay in place.
        Bid bid = punkBids[punkIndex];
        if (bid.bidder == msg.sender) {
            // Kill bid and refund value
            pendingWithdrawals[msg.sender] += bid.value;
            punkBids[punkIndex] = Bid(false, punkIndex, 0x0, 0);
        }
    }

    function withdraw() {
        if (!allPunksAssigned) throw;
        uint amount = pendingWithdrawals[msg.sender];
        // Remember to zero the pending refund before
        // sending to prevent re-entrancy attacks
        pendingWithdrawals[msg.sender] = 0;
        msg.sender.transfer(amount);
    }

    function enterBidForPunk(uint punkIndex) payable {
        if (punkIndex >= 10000) throw;
        if (!allPunksAssigned) throw;                
        if (punkIndexToAddress[punkIndex] == 0x0) throw;
        if (punkIndexToAddress[punkIndex] == msg.sender) throw;
        if (msg.value == 0) throw;
        Bid existing = punkBids[punkIndex];
        if (msg.value <= existing.value) throw;
        if (existing.value > 0) {
            // Refund the failing bid
            pendingWithdrawals[existing.bidder] += existing.value;
        }
        punkBids[punkIndex] = Bid(true, punkIndex, msg.sender, msg.value);
        PunkBidEntered(punkIndex, msg.value, msg.sender);
    }

    function acceptBidForPunk(uint punkIndex, uint minPrice) {
        if (punkIndex >= 10000) throw;
        if (!allPunksAssigned) throw;                
        if (punkIndexToAddress[punkIndex] != msg.sender) throw;
        address seller = msg.sender;
        Bid bid = punkBids[punkIndex];
        if (bid.value == 0) throw;
        if (bid.value < minPrice) throw;

        punkIndexToAddress[punkIndex] = bid.bidder;
        balanceOf[seller]--;
        balanceOf[bid.bidder]++;
        Transfer(seller, bid.bidder, 1);

        punksOfferedForSale[punkIndex] = Offer(false, punkIndex, bid.bidder, 0, 0x0);
        uint amount = bid.value;
        punkBids[punkIndex] = Bid(false, punkIndex, 0x0, 0);
        pendingWithdrawals[seller] += amount;
        PunkBought(punkIndex, bid.value, seller, bid.bidder);
    }

    function withdrawBidForPunk(uint punkIndex) {
        if (punkIndex >= 10000) throw;
        if (!allPunksAssigned) throw;                
        if (punkIndexToAddress[punkIndex] == 0x0) throw;
        if (punkIndexToAddress[punkIndex] == msg.sender) throw;
        Bid bid = punkBids[punkIndex];
        if (bid.bidder != msg.sender) throw;
        PunkBidWithdrawn(punkIndex, bid.value, msg.sender);
        uint amount = bid.value;
        punkBids[punkIndex] = Bid(false, punkIndex, 0x0, 0);
        // Refund the bid money
        msg.sender.transfer(amount);
    }

}",True
0xa1000870e20c03fab9744969164e91e14edda850,"/**
 *Submitted for verification at Etherscan.io on 2024-09-07
*/

/**
 *Submitted for verification at Etherscan.io on 2024-08-01
*/

/**
 *Submitted for verification at Etherscan.io on 2024-05-13
*/

// SPDX-License-Identifier: UNLICENSE

/*

Website: https://mikuhatsune.xyz

Telegram: https://t.me/HatsuneMikuETH

X: https://x.com/HatsuneMikuEth
*/

pragma solidity 0.8.23;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, ""SafeMath: subtraction overflow"");
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, ""SafeMath: division by zero"");
    }

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        return c;
    }

}

contract Ownable is Context {
    address private _owner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_owner == _msgSender(), ""Ownable: caller is not the owner"");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

}

interface IUniswapV2Factory {
    function createPair(address tokenA, address tokenB) external returns (address pair);
}

interface IUniswapV2Router02 {
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    function factory() external pure returns (address);
    function WETH() external pure returns (address);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
}

contract $MIKU is Context, IERC20, Ownable {
    using SafeMath for uint256;
    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;
    mapping (address => bool) private _isExcludedFromFee;
    mapping (address => bool) private bots;
    address payable private _taxWallet;

    uint256 private _initialBuyTax=25;
    uint256 private _initialSellTax=28;
    uint256 public _finalBuyTax=0;
    uint256 public _finalSellTax=0;
    uint256 private _reduceBuyTaxAt=11;
    uint256 private _reduceSellTaxAt=20;
    uint256 private _preventSwapBefore=15;
    uint256 public _transferTax=0;
    uint256 public _buyCount=0;

    uint8 private constant _decimals = 9;
    uint256 private constant _tTotal = 1000000000 * 10**_decimals;
    string private constant _name = unicode""Hatsune Miku"";
    string private constant _symbol = unicode""$MIKU"";
    uint256 public _maxTxAmount = 20000000 * 10**_decimals; // 2%
    uint256 public _maxWalletSize = 20000000 * 10**_decimals; // 2%
    uint256 public _taxSwapThreshold= 10000000 * 10**_decimals; //1% 
    uint256 public _maxTaxSwap= 20000000 * 10**_decimals; //2%
    
    IUniswapV2Router02 private uniswapV2Router;
    address private uniswapV2Pair;
    bool private tradingOpen;
    bool private inSwap = false;
    bool private swapEnabled = false;
    uint256 private sellCount = 0;
    uint256 private lastSellBlock = 0;
    event MaxTxAmountUpdated(uint _maxTxAmount);
    event TransferTaxUpdated(uint _tax);
    modifier lockTheSwap {
        inSwap = true;
        _;
        inSwap = false;
    }

    constructor () {
        _taxWallet = payable(0xa5671b7a954049bCFAf3A87422D64c5C2A7F22b8);
        _balances[_msgSender()] = _tTotal;
        _isExcludedFromFee[owner()] = true;
        _isExcludedFromFee[address(this)] = true;
        _isExcludedFromFee[_taxWallet] = true;

        emit Transfer(address(0), _msgSender(), _tTotal);
    }

    function name() public pure returns (string memory) {
        return _name;
    }

    function symbol() public pure returns (string memory) {
        return _symbol;
    }

    function decimals() public pure returns (uint8) {
        return _decimals;
    }

    function totalSupply() public pure override returns (uint256) {
        return _tTotal;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }

    function _approve(address owner, address spender, uint256 amount) private {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _transfer(address from, address to, uint256 amount) private {
        require(from != address(0), ""ERC20: transfer from the zero address"");
        require(to != address(0), ""ERC20: transfer to the zero address"");
        require(amount > 0, ""Transfer amount must be greater than zero"");
        uint256 taxAmount=0;
        if (from != owner() && to != owner() && to != _taxWallet) {
            require(!bots[from] && !bots[to]);

            if(_buyCount==0){
                taxAmount = amount.mul((_buyCount>_reduceBuyTaxAt)?_finalBuyTax:_initialBuyTax).div(100);
            }
            if(_buyCount>0){
                taxAmount = amount.mul(_transferTax).div(100);
            }

            if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] ) {
                require(amount <= _maxTxAmount, ""Exceeds the _maxTxAmount."");
                require(balanceOf(to) + amount <= _maxWalletSize, ""Exceeds the maxWalletSize."");
                taxAmount = amount.mul((_buyCount>_reduceBuyTaxAt)?_finalBuyTax:_initialBuyTax).div(100);
                _buyCount++;
            }

            if(to == uniswapV2Pair && from!= address(this) ){
                taxAmount = amount.mul((_buyCount>_reduceSellTaxAt)?_finalSellTax:_initialSellTax).div(100);
            }

            uint256 contractTokenBalance = balanceOf(address(this));
            if (!inSwap && to == uniswapV2Pair && swapEnabled && contractTokenBalance > _taxSwapThreshold && _buyCount > _preventSwapBefore) {
                if (block.number > lastSellBlock) {
                    sellCount = 0;
                }
                require(sellCount < 3, ""Only 3 sells per block!"");
                swapTokensForEth(min(amount, min(contractTokenBalance, _maxTaxSwap)));
                uint256 contractETHBalance = address(this).balance;
                if (contractETHBalance > 0) {
                    sendETHToFee(address(this).balance);
                }
                sellCount++;
                lastSellBlock = block.number;
            }
        }

        if(taxAmount>0){
          _balances[address(this)]=_balances[address(this)].add(taxAmount);
          emit Transfer(from, address(this),taxAmount);
        }
        _balances[from]=_balances[from].sub(amount);
        _balances[to]=_balances[to].add(amount.sub(taxAmount));
        emit Transfer(from, to, amount.sub(taxAmount));
    }


    function min(uint256 a, uint256 b) private pure returns (uint256){
      return (a>b)?b:a;
    }

    function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapV2Router.WETH();
        _approve(address(this), address(uniswapV2Router), tokenAmount);
        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function removeLimits() external onlyOwner{
        _maxTxAmount = _tTotal;
        _maxWalletSize=_tTotal;
        emit MaxTxAmountUpdated(_tTotal);
    }

    function removeTransferTax() external onlyOwner{
        _transferTax = 0;
        emit TransferTaxUpdated(0);
    }

    function sendETHToFee(uint256 amount) private {
        _taxWallet.transfer(amount);
    }

    function addBots(address[] memory bots_) public onlyOwner {
        for (uint i = 0; i < bots_.length; i++) {
            bots[bots_[i]] = true;
        }
    }

    function delBots(address[] memory notbot) public onlyOwner {
      for (uint i = 0; i < notbot.length; i++) {
          bots[notbot[i]] = false;
      }
    }

    function isBot(address a) public view returns (bool){
      return bots[a];
    }

    function openTrading() external onlyOwner() {
        require(!tradingOpen,""trading is already open"");
        uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
        _approve(address(this), address(uniswapV2Router), _tTotal);
        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());
        uniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this),balanceOf(address(this)),0,0,owner(),block.timestamp);
        IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max);
        swapEnabled = true;
        tradingOpen = true;
    }

    
    function reduceFee(uint256 _newFee) external{
      require(_msgSender()==_taxWallet);
      require(_newFee<=_finalBuyTax && _newFee<=_finalSellTax);
      _finalBuyTax=_newFee;
      _finalSellTax=_newFee;
    }

    receive() external payable {}

    function manualSwap() external {
        require(_msgSender()==_taxWallet);
        uint256 tokenBalance=balanceOf(address(this));
        if(tokenBalance>0){
          swapTokensForEth(tokenBalance);
        }
        uint256 ethBalance=address(this).balance;
        if(ethBalance>0){
          sendETHToFee(ethBalance);
        }
    }
}",True
0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2,"// Copyright (C) 2015, 2016, 2017 Dapphub

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

pragma solidity ^0.4.18;

contract WETH9 {
    string public name     = ""Wrapped Ether"";
    string public symbol   = ""WETH"";
    uint8  public decimals = 18;

    event  Approval(address indexed src, address indexed guy, uint wad);
    event  Transfer(address indexed src, address indexed dst, uint wad);
    event  Deposit(address indexed dst, uint wad);
    event  Withdrawal(address indexed src, uint wad);

    mapping (address => uint)                       public  balanceOf;
    mapping (address => mapping (address => uint))  public  allowance;

    function() public payable {
        deposit();
    }
    function deposit() public payable {
        balanceOf[msg.sender] += msg.value;
        Deposit(msg.sender, msg.value);
    }
    function withdraw(uint wad) public {
        require(balanceOf[msg.sender] >= wad);
        balanceOf[msg.sender] -= wad;
        msg.sender.transfer(wad);
        Withdrawal(msg.sender, wad);
    }

    function totalSupply() public view returns (uint) {
        return this.balance;
    }

    function approve(address guy, uint wad) public returns (bool) {
        allowance[msg.sender][guy] = wad;
        Approval(msg.sender, guy, wad);
        return true;
    }

    function transfer(address dst, uint wad) public returns (bool) {
        return transferFrom(msg.sender, dst, wad);
    }

    function transferFrom(address src, address dst, uint wad)
        public
        returns (bool)
    {
        require(balanceOf[src] >= wad);

        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {
            require(allowance[src][msg.sender] >= wad);
            allowance[src][msg.sender] -= wad;
        }

        balanceOf[src] -= wad;
        balanceOf[dst] += wad;

        Transfer(src, dst, wad);

        return true;
    }
}


/*
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  ""This License"" refers to version 3 of the GNU General Public License.

  ""Copyright"" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  ""The Program"" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as ""you"".  ""Licensees"" and
""recipients"" may be individuals or organizations.

  To ""modify"" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a ""modified version"" of the
earlier work or a work ""based on"" the earlier work.

  A ""covered work"" means either the unmodified Program or a work based
on the Program.

  To ""propagate"" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To ""convey"" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays ""Appropriate Legal Notices""
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The ""source code"" for a work means the preferred form of the work
for making modifications to it.  ""Object code"" means any non-source
form of a work.

  A ""Standard Interface"" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The ""System Libraries"" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
""Major Component"", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The ""Corresponding Source"" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    ""keep intact all notices"".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
""aggregate"" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A ""User Product"" is either (1) a ""consumer product"", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, ""normally used"" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  ""Installation Information"" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  ""Additional permissions"" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered ""further
restrictions"" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An ""entity transaction"" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A ""contributor"" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's ""contributor version"".

  A contributor's ""essential patent claims"" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, ""control"" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a ""patent license"" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To ""grant"" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  ""Knowingly relying"" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is ""discriminatory"" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License ""or any later version"" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM ""AS IS"" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the ""copyright"" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an ""about box"".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a ""copyright disclaimer"" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<http://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<http://www.gnu.org/philosophy/why-not-lgpl.html>.

*/",True
0x40a50cf069e992aa4536211b23f286ef88752187,"// File: language
Solidity

// File: sources
{'src/CoWSwapEthFlow.sol': {'content': '// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.8;\n\nimport ""./libraries/EthFlowOrder.sol"";\nimport ""./interfaces/ICoWSwapSettlement.sol"";\nimport ""./interfaces/ICoWSwapEthFlow.sol"";\nimport ""./interfaces/IWrappedNativeToken.sol"";\nimport ""./mixins/CoWSwapOnchainOrders.sol"";\nimport ""./vendored/GPv2EIP1271.sol"";\n\n/// @title CoW Swap ETH Flow\n/// @author CoW Swap Developers\ncontract CoWSwapEthFlow is\n    CoWSwapOnchainOrders,\n    EIP1271Verifier,\n    ICoWSwapEthFlow\n{\n    using EthFlowOrder for EthFlowOrder.Data;\n    using GPv2Order for GPv2Order.Data;\n    using GPv2Order for bytes;\n\n    /// @dev The address of the CoW Swap settlement contract that will be used to settle orders created by this\n    /// contract.\n    ICoWSwapSettlement public immutable cowSwapSettlement;\n\n    /// @dev The address of the contract representing the default native token in the current chain (e.g., WETH for\n    /// Ethereum mainnet).\n    IWrappedNativeToken public immutable wrappedNativeToken;\n\n    /// @dev Each ETH flow order as described in [`EthFlowOrder.Data`] can be converted to a CoW Swap order. Distinct\n    /// CoW Swap orders have non-colliding order hashes. This mapping associates some extra data to a specific CoW Swap\n    /// order. This data is stored onchain and is used to verify the ownership and validity of an ETH flow order.\n    /// An ETH flow order can be settled onchain only if converting it to a CoW Swap order and hashing yields valid\n    /// onchain data.\n    mapping(bytes32 => EthFlowOrder.OnchainData) public orders;\n\n    /// @param _cowSwapSettlement The CoW Swap settlement contract.\n    /// @param _wrappedNativeToken The default native token in the current chain (e.g., WETH on mainnet).\n    constructor(\n        ICoWSwapSettlement _cowSwapSettlement,\n        IWrappedNativeToken _wrappedNativeToken\n    ) CoWSwapOnchainOrders(address(_cowSwapSettlement)) {\n        cowSwapSettlement = _cowSwapSettlement;\n        wrappedNativeToken = _wrappedNativeToken;\n\n        _wrappedNativeToken.approve(\n            cowSwapSettlement.vaultRelayer(),\n            type(uint256).max\n        );\n    }\n\n    // The contract needs to be able to receive native tokens when unwrapping.\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n\n    /// @inheritdoc ICoWSwapEthFlow\n    function wrapAll() external {\n        wrap(address(this).balance);\n    }\n\n    /// @inheritdoc ICoWSwapEthFlow\n    function wrap(uint256 amount) public {\n        // The fallback implementation of the standard WETH9 contract just calls `deposit`. Using the fallback instead\n        // of directly calling `deposit` is slightly cheaper in terms of gas.\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = payable(address(wrappedNativeToken)).call{\n            value: amount\n        }("""");\n        // The success value is intentionally disregarded. The callback of the standard WETH9 contract has no revert\n        // path in the code, so it could only revert if the internal call runs out of gas. This is not considered a\n        // security risk since a reverting internal call would just mean that calling this function has no effect.\n        success;\n    }\n\n    /// @inheritdoc ICoWSwapEthFlow\n    function unwrap(uint256 amount) external {\n        wrappedNativeToken.withdraw(amount);\n    }\n\n    /// @inheritdoc ICoWSwapEthFlow\n    function createOrder(EthFlowOrder.Data calldata order)\n        external\n        payable\n        returns (bytes32 orderHash)\n    {\n        if (msg.value != order.sellAmount + order.feeAmount) {\n            revert IncorrectEthAmount();\n        }\n\n        if (0 == order.sellAmount) {\n            revert NotAllowedZeroSellAmount();\n        }\n\n        // solhint-disable-next-line not-rely-on-time\n        if (order.validTo < block.timestamp) {\n            revert OrderIsAlreadyExpired();\n        }\n\n        EthFlowOrder.OnchainData memory onchainData = EthFlowOrder.OnchainData(\n            msg.sender,\n            order.validTo\n        );\n\n        OnchainSignature memory signature = OnchainSignature(\n            OnchainSigningScheme.Eip1271,\n            abi.encodePacked(address(this))\n        );\n\n        // The data event field includes extra information needed to settle orders with the CoW Swap API.\n        bytes memory data = abi.encodePacked(\n            order.quoteId,\n            onchainData.validTo\n        );\n\n        orderHash = broadcastOrder(\n            onchainData.owner,\n            order.toCoWSwapOrder(wrappedNativeToken),\n            signature,\n            data\n        );\n\n        if (orders[orderHash].owner != EthFlowOrder.NO_OWNER) {\n            revert OrderIsAlreadyOwned(orderHash);\n        }\n\n        orders[orderHash] = onchainData;\n    }\n\n    /// @inheritdoc ICoWSwapEthFlow\n    function invalidateOrdersIgnoringNotAllowed(\n        EthFlowOrder.Data[] calldata orderArray\n    ) external {\n        for (uint256 i = 0; i < orderArray.length; i++) {\n            _invalidateOrder(orderArray[i], false);\n        }\n    }\n\n    /// @inheritdoc ICoWSwapEthFlow\n    function invalidateOrder(EthFlowOrder.Data calldata order) public {\n        _invalidateOrder(order, true);\n    }\n\n    /// @dev Performs the same tasks as `invalidateOrder` (see documentation in `ICoWSwapEthFlow`), but also allows the\n    /// caller to ignore the revert condition `NotAllowedToInvalidateOrder`. Instead of reverting, it stops execution\n    /// without causing any state change.\n    ///\n    /// @param order order to be invalidated.\n    /// @param revertOnInvalidDeletion controls whether the function call should revert or just return.\n    function _invalidateOrder(\n        EthFlowOrder.Data calldata order,\n        bool revertOnInvalidDeletion\n    ) internal {\n        GPv2Order.Data memory cowSwapOrder = order.toCoWSwapOrder(\n            wrappedNativeToken\n        );\n        bytes32 orderHash = cowSwapOrder.hash(cowSwapDomainSeparator);\n\n        EthFlowOrder.OnchainData memory orderData = orders[orderHash];\n\n        // solhint-disable-next-line not-rely-on-time\n        bool isTradable = orderData.validTo >= block.timestamp;\n        if (\n            orderData.owner == EthFlowOrder.INVALIDATED_OWNER ||\n            orderData.owner == EthFlowOrder.NO_OWNER ||\n            (isTradable && orderData.owner != msg.sender)\n        ) {\n            if (revertOnInvalidDeletion) {\n                revert NotAllowedToInvalidateOrder(orderHash);\n            } else {\n                return;\n            }\n        }\n\n        orders[orderHash].owner = EthFlowOrder.INVALIDATED_OWNER;\n\n        bytes memory orderUid = new bytes(GPv2Order.UID_LENGTH);\n        orderUid.packOrderUidParams(\n            orderHash,\n            address(this),\n            cowSwapOrder.validTo\n        );\n\n        // solhint-disable-next-line not-rely-on-time\n        if (isTradable) {\n            // Order is valid but its owner decided to invalidate it.\n            emit OrderInvalidation(orderUid);\n        } else {\n            // The order cannot be traded anymore, so this transaction is likely triggered to get back the ETH. We are\n            // interested in knowing who is the source of the refund.\n            emit OrderRefund(orderUid, msg.sender);\n        }\n\n        uint256 filledAmount = cowSwapSettlement.filledAmount(orderUid);\n\n        // This comment argues that a CoW Swap trader does not pay more fees if a partially fillable order is\n        // (partially) settled in multiple batches rather than in one single batch of the combined size.\n        // This also means that we can refund the user assuming the worst case of settling the filled amount in a single\n        // batch without risking giving out more funds than available in the contract because of rounding issues.\n        // A CoW Swap trader is always charged exactly the amount of fees that is proportional to the filled amount\n        // rounded down to the smaller integer. The code is here:\n        // https://github.com/cowprotocol/contracts/blob/d4e0fcd58367907bf1aff54d182222eeaee793dd/src/contracts/GPv2Settlement.sol#L385-L387\n        // We show that a trader pays less in fee to CoW Swap when settiling a partially fillable order in two\n        // executions rather than a single one for the combined amount; by induction this proves our original statement.\n        // Our previous statement is equivalent to `floor(a/c) + floor(b/c) ≤ floor((a+b)/c)`. Writing a and b in terms\n        // of reminders (`a = ad*c+ar`, `b = bd*c+br`) the equation becomes `ad + bd ≤ ad + bd + floor((ar+br)/c)`,\n        // which is immediately true.\n        uint256 refundAmount;\n        unchecked {\n            // - Multiplication overflow: since this smart contract never invalidates orders on CoW Swap,\n            //   `filledAmount <= sellAmount`. Also, `feeAmount + sellAmount` is an amount of native tokens that was\n            //   originally sent by the user. As such, it cannot be larger than the amount of native tokens available,\n            //   which is smaller than 2¹²⁸/10¹⁸ ≈ 10²⁰ in all networks supported by CoW Swap so far. Since both values\n            //    are smaller than 2¹²⁸, their product does not overflow a uint256.\n            // - Subtraction underflow: again `filledAmount ≤ sellAmount`, meaning:\n            //   feeAmount * filledAmount / sellAmount ≤ feeAmount\n            uint256 feeRefundAmount = cowSwapOrder.feeAmount -\n                ((cowSwapOrder.feeAmount * filledAmount) /\n                    cowSwapOrder.sellAmount);\n\n            // - Subtraction underflow: as noted before, filledAmount ≤ sellAmount.\n            // - Addition overflow: as noted before, the user already sent feeAmount + sellAmount native tokens, which\n            //   did not overflow.\n            refundAmount =\n                cowSwapOrder.sellAmount -\n                filledAmount +\n                feeRefundAmount;\n        }\n\n        // If not enough native token is available in the contract, unwrap the needed amount.\n        if (address(this).balance < refundAmount) {\n            uint256 withdrawAmount;\n            unchecked {\n                withdrawAmount = refundAmount - address(this).balance;\n            }\n            wrappedNativeToken.withdraw(withdrawAmount);\n        }\n\n        // Using low level calls to perform the transfer avoids setting arbitrary limits to the amount of gas used in a\n        // call. Reentrancy is avoided thanks to the `nonReentrant` function modifier.\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = payable(orderData.owner).call{value: refundAmount}(\n            """"\n        );\n        if (!success) {\n            revert EthTransferFailed();\n        }\n    }\n\n    /// @inheritdoc ICoWSwapEthFlow\n    function isValidSignature(bytes32 orderHash, bytes memory)\n        external\n        view\n        override(EIP1271Verifier, ICoWSwapEthFlow)\n        returns (bytes4)\n    {\n        // Note: the signature parameter is ignored since all information needed to verify the validity of the order is\n        // already available onchain.\n        EthFlowOrder.OnchainData memory orderData = orders[orderHash];\n        if (\n            (orderData.owner != EthFlowOrder.NO_OWNER) &&\n            (orderData.owner != EthFlowOrder.INVALIDATED_OWNER) &&\n            // solhint-disable-next-line not-rely-on-time\n            (orderData.validTo >= block.timestamp)\n        ) {\n            return GPv2EIP1271.MAGICVALUE;\n        } else {\n            return bytes4(type(uint32).max);\n        }\n    }\n}\n'}, 'src/interfaces/ICoWSwapEthFlow.sol': {'content': '// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.8;\n\nimport ""../libraries/EthFlowOrder.sol"";\n\n/// @title CoW Swap ETH Flow Event Interface\n/// @author CoW Swap Developers\ninterface ICoWSwapEthFlowEvents {\n    /// @dev Event emitted to notify that an order was refunded. Note that this event is not fired every time the order\n    /// is invalidated (even though the user receives all unspent ETH back). This is because we want to differenciate\n    /// the case where the user invalidates a valid order and when the user receives back the funds from an expired\n    /// order.\n    ///\n    /// @param orderUid CoW Swap\'s unique order identifier of the order that has been invalidated (and refunded).\n    /// @param refunder The address that triggered the order refund.\n    event OrderRefund(bytes orderUid, address indexed refunder);\n}\n\n/// @title CoW Swap ETH Flow Interface\n/// @author CoW Swap Developers\ninterface ICoWSwapEthFlow is ICoWSwapEthFlowEvents {\n    /// @dev Error thrown when trying to create a new order whose order hash is the same as an order hash that was\n    /// already assigned.\n    error OrderIsAlreadyOwned(bytes32 orderHash);\n\n    /// @dev Error thrown when trying to create an order that would be expired at the time of creation\n    error OrderIsAlreadyExpired();\n\n    /// @dev Error thrown when trying to create an order without sending the expected amount of ETH to this contract.\n    error IncorrectEthAmount();\n\n    /// @dev Error thrown when trying to create an order with a sell amount == 0\n    error NotAllowedZeroSellAmount();\n\n    /// @dev Error thrown if trying to invalidate an order while not allowed.\n    error NotAllowedToInvalidateOrder(bytes32 orderHash);\n\n    /// @dev Error thrown when unsuccessfully sending ETH to an address.\n    error EthTransferFailed();\n\n    /// @dev Function that creates and broadcasts an ETH flow order that sells native ETH. The order is paid for when\n    /// the caller sends out the transaction. The caller takes ownership of the new order.\n    ///\n    /// @param order The data describing the order to be created. See [`EthFlowOrder.Data`] for extra information on\n    /// each parameter.\n    /// @return orderHash The hash of the CoW Swap order that is created to settle the new ETH order.\n    function createOrder(EthFlowOrder.Data calldata order)\n        external\n        payable\n        returns (bytes32 orderHash);\n\n    /// @dev Marks existing ETH-flow orders as invalid and, for each order, refunds the ETH that hasn\'t been traded yet.\n    /// The function call will not revert, if some orders are not refundable. It will silently ignore these orders.\n    /// Note that some parameters of the orders are ignored, as for example the order expiration date and the quote id.\n    ///\n    /// @param orderArray Array of orders to be invalidated.\n    function invalidateOrdersIgnoringNotAllowed(\n        EthFlowOrder.Data[] calldata orderArray\n    ) external;\n\n    /// @dev Marks an existing ETH-flow order as invalid and refunds the ETH that hasn\'t been traded yet.\n    /// Note that some parameters of the orders are ignored, as for example the order expiration date and the quote id.\n    ///\n    /// @param order Order to be invalidated.\n    function invalidateOrder(EthFlowOrder.Data calldata order) external;\n\n    /// @dev EIP1271-compliant onchain signature verification function.\n    /// This function is used by the CoW Swap settlement contract to determine if an order that is signed with an\n    /// EIP1271 signature is valid. As this contract has approved the vault relayer contract, a valid signature for an\n    /// order means that the order can be traded on CoW Swap.\n    ///\n    /// @param orderHash Hash of the order to be signed. This is the EIP-712 signing hash for the specified order as\n    /// defined in the CoW Swap settlement contract.\n    /// @param signature Signature byte array. This parameter is unused since as all information needed to verify if an\n    /// order is already available onchain.\n    /// @return magicValue Either the EIP-1271 ""magic value"" indicating success (0x1626ba7e) or a different value\n    /// indicating failure (0xffffffff).\n    function isValidSignature(bytes32 orderHash, bytes memory signature)\n        external\n        view\n        returns (bytes4 magicValue);\n\n    /// @dev This function reads the  chain\'s native token balance of this contract (e.g., ETH for mainnet) and converts\n    // the entire amount to its wrapped version (e.g., WETH).\n    function wrapAll() external;\n\n    /// @dev This function takes the specified amount of the chain\'s native token (e.g., ETH for mainnet) stored by this\n    /// contract and converts it to its wrapped version (e.g., WETH).\n    ///\n    /// @param amount The amount of native tokens to convert to wrapped native tokens.\n    function wrap(uint256 amount) external;\n\n    /// @dev This function takes the specified amount of the chain\'s wrapped native token (e.g., WETH for mainnet)\n    /// and converts it to its unwrapped version (e.g., ETH).\n    ///\n    /// @param amount The amount of wrapped native tokens to convert to native tokens.\n    function unwrap(uint256 amount) external;\n}\n'}, 'src/interfaces/ICoWSwapOnchainOrders.sol': {'content': '// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.8;\n\nimport ""../vendored/GPv2Order.sol"";\n\n/// @title CoW Swap Onchain Order Creator Interface\n/// @author CoW Swap Developers\ninterface ICoWSwapOnchainOrders {\n    /// @dev List of signature schemes that are supported by this contract to create orders onchain.\n    enum OnchainSigningScheme {\n        Eip1271,\n        PreSign\n    }\n\n    /// @dev Struct containing information on the signign scheme used plus the corresponding signature.\n    struct OnchainSignature {\n        /// @dev The signing scheme used by the signature data.\n        OnchainSigningScheme scheme;\n        /// @dev The data used as an order signature.\n        bytes data;\n    }\n\n    /// @dev Event emitted to broadcast an order onchain.\n    ///\n    /// @param sender The user who triggered the creation of the order. Note that this address does *not* need to be\n    /// the actual owner of the order and does not need to be related to the order or signature in any way.\n    /// For example, if a smart contract creates orders on behalf of the user, then the sender would be the user who\n    /// triggers the creation of the order, while the actual owner of the order would be the smart contract that\n    /// creates it.\n    /// @param order Information on the order that is created in this transacion. The order is expected to be a valid\n    /// order for the CoW Swap settlement contract and contain all information needed to settle it in a batch.\n    /// @param signature The signature that can be used to verify the newly created order. Note that it is always\n    /// possible to recover the owner of the order from a valid signature.\n    /// @param data Any extra data that should be passed along with the order. This will be used by the services that\n    /// collects onchain orders and no specific encoding is enforced on this field. It is supposed to encode extra\n    /// information that is not included in the order data so that it can be passed along when decoding an onchain\n    /// order. As an example, a contract that creates orders on behalf of a user could set a different expiration date\n    /// than the one specified in the order.\n    event OrderPlacement(\n        address indexed sender,\n        GPv2Order.Data order,\n        OnchainSignature signature,\n        bytes data\n    );\n\n    /// @dev Event emitted to notify that an order was invalidated.\n    ///\n    /// @param orderUid CoW Swap\'s unique order identifier of the order that has been invalidated.\n    event OrderInvalidation(bytes orderUid);\n}\n'}, 'src/interfaces/ICoWSwapSettlement.sol': {'content': '// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.8;\n\n/// @title CoW Swap Settlement Contract Interface\n/// @author CoW Swap Developers\n/// @dev This interface collects the functions of the CoW Swap settlement contract that are used by the ETH flow\n/// contract.\ninterface ICoWSwapSettlement {\n    /// @dev Map each user order by UID to the amount that has been filled so\n    /// far. If this amount is larger than or equal to the amount traded in the\n    /// order (amount sold for sell orders, amount bought for buy orders) then\n    /// the order cannot be traded anymore. If the order is fill or kill, then\n    /// this value is only used to determine whether the order has already been\n    /// executed.\n    /// @param orderUid The uinique identifier to use to retrieve the filled amount.\n    function filledAmount(bytes memory orderUid) external returns (uint256);\n\n    /// @dev The address of the vault relayer: the contract that handles withdrawing tokens from the user to the\n    /// settlement contract. A user who wants to sell a token on CoW Swap must approve this contract to spend the token.\n    function vaultRelayer() external returns (address);\n}\n'}, 'src/interfaces/IWrappedNativeToken.sol': {'content': '// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.8;\n\nimport ""../vendored/IERC20.sol"";\n\n/// @title CoW Swap Wrapped Native Token Interface\n/// @author CoW Swap Developers\ninterface IWrappedNativeToken is IERC20 {\n    /// @dev Deposit native token in exchange for wrapped netive tokens.\n    function deposit() external payable;\n\n    /// @dev Burn wrapped native tokens in exchange for native tokens.\n    /// @param amount Amount of wrapped tokens to exchange for native tokens.\n    function withdraw(uint256 amount) external;\n}\n'}, 'src/libraries/CoWSwapEip712.sol': {'content': '// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.8;\n\n/// @title CoW Swap EIP-712 Encoding Library\n/// @author CoW Swap Developers\n/// @dev The code in this contract was largely taken from:\n/// <https://raw.githubusercontent.com/cowprotocol/contracts/v1.0.0/src/contracts/mixins/GPv2Signing.sol>\nlibrary CoWSwapEip712 {\n    /// @dev The EIP-712 domain type hash used for computing the domain separator.\n    bytes32 private constant DOMAIN_TYPE_HASH =\n        keccak256(\n            ""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""\n        );\n\n    /// @dev The EIP-712 domain name used for computing the domain separator.\n    bytes32 private constant DOMAIN_NAME = keccak256(""Gnosis Protocol"");\n\n    /// @dev The EIP-712 domain version used for computing the domain separator.\n    bytes32 private constant DOMAIN_VERSION = keccak256(""v2"");\n\n    /// @dev Computes the EIP-712 domain separator of the CoW Swap settlement contract on the current network.\n    ///\n    /// @param cowSwapAddress The address of the CoW Swap settlement contract for which to compute the domain separator.\n    /// Note that there are no checks to verify that the input address points to an actual contract.\n    /// @return The domain separator of the settlement contract for the input address as computed by the settlement\n    /// contract internally.\n    function domainSeparator(address cowSwapAddress)\n        internal\n        view\n        returns (bytes32)\n    {\n        // NOTE: Currently, the only way to get the chain ID in solidity is using assembly.\n        uint256 chainId;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n\n        return\n            keccak256(\n                abi.encode(\n                    DOMAIN_TYPE_HASH,\n                    DOMAIN_NAME,\n                    DOMAIN_VERSION,\n                    chainId,\n                    cowSwapAddress\n                )\n            );\n    }\n}\n'}, 'src/libraries/EthFlowOrder.sol': {'content': '// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.8;\n\nimport ""../vendored/GPv2Order.sol"";\nimport ""../vendored/IERC20.sol"";\n\n/// @title CoW Swap ETH Flow Order Library\n/// @author CoW Swap Developers\nlibrary EthFlowOrder {\n    /// @dev Struct collecting all parameters of an ETH flow order that need to be stored onchain.\n    struct OnchainData {\n        /// @dev The address of the user whom the order belongs to.\n        address owner;\n        /// @dev The latest timestamp in seconds when the order can be settled.\n        uint32 validTo;\n    }\n\n    /// @dev Data describing all parameters of an ETH flow order.\n    struct Data {\n        /// @dev The address of the token that should be bought for ETH. It follows the same format as in the CoW Swap\n        /// contracts, meaning that the token GPv2Transfer.BUY_ETH_ADDRESS (0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\n        /// represents native ETH (and should most likely not be used in this context).\n        IERC20 buyToken;\n        /// @dev The address that should receive the proceeds from the order. Note that using the address\n        /// GPv2Order.RECEIVER_SAME_AS_OWNER (i.e., the zero address) as the receiver is not allowed.\n        address receiver;\n        /// @dev The exact amount of ETH that should be sold in this order.\n        uint256 sellAmount;\n        /// @dev The minimum amount of buyToken that should be received to settle this order.\n        uint256 buyAmount;\n        /// @dev Extra data to include in the order. It is used by the CoW Swap infrastructure as extra information on\n        /// the order and has no direct effect on on-chain execution.\n        bytes32 appData;\n        /// @dev The exact amount of ETH that should be paid by the user to the CoW Swap contract after the order is\n        /// settled.\n        uint256 feeAmount;\n        /// @dev The latest timestamp in seconds when the order can be settled.\n        uint32 validTo;\n        /// @dev Flag indicating whether the order is fill-or-kill or can be filled partially.\n        bool partiallyFillable;\n        /// @dev quoteId The quote id obtained from the CoW Swap API to lock in the current price. It is not directly\n        /// used by any onchain component but is part of the information emitted onchain on order creation and may be\n        /// required for an order to be automatically picked up by the CoW Swap orderbook.\n        int64 quoteId;\n    }\n\n    /// @dev An order that is owned by this address is an order that has not yet been assigned.\n    address internal constant NO_OWNER = address(0);\n\n    /// @dev An order that is owned by this address is an order that has been invalidated. Note that this address cannot\n    /// be directly used to create orders.\n    address internal constant INVALIDATED_OWNER = address(type(uint160).max);\n\n    /// @dev Error returned if the receiver of the ETH flow order is unspecified (`GPv2Order.RECEIVER_SAME_AS_OWNER`).\n    error ReceiverMustBeSet();\n\n    /// @dev Transforms an ETH flow order into the CoW Swap order that can be settled by the ETH flow contract.\n    ///\n    /// @param order The ETH flow order to be converted.\n    /// @param wrappedNativeToken The address of the wrapped native token for the current network (e.g., WETH for\n    /// Ethereum mainet).\n    /// @return The CoW Swap order data that represents the user order in the ETH flow contract.\n    function toCoWSwapOrder(Data memory order, IERC20 wrappedNativeToken)\n        internal\n        pure\n        returns (GPv2Order.Data memory)\n    {\n        if (order.receiver == GPv2Order.RECEIVER_SAME_AS_OWNER) {\n            // The receiver field specified which address is going to receive the proceeds from the orders. If using\n            // `RECEIVER_SAME_AS_OWNER`, then the receiver is implicitly assumed by the CoW Swap Protocol to be the\n            // same as the order owner.\n            // However, the owner of an ETH flow order is always the ETH flow smart contract, and any ERC20 tokens sent\n            // to this contract would be lost.\n            revert ReceiverMustBeSet();\n        }\n\n        // Note that not all fields from `order` are used in creating the corresponding CoW Swap order.\n        // For example, validTo and quoteId are ignored.\n        return\n            GPv2Order.Data(\n                wrappedNativeToken, // IERC20 sellToken\n                order.buyToken, // IERC20 buyToken\n                order.receiver, // address receiver\n                order.sellAmount, // uint256 sellAmount\n                order.buyAmount, // uint256 buyAmount\n                // This CoW Swap order is not allowed to expire. If it expired, then any solver of CoW Swap contract\n                // would be allowed to clear the `filledAmount` for this order using `freeFilledAmountStorage`, making\n                // it impossible to detect if the order has been previously filled.\n                // Note that order.validTo is disregarded in building the CoW Swap order.\n                type(uint32).max, // uint32 validTo\n                order.appData, // bytes32 appData\n                order.feeAmount, // uint256 feeAmount\n                // Only sell orders are allowed. In a buy order, any leftover ETH would stay in the ETH flow contract\n                // and would need to be sent back to the user, whose extra gas cost is usually not worth it.\n                GPv2Order.KIND_SELL, // bytes32 kind\n                order.partiallyFillable, // bool partiallyFillable\n                // We do not currently support interacting with the Balancer vault.\n                GPv2Order.BALANCE_ERC20, // bytes32 sellTokenBalance\n                GPv2Order.BALANCE_ERC20 // bytes32 buyTokenBalance\n            );\n    }\n}\n'}, 'src/mixins/CoWSwapOnchainOrders.sol': {'content': '// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.8;\n\nimport ""../vendored/GPv2Order.sol"";\nimport ""../interfaces/ICoWSwapOnchainOrders.sol"";\nimport ""../libraries/CoWSwapEip712.sol"";\n\n/// @title CoW Swap Onchain Order Creator Event Emitter\n/// @author CoW Swap Developers\ncontract CoWSwapOnchainOrders is ICoWSwapOnchainOrders {\n    using GPv2Order for GPv2Order.Data;\n    using GPv2Order for bytes;\n\n    /// @dev The domain separator for the CoW Swap settlement contract.\n    bytes32 internal immutable cowSwapDomainSeparator;\n\n    /// @param settlementContractAddress The address of CoW Swap\'s settlement contract on the chain where this contract\n    /// is deployed.\n    constructor(address settlementContractAddress) {\n        cowSwapDomainSeparator = CoWSwapEip712.domainSeparator(\n            settlementContractAddress\n        );\n    }\n\n    /// @dev Emits an event with all information needed to execute an order onchain and returns the corresponding order\n    /// hash.\n    ///\n    /// See [`ICoWSwapOnchainOrders.OrderPlacement`] for details on the meaning of each parameter.\n    /// @return The EIP-712 hash of the order data as computed by the CoW Swap settlement contract.\n    function broadcastOrder(\n        address sender,\n        GPv2Order.Data memory order,\n        OnchainSignature memory signature,\n        bytes memory data\n    ) internal returns (bytes32) {\n        emit OrderPlacement(sender, order, signature, data);\n        return order.hash(cowSwapDomainSeparator);\n    }\n}\n'}, 'src/vendored/GPv2EIP1271.sol': {'content': '// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.8;\n\n// Vendored from GPv2 contracts v1.0.0, see:\n// <https://raw.githubusercontent.com/cowprotocol/contracts/main/src/contracts/interfaces/GPv2EIP1271.sol>\n// The following changes were made:\n// - Bumped up Solidity version.\n\nlibrary GPv2EIP1271 {\n    /// @dev Value returned by a call to `isValidSignature` if the signature\n    /// was verified successfully. The value is defined in EIP-1271 as:\n    /// bytes4(keccak256(""isValidSignature(bytes32,bytes)""))\n    bytes4 internal constant MAGICVALUE = 0x1626ba7e;\n}\n\n/// @title EIP1271 Interface\n/// @dev Standardized interface for an implementation of smart contract\n/// signatures as described in EIP-1271. The code that follows is identical to\n/// the code in the standard with the exception of formatting and syntax\n/// changes to adapt the code to our Solidity version.\ninterface EIP1271Verifier {\n    /// @dev Should return whether the signature provided is valid for the\n    /// provided data\n    /// @param _hash      Hash of the data to be signed\n    /// @param _signature Signature byte array associated with _data\n    ///\n    /// MUST return the bytes4 magic value 0x1626ba7e when function passes.\n    /// MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for\n    /// solc > 0.5)\n    /// MUST allow external calls\n    ///\n    function isValidSignature(bytes32 _hash, bytes memory _signature)\n        external\n        view\n        returns (bytes4 magicValue);\n}\n'}, 'src/vendored/GPv2Order.sol': {'content': '// SPDX-License-Identifier: LGPL-3.0-or-later\n\n// Vendored from GPv2 contracts v1.0.0, see:\n// <https://raw.githubusercontent.com/cowprotocol/contracts/v1.0.0/src/contracts/libraries/GPv2Order.sol>\n// The following changes were made:\n// - Bumped up Solidity version.\n// - Vendored imports.\n\npragma solidity ^0.8;\n\nimport ""./IERC20.sol"";\n\n/// @title Gnosis Protocol v2 Order Library\n/// @author Gnosis Developers\nlibrary GPv2Order {\n    /// @dev The complete data for a Gnosis Protocol order. This struct contains\n    /// all order parameters that are signed for submitting to GP.\n    struct Data {\n        IERC20 sellToken;\n        IERC20 buyToken;\n        address receiver;\n        uint256 sellAmount;\n        uint256 buyAmount;\n        uint32 validTo;\n        bytes32 appData;\n        uint256 feeAmount;\n        bytes32 kind;\n        bool partiallyFillable;\n        bytes32 sellTokenBalance;\n        bytes32 buyTokenBalance;\n    }\n\n    /// @dev The order EIP-712 type hash for the [`GPv2Order.Data`] struct.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\n    ///     ""Order("" +\n    ///         ""address sellToken,"" +\n    ///         ""address buyToken,"" +\n    ///         ""address receiver,"" +\n    ///         ""uint256 sellAmount,"" +\n    ///         ""uint256 buyAmount,"" +\n    ///         ""uint32 validTo,"" +\n    ///         ""bytes32 appData,"" +\n    ///         ""uint256 feeAmount,"" +\n    ///         ""string kind,"" +\n    ///         ""bool partiallyFillable"" +\n    ///         ""string sellTokenBalance"" +\n    ///         ""string buyTokenBalance"" +\n    ///     "")""\n    /// )\n    /// ```\n    bytes32 internal constant TYPE_HASH =\n        hex""d5a25ba2e97094ad7d83dc28a6572da797d6b3e7fc6663bd93efb789fc17e489"";\n\n    /// @dev The marker value for a sell order for computing the order struct\n    /// hash. This allows the EIP-712 compatible wallets to display a\n    /// descriptive string for the order kind (instead of 0 or 1).\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(""sell"")\n    /// ```\n    bytes32 internal constant KIND_SELL =\n        hex""f3b277728b3fee749481eb3e0b3b48980dbbab78658fc419025cb16eee346775"";\n\n    /// @dev The OrderKind marker value for a buy order for computing the order\n    /// struct hash.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(""buy"")\n    /// ```\n    bytes32 internal constant KIND_BUY =\n        hex""6ed88e868af0a1983e3886d5f3e95a2fafbd6c3450bc229e27342283dc429ccc"";\n\n    /// @dev The TokenBalance marker value for using direct ERC20 balances for\n    /// computing the order struct hash.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(""erc20"")\n    /// ```\n    bytes32 internal constant BALANCE_ERC20 =\n        hex""5a28e9363bb942b639270062aa6bb295f434bcdfc42c97267bf003f272060dc9"";\n\n    /// @dev The TokenBalance marker value for using Balancer Vault external\n    /// balances (in order to re-use Vault ERC20 approvals) for computing the\n    /// order struct hash.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(""external"")\n    /// ```\n    bytes32 internal constant BALANCE_EXTERNAL =\n        hex""abee3b73373acd583a130924aad6dc38cfdc44ba0555ba94ce2ff63980ea0632"";\n\n    /// @dev The TokenBalance marker value for using Balancer Vault internal\n    /// balances for computing the order struct hash.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(""internal"")\n    /// ```\n    bytes32 internal constant BALANCE_INTERNAL =\n        hex""4ac99ace14ee0a5ef932dc609df0943ab7ac16b7583634612f8dc35a4289a6ce"";\n\n    /// @dev Marker address used to indicate that the receiver of the trade\n    /// proceeds should the owner of the order.\n    ///\n    /// This is chosen to be `address(0)` for gas efficiency as it is expected\n    /// to be the most common case.\n    address internal constant RECEIVER_SAME_AS_OWNER = address(0);\n\n    /// @dev The byte length of an order unique identifier.\n    uint256 internal constant UID_LENGTH = 56;\n\n    /// @dev Returns the actual receiver for an order. This function checks\n    /// whether or not the [`receiver`] field uses the marker value to indicate\n    /// it is the same as the order owner.\n    ///\n    /// @return receiver The actual receiver of trade proceeds.\n    function actualReceiver(Data memory order, address owner)\n        internal\n        pure\n        returns (address receiver)\n    {\n        if (order.receiver == RECEIVER_SAME_AS_OWNER) {\n            receiver = owner;\n        } else {\n            receiver = order.receiver;\n        }\n    }\n\n    /// @dev Return the EIP-712 signing hash for the specified order.\n    ///\n    /// @param order The order to compute the EIP-712 signing hash for.\n    /// @param domainSeparator The EIP-712 domain separator to use.\n    /// @return orderDigest The 32 byte EIP-712 struct hash.\n    function hash(Data memory order, bytes32 domainSeparator)\n        internal\n        pure\n        returns (bytes32 orderDigest)\n    {\n        bytes32 structHash;\n\n        // NOTE: Compute the EIP-712 order struct hash in place. As suggested\n        // in the EIP proposal, noting that the order struct has 10 fields, and\n        // including the type hash `(12 + 1) * 32 = 416` bytes to hash.\n        // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#rationale-for-encodedata>\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let dataStart := sub(order, 32)\n            let temp := mload(dataStart)\n            mstore(dataStart, TYPE_HASH)\n            structHash := keccak256(dataStart, 416)\n            mstore(dataStart, temp)\n        }\n\n        // NOTE: Now that we have the struct hash, compute the EIP-712 signing\n        // hash using scratch memory past the free memory pointer. The signing\n        // hash is computed from `""\\x19\\x01"" || domainSeparator || structHash`.\n        // <https://docs.soliditylang.org/en/v0.8.16/internals/layout_in_memory.html#layout-in-memory>\n        // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#specification>\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, ""\\x19\\x01"")\n            mstore(add(freeMemoryPointer, 2), domainSeparator)\n            mstore(add(freeMemoryPointer, 34), structHash)\n            orderDigest := keccak256(freeMemoryPointer, 66)\n        }\n    }\n\n    /// @dev Packs order UID parameters into the specified memory location. The\n    /// result is equivalent to `abi.encodePacked(...)` with the difference that\n    /// it allows re-using the memory for packing the order UID.\n    ///\n    /// This function reverts if the order UID buffer is not the correct size.\n    ///\n    /// @param orderUid The buffer pack the order UID parameters into.\n    /// @param orderDigest The EIP-712 struct digest derived from the order\n    /// parameters.\n    /// @param owner The address of the user who owns this order.\n    /// @param validTo The epoch time at which the order will stop being valid.\n    function packOrderUidParams(\n        bytes memory orderUid,\n        bytes32 orderDigest,\n        address owner,\n        uint32 validTo\n    ) internal pure {\n        require(orderUid.length == UID_LENGTH, ""GPv2: uid buffer overflow"");\n\n        // NOTE: Write the order UID to the allocated memory buffer. The order\n        // parameters are written to memory in **reverse order** as memory\n        // operations write 32-bytes at a time and we want to use a packed\n        // encoding. This means, for example, that after writing the value of\n        // `owner` to bytes `20:52`, writing the `orderDigest` to bytes `0:32`\n        // will **overwrite** bytes `20:32`. This is desirable as addresses are\n        // only 20 bytes and `20:32` should be `0`s:\n        //\n        //        |           1111111111222222222233333333334444444444555555\n        //   byte | 01234567890123456789012345678901234567890123456789012345\n        // -------+---------------------------------------------------------\n        //  field | [.........orderDigest..........][......owner.......][vT]\n        // -------+---------------------------------------------------------\n        // mstore |                         [000000000000000000000000000.vT]\n        //        |                     [00000000000.......owner.......]\n        //        | [.........orderDigest..........]\n        //\n        // Additionally, since Solidity `bytes memory` are length prefixed,\n        // 32 needs to be added to all the offsets.\n        //\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(add(orderUid, 56), validTo)\n            mstore(add(orderUid, 52), owner)\n            mstore(add(orderUid, 32), orderDigest)\n        }\n    }\n\n    /// @dev Extracts specific order information from the standardized unique\n    /// order id of the protocol.\n    ///\n    /// @param orderUid The unique identifier used to represent an order in\n    /// the protocol. This uid is the packed concatenation of the order digest,\n    /// the validTo order parameter and the address of the user who created the\n    /// order. It is used by the user to interface with the contract directly,\n    /// and not by calls that are triggered by the solvers.\n    /// @return orderDigest The EIP-712 signing digest derived from the order\n    /// parameters.\n    /// @return owner The address of the user who owns this order.\n    /// @return validTo The epoch time at which the order will stop being valid.\n    function extractOrderUidParams(bytes calldata orderUid)\n        internal\n        pure\n        returns (\n            bytes32 orderDigest,\n            address owner,\n            uint32 validTo\n        )\n    {\n        require(orderUid.length == UID_LENGTH, ""GPv2: invalid uid"");\n\n        // Use assembly to efficiently decode packed calldata.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            orderDigest := calldataload(orderUid.offset)\n            owner := shr(96, calldataload(add(orderUid.offset, 32)))\n            validTo := shr(224, calldataload(add(orderUid.offset, 52)))\n        }\n    }\n}\n'}, 'src/vendored/IERC20.sol': {'content': ""// SPDX-License-Identifier: MIT\n\n// Vendored from OpenZeppelin Contracts v4.4.0, see:\n// <https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/v4.4.0/contracts/token/ERC20/IERC20.sol>\n\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n""}}

// File: settings
{'optimizer': {'enabled': True, 'runs': 1000000}, 'evmVersion': 'london', 'remappings': [':ds-test/=lib/forge-std/lib/ds-test/src/', ':forge-std/=lib/forge-std/src/', ':openzeppelin-contracts/=lib/openzeppelin-contracts/'], 'libraries': {}, 'outputSelection': {'*': {'*': ['evm.bytecode', 'evm.deployedBytecode', 'devdoc', 'userdoc', 'metadata', 'abi']}}}",True
0x4313c378cc91ea583c91387b9216e2c03096b27f,"// File: language
Solidity

// File: sources
{'@openzeppelin/contracts/access/Ownable.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport ""../utils/Context.sol"";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), ""Ownable: caller is not the owner"");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), ""Ownable: new owner is the zero address"");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n'}, '@openzeppelin/contracts/interfaces/draft-IERC1822.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n'}, '@openzeppelin/contracts/interfaces/IERC1967.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.3) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.9._\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n'}, '@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/beacon/BeaconProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport ""./IBeacon.sol"";\nimport ""../Proxy.sol"";\nimport ""../ERC1967/ERC1967Upgrade.sol"";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256(\'eip1967.proxy.beacon\')) - 1`, so that it doesn\'t\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract BeaconProxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it\'s used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address) {\n        return _getBeacon();\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\n     *\n     * If `data` is nonempty, it\'s used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n}\n'}, '@openzeppelin/contracts/proxy/beacon/IBeacon.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n'}, '@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/UpgradeableBeacon.sol)\n\npragma solidity ^0.8.0;\n\nimport ""./IBeacon.sol"";\nimport ""../../access/Ownable.sol"";\nimport ""../../utils/Address.sol"";\n\n/**\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\n * implementation contract, which is where they will delegate all function calls.\n *\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\n */\ncontract UpgradeableBeacon is IBeacon, Ownable {\n    address private _implementation;\n\n    /**\n     * @dev Emitted when the implementation returned by the beacon is changed.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the\n     * beacon.\n     */\n    constructor(address implementation_) {\n        _setImplementation(implementation_);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function implementation() public view virtual override returns (address) {\n        return _implementation;\n    }\n\n    /**\n     * @dev Upgrades the beacon to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * Requirements:\n     *\n     * - msg.sender must be the owner of the contract.\n     * - `newImplementation` must be a contract.\n     */\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation contract address for this beacon\n     *\n     * Requirements:\n     *\n     * - `newImplementation` must be a contract.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), ""UpgradeableBeacon: implementation is not a contract"");\n        _implementation = newImplementation;\n    }\n}\n'}, '@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport ""../Proxy.sol"";\nimport ""./ERC1967Upgrade.sol"";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn\'t conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it\'s used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n'}, '@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.3) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport ""../beacon/IBeacon.sol"";\nimport ""../../interfaces/IERC1967.sol"";\nimport ""../../interfaces/draft-IERC1822.sol"";\nimport ""../../utils/Address.sol"";\nimport ""../../utils/StorageSlot.sol"";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade is IERC1967 {\n    // This is the keccak-256 hash of ""eip1967.proxy.rollback"" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of ""eip1967.proxy.implementation"" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), ""ERC1967: new implementation is not a contract"");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, ""ERC1967Upgrade: unsupported proxiableUUID"");\n            } catch {\n                revert(""ERC1967Upgrade: new implementation is not UUPS"");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of ""eip1967.proxy.admin"" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), ""ERC1967: new admin is the zero address"");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256(\'eip1967.proxy.beacon\')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), ""ERC1967: new beacon is not a contract"");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            ""ERC1967: beacon implementation is not a contract""\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n'}, '@openzeppelin/contracts/proxy/Proxy.sol': {'content': ""// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n""}, '@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.3) (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.0;\n\nimport ""./TransparentUpgradeableProxy.sol"";\nimport ""../../access/Ownable.sol"";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(ITransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(""implementation()"")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex""5c60da1b"");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(ITransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(""admin()"")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex""f851a440"");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(ITransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(ITransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        ITransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n'}, '@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.3) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport ""../ERC1967/ERC1967Proxy.sol"";\n\n/**\n * @dev Interface for {TransparentUpgradeableProxy}. In order to implement transparency, {TransparentUpgradeableProxy}\n * does not implement this interface directly, and some of its functions are implemented by an internal dispatch\n * mechanism. The compiler is unaware that these functions are implemented by {TransparentUpgradeableProxy} and will not\n * include them in the ABI so this interface must be used to interact with it.\n */\ninterface ITransparentUpgradeableProxy is IERC1967 {\n    function admin() external view returns (address);\n\n    function implementation() external view returns (address);\n\n    function changeAdmin(address) external;\n\n    function upgradeTo(address) external;\n\n    function upgradeToAndCall(address, bytes memory) external payable;\n}\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * ""admin cannot fallback to proxy target"".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it\'s best if it\'s a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n *\n * NOTE: The real interface of this proxy is that defined in `ITransparentUpgradeableProxy`. This contract does not\n * inherit from that interface, and instead the admin functions are implicitly implemented using a custom dispatch\n * mechanism in `_fallback`. Consequently, the compiler will not produce an ABI for this contract. This is necessary to\n * fully implement transparency without decoding reverts caused by selector clashes between the proxy and the\n * implementation.\n *\n * WARNING: It is not recommended to extend this contract to add additional external functions. If you do so, the compiler\n * will not check that there are no selector conflicts, due to the note above. A selector clash between any new function\n * and the functions declared in {ITransparentUpgradeableProxy} will be resolved in favor of the new one. This could\n * render the admin operations inaccessible, which could prevent upgradeability. Transparency may also be compromised.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     *\n     * CAUTION: This modifier is deprecated, as it could cause issues if the modified function has arguments, and the\n     * implementation provides a function with the same selector.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior\n     */\n    function _fallback() internal virtual override {\n        if (msg.sender == _getAdmin()) {\n            bytes memory ret;\n            bytes4 selector = msg.sig;\n            if (selector == ITransparentUpgradeableProxy.upgradeTo.selector) {\n                ret = _dispatchUpgradeTo();\n            } else if (selector == ITransparentUpgradeableProxy.upgradeToAndCall.selector) {\n                ret = _dispatchUpgradeToAndCall();\n            } else if (selector == ITransparentUpgradeableProxy.changeAdmin.selector) {\n                ret = _dispatchChangeAdmin();\n            } else if (selector == ITransparentUpgradeableProxy.admin.selector) {\n                ret = _dispatchAdmin();\n            } else if (selector == ITransparentUpgradeableProxy.implementation.selector) {\n                ret = _dispatchImplementation();\n            } else {\n                revert(""TransparentUpgradeableProxy: admin cannot fallback to proxy target"");\n            }\n            assembly {\n                return(add(ret, 0x20), mload(ret))\n            }\n        } else {\n            super._fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function _dispatchAdmin() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address admin = _getAdmin();\n        return abi.encode(admin);\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function _dispatchImplementation() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address implementation = _implementation();\n        return abi.encode(implementation);\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _dispatchChangeAdmin() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address newAdmin = abi.decode(msg.data[4:], (address));\n        _changeAdmin(newAdmin);\n\n        return """";\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     */\n    function _dispatchUpgradeTo() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address newImplementation = abi.decode(msg.data[4:], (address));\n        _upgradeToAndCall(newImplementation, bytes(""""), false);\n\n        return """";\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     */\n    function _dispatchUpgradeToAndCall() private returns (bytes memory) {\n        (address newImplementation, bytes memory data) = abi.decode(msg.data[4:], (address, bytes));\n        _upgradeToAndCall(newImplementation, data, true);\n\n        return """";\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev To keep this contract fully transparent, all `ifAdmin` functions must be payable. This helper is here to\n     * emulate some proxy functions being non-payable while still allowing value to pass through.\n     */\n    function _requireZeroValue() private {\n        require(msg.value == 0);\n    }\n}\n'}, '@openzeppelin/contracts/utils/Address.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, ""Address: insufficient balance"");\n\n        (bool success, ) = recipient.call{value: amount}("""");\n        require(success, ""Address: unable to send value, recipient may have reverted"");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, ""Address: low-level call failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, ""Address: insufficient balance for call"");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, ""Address: low-level static call failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, ""Address: low-level delegate call failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), ""Address: call to non-contract"");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n'}, '@openzeppelin/contracts/utils/Context.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n'}, '@openzeppelin/contracts/utils/StorageSlot.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), ""ERC1967: new implementation is not a contract"");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n'}}

// File: settings
{'optimizer': {'enabled': True, 'runs': 200}, 'outputSelection': {'*': {'*': ['evm.bytecode', 'evm.deployedBytecode', 'devdoc', 'userdoc', 'metadata', 'abi']}}}",True
0x1ff7d7c0a7d8e94046708c611dec5056a9d2b823,"// File: language
Solidity

// File: sources
{'@openzeppelin/contracts/access/Ownable.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport ""../utils/Context.sol"";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), ""Ownable: caller is not the owner"");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), ""Ownable: new owner is the zero address"");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n'}, '@openzeppelin/contracts/interfaces/draft-IERC1822.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n'}, '@openzeppelin/contracts/interfaces/IERC1967.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.3) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.9._\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n'}, '@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/beacon/BeaconProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport ""./IBeacon.sol"";\nimport ""../Proxy.sol"";\nimport ""../ERC1967/ERC1967Upgrade.sol"";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256(\'eip1967.proxy.beacon\')) - 1`, so that it doesn\'t\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract BeaconProxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it\'s used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address) {\n        return _getBeacon();\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\n     *\n     * If `data` is nonempty, it\'s used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n}\n'}, '@openzeppelin/contracts/proxy/beacon/IBeacon.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n'}, '@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/UpgradeableBeacon.sol)\n\npragma solidity ^0.8.0;\n\nimport ""./IBeacon.sol"";\nimport ""../../access/Ownable.sol"";\nimport ""../../utils/Address.sol"";\n\n/**\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\n * implementation contract, which is where they will delegate all function calls.\n *\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\n */\ncontract UpgradeableBeacon is IBeacon, Ownable {\n    address private _implementation;\n\n    /**\n     * @dev Emitted when the implementation returned by the beacon is changed.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the\n     * beacon.\n     */\n    constructor(address implementation_) {\n        _setImplementation(implementation_);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function implementation() public view virtual override returns (address) {\n        return _implementation;\n    }\n\n    /**\n     * @dev Upgrades the beacon to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * Requirements:\n     *\n     * - msg.sender must be the owner of the contract.\n     * - `newImplementation` must be a contract.\n     */\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation contract address for this beacon\n     *\n     * Requirements:\n     *\n     * - `newImplementation` must be a contract.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), ""UpgradeableBeacon: implementation is not a contract"");\n        _implementation = newImplementation;\n    }\n}\n'}, '@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport ""../Proxy.sol"";\nimport ""./ERC1967Upgrade.sol"";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn\'t conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it\'s used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n'}, '@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.3) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport ""../beacon/IBeacon.sol"";\nimport ""../../interfaces/IERC1967.sol"";\nimport ""../../interfaces/draft-IERC1822.sol"";\nimport ""../../utils/Address.sol"";\nimport ""../../utils/StorageSlot.sol"";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade is IERC1967 {\n    // This is the keccak-256 hash of ""eip1967.proxy.rollback"" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of ""eip1967.proxy.implementation"" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), ""ERC1967: new implementation is not a contract"");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, ""ERC1967Upgrade: unsupported proxiableUUID"");\n            } catch {\n                revert(""ERC1967Upgrade: new implementation is not UUPS"");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of ""eip1967.proxy.admin"" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), ""ERC1967: new admin is the zero address"");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256(\'eip1967.proxy.beacon\')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), ""ERC1967: new beacon is not a contract"");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            ""ERC1967: beacon implementation is not a contract""\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n'}, '@openzeppelin/contracts/proxy/Proxy.sol': {'content': ""// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n""}, '@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.3) (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.0;\n\nimport ""./TransparentUpgradeableProxy.sol"";\nimport ""../../access/Ownable.sol"";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(ITransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(""implementation()"")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex""5c60da1b"");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(ITransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(""admin()"")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex""f851a440"");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(ITransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(ITransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        ITransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n'}, '@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.3) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport ""../ERC1967/ERC1967Proxy.sol"";\n\n/**\n * @dev Interface for {TransparentUpgradeableProxy}. In order to implement transparency, {TransparentUpgradeableProxy}\n * does not implement this interface directly, and some of its functions are implemented by an internal dispatch\n * mechanism. The compiler is unaware that these functions are implemented by {TransparentUpgradeableProxy} and will not\n * include them in the ABI so this interface must be used to interact with it.\n */\ninterface ITransparentUpgradeableProxy is IERC1967 {\n    function admin() external view returns (address);\n\n    function implementation() external view returns (address);\n\n    function changeAdmin(address) external;\n\n    function upgradeTo(address) external;\n\n    function upgradeToAndCall(address, bytes memory) external payable;\n}\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * ""admin cannot fallback to proxy target"".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it\'s best if it\'s a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n *\n * NOTE: The real interface of this proxy is that defined in `ITransparentUpgradeableProxy`. This contract does not\n * inherit from that interface, and instead the admin functions are implicitly implemented using a custom dispatch\n * mechanism in `_fallback`. Consequently, the compiler will not produce an ABI for this contract. This is necessary to\n * fully implement transparency without decoding reverts caused by selector clashes between the proxy and the\n * implementation.\n *\n * WARNING: It is not recommended to extend this contract to add additional external functions. If you do so, the compiler\n * will not check that there are no selector conflicts, due to the note above. A selector clash between any new function\n * and the functions declared in {ITransparentUpgradeableProxy} will be resolved in favor of the new one. This could\n * render the admin operations inaccessible, which could prevent upgradeability. Transparency may also be compromised.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     *\n     * CAUTION: This modifier is deprecated, as it could cause issues if the modified function has arguments, and the\n     * implementation provides a function with the same selector.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior\n     */\n    function _fallback() internal virtual override {\n        if (msg.sender == _getAdmin()) {\n            bytes memory ret;\n            bytes4 selector = msg.sig;\n            if (selector == ITransparentUpgradeableProxy.upgradeTo.selector) {\n                ret = _dispatchUpgradeTo();\n            } else if (selector == ITransparentUpgradeableProxy.upgradeToAndCall.selector) {\n                ret = _dispatchUpgradeToAndCall();\n            } else if (selector == ITransparentUpgradeableProxy.changeAdmin.selector) {\n                ret = _dispatchChangeAdmin();\n            } else if (selector == ITransparentUpgradeableProxy.admin.selector) {\n                ret = _dispatchAdmin();\n            } else if (selector == ITransparentUpgradeableProxy.implementation.selector) {\n                ret = _dispatchImplementation();\n            } else {\n                revert(""TransparentUpgradeableProxy: admin cannot fallback to proxy target"");\n            }\n            assembly {\n                return(add(ret, 0x20), mload(ret))\n            }\n        } else {\n            super._fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function _dispatchAdmin() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address admin = _getAdmin();\n        return abi.encode(admin);\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function _dispatchImplementation() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address implementation = _implementation();\n        return abi.encode(implementation);\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _dispatchChangeAdmin() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address newAdmin = abi.decode(msg.data[4:], (address));\n        _changeAdmin(newAdmin);\n\n        return """";\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     */\n    function _dispatchUpgradeTo() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address newImplementation = abi.decode(msg.data[4:], (address));\n        _upgradeToAndCall(newImplementation, bytes(""""), false);\n\n        return """";\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     */\n    function _dispatchUpgradeToAndCall() private returns (bytes memory) {\n        (address newImplementation, bytes memory data) = abi.decode(msg.data[4:], (address, bytes));\n        _upgradeToAndCall(newImplementation, data, true);\n\n        return """";\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev To keep this contract fully transparent, all `ifAdmin` functions must be payable. This helper is here to\n     * emulate some proxy functions being non-payable while still allowing value to pass through.\n     */\n    function _requireZeroValue() private {\n        require(msg.value == 0);\n    }\n}\n'}, '@openzeppelin/contracts/utils/Address.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, ""Address: insufficient balance"");\n\n        (bool success, ) = recipient.call{value: amount}("""");\n        require(success, ""Address: unable to send value, recipient may have reverted"");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, ""Address: low-level call failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, ""Address: insufficient balance for call"");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, ""Address: low-level static call failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, ""Address: low-level delegate call failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), ""Address: call to non-contract"");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n'}, '@openzeppelin/contracts/utils/Context.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n'}, '@openzeppelin/contracts/utils/StorageSlot.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), ""ERC1967: new implementation is not a contract"");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n'}}

// File: settings
{'optimizer': {'enabled': True, 'runs': 200}, 'outputSelection': {'*': {'*': ['evm.bytecode', 'evm.deployedBytecode', 'devdoc', 'userdoc', 'metadata', 'abi']}}}",True
0xaeb0c00d0125a8a788956ade4f4f12ead9f65ddf,"// File: language
Solidity

// File: sources
{'@openzeppelin/contracts/access/Ownable.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from ""../utils/Context.sol"";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n'}, '@openzeppelin/contracts/interfaces/IERC1967.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n'}, '@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/BeaconProxy.sol)\n\npragma solidity ^0.8.20;\n\nimport {IBeacon} from ""./IBeacon.sol"";\nimport {Proxy} from ""../Proxy.sol"";\nimport {ERC1967Utils} from ""../ERC1967/ERC1967Utils.sol"";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\n *\n * The beacon address can only be set once during construction, and cannot be changed afterwards. It is stored in an\n * immutable variable to avoid unnecessary storage reads, and also in the beacon storage slot specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] so that it can be accessed externally.\n *\n * CAUTION: Since the beacon address can never be changed, you must ensure that you either control the beacon, or trust\n * the beacon to not upgrade the implementation maliciously.\n *\n * IMPORTANT: Do not use the implementation logic to modify the beacon storage slot. Doing so would leave the proxy in\n * an inconsistent state where the beacon storage slot does not match the beacon address.\n */\ncontract BeaconProxy is Proxy {\n    // An immutable address for the beacon to avoid unnecessary SLOADs before each delegate call.\n    address private immutable _beacon;\n\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it\'s used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     * - If `data` is empty, `msg.value` must be zero.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        ERC1967Utils.upgradeBeaconToAndCall(beacon, data);\n        _beacon = beacon;\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /**\n     * @dev Returns the beacon.\n     */\n    function _getBeacon() internal view virtual returns (address) {\n        return _beacon;\n    }\n}\n'}, '@openzeppelin/contracts/proxy/beacon/IBeacon.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {UpgradeableBeacon} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n'}, '@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/UpgradeableBeacon.sol)\n\npragma solidity ^0.8.20;\n\nimport {IBeacon} from ""./IBeacon.sol"";\nimport {Ownable} from ""../../access/Ownable.sol"";\n\n/**\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\n * implementation contract, which is where they will delegate all function calls.\n *\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\n */\ncontract UpgradeableBeacon is IBeacon, Ownable {\n    address private _implementation;\n\n    /**\n     * @dev The `implementation` of the beacon is invalid.\n     */\n    error BeaconInvalidImplementation(address implementation);\n\n    /**\n     * @dev Emitted when the implementation returned by the beacon is changed.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Sets the address of the initial implementation, and the initial owner who can upgrade the beacon.\n     */\n    constructor(address implementation_, address initialOwner) Ownable(initialOwner) {\n        _setImplementation(implementation_);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function implementation() public view virtual returns (address) {\n        return _implementation;\n    }\n\n    /**\n     * @dev Upgrades the beacon to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * Requirements:\n     *\n     * - msg.sender must be the owner of the contract.\n     * - `newImplementation` must be a contract.\n     */\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\n        _setImplementation(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation contract address for this beacon\n     *\n     * Requirements:\n     *\n     * - `newImplementation` must be a contract.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert BeaconInvalidImplementation(newImplementation);\n        }\n        _implementation = newImplementation;\n        emit Upgraded(newImplementation);\n    }\n}\n'}, '@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.20;\n\nimport {Proxy} from ""../Proxy.sol"";\nimport {ERC1967Utils} from ""./ERC1967Utils.sol"";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn\'t conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `implementation`.\n     *\n     * If `_data` is nonempty, it\'s used as data in a delegate call to `implementation`. This will typically be an\n     * encoded function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     *\n     * Requirements:\n     *\n     * - If `data` is empty, `msg.value` must be zero.\n     */\n    constructor(address implementation, bytes memory _data) payable {\n        ERC1967Utils.upgradeToAndCall(implementation, _data);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return ERC1967Utils.getImplementation();\n    }\n}\n'}, '@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Utils.sol)\n\npragma solidity ^0.8.20;\n\nimport {IBeacon} from ""../beacon/IBeacon.sol"";\nimport {Address} from ""../../utils/Address.sol"";\nimport {StorageSlot} from ""../../utils/StorageSlot.sol"";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n */\nlibrary ERC1967Utils {\n    // We re-declare ERC-1967 events here because they can\'t be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of ""eip1967.proxy.implementation"" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of ""eip1967.proxy.admin"" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of ""eip1967.proxy.beacon"" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn\'t perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}\n'}, '@openzeppelin/contracts/proxy/Proxy.sol': {'content': ""// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback\n     * function and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n}\n""}, '@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.20;\n\nimport {ITransparentUpgradeableProxy} from ""./TransparentUpgradeableProxy.sol"";\nimport {Ownable} from ""../../access/Ownable.sol"";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgrade(address)`\n     * and `upgradeAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `""5.0.0""`, only `upgradeAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = ""5.0.0"";\n\n    /**\n     * @dev Sets the initial owner who can perform upgrades.\n     */\n    constructor(address initialOwner) Ownable(initialOwner) {}\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation.\n     * See {TransparentUpgradeableProxy-_dispatchUpgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     * - If `data` is empty, `msg.value` must be zero.\n     */\n    function upgradeAndCall(\n        ITransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n'}, '@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC1967Utils} from ""../ERC1967/ERC1967Utils.sol"";\nimport {ERC1967Proxy} from ""../ERC1967/ERC1967Proxy.sol"";\nimport {IERC1967} from ""../../interfaces/IERC1967.sol"";\nimport {ProxyAdmin} from ""./ProxyAdmin.sol"";\n\n/**\n * @dev Interface for {TransparentUpgradeableProxy}. In order to implement transparency, {TransparentUpgradeableProxy}\n * does not implement this interface directly, and its upgradeability mechanism is implemented by an internal dispatch\n * mechanism. The compiler is unaware that these functions are implemented by {TransparentUpgradeableProxy} and will not\n * include them in the ABI so this interface must be used to interact with it.\n */\ninterface ITransparentUpgradeableProxy is IERC1967 {\n    function upgradeToAndCall(address, bytes calldata) external payable;\n}\n\n/**\n * @dev This contract implements a proxy that is upgradeable through an associated {ProxyAdmin} instance.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches the {ITransparentUpgradeableProxy-upgradeToAndCall} function exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can call the `upgradeToAndCall` function but any other call won\'t be forwarded to\n * the implementation. If the admin tries to call a function on the implementation it will fail with an error indicating\n * the proxy admin cannot fallback to the target implementation.\n *\n * These properties mean that the admin account can only be used for upgrading the proxy, so it\'s best if it\'s a\n * dedicated account that is not used for anything else. This will avoid headaches due to sudden errors when trying to\n * call a function from the proxy implementation. For this reason, the proxy deploys an instance of {ProxyAdmin} and\n * allows upgrades only if they come through it. You should think of the `ProxyAdmin` instance as the administrative\n * interface of the proxy, including the ability to change who can trigger upgrades by transferring ownership.\n *\n * NOTE: The real interface of this proxy is that defined in `ITransparentUpgradeableProxy`. This contract does not\n * inherit from that interface, and instead `upgradeToAndCall` is implicitly implemented using a custom dispatch\n * mechanism in `_fallback`. Consequently, the compiler will not produce an ABI for this contract. This is necessary to\n * fully implement transparency without decoding reverts caused by selector clashes between the proxy and the\n * implementation.\n *\n * NOTE: This proxy does not inherit from {Context} deliberately. The {ProxyAdmin} of this contract won\'t send a\n * meta-transaction in any way, and any other meta-transaction setup should be made in the implementation contract.\n *\n * IMPORTANT: This contract avoids unnecessary storage reads by setting the admin only during construction as an\n * immutable variable, preventing any changes thereafter. However, the admin slot defined in ERC-1967 can still be\n * overwritten by the implementation logic pointed to by this proxy. In such cases, the contract may end up in an\n * undesirable state where the admin slot is different from the actual admin.\n *\n * WARNING: It is not recommended to extend this contract to add additional external functions. If you do so, the\n * compiler will not check that there are no selector conflicts, due to the note above. A selector clash between any new\n * function and the functions declared in {ITransparentUpgradeableProxy} will be resolved in favor of the new one. This\n * could render the `upgradeToAndCall` function inaccessible, preventing upgradeability and compromising transparency.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    // An immutable address for the admin to avoid unnecessary SLOADs before each call\n    // at the expense of removing the ability to change the admin once it\'s set.\n    // This is acceptable if the admin is always a ProxyAdmin instance or similar contract\n    // with its own ability to transfer the permissions to another account.\n    address private immutable _admin;\n\n    /**\n     * @dev The proxy caller is the current admin, and can\'t fallback to the proxy target.\n     */\n    error ProxyDeniedAdminAccess();\n\n    /**\n     * @dev Initializes an upgradeable proxy managed by an instance of a {ProxyAdmin} with an `initialOwner`,\n     * backed by the implementation at `_logic`, and optionally initialized with `_data` as explained in\n     * {ERC1967Proxy-constructor}.\n     */\n    constructor(address _logic, address initialOwner, bytes memory _data) payable ERC1967Proxy(_logic, _data) {\n        _admin = address(new ProxyAdmin(initialOwner));\n        // Set the storage value and emit an event for ERC-1967 compatibility\n        ERC1967Utils.changeAdmin(_proxyAdmin());\n    }\n\n    /**\n     * @dev Returns the admin of this proxy.\n     */\n    function _proxyAdmin() internal virtual returns (address) {\n        return _admin;\n    }\n\n    /**\n     * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior.\n     */\n    function _fallback() internal virtual override {\n        if (msg.sender == _proxyAdmin()) {\n            if (msg.sig != ITransparentUpgradeableProxy.upgradeToAndCall.selector) {\n                revert ProxyDeniedAdminAccess();\n            } else {\n                _dispatchUpgradeToAndCall();\n            }\n        } else {\n            super._fallback();\n        }\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy. See {ERC1967Utils-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - If `data` is empty, `msg.value` must be zero.\n     */\n    function _dispatchUpgradeToAndCall() private {\n        (address newImplementation, bytes memory data) = abi.decode(msg.data[4:], (address, bytes));\n        ERC1967Utils.upgradeToAndCall(newImplementation, data);\n    }\n}\n'}, '@openzeppelin/contracts/utils/Address.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("""");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n'}, '@openzeppelin/contracts/utils/Context.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n'}, '@openzeppelin/contracts/utils/StorageSlot.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n'}}

// File: settings
{'optimizer': {'enabled': True, 'runs': 200}, 'outputSelection': {'*': {'*': ['evm.bytecode', 'evm.deployedBytecode', 'devdoc', 'userdoc', 'metadata', 'abi']}}, 'evmVersion': 'paris'}",True
0x881d40237659c251811cec9c364ef91dc08d300c,"// File: language
Solidity

// File: sources
{'contracts/adapters/CommonAdapter.sol': {'content': 'pragma solidity ^0.6.0;\r\n\r\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\r\nimport ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";\r\nimport ""@openzeppelin/contracts/utils/Address.sol"";\r\n\r\nimport ""../Constants.sol"";\r\n\r\ncontract CommonAdapter {\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n    using Address for address payable;\r\n\r\n    /**\r\n     * @dev Performs a swap\r\n     * @param recipient The original msg.sender performing the swap\r\n     * @param aggregator Address of the aggregator\'s contract\r\n     * @param spender Address to which tokens will be approved\r\n     * @param method Selector of the function to be called in the aggregator\'s contract\r\n     * @param tokenFrom Token to be swapped\r\n     * @param tokenTo Token to be received\r\n     * @param amountFrom Amount of tokenFrom to swap\r\n     * @param amountTo Minimum amount of tokenTo to receive\r\n     * @param data Data used for the call made to the aggregator\'s contract\r\n     */\r\n    function swap(\r\n        address payable recipient,\r\n        address aggregator,\r\n        address spender,\r\n        bytes4 method,\r\n        IERC20 tokenFrom,\r\n        IERC20 tokenTo,\r\n        uint256 amountFrom,\r\n        uint256 amountTo,\r\n        bytes calldata data\r\n    ) external payable {\r\n        require(tokenFrom != tokenTo, ""TOKEN_PAIR_INVALID"");\r\n\r\n        if (address(tokenFrom) != Constants.ETH) {\r\n            _approveSpender(tokenFrom, spender, amountFrom);\r\n        }\r\n\r\n        // We always forward msg.value as it may be necessary to pay fees\r\n        bytes memory encodedData = abi.encodePacked(method, data);\r\n        aggregator.functionCallWithValue(encodedData, msg.value);\r\n\r\n        // Transfer remaining balance of tokenFrom to sender\r\n        if (address(tokenFrom) != Constants.ETH) {\r\n            uint256 balance = tokenFrom.balanceOf(address(this));\r\n            _transfer(tokenFrom, balance, recipient);\r\n        }\r\n\r\n        uint256 weiBalance = address(this).balance;\r\n\r\n        // Transfer remaining balance of tokenTo to sender\r\n        if (address(tokenTo) != Constants.ETH) {\r\n            uint256 balance = tokenTo.balanceOf(address(this));\r\n            require(balance >= amountTo, ""INSUFFICIENT_AMOUNT"");\r\n            _transfer(tokenTo, balance, recipient);\r\n        } else {\r\n            // If tokenTo == ETH, then check that the remaining ETH balance >= amountTo\r\n            require(weiBalance >= amountTo, ""INSUFFICIENT_AMOUNT"");\r\n        }\r\n\r\n        // If there are unused fees or if tokenTo is ETH, transfer to sender\r\n        if (weiBalance > 0) {\r\n            recipient.sendValue(weiBalance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers token to sender if amount > 0\r\n     * @param token IERC20 token to transfer to sender\r\n     * @param amount Amount of token to transfer\r\n     * @param recipient Address that will receive the tokens\r\n     */\r\n    function _transfer(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        address recipient\r\n    ) internal {\r\n        if (amount > 0) {\r\n            token.safeTransfer(recipient, amount);\r\n        }\r\n    }\r\n\r\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/SafeERC20.sol\r\n    /**\r\n     * @dev Approves max amount of token to the spender if the allowance is lower than amount\r\n     * @param token The ERC20 token to approve\r\n     * @param spender Address to which funds will be approved\r\n     * @param amount Amount used to compare current allowance\r\n     */\r\n    function _approveSpender(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal {\r\n        // If allowance is not enough, approve max possible amount\r\n        uint256 allowance = token.allowance(address(this), spender);\r\n        if (allowance < amount) {\r\n            bytes memory returndata = address(token).functionCall(\r\n                abi.encodeWithSelector(\r\n                    token.approve.selector,\r\n                    spender,\r\n                    type(uint256).max\r\n                )\r\n            );\r\n\r\n            if (returndata.length > 0) {\r\n                // Return data is optional\r\n                require(abi.decode(returndata, (bool)), ""APPROVAL_FAILED"");\r\n            }\r\n        }\r\n    }\r\n}\r\n'}, '@openzeppelin/contracts/token/ERC20/IERC20.sol': {'content': ""// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n""}, '@openzeppelin/contracts/token/ERC20/SafeERC20.sol': {'content': '// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport ""./IERC20.sol"";\nimport ""../../math/SafeMath.sol"";\nimport ""../../utils/Address.sol"";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            ""SafeERC20: approve from non-zero to non-zero allowance""\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, ""SafeERC20: decreased allowance below zero"");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, ""SafeERC20: low-level call failed"");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), ""SafeERC20: ERC20 operation did not succeed"");\n        }\n    }\n}\n'}, '@openzeppelin/contracts/math/SafeMath.sol': {'content': '// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity\'s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\'s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\'s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, ""SafeMath: addition overflow"");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\'s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, ""SafeMath: subtraction overflow"");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\'s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\'s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n        // benefit is lost if \'b\' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, ""SafeMath: multiplication overflow"");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\'s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, ""SafeMath: division by zero"");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\'s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\'t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\'s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, ""SafeMath: modulo by zero"");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\'s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n'}, '@openzeppelin/contracts/utils/Address.sol': {'content': '// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, ""Address: insufficient balance"");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }("""");\n        require(success, ""Address: unable to send value, recipient may have reverted"");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, ""Address: low-level call failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, ""Address: insufficient balance for call"");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), ""Address: call to non-contract"");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n'}, 'contracts/Constants.sol': {'content': '// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\nlibrary Constants {\r\n    address internal constant ETH = 0x0000000000000000000000000000000000000000;\r\n}\r\n'}, 'contracts/adapters/FeeCommonAdapter.sol': {'content': 'pragma solidity ^0.6.0;\r\n\r\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\r\nimport ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";\r\nimport ""@openzeppelin/contracts/math/SafeMath.sol"";\r\nimport ""@openzeppelin/contracts/utils/Address.sol"";\r\n\r\nimport ""../Constants.sol"";\r\n\r\ncontract FeeCommonAdapter {\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n    using Address for address payable;\r\n    using SafeMath for uint256;\r\n\r\n    // solhint-disable-next-line var-name-mixedcase\r\n    address payable public immutable FEE_WALLET;\r\n\r\n    constructor(address payable feeWallet) public {\r\n        FEE_WALLET = feeWallet;\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a swap\r\n     * @param recipient The original msg.sender performing the swap\r\n     * @param aggregator Address of the aggregator\'s contract\r\n     * @param spender Address to which tokens will be approved\r\n     * @param method Selector of the function to be called in the aggregator\'s contract\r\n     * @param tokenFrom Token to be swapped\r\n     * @param tokenTo Token to be received\r\n     * @param amountFrom Amount of tokenFrom to swap\r\n     * @param amountTo Minimum amount of tokenTo to receive\r\n     * @param data Data used for the call made to the aggregator\'s contract\r\n     * @param fee Amount of tokenFrom sent to the fee wallet\r\n     */\r\n    function swap(\r\n        address payable recipient,\r\n        address aggregator,\r\n        address spender,\r\n        bytes4 method,\r\n        IERC20 tokenFrom,\r\n        IERC20 tokenTo,\r\n        uint256 amountFrom,\r\n        uint256 amountTo,\r\n        bytes calldata data,\r\n        uint256 fee\r\n    ) external payable {\r\n        require(tokenFrom != tokenTo, ""TOKEN_PAIR_INVALID"");\r\n\r\n        if (address(tokenFrom) == Constants.ETH) {\r\n            FEE_WALLET.sendValue(fee);\r\n        } else {\r\n            _transfer(tokenFrom, fee, FEE_WALLET);\r\n            _approveSpender(tokenFrom, spender, amountFrom);\r\n        }\r\n\r\n        // We always forward msg.value as it may be necessary to pay fees\r\n        aggregator.functionCallWithValue(\r\n            abi.encodePacked(method, data),\r\n            address(this).balance\r\n        );\r\n\r\n        // Transfer remaining balance of tokenFrom to sender\r\n        if (address(tokenFrom) != Constants.ETH) {\r\n            _transfer(tokenFrom, tokenFrom.balanceOf(address(this)), recipient);\r\n        }\r\n\r\n        uint256 weiBalance = address(this).balance;\r\n\r\n        // Transfer remaining balance of tokenTo to sender\r\n        if (address(tokenTo) != Constants.ETH) {\r\n            uint256 balance = tokenTo.balanceOf(address(this));\r\n            require(balance >= amountTo, ""INSUFFICIENT_AMOUNT"");\r\n            _transfer(tokenTo, balance, recipient);\r\n        } else {\r\n            // If tokenTo == ETH, then check that the remaining ETH balance >= amountTo\r\n            require(weiBalance >= amountTo, ""INSUFFICIENT_AMOUNT"");\r\n        }\r\n\r\n        // If there are unused fees or if tokenTo is ETH, transfer to sender\r\n        if (weiBalance > 0) {\r\n            recipient.sendValue(weiBalance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers token to sender if amount > 0\r\n     * @param token IERC20 token to transfer to sender\r\n     * @param amount Amount of token to transfer\r\n     * @param recipient Address that will receive the tokens\r\n     */\r\n    function _transfer(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        address recipient\r\n    ) internal {\r\n        if (amount > 0) {\r\n            token.safeTransfer(recipient, amount);\r\n        }\r\n    }\r\n\r\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/SafeERC20.sol\r\n    /**\r\n     * @dev Approves max amount of token to the spender if the allowance is lower than amount\r\n     * @param token The ERC20 token to approve\r\n     * @param spender Address to which funds will be approved\r\n     * @param amount Amount used to compare current allowance\r\n     */\r\n    function _approveSpender(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal {\r\n        // If allowance is not enough, approve max possible amount\r\n        uint256 allowance = token.allowance(address(this), spender);\r\n        if (allowance < amount) {\r\n            bytes memory returndata = address(token).functionCall(\r\n                abi.encodeWithSelector(\r\n                    token.approve.selector,\r\n                    spender,\r\n                    type(uint256).max\r\n                )\r\n            );\r\n\r\n            if (returndata.length > 0) {\r\n                // Return data is optional\r\n                require(abi.decode(returndata, (bool)), ""APPROVAL_FAILED"");\r\n            }\r\n        }\r\n    }\r\n}\r\n'}, 'contracts/adapters/FeeWethAdapter.sol': {'content': 'pragma solidity ^0.6.0;\r\n\r\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\r\nimport ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";\r\nimport ""@openzeppelin/contracts/math/SafeMath.sol"";\r\nimport ""@openzeppelin/contracts/utils/Address.sol"";\r\n\r\nimport ""../Constants.sol"";\r\nimport ""../IWETH.sol"";\r\n\r\ncontract FeeWethAdapter {\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n    using Address for address payable;\r\n    using SafeMath for uint256;\r\n\r\n    IWETH public immutable weth;\r\n    // solhint-disable-next-line var-name-mixedcase\r\n    address payable public immutable FEE_WALLET;\r\n\r\n    constructor(IWETH _weth, address payable feeWallet) public {\r\n        weth = _weth;\r\n        FEE_WALLET = feeWallet;\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a swap\r\n     * @param recipient The original msg.sender performing the swap\r\n     * @param aggregator Address of the aggregator\'s contract\r\n     * @param spender Address to which tokens will be approved\r\n     * @param method Selector of the function to be called in the aggregator\'s contract\r\n     * @param tokenFrom Token to be swapped\r\n     * @param tokenTo Token to be received\r\n     * @param amountFrom Amount of tokenFrom to swap\r\n     * @param amountTo Minimum amount of tokenTo to receive\r\n     * @param data Data used for the call made to the aggregator\'s contract\r\n     * @param fee Amount of tokenFrom sent to the fee wallet\r\n     */\r\n    function swap(\r\n        address payable recipient,\r\n        address aggregator,\r\n        address spender,\r\n        bytes4 method,\r\n        IERC20 tokenFrom,\r\n        IERC20 tokenTo,\r\n        uint256 amountFrom,\r\n        uint256 amountTo,\r\n        bytes calldata data,\r\n        uint256 fee\r\n    ) external payable {\r\n        require(tokenFrom != tokenTo, ""TOKEN_PAIR_INVALID"");\r\n\r\n        if (address(tokenFrom) == Constants.ETH) {\r\n            FEE_WALLET.sendValue(fee);\r\n            // If tokenFrom is ETH, msg.value = fee + amountFrom (total fee could be 0)\r\n            // Can\'t deal with ETH, convert to WETH, the remaining balance will be the fee\r\n            weth.deposit{value: amountFrom}();\r\n            _approveSpender(weth, spender, amountFrom);\r\n        } else {\r\n            _transfer(tokenFrom, fee, FEE_WALLET);\r\n            // Otherwise capture tokens from sender\r\n            _approveSpender(tokenFrom, spender, amountFrom);\r\n        }\r\n\r\n        // Perform the swap\r\n        aggregator.functionCallWithValue(\r\n            abi.encodePacked(method, data),\r\n            address(this).balance\r\n        );\r\n\r\n        // Transfer remaining balance of tokenFrom to sender\r\n        if (address(tokenFrom) != Constants.ETH) {\r\n            _transfer(tokenFrom, tokenFrom.balanceOf(address(this)), recipient);\r\n        } else {\r\n            // If using ETH, just unwrap any remaining WETH\r\n            // At the end of this function all ETH will be transferred to the sender\r\n            _unwrapWETH();\r\n        }\r\n\r\n        uint256 weiBalance = address(this).balance;\r\n\r\n        // Transfer remaining balance of tokenTo to sender\r\n        if (address(tokenTo) != Constants.ETH) {\r\n            uint256 balance = tokenTo.balanceOf(address(this));\r\n            require(balance >= amountTo, ""INSUFFICIENT_AMOUNT"");\r\n            _transfer(tokenTo, balance, recipient);\r\n        } else {\r\n            // If tokenTo == ETH, unwrap received WETH and add it to the wei balance,\r\n            // then check that the remaining ETH balance >= amountTo\r\n            // It is safe to not use safeMath as no one can have enough Ether to overflow\r\n            weiBalance += _unwrapWETH();\r\n            require(weiBalance >= amountTo, ""INSUFFICIENT_AMOUNT"");\r\n        }\r\n\r\n        // If there are unused fees or if tokenTo is ETH, transfer to sender\r\n        if (weiBalance > 0) {\r\n            recipient.sendValue(weiBalance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Unwraps all available WETH into ETH\r\n     */\r\n    function _unwrapWETH() internal returns (uint256) {\r\n        uint256 balance = weth.balanceOf(address(this));\r\n        weth.withdraw(balance);\r\n        return balance;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers token to sender if amount > 0\r\n     * @param token IERC20 token to transfer to sender\r\n     * @param amount Amount of token to transfer\r\n     * @param recipient Address that will receive the tokens\r\n     */\r\n    function _transfer(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        address recipient\r\n    ) internal {\r\n        if (amount > 0) {\r\n            token.safeTransfer(recipient, amount);\r\n        }\r\n    }\r\n\r\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/SafeERC20.sol\r\n    /**\r\n     * @dev Approves max amount of token to the spender if the allowance is lower than amount\r\n     * @param token The ERC20 token to approve\r\n     * @param spender Address to which funds will be approved\r\n     * @param amount Amount used to compare current allowance\r\n     */\r\n    function _approveSpender(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal {\r\n        // If allowance is not enough, approve max possible amount\r\n        uint256 allowance = token.allowance(address(this), spender);\r\n        if (allowance < amount) {\r\n            bytes memory returndata = address(token).functionCall(\r\n                abi.encodeWithSelector(\r\n                    token.approve.selector,\r\n                    spender,\r\n                    type(uint256).max\r\n                )\r\n            );\r\n\r\n            if (returndata.length > 0) {\r\n                // Return data is optional\r\n                require(abi.decode(returndata, (bool)), ""APPROVAL_FAILED"");\r\n            }\r\n        }\r\n    }\r\n}\r\n'}, 'contracts/IWETH.sol': {'content': 'pragma solidity ^0.6.0;\r\n\r\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\r\n\r\ninterface IWETH is IERC20 {\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint256) external;\r\n}\r\n'}, 'contracts/adapters/UniswapAdapter.sol': {'content': 'pragma solidity ^0.6.0;\r\n\r\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\r\nimport ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";\r\nimport ""@openzeppelin/contracts/math/SafeMath.sol"";\r\nimport ""@openzeppelin/contracts/utils/Address.sol"";\r\nimport ""@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol"";\r\n\r\nimport ""../Constants.sol"";\r\n\r\ncontract UniswapAdapter {\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n    using Address for address payable;\r\n    using SafeMath for uint256;\r\n\r\n    // solhint-disable-next-line var-name-mixedcase\r\n    IUniswapV2Router02 public immutable UNISWAP;\r\n    // solhint-disable-next-line var-name-mixedcase\r\n    address payable public immutable FEE_WALLET;\r\n\r\n    constructor(address payable feeWallet, IUniswapV2Router02 uniswap) public {\r\n        FEE_WALLET = feeWallet;\r\n        UNISWAP = uniswap;\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a swap\r\n     * @param recipient The original msg.sender performing the swap\r\n     * @param tokenFrom Token to be swapped\r\n     * @param tokenTo Token to be received\r\n     * @param amountFrom Amount of tokenFrom to swap\r\n     * @param amountTo Minimum amount of tokenTo to receive\r\n     * @param path Used by Uniswap\r\n     * @param deadline Timestamp at which the swap becomes invalid. Used by Uniswap\r\n     * @param feeOnTransfer Use `supportingFeeOnTransfer` Uniswap methods\r\n     * @param fee Amount of tokenFrom sent to the fee wallet\r\n     */\r\n    function swap(\r\n        address payable recipient,\r\n        IERC20 tokenFrom,\r\n        IERC20 tokenTo,\r\n        uint256 amountFrom,\r\n        uint256 amountTo,\r\n        address[] calldata path,\r\n        uint256 deadline,\r\n        bool feeOnTransfer,\r\n        uint256 fee\r\n    ) external payable {\r\n        require(tokenFrom != tokenTo, ""TOKEN_PAIR_INVALID"");\r\n\r\n        if (address(tokenFrom) == Constants.ETH) {\r\n            FEE_WALLET.sendValue(fee);\r\n        } else {\r\n            _transfer(tokenFrom, fee, FEE_WALLET);\r\n        }\r\n\r\n        if (address(tokenFrom) == Constants.ETH) {\r\n            if (feeOnTransfer) {\r\n                UNISWAP.swapExactETHForTokensSupportingFeeOnTransferTokens{\r\n                    value: address(this).balance\r\n                }(amountTo, path, address(this), deadline);\r\n            } else {\r\n                UNISWAP.swapExactETHForTokens{value: address(this).balance}(\r\n                    amountTo,\r\n                    path,\r\n                    address(this),\r\n                    deadline\r\n                );\r\n            }\r\n        } else {\r\n            _approveSpender(tokenFrom, address(UNISWAP), amountFrom);\r\n            if (address(tokenTo) == Constants.ETH) {\r\n                if (feeOnTransfer) {\r\n                    UNISWAP.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n                        amountFrom,\r\n                        amountTo,\r\n                        path,\r\n                        address(this),\r\n                        deadline\r\n                    );\r\n                } else {\r\n                    UNISWAP.swapExactTokensForETH(\r\n                        amountFrom,\r\n                        amountTo,\r\n                        path,\r\n                        address(this),\r\n                        deadline\r\n                    );\r\n                }\r\n            } else {\r\n                if (feeOnTransfer) {\r\n                    UNISWAP\r\n                        .swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n                        amountFrom,\r\n                        amountTo,\r\n                        path,\r\n                        address(this),\r\n                        deadline\r\n                    );\r\n                } else {\r\n                    UNISWAP.swapExactTokensForTokens(\r\n                        amountFrom,\r\n                        amountTo,\r\n                        path,\r\n                        address(this),\r\n                        deadline\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        // Transfer remaining balance of tokenFrom to sender\r\n        if (address(tokenFrom) != Constants.ETH) {\r\n            _transfer(tokenFrom, tokenFrom.balanceOf(address(this)), recipient);\r\n        }\r\n\r\n        uint256 weiBalance = address(this).balance;\r\n\r\n        // Transfer remaining balance of tokenTo to sender\r\n        if (address(tokenTo) != Constants.ETH) {\r\n            uint256 balance = tokenTo.balanceOf(address(this));\r\n            require(balance >= amountTo, ""INSUFFICIENT_AMOUNT"");\r\n            _transfer(tokenTo, balance, recipient);\r\n        } else {\r\n            // If tokenTo == ETH, then check that the remaining ETH balance >= amountTo\r\n            require(weiBalance >= amountTo, ""INSUFFICIENT_AMOUNT"");\r\n        }\r\n\r\n        // If there are unused fees or if tokenTo is ETH, transfer to sender\r\n        if (weiBalance > 0) {\r\n            recipient.sendValue(weiBalance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers token to sender if amount > 0\r\n     * @param token IERC20 token to transfer to sender\r\n     * @param amount Amount of token to transfer\r\n     * @param recipient Address that will receive the tokens\r\n     */\r\n    function _transfer(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        address recipient\r\n    ) internal {\r\n        if (amount > 0) {\r\n            token.safeTransfer(recipient, amount);\r\n        }\r\n    }\r\n\r\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/SafeERC20.sol\r\n    /**\r\n     * @dev Approves max amount of token to the spender if the allowance is lower than amount\r\n     * @param token The ERC20 token to approve\r\n     * @param spender Address to which funds will be approved\r\n     * @param amount Amount used to compare current allowance\r\n     */\r\n    function _approveSpender(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal {\r\n        // If allowance is not enough, approve max possible amount\r\n        uint256 allowance = token.allowance(address(this), spender);\r\n        if (allowance < amount) {\r\n            bytes memory returndata = address(token).functionCall(\r\n                abi.encodeWithSelector(\r\n                    token.approve.selector,\r\n                    spender,\r\n                    type(uint256).max\r\n                )\r\n            );\r\n\r\n            if (returndata.length > 0) {\r\n                // Return data is optional\r\n                require(abi.decode(returndata, (bool)), ""APPROVAL_FAILED"");\r\n            }\r\n        }\r\n    }\r\n}\r\n'}, '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol': {'content': ""pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n""}, '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol': {'content': 'pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n'}, 'contracts/adapters/WethAdapter.sol': {'content': 'pragma solidity ^0.6.0;\r\n\r\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\r\nimport ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";\r\nimport ""@openzeppelin/contracts/utils/Address.sol"";\r\n\r\nimport ""../Constants.sol"";\r\nimport ""../IWETH.sol"";\r\n\r\ncontract WethAdapter {\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n    using Address for address payable;\r\n\r\n    IWETH public immutable weth;\r\n\r\n    constructor(IWETH _weth) public {\r\n        weth = _weth;\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a swap\r\n     * @param recipient The original msg.sender performing the swap\r\n     * @param aggregator Address of the aggregator\'s contract\r\n     * @param spender Address to which tokens will be approved\r\n     * @param method Selector of the function to be called in the aggregator\'s contract\r\n     * @param tokenFrom Token to be swapped\r\n     * @param tokenTo Token to be received\r\n     * @param amountFrom Amount of tokenFrom to swap\r\n     * @param amountTo Minimum amount of tokenTo to receive\r\n     * @param data Data used for the call made to the aggregator\'s contract\r\n     */\r\n    function swap(\r\n        address payable recipient,\r\n        address aggregator,\r\n        address spender,\r\n        bytes4 method,\r\n        IERC20 tokenFrom,\r\n        IERC20 tokenTo,\r\n        uint256 amountFrom,\r\n        uint256 amountTo,\r\n        bytes calldata data\r\n    ) external payable {\r\n        require(tokenFrom != tokenTo, ""TOKEN_PAIR_INVALID"");\r\n\r\n        if (address(tokenFrom) == Constants.ETH) {\r\n            // If tokenFrom is ETH, msg.value = fee + amountFrom (total fee could be 0)\r\n            // Can\'t deal with ETH, convert to WETH, the remaining balance will be the fee\r\n            weth.deposit{value: amountFrom}();\r\n            _approveSpender(weth, spender, amountFrom);\r\n        } else {\r\n            // Otherwise capture tokens from sender\r\n            _approveSpender(tokenFrom, spender, amountFrom);\r\n        }\r\n\r\n        // Perform the swap\r\n        aggregator.functionCallWithValue(\r\n            abi.encodePacked(method, data),\r\n            address(this).balance\r\n        );\r\n\r\n        // Transfer remaining balance of tokenFrom to sender\r\n        if (address(tokenFrom) != Constants.ETH) {\r\n            _transfer(tokenFrom, tokenFrom.balanceOf(address(this)), recipient);\r\n        } else {\r\n            // If using ETH, just unwrap any remaining WETH\r\n            // At the end of this function all ETH will be transferred to the sender\r\n            _unwrapWETH();\r\n        }\r\n\r\n        uint256 weiBalance = address(this).balance;\r\n\r\n        // Transfer remaining balance of tokenTo to sender\r\n        if (address(tokenTo) != Constants.ETH) {\r\n            uint256 balance = tokenTo.balanceOf(address(this));\r\n            require(balance >= amountTo, ""INSUFFICIENT_AMOUNT"");\r\n            _transfer(tokenTo, balance, recipient);\r\n        } else {\r\n            // If tokenTo == ETH, unwrap received WETH and add it to the wei balance,\r\n            // then check that the remaining ETH balance >= amountTo\r\n            // It is safe to not use safeMath as no one can have enough Ether to overflow\r\n            weiBalance += _unwrapWETH();\r\n            require(weiBalance >= amountTo, ""INSUFFICIENT_AMOUNT"");\r\n        }\r\n\r\n        // If there are unused fees or if tokenTo is ETH, transfer to sender\r\n        if (weiBalance > 0) {\r\n            recipient.sendValue(weiBalance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Unwraps all available WETH into ETH\r\n     */\r\n    function _unwrapWETH() internal returns (uint256) {\r\n        uint256 balance = weth.balanceOf(address(this));\r\n        weth.withdraw(balance);\r\n        return balance;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers token to sender if amount > 0\r\n     * @param token IERC20 token to transfer to sender\r\n     * @param amount Amount of token to transfer\r\n     * @param recipient Address that will receive the tokens\r\n     */\r\n    function _transfer(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        address recipient\r\n    ) internal {\r\n        if (amount > 0) {\r\n            token.safeTransfer(recipient, amount);\r\n        }\r\n    }\r\n\r\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/SafeERC20.sol\r\n    /**\r\n     * @dev Approves max amount of token to the spender if the allowance is lower than amount\r\n     * @param token The ERC20 token to approve\r\n     * @param spender Address to which funds will be approved\r\n     * @param amount Amount used to compare current allowance\r\n     */\r\n    function _approveSpender(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal {\r\n        // If allowance is not enough, approve max possible amount\r\n        uint256 allowance = token.allowance(address(this), spender);\r\n        if (allowance < amount) {\r\n            bytes memory returndata = address(token).functionCall(\r\n                abi.encodeWithSelector(\r\n                    token.approve.selector,\r\n                    spender,\r\n                    type(uint256).max\r\n                )\r\n            );\r\n\r\n            if (returndata.length > 0) {\r\n                // Return data is optional\r\n                require(abi.decode(returndata, (bool)), ""APPROVAL_FAILED"");\r\n            }\r\n        }\r\n    }\r\n}\r\n'}, 'contracts/ICHI.sol': {'content': '// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\r\n\r\ninterface ICHI is IERC20 {\r\n    function freeUpTo(uint256 value) external returns (uint256);\r\n\r\n    function freeFromUpTo(\r\n        address from,\r\n        uint256 value\r\n    ) external returns (uint256);\r\n\r\n    function mint(uint256 value) external;\r\n}\r\n'}, 'contracts/Imports.sol': {'content': '  \r\n// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.6.0;\r\n\r\n// We import the contract so truffle compiles it, and we have the ABI\r\n// available when working from truffle console.\r\nimport ""@openzeppelin/contracts/token/ERC20/ERC20.sol""; //helpers'}, '@openzeppelin/contracts/token/ERC20/ERC20.sol': {'content': '// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport ""../../GSN/Context.sol"";\nimport ""./IERC20.sol"";\nimport ""../../math/SafeMath.sol"";\nimport ""../../utils/Address.sol"";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn\'t required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``\'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, ""ERC20: transfer amount exceeds allowance""));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, ""ERC20: decreased allowance below zero""));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), ""ERC20: transfer from the zero address"");\n        require(recipient != address(0), ""ERC20: transfer to the zero address"");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, ""ERC20: transfer amount exceeds balance"");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), ""ERC20: mint to the zero address"");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), ""ERC20: burn from the zero address"");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, ""ERC20: burn amount exceeds balance"");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), ""ERC20: approve from the zero address"");\n        require(spender != address(0), ""ERC20: approve to the zero address"");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n'}, '@openzeppelin/contracts/GSN/Context.sol': {'content': '// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n'}, 'contracts/MetaSwap.sol': {'content': '// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\nimport ""@openzeppelin/contracts/access/Ownable.sol"";\r\nimport ""@openzeppelin/contracts/utils/Pausable.sol"";\r\nimport ""@openzeppelin/contracts/utils/Address.sol"";\r\nimport ""@openzeppelin/contracts/utils/ReentrancyGuard.sol"";\r\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\r\nimport ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";\r\n\r\nimport ""./ICHI.sol"";\r\nimport ""./Spender.sol"";\r\n\r\n/**\r\n * @title MetaSwap\r\n */\r\ncontract MetaSwap is Ownable, Pausable, ReentrancyGuard {\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n    using Address for address payable;\r\n\r\n    struct Adapter {\r\n        address addr; // adapter\'s address\r\n        bytes4 selector;\r\n        bytes data; // adapter\'s fixed data\r\n    }\r\n\r\n    ICHI public immutable chi;\r\n    Spender public immutable spender;\r\n\r\n    // Mapping of aggregatorId to aggregator\r\n    mapping(string => Adapter) public adapters;\r\n    mapping(string => bool) public adapterRemoved;\r\n\r\n    event AdapterSet(\r\n        string indexed aggregatorId,\r\n        address indexed addr,\r\n        bytes4 selector,\r\n        bytes data\r\n    );\r\n    event AdapterRemoved(string indexed aggregatorId);\r\n    event Swap(string indexed aggregatorId, address indexed sender);\r\n\r\n    constructor(ICHI _chi) public {\r\n        chi = _chi;\r\n        spender = new Spender();\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the adapter for an aggregator. It can\'t be changed later.\r\n     * @param aggregatorId Aggregator\'s identifier\r\n     * @param addr Address of the contract that contains the logic for this aggregator\r\n     * @param selector The function selector of the swap function in the adapter\r\n     * @param data Fixed abi encoded data the will be passed in each delegatecall made to the adapter\r\n     */\r\n    function setAdapter(\r\n        string calldata aggregatorId,\r\n        address addr,\r\n        bytes4 selector,\r\n        bytes calldata data\r\n    ) external onlyOwner {\r\n        require(addr.isContract(), ""ADAPTER_IS_NOT_A_CONTRACT"");\r\n        require(!adapterRemoved[aggregatorId], ""ADAPTER_REMOVED"");\r\n\r\n        Adapter storage adapter = adapters[aggregatorId];\r\n        require(adapter.addr == address(0), ""ADAPTER_EXISTS"");\r\n\r\n        adapter.addr = addr;\r\n        adapter.selector = selector;\r\n        adapter.data = data;\r\n        emit AdapterSet(aggregatorId, addr, selector, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes the adapter for an existing aggregator. This can\'t be undone.\r\n     * @param aggregatorId Aggregator\'s identifier\r\n     */\r\n    function removeAdapter(string calldata aggregatorId) external onlyOwner {\r\n        require(\r\n            adapters[aggregatorId].addr != address(0),\r\n            ""ADAPTER_DOES_NOT_EXIST""\r\n        );\r\n        delete adapters[aggregatorId];\r\n        adapterRemoved[aggregatorId] = true;\r\n        emit AdapterRemoved(aggregatorId);\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a swap\r\n     * @param aggregatorId Identifier of the aggregator to be used for the swap\r\n     * @param data Dynamic data which is concatenated with the fixed aggregator\'s\r\n     * data in the delecatecall made to the adapter\r\n     */\r\n    function swap(\r\n        string calldata aggregatorId,\r\n        IERC20 tokenFrom,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external payable whenNotPaused nonReentrant {\r\n        _swap(aggregatorId, tokenFrom, amount, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a swap\r\n     * @param aggregatorId Identifier of the aggregator to be used for the swap\r\n     * @param data Dynamic data which is concatenated with the fixed aggregator\'s\r\n     * data in the delecatecall made to the adapter\r\n     */\r\n    function swapUsingGasToken(\r\n        string calldata aggregatorId,\r\n        IERC20 tokenFrom,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external payable whenNotPaused nonReentrant {\r\n        uint256 gas = gasleft();\r\n\r\n        _swap(aggregatorId, tokenFrom, amount, data);\r\n\r\n        uint256 gasSpent = 21000 + gas - gasleft() + 16 * msg.data.length;\r\n        chi.freeFromUpTo(msg.sender, (gasSpent + 14154) / 41947);\r\n    }\r\n\r\n    function pauseSwaps() external onlyOwner {\r\n        _pause();\r\n    }\r\n\r\n    function unpauseSwaps() external onlyOwner {\r\n        _unpause();\r\n    }\r\n\r\n    function _swap(\r\n        string calldata aggregatorId,\r\n        IERC20 tokenFrom,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) internal {\r\n        Adapter storage adapter = adapters[aggregatorId];\r\n\r\n        if (address(tokenFrom) != Constants.ETH) {\r\n            tokenFrom.safeTransferFrom(msg.sender, address(spender), amount);\r\n        }\r\n\r\n        spender.swap{value: msg.value}(\r\n            adapter.addr,\r\n            abi.encodePacked(\r\n                adapter.selector,\r\n                abi.encode(msg.sender),\r\n                adapter.data,\r\n                data\r\n            )\r\n        );\r\n\r\n        emit Swap(aggregatorId, msg.sender);\r\n    }\r\n}\r\n'}, '@openzeppelin/contracts/access/Ownable.sol': {'content': '// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport ""../GSN/Context.sol"";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), ""Ownable: caller is not the owner"");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), ""Ownable: new owner is the zero address"");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n'}, '@openzeppelin/contracts/utils/Pausable.sol': {'content': '// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport ""../GSN/Context.sol"";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\ncontract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () internal {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, ""Pausable: paused"");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(_paused, ""Pausable: not paused"");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n'}, '@openzeppelin/contracts/utils/ReentrancyGuard.sol': {'content': '// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\ncontract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n'}, 'contracts/Spender.sol': {'content': '// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\nimport ""./Constants.sol"";\r\n\r\ncontract Spender {\r\n    address public immutable metaswap;\r\n\r\n    constructor() public {\r\n        metaswap = msg.sender;\r\n    }\r\n\r\n    /// @dev Receives ether from swaps\r\n    fallback() external payable {}\r\n\r\n    function swap(address adapter, bytes calldata data) external payable {\r\n        require(msg.sender == metaswap, ""FORBIDDEN"");\r\n        require(adapter != address(0), ""ADAPTER_NOT_PROVIDED"");\r\n        _delegate(adapter, data, ""ADAPTER_DELEGATECALL_FAILED"");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a delegatecall and bubbles up the errors, adapted from\r\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\r\n     * @param target Address of the contract to delegatecall\r\n     * @param data Data passed in the delegatecall\r\n     * @param errorMessage Fallback revert reason\r\n     */\r\n    function _delegate(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) private returns (bytes memory) {\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n'}, 'contracts/mocks/MockAdapter.sol': {'content': 'pragma solidity ^0.6.0;\r\n\r\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\r\nimport ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";\r\nimport ""@openzeppelin/contracts/utils/Address.sol"";\r\n\r\ncontract MockAdapter {\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n    using Address for address payable;\r\n\r\n    event MockAdapterEvent(\r\n        address sender,\r\n        uint256 valueFixed,\r\n        uint256 valueDynamic\r\n    );\r\n\r\n    function test(\r\n        address sender,\r\n        uint256 valueFixed,\r\n        uint256 valueDynamic\r\n    ) external payable {\r\n        emit MockAdapterEvent(sender, valueFixed, valueDynamic);\r\n    }\r\n\r\n    function testRevert(\r\n        address,\r\n        uint256,\r\n        uint256\r\n    ) external payable {\r\n        revert(""SWAP_FAILED"");\r\n    }\r\n\r\n    function testRevertNoReturnData(\r\n        address,\r\n        uint256,\r\n        uint256\r\n    ) external payable {\r\n        revert();\r\n    }\r\n}\r\n'}, 'contracts/mocks/MockContract.sol': {'content': 'pragma solidity ^0.6.0;\r\n\r\n// TAKEN FROM https://github.com/gnosis/mock-contract\r\n// TODO: use their npm package once it is published for solidity 0.6\r\n\r\ninterface MockInterface {\r\n    /**\r\n     * @dev After calling this method, the mock will return `response` when it is called\r\n     * with any calldata that is not mocked more specifically below\r\n     * (e.g. using givenMethodReturn).\r\n     * @param response ABI encoded response that will be returned if method is invoked\r\n     */\r\n    function givenAnyReturn(bytes calldata response) external;\r\n\r\n    function givenAnyReturnBool(bool response) external;\r\n\r\n    function givenAnyReturnUint(uint256 response) external;\r\n\r\n    function givenAnyReturnAddress(address response) external;\r\n\r\n    function givenAnyRevert() external;\r\n\r\n    function givenAnyRevertWithMessage(string calldata message) external;\r\n\r\n    function givenAnyRunOutOfGas() external;\r\n\r\n    /**\r\n     * @dev After calling this method, the mock will return `response` when the given\r\n     * methodId is called regardless of arguments. If the methodId and arguments\r\n     * are mocked more specifically (using `givenMethodAndArguments`) the latter\r\n     * will take precedence.\r\n     * @param method ABI encoded methodId. It is valid to pass full calldata (including arguments). The mock will extract the methodId from it\r\n     * @param response ABI encoded response that will be returned if method is invoked\r\n     */\r\n    function givenMethodReturn(bytes calldata method, bytes calldata response)\r\n        external;\r\n\r\n    function givenMethodReturnBool(bytes calldata method, bool response)\r\n        external;\r\n\r\n    function givenMethodReturnUint(bytes calldata method, uint256 response)\r\n        external;\r\n\r\n    function givenMethodReturnAddress(bytes calldata method, address response)\r\n        external;\r\n\r\n    function givenMethodRevert(bytes calldata method) external;\r\n\r\n    function givenMethodRevertWithMessage(\r\n        bytes calldata method,\r\n        string calldata message\r\n    ) external;\r\n\r\n    function givenMethodRunOutOfGas(bytes calldata method) external;\r\n\r\n    /**\r\n     * @dev After calling this method, the mock will return `response` when the given\r\n     * methodId is called with matching arguments. These exact calldataMocks will take\r\n     * precedence over all other calldataMocks.\r\n     * @param call ABI encoded calldata (methodId and arguments)\r\n     * @param response ABI encoded response that will be returned if contract is invoked with calldata\r\n     */\r\n    function givenCalldataReturn(bytes calldata call, bytes calldata response)\r\n        external;\r\n\r\n    function givenCalldataReturnBool(bytes calldata call, bool response)\r\n        external;\r\n\r\n    function givenCalldataReturnUint(bytes calldata call, uint256 response)\r\n        external;\r\n\r\n    function givenCalldataReturnAddress(bytes calldata call, address response)\r\n        external;\r\n\r\n    function givenCalldataRevert(bytes calldata call) external;\r\n\r\n    function givenCalldataRevertWithMessage(\r\n        bytes calldata call,\r\n        string calldata message\r\n    ) external;\r\n\r\n    function givenCalldataRunOutOfGas(bytes calldata call) external;\r\n\r\n    /**\r\n     * @dev Returns the number of times anything has been called on this mock since last reset\r\n     */\r\n    function invocationCount() external returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the number of times the given method has been called on this mock since last reset\r\n     * @param method ABI encoded methodId. It is valid to pass full calldata (including arguments). The mock will extract the methodId from it\r\n     */\r\n    function invocationCountForMethod(bytes calldata method)\r\n        external\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the number of times this mock has been called with the exact calldata since last reset.\r\n     * @param call ABI encoded calldata (methodId and arguments)\r\n     */\r\n    function invocationCountForCalldata(bytes calldata call)\r\n        external\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Resets all mocked methods and invocation counts.\r\n     */\r\n    function reset() external;\r\n}\r\n\r\n/**\r\n * Implementation of the MockInterface.\r\n */\r\ncontract MockContract is MockInterface {\r\n    enum MockType {Return, Revert, OutOfGas}\r\n\r\n    bytes32 public constant MOCKS_LIST_START = hex""01"";\r\n    bytes public constant MOCKS_LIST_END = ""0xff"";\r\n    bytes32 public constant MOCKS_LIST_END_HASH = keccak256(MOCKS_LIST_END);\r\n    bytes4 public constant SENTINEL_ANY_MOCKS = hex""01"";\r\n    bytes public constant DEFAULT_FALLBACK_VALUE = abi.encode(false);\r\n\r\n    // A linked list allows easy iteration and inclusion checks\r\n    mapping(bytes32 => bytes) calldataMocks;\r\n    mapping(bytes => MockType) calldataMockTypes;\r\n    mapping(bytes => bytes) calldataExpectations;\r\n    mapping(bytes => string) calldataRevertMessage;\r\n    mapping(bytes32 => uint256) calldataInvocations;\r\n\r\n    mapping(bytes4 => bytes4) methodIdMocks;\r\n    mapping(bytes4 => MockType) methodIdMockTypes;\r\n    mapping(bytes4 => bytes) methodIdExpectations;\r\n    mapping(bytes4 => string) methodIdRevertMessages;\r\n    mapping(bytes32 => uint256) methodIdInvocations;\r\n\r\n    MockType fallbackMockType;\r\n    bytes fallbackExpectation = DEFAULT_FALLBACK_VALUE;\r\n    string fallbackRevertMessage;\r\n    uint256 invocations;\r\n    uint256 resetCount;\r\n\r\n    constructor() public {\r\n        calldataMocks[MOCKS_LIST_START] = MOCKS_LIST_END;\r\n        methodIdMocks[SENTINEL_ANY_MOCKS] = SENTINEL_ANY_MOCKS;\r\n    }\r\n\r\n    function trackCalldataMock(bytes memory call) private {\r\n        bytes32 callHash = keccak256(call);\r\n        if (calldataMocks[callHash].length == 0) {\r\n            calldataMocks[callHash] = calldataMocks[MOCKS_LIST_START];\r\n            calldataMocks[MOCKS_LIST_START] = call;\r\n        }\r\n    }\r\n\r\n    function trackMethodIdMock(bytes4 methodId) private {\r\n        if (methodIdMocks[methodId] == 0x0) {\r\n            methodIdMocks[methodId] = methodIdMocks[SENTINEL_ANY_MOCKS];\r\n            methodIdMocks[SENTINEL_ANY_MOCKS] = methodId;\r\n        }\r\n    }\r\n\r\n    function _givenAnyReturn(bytes memory response) internal {\r\n        fallbackMockType = MockType.Return;\r\n        fallbackExpectation = response;\r\n    }\r\n\r\n    function givenAnyReturn(bytes calldata response) external override {\r\n        _givenAnyReturn(response);\r\n    }\r\n\r\n    function givenAnyReturnBool(bool response) external override {\r\n        uint256 flag = response ? 1 : 0;\r\n        _givenAnyReturn(uintToBytes(flag));\r\n    }\r\n\r\n    function givenAnyReturnUint(uint256 response) external override {\r\n        _givenAnyReturn(uintToBytes(response));\r\n    }\r\n\r\n    function givenAnyReturnAddress(address response) external override {\r\n        _givenAnyReturn(uintToBytes(uint256(response)));\r\n    }\r\n\r\n    function givenAnyRevert() external override {\r\n        fallbackMockType = MockType.Revert;\r\n        fallbackRevertMessage = """";\r\n    }\r\n\r\n    function givenAnyRevertWithMessage(string calldata message)\r\n        external\r\n        override\r\n    {\r\n        fallbackMockType = MockType.Revert;\r\n        fallbackRevertMessage = message;\r\n    }\r\n\r\n    function givenAnyRunOutOfGas() external override {\r\n        fallbackMockType = MockType.OutOfGas;\r\n    }\r\n\r\n    function _givenCalldataReturn(bytes memory call, bytes memory response)\r\n        private\r\n    {\r\n        calldataMockTypes[call] = MockType.Return;\r\n        calldataExpectations[call] = response;\r\n        trackCalldataMock(call);\r\n    }\r\n\r\n    function givenCalldataReturn(bytes calldata call, bytes calldata response)\r\n        external\r\n        override\r\n    {\r\n        _givenCalldataReturn(call, response);\r\n    }\r\n\r\n    function givenCalldataReturnBool(bytes calldata call, bool response)\r\n        external\r\n        override\r\n    {\r\n        uint256 flag = response ? 1 : 0;\r\n        _givenCalldataReturn(call, uintToBytes(flag));\r\n    }\r\n\r\n    function givenCalldataReturnUint(bytes calldata call, uint256 response)\r\n        external\r\n        override\r\n    {\r\n        _givenCalldataReturn(call, uintToBytes(response));\r\n    }\r\n\r\n    function givenCalldataReturnAddress(bytes calldata call, address response)\r\n        external\r\n        override\r\n    {\r\n        _givenCalldataReturn(call, uintToBytes(uint256(response)));\r\n    }\r\n\r\n    function _givenMethodReturn(bytes memory call, bytes memory response)\r\n        private\r\n    {\r\n        bytes4 method = bytesToBytes4(call);\r\n        methodIdMockTypes[method] = MockType.Return;\r\n        methodIdExpectations[method] = response;\r\n        trackMethodIdMock(method);\r\n    }\r\n\r\n    function givenMethodReturn(bytes calldata call, bytes calldata response)\r\n        external\r\n        override\r\n    {\r\n        _givenMethodReturn(call, response);\r\n    }\r\n\r\n    function givenMethodReturnBool(bytes calldata call, bool response)\r\n        external\r\n        override\r\n    {\r\n        uint256 flag = response ? 1 : 0;\r\n        _givenMethodReturn(call, uintToBytes(flag));\r\n    }\r\n\r\n    function givenMethodReturnUint(bytes calldata call, uint256 response)\r\n        external\r\n        override\r\n    {\r\n        _givenMethodReturn(call, uintToBytes(response));\r\n    }\r\n\r\n    function givenMethodReturnAddress(bytes calldata call, address response)\r\n        external\r\n        override\r\n    {\r\n        _givenMethodReturn(call, uintToBytes(uint256(response)));\r\n    }\r\n\r\n    function givenCalldataRevert(bytes calldata call) external override {\r\n        calldataMockTypes[call] = MockType.Revert;\r\n        calldataRevertMessage[call] = """";\r\n        trackCalldataMock(call);\r\n    }\r\n\r\n    function givenMethodRevert(bytes calldata call) external override {\r\n        bytes4 method = bytesToBytes4(call);\r\n        methodIdMockTypes[method] = MockType.Revert;\r\n        trackMethodIdMock(method);\r\n    }\r\n\r\n    function givenCalldataRevertWithMessage(\r\n        bytes calldata call,\r\n        string calldata message\r\n    ) external override {\r\n        calldataMockTypes[call] = MockType.Revert;\r\n        calldataRevertMessage[call] = message;\r\n        trackCalldataMock(call);\r\n    }\r\n\r\n    function givenMethodRevertWithMessage(\r\n        bytes calldata call,\r\n        string calldata message\r\n    ) external override {\r\n        bytes4 method = bytesToBytes4(call);\r\n        methodIdMockTypes[method] = MockType.Revert;\r\n        methodIdRevertMessages[method] = message;\r\n        trackMethodIdMock(method);\r\n    }\r\n\r\n    function givenCalldataRunOutOfGas(bytes calldata call) external override {\r\n        calldataMockTypes[call] = MockType.OutOfGas;\r\n        trackCalldataMock(call);\r\n    }\r\n\r\n    function givenMethodRunOutOfGas(bytes calldata call) external override {\r\n        bytes4 method = bytesToBytes4(call);\r\n        methodIdMockTypes[method] = MockType.OutOfGas;\r\n        trackMethodIdMock(method);\r\n    }\r\n\r\n    function invocationCount() external override returns (uint256) {\r\n        return invocations;\r\n    }\r\n\r\n    function invocationCountForMethod(bytes calldata call)\r\n        external\r\n        override\r\n        returns (uint256)\r\n    {\r\n        bytes4 method = bytesToBytes4(call);\r\n        return\r\n            methodIdInvocations[keccak256(\r\n                abi.encodePacked(resetCount, method)\r\n            )];\r\n    }\r\n\r\n    function invocationCountForCalldata(bytes calldata call)\r\n        external\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return\r\n            calldataInvocations[keccak256(abi.encodePacked(resetCount, call))];\r\n    }\r\n\r\n    function reset() external override {\r\n        // Reset all exact calldataMocks\r\n        bytes memory nextMock = calldataMocks[MOCKS_LIST_START];\r\n        bytes32 mockHash = keccak256(nextMock);\r\n        // We cannot compary bytes\r\n        while (mockHash != MOCKS_LIST_END_HASH) {\r\n            // Reset all mock maps\r\n            calldataMockTypes[nextMock] = MockType.Return;\r\n            calldataExpectations[nextMock] = hex"""";\r\n            calldataRevertMessage[nextMock] = """";\r\n            // Set next mock to remove\r\n            nextMock = calldataMocks[mockHash];\r\n            // Remove from linked list\r\n            calldataMocks[mockHash] = """";\r\n            // Update mock hash\r\n            mockHash = keccak256(nextMock);\r\n        }\r\n        // Clear list\r\n        calldataMocks[MOCKS_LIST_START] = MOCKS_LIST_END;\r\n\r\n        // Reset all any calldataMocks\r\n        bytes4 nextAnyMock = methodIdMocks[SENTINEL_ANY_MOCKS];\r\n        while (nextAnyMock != SENTINEL_ANY_MOCKS) {\r\n            bytes4 currentAnyMock = nextAnyMock;\r\n            methodIdMockTypes[currentAnyMock] = MockType.Return;\r\n            methodIdExpectations[currentAnyMock] = hex"""";\r\n            methodIdRevertMessages[currentAnyMock] = """";\r\n            nextAnyMock = methodIdMocks[currentAnyMock];\r\n            // Remove from linked list\r\n            methodIdMocks[currentAnyMock] = 0x0;\r\n        }\r\n        // Clear list\r\n        methodIdMocks[SENTINEL_ANY_MOCKS] = SENTINEL_ANY_MOCKS;\r\n\r\n        fallbackExpectation = DEFAULT_FALLBACK_VALUE;\r\n        fallbackMockType = MockType.Return;\r\n        invocations = 0;\r\n        resetCount += 1;\r\n    }\r\n\r\n    function useAllGas() private {\r\n        while (true) {\r\n            bool s;\r\n            assembly {\r\n                //expensive call to EC multiply contract\r\n                s := call(sub(gas(), 2000), 6, 0, 0x0, 0xc0, 0x0, 0x60)\r\n            }\r\n        }\r\n    }\r\n\r\n    function bytesToBytes4(bytes memory b) private pure returns (bytes4) {\r\n        bytes4 out;\r\n        for (uint256 i = 0; i < 4; i++) {\r\n            out |= bytes4(b[i] & 0xFF) >> (i * 8);\r\n        }\r\n        return out;\r\n    }\r\n\r\n    function uintToBytes(uint256 x) private pure returns (bytes memory b) {\r\n        b = new bytes(32);\r\n        assembly {\r\n            mstore(add(b, 32), x)\r\n        }\r\n    }\r\n\r\n    function updateInvocationCount(\r\n        bytes4 methodId,\r\n        bytes memory originalMsgData\r\n    ) public {\r\n        require(\r\n            msg.sender == address(this),\r\n            ""Can only be called from the contract itself""\r\n        );\r\n        invocations += 1;\r\n        methodIdInvocations[keccak256(\r\n            abi.encodePacked(resetCount, methodId)\r\n        )] += 1;\r\n        calldataInvocations[keccak256(\r\n            abi.encodePacked(resetCount, originalMsgData)\r\n        )] += 1;\r\n    }\r\n\r\n    fallback() external payable {\r\n        bytes4 methodId;\r\n        assembly {\r\n            methodId := calldataload(0)\r\n        }\r\n\r\n        // First, check exact matching overrides\r\n        if (calldataMockTypes[msg.data] == MockType.Revert) {\r\n            revert(calldataRevertMessage[msg.data]);\r\n        }\r\n        if (calldataMockTypes[msg.data] == MockType.OutOfGas) {\r\n            useAllGas();\r\n        }\r\n        bytes memory result = calldataExpectations[msg.data];\r\n\r\n        // Then check method Id overrides\r\n        if (result.length == 0) {\r\n            if (methodIdMockTypes[methodId] == MockType.Revert) {\r\n                revert(methodIdRevertMessages[methodId]);\r\n            }\r\n            if (methodIdMockTypes[methodId] == MockType.OutOfGas) {\r\n                useAllGas();\r\n            }\r\n            result = methodIdExpectations[methodId];\r\n        }\r\n\r\n        // Last, use the fallback override\r\n        if (result.length == 0) {\r\n            if (fallbackMockType == MockType.Revert) {\r\n                revert(fallbackRevertMessage);\r\n            }\r\n            if (fallbackMockType == MockType.OutOfGas) {\r\n                useAllGas();\r\n            }\r\n            result = fallbackExpectation;\r\n        }\r\n\r\n        // Record invocation as separate call so we don\'t rollback in case we are called with STATICCALL\r\n        (, bytes memory r) = address(this).call{gas: 100000}(\r\n            abi.encodeWithSignature(\r\n                ""updateInvocationCount(bytes4,bytes)"",\r\n                methodId,\r\n                msg.data\r\n            )\r\n        );\r\n        assert(r.length == 0);\r\n\r\n        assembly {\r\n            return(add(0x20, result), mload(result))\r\n        }\r\n    }\r\n}\r\n'}, 'contracts/mocks/MockSelfDestruct.sol': {'content': 'pragma solidity ^0.6.0;\r\n\r\ncontract MockSelfDestruct {\r\n    constructor() public payable {}\r\n\r\n    fallback() external payable {\r\n        selfdestruct(msg.sender);\r\n    }\r\n\r\n    function kill(address payable target) external payable {\r\n        selfdestruct(target);\r\n    }\r\n}\r\n'}}

// File: settings
{'metadata': {'useLiteralContent': False}, 'optimizer': {'enabled': True, 'runs': 1000000}, 'outputSelection': {'*': {'*': ['evm.bytecode', 'evm.deployedBytecode', 'devdoc', 'userdoc', 'metadata', 'abi']}}, 'libraries': {}}",True
0x88ee7a3537667958d040216d9dc1752d1274d838,"pragma solidity ^0.4.17;

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of ""user permissions"".
 */
contract Ownable {
    address public owner;

    /**
      * @dev The Ownable constructor sets the original `owner` of the contract to the sender
      * account.
      */
    function Ownable() public {
        owner = msg.sender;
    }

    /**
      * @dev Throws if called by any account other than the owner.
      */
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    /**
    * @dev Allows the current owner to transfer control of the contract to a newOwner.
    * @param newOwner The address to transfer ownership to.
    */
    function transferOwnership(address newOwner) public onlyOwner {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

}

/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20Basic {
    uint public _totalSupply;
    function totalSupply() public constant returns (uint);
    function balanceOf(address who) public constant returns (uint);
    function transfer(address to, uint value) public;
    event Transfer(address indexed from, address indexed to, uint value);
}

/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 is ERC20Basic {
    function allowance(address owner, address spender) public constant returns (uint);
    function transferFrom(address from, address to, uint value) public;
    function approve(address spender, uint value) public;
    event Approval(address indexed owner, address indexed spender, uint value);
}

/**
 * @title Basic token
 * @dev Basic version of StandardToken, with no allowances.
 */
contract BasicToken is Ownable, ERC20Basic {
    using SafeMath for uint;

    mapping(address => uint) public balances;

    // additional variables for use if transaction fees ever became necessary
    uint public basisPointsRate = 0;
    uint public maximumFee = 0;

    /**
    * @dev Fix for the ERC20 short address attack.
    */
    modifier onlyPayloadSize(uint size) {
        require(!(msg.data.length < size + 4));
        _;
    }

    /**
    * @dev transfer token for a specified address
    * @param _to The address to transfer to.
    * @param _value The amount to be transferred.
    */
    function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) {
        uint fee = (_value.mul(basisPointsRate)).div(10000);
        if (fee > maximumFee) {
            fee = maximumFee;
        }
        uint sendAmount = _value.sub(fee);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(sendAmount);
        if (fee > 0) {
            balances[owner] = balances[owner].add(fee);
            Transfer(msg.sender, owner, fee);
        }
        Transfer(msg.sender, _to, sendAmount);
    }

    /**
    * @dev Gets the balance of the specified address.
    * @param _owner The address to query the the balance of.
    * @return An uint representing the amount owned by the passed address.
    */
    function balanceOf(address _owner) public constant returns (uint balance) {
        return balances[_owner];
    }

}

/**
 * @title Standard ERC20 token
 *
 * @dev Implementation of the basic standard token.
 * @dev https://github.com/ethereum/EIPs/issues/20
 * @dev Based oncode by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
 */
contract StandardToken is BasicToken, ERC20 {

    mapping (address => mapping (address => uint)) public allowed;

    uint public constant MAX_UINT = 2**256 - 1;

    /**
    * @dev Transfer tokens from one address to another
    * @param _from address The address which you want to send tokens from
    * @param _to address The address which you want to transfer to
    * @param _value uint the amount of tokens to be transferred
    */
    function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3 * 32) {
        var _allowance = allowed[_from][msg.sender];

        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
        // if (_value > _allowance) throw;

        uint fee = (_value.mul(basisPointsRate)).div(10000);
        if (fee > maximumFee) {
            fee = maximumFee;
        }
        if (_allowance < MAX_UINT) {
            allowed[_from][msg.sender] = _allowance.sub(_value);
        }
        uint sendAmount = _value.sub(fee);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(sendAmount);
        if (fee > 0) {
            balances[owner] = balances[owner].add(fee);
            Transfer(_from, owner, fee);
        }
        Transfer(_from, _to, sendAmount);
    }

    /**
    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
    * @param _spender The address which will spend the funds.
    * @param _value The amount of tokens to be spent.
    */
    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {

        // To change the approve amount you first have to reduce the addresses`
        //  allowance to zero by calling `approve(_spender, 0)` if it is not
        //  already 0 to mitigate the race condition described here:
        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
        require(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));

        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
    }

    /**
    * @dev Function to check the amount of tokens than an owner allowed to a spender.
    * @param _owner address The address which owns the funds.
    * @param _spender address The address which will spend the funds.
    * @return A uint specifying the amount of tokens still available for the spender.
    */
    function allowance(address _owner, address _spender) public constant returns (uint remaining) {
        return allowed[_owner][_spender];
    }

}


/**
 * @title Pausable
 * @dev Base contract which allows children to implement an emergency stop mechanism.
 */
contract Pausable is Ownable {
    event Pause();
    event Unpause();

    bool public paused = false;


    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
   */
    modifier whenNotPaused() {
        require(!paused);
        _;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is paused.
   */
    modifier whenPaused() {
        require(paused);
        _;
    }

    /**
     * @dev called by the owner to pause, triggers stopped state
   */
    function pause() onlyOwner whenNotPaused public {
        paused = true;
        Pause();
    }

    /**
     * @dev called by the owner to unpause, returns to normal state
   */
    function unpause() onlyOwner whenPaused public {
        paused = false;
        Unpause();
    }
}

contract BlackList is Ownable, BasicToken {

    /////// Getters to allow the same blacklist to be used also by other contracts (including upgraded Tether) ///////
    function getBlackListStatus(address _maker) external constant returns (bool) {
        return isBlackListed[_maker];
    }

    function getOwner() external constant returns (address) {
        return owner;
    }

    mapping (address => bool) public isBlackListed;

    function addBlackList (address _evilUser) public onlyOwner {
        isBlackListed[_evilUser] = true;
        AddedBlackList(_evilUser);
    }

    function removeBlackList (address _clearedUser) public onlyOwner {
        isBlackListed[_clearedUser] = false;
        RemovedBlackList(_clearedUser);
    }

    function destroyBlackFunds (address _blackListedUser) public onlyOwner {
        require(isBlackListed[_blackListedUser]);
        uint dirtyFunds = balanceOf(_blackListedUser);
        balances[_blackListedUser] = 0;
        _totalSupply -= dirtyFunds;
        DestroyedBlackFunds(_blackListedUser, dirtyFunds);
    }

    event DestroyedBlackFunds(address _blackListedUser, uint _balance);

    event AddedBlackList(address _user);

    event RemovedBlackList(address _user);

}

contract UpgradedStandardToken is StandardToken{
    // those methods are called by the legacy contract
    // and they must ensure msg.sender to be the contract address
    function transferByLegacy(address from, address to, uint value) public;
    function transferFromByLegacy(address sender, address from, address spender, uint value) public;
    function approveByLegacy(address from, address spender, uint value) public;
}

contract MMCoin is Pausable, StandardToken, BlackList {
    uint256 public MAX_SUPPLY;  // Change MAX_SUPPLY to a status variable
    string public name;
    string public symbol;
    uint public decimals;
    address public upgradedAddress;
    bool public deprecated;

    //  The contract can be initialized with a number of tokens
    //  All the tokens are deposited to the owner address
    //
    // @param _balance Initial supply of the contract
    // @param _name Token Name
    // @param _symbol Token symbol
    // @param _decimals Token decimals
    function MMCoin(uint _initialSupply, string _name, string _symbol, uint _decimals) public {
        _totalSupply = _initialSupply;
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        MAX_SUPPLY = 11222017204.753513 * 10**6;
        balances[owner] = _initialSupply;
        deprecated = false;
    }

    struct LockInfo {
        uint256 initialLockAmount;
        uint256 lockAmount;        // Current remaining lock quantity
        uint256 releaseStart;      // Start release timestamp
        uint256 releaseInterval;   // Release interval (in seconds)
        uint256 releasedTokens;    // The number of tokens released
        uint256 releasePeriods;    // Number of release periods
    }

    mapping(address => LockInfo) public lockInfos;

    // Add a function to lock information
    function addLock(address user, uint256 initialLockAmount, uint256 lockAmount, uint256 releaseStart, uint256 releaseInterval, uint256 releasePeriods) public onlyOwner {
        require(user != address(0));
        require(initialLockAmount > 0 && lockAmount > 0);
        require(initialLockAmount == lockAmount);
        require(releaseStart > 0 && releaseInterval > 0 && releasePeriods > 0);

        LockInfo storage info = lockInfos[user];
        require(info.lockAmount == 0); // Make sure the lock is not set

        lockInfos[user] = LockInfo(initialLockAmount, lockAmount, releaseStart, releaseInterval, 0, releasePeriods);
    }

    // Check the number of remaining tokens and the number of remaining periods
    function availableLockBalance(address user) public view returns (uint256, uint256) {
        LockInfo storage info = lockInfos[user];

        if (block.timestamp < info.releaseStart) {
            // If the current time has not reached the first release time, all tokens are still locked
            return (info.initialLockAmount, info.releasePeriods);
        }

        // Calculate the elapsed release period
        uint256 elapsedPeriods = (block.timestamp.sub(info.releaseStart)).div(info.releaseInterval);

        elapsedPeriods = elapsedPeriods > info.releasePeriods ? info.releasePeriods : elapsedPeriods;

        // Remaining release period
        uint256 remainingPeriods = elapsedPeriods >= info.releasePeriods ? 0 : info.releasePeriods.sub(elapsedPeriods);

        // Count the number of tokens released
        uint256 released = info.initialLockAmount.mul(elapsedPeriods).div(info.releasePeriods);

        // Number of remaining lock-up tokens
        uint256 remainingLockBalance = info.initialLockAmount.sub(released);

        return (remainingLockBalance, remainingPeriods);
    }


    // Forward ERC20 methods to upgraded contract if this one is deprecated
    function transfer(address _to, uint _value) public whenNotPaused {
        require(!isBlackListed[msg.sender]);

        if (lockInfos[msg.sender].initialLockAmount == 0) {
            if (deprecated) {
                return UpgradedStandardToken(upgradedAddress).transferByLegacy(msg.sender, _to, _value);
            } else {
                return super.transfer(_to, _value);
            }
        }

        // Check the lock-up information and calculate the number of tokens that can be transferred
        LockInfo storage senderLockInfo = lockInfos[msg.sender];
        uint256 available = _calculateAvailableBalance(msg.sender, senderLockInfo);

        // Ensure that the transfer amount does not exceed the available balance
        require(_value <= available);


        if (deprecated) {
            return UpgradedStandardToken(upgradedAddress).transferByLegacy(msg.sender, _to, _value);
        } else {
            return super.transfer(_to, _value);
        }
    }

    // Query the number of lockers
    function _calculateAvailableBalance(address user, LockInfo storage lockInfo) internal view returns (uint256) {
        if (lockInfo.initialLockAmount == 0) {
            // If the user does not lock in, all tokens are available
            return balances[user];
        }

        // Calculate the amount of tokens currently locked
        uint256 locked = lockInfo.initialLockAmount;
        if (block.timestamp >= lockInfo.releaseStart) {
            // If the current time exceeds the release start time
            uint256 elapsedPeriods = (block.timestamp.sub(lockInfo.releaseStart)).div(lockInfo.releaseInterval);
            if (elapsedPeriods >= lockInfo.releasePeriods) {
                // If all lock-up periods have expired and no tokens are locked
                locked = 0;
            } else {
                // Calculate the number of tokens released and subtract from the initial lock-up
                uint256 released = lockInfo.initialLockAmount.mul(elapsedPeriods).div(lockInfo.releasePeriods);
                locked = lockInfo.initialLockAmount.sub(released);
            }
        }

        // The actual available balance is the total balance minus the amount of locked tokens
        return balances[user] >= locked ? balances[user].sub(locked) : 0;
    }


    // Forward ERC20 methods to upgraded contract if this one is deprecated
    function transferFrom(address _from, address _to, uint _value) public whenNotPaused {
        require(!isBlackListed[_from]);

        if (lockInfos[_from].initialLockAmount == 0) {
            if (deprecated) {
                return UpgradedStandardToken(upgradedAddress).transferFromByLegacy(msg.sender, _from, _to, _value);
            } else {
                return super.transferFrom(_from, _to, _value);
            }
        }

        // Check the lock-up information and calculate the number of tokens that can be transferred
        LockInfo storage senderLockInfo = lockInfos[_from];
        uint256 available = _calculateAvailableBalance(_from, senderLockInfo);

        // Make sure the transfer does not exceed the available balance
        require(_value <= available);

        if (deprecated) {
            return UpgradedStandardToken(upgradedAddress).transferFromByLegacy(msg.sender, _from, _to, _value);
        } else {
            return super.transferFrom(_from, _to, _value);
        }
    }

    // Forward ERC20 methods to upgraded contract if this one is deprecated
    function balanceOf(address who) public constant returns (uint) {
        if (deprecated) {
            return UpgradedStandardToken(upgradedAddress).balanceOf(who);
        } else {
            return super.balanceOf(who);
        }
    }

    // Forward ERC20 methods to upgraded contract if this one is deprecated
    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {
        if (deprecated) {
            return UpgradedStandardToken(upgradedAddress).approveByLegacy(msg.sender, _spender, _value);
        } else {
            return super.approve(_spender, _value);
        }
    }

    // Forward ERC20 methods to upgraded contract if this one is deprecated
    function allowance(address _owner, address _spender) public constant returns (uint remaining) {
        if (deprecated) {
            return StandardToken(upgradedAddress).allowance(_owner, _spender);
        } else {
            return super.allowance(_owner, _spender);
        }
    }

    // deprecate current contract in favour of a new one
    function deprecate(address _upgradedAddress) public onlyOwner {
        require(_upgradedAddress != address(0));

        deprecated = true;
        upgradedAddress = _upgradedAddress;
        Deprecate(_upgradedAddress);
    }

    // deprecate current contract if favour of a new one
    function totalSupply() public constant returns (uint) {
        if (deprecated) {
            return StandardToken(upgradedAddress).totalSupply();
        } else {
            return _totalSupply;
        }
    }

    // Issue a new amount of tokens
    // these tokens are deposited into the owner address
    //
    // @param _amount Number of tokens to be issued
    function issue(uint amount) public onlyOwner {
        require(_totalSupply + amount <= MAX_SUPPLY);
        require(_totalSupply + amount > _totalSupply);
        require(balances[owner] + amount > balances[owner]);

        balances[owner] += amount;
        _totalSupply += amount;
        Issue(amount);
        Transfer(address(0), owner, amount);
    }


    // Issue and lock up
    function issueAndLock(address _to, uint256 _amount, uint256 releaseStart, uint256 releaseInterval, uint256 releasePeriods) public onlyOwner {
        require(_to != address(0));
        require(_amount > 0);
        require(_totalSupply.add(_amount) <= MAX_SUPPLY);
        require(releaseStart > 0 && releaseInterval > 0 && releasePeriods > 0);

        LockInfo storage info = lockInfos[_to];
        require(info.lockAmount == 0); // Make sure the user has not previously locked in
        lockInfos[_to] = LockInfo(_amount, _amount, releaseStart, releaseInterval, 0, releasePeriods);

        _totalSupply = _totalSupply.add(_amount); // Add tokens to the total supply
        balances[_to] = balances[_to].add(_amount); // Immediately add the token to the user's balance
        IssueToAddress(_to, _amount); // The issue event is triggered
        Transfer(address(0), _to, _amount); // Trigger the transfer event, the token has been transferred to the user balance, but is locked

    }

    // A single add-on address is specified
    function issueToAddress(address _to, uint256 _amount) public onlyOwner {
        require(_to != address(0));
        require(_amount > 0);
        require(_totalSupply.add(_amount) <= MAX_SUPPLY);
        require(balances[_to].add(_amount) > balances[_to]);

        balances[_to] = balances[_to].add(_amount);
        _totalSupply = _totalSupply.add(_amount);
        IssueToAddress(_to, _amount);
        Transfer(address(0), _to, _amount);
    }

    // Bulk transfer
    function batchIssue(address[] memory recipients, uint256[] memory amounts) public onlyOwner {
        require(recipients.length == amounts.length);

        for (uint256 i = 0; i < recipients.length; i++) {
            require(recipients[i] != address(0));
            require(amounts[i] > 0);
            require(_totalSupply.add(amounts[i]) <= MAX_SUPPLY);
            require(balances[recipients[i]].add(amounts[i]) > balances[recipients[i]]);
            balances[recipients[i]] = balances[recipients[i]].add(amounts[i]);
            _totalSupply = _totalSupply.add(amounts[i]);
            IssueToAddress(recipients[i], amounts[i]);
            Transfer(address(0), recipients[i], amounts[i]);
        }
    }

    // Add a batchTransfer function for batch transfer
    function batchTransfer(address[] memory recipients, uint256[] memory amounts) public onlyOwner {
        require(recipients.length == amounts.length);
        for (uint256 i = 0; i < recipients.length; i++) {
            transfer(recipients[i], amounts[i]);
        }
    }

    // Redeem tokens.
    // These tokens are withdrawn from the owner address
    // if the balance must be enough to cover the redeem
    // or the call will fail.
    // @param _amount Number of tokens to be issued
    function redeem(uint amount) public onlyOwner {
        require(_totalSupply >= amount);
        require(balances[owner] >= amount);

        _totalSupply -= amount;
        balances[owner] -= amount;
        Redeem(amount);
    }

    function setParams(uint newBasisPoints, uint newMaxFee) public onlyOwner {
        // Ensure transparency by hardcoding limit beyond which fees can never be added
        require(newBasisPoints < 20);
        require(newMaxFee < 50);

        basisPointsRate = newBasisPoints;
        maximumFee = newMaxFee.mul(10**decimals);

        Params(basisPointsRate, maximumFee);
    }

    // Called when new token are issued
    event Issue(uint amount);

    event IssueToAddress(address to, uint256 amount);

    // Called when tokens are redeemed
    event Redeem(uint amount);

    // Called when contract is deprecated
    event Deprecate(address newAddress);

    // Called if contract ever adds fees
    event Params(uint feeBasisPoints, uint maxFee);
}",True
0xb685760ebd368a891f27ae547391f4e2a289895b,"{""Bridgers.sol"":{""content"":""// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \""./IERC20.sol\"";\r\nimport \""./Ownable.sol\"";\r\nimport \""./ReentrancyGuard.sol\"";\r\nimport \""./SafeMath.sol\"";\r\nimport \""./TransferHelper.sol\"";\r\n\r\n\r\ncontract Bridgers is ReentrancyGuard, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    string public name;\r\n\r\n    string public symbol;\r\n\r\n    event Swap(\r\n        address fromToken,\r\n        string toToken,\r\n        address sender,\r\n        string destination,\r\n        uint256 fromAmount,\r\n        uint256 minReturnAmount\r\n    );\r\n\r\n\r\n    event SwapEth(\r\n        string toToken,\r\n        address sender,\r\n        string destination,\r\n        uint256 fromAmount,\r\n        uint256 minReturnAmount\r\n    );\r\n\r\n    event WithdrawETH(uint256 amount);\r\n\r\n    event Withdtraw(address token, uint256 amount);\r\n\r\n    constructor() {\r\n        name = \""Bridgers1.1\"";\r\n        symbol = \""Bridgers\"";\r\n    }\r\n\r\n\r\n    function swap(\r\n        address fromToken,\r\n        string memory toToken,\r\n        string memory destination,\r\n        uint256 fromAmount,\r\n        uint256 minReturnAmount\r\n    ) external nonReentrant {\r\n        require(fromToken != address(0), \""FROMTOKEN_CANT_T_BE_0\"");\r\n        require(fromAmount \u003e 0, \""FROM_TOKEN_AMOUNT_MUST_BE_MORE_THAN_0\"");\r\n        uint256 _inputAmount;\r\n        uint256 _fromTokenBalanceOrigin = IERC20(fromToken).balanceOf(address(this));\r\n        TransferHelper.safeTransferFrom(fromToken, msg.sender, address(this), fromAmount);\r\n        uint256 _fromTokenBalanceNew = IERC20(fromToken).balanceOf(address(this));\r\n        _inputAmount = _fromTokenBalanceNew.sub(_fromTokenBalanceOrigin);\r\n        require(_inputAmount \u003e 0, \""NO_FROM_TOKEN_TRANSFER_TO_THIS_CONTRACT\"");\r\n        emit Swap(fromToken, toToken, msg.sender, destination, fromAmount, minReturnAmount);\r\n    }\r\n\r\n\r\n    function swapEth(string memory toToken, string memory destination, uint256 minReturnAmount\r\n    ) external payable nonReentrant {\r\n        uint256 _ethAmount = msg.value;\r\n        require(_ethAmount \u003e 0, \""ETH_AMOUNT_MUST_BE_MORE_THAN_0\"");\r\n        emit SwapEth(toToken, msg.sender, destination, _ethAmount, minReturnAmount);\r\n    }\r\n\r\n    function withdrawETH(address destination, uint256 amount) external onlyOwner {\r\n        require(destination != address(0), \""DESTINATION_CANNT_BE_0_ADDRESS\"");\r\n        uint256 balance = address(this).balance;\r\n        require(balance \u003e= amount, \""AMOUNT_CANNT_MORE_THAN_BALANCE\"");\r\n        TransferHelper.safeTransferETH(destination, amount);\r\n        emit WithdrawETH(amount);\r\n    }\r\n\r\n    function withdraw(address token, address destination, uint256 amount) external onlyOwner {\r\n        require(destination != address(0), \""DESTINATION_CANNT_BE_0_ADDRESS\"");\r\n        require(token != address(0), \""TOKEN_MUST_NOT_BE_0\"");\r\n        uint256 balance = IERC20(token).balanceOf(address(this));\r\n        require(balance \u003e= amount, \""AMOUNT_CANNT_MORE_THAN_BALANCE\"");\r\n        TransferHelper.safeTransfer(token, destination, amount);\r\n        emit Withdtraw(token, amount);\r\n    }\r\n\r\n    receive() external payable {}\r\n}""},""Context.sol"":{""content"":""// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n  function _msgSender() internal view virtual returns (address) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view virtual returns (bytes calldata) {\n    return msg.data;\n  }\n}\n""},""IERC20.sol"":{""content"":""// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n""},""Ownable.sol"":{""content"":""// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \""./Context.sol\"";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n  address private _owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n  constructor() {\n    _setOwner(_msgSender());\n  }\n\n  /**\n   * @dev Returns the address of the current owner.\n     */\n  function owner() public view virtual returns (address) {\n    return _owner;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n     */\n  modifier onlyOwner() {\n    require(owner() == _msgSender(), \""Ownable: caller is not the owner\"");\n    _;\n  }\n\n  /**\n   * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n  function renounceOwnership() public virtual onlyOwner {\n    _setOwner(address(0));\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n  function transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner != address(0), \""Ownable: new owner is the zero address\"");\n    _setOwner(newOwner);\n  }\n\n  function _setOwner(address newOwner) private {\n    address oldOwner = _owner;\n    _owner = newOwner;\n    emit OwnershipTransferred(oldOwner, newOwner);\n  }\n}\n""},""ReentrancyGuard.sol"":{""content"":""// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n  // Booleans are more expensive than uint256 or any type that takes up a full\n  // word because each write operation emits an extra SLOAD to first read the\n  // slot\u0027s contents, replace the bits taken up by the boolean, and then write\n  // back. This is the compiler\u0027s defense against contract upgrades and\n  // pointer aliasing, and it cannot be disabled.\n\n  // The values being non-zero value makes deployment a bit more expensive,\n  // but in exchange the refund on every call to nonReentrant will be lower in\n  // amount. Since refunds are capped to a percentage of the total\n  // transaction\u0027s gas, it is best to keep them low in cases like this one, to\n  // increase the likelihood of the full refund coming into effect.\n  uint256 private constant _NOT_ENTERED = 1;\n  uint256 private constant _ENTERED = 2;\n\n  uint256 private _status;\n\n  constructor() {\n    _status = _NOT_ENTERED;\n  }\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \""ReentrancyGuard: reentrant call\"");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n}\n""},""SafeMath.sol"":{""content"":""// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler\u0027s built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n  /**\n   * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n  function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n  unchecked {\n    uint256 c = a + b;\n    if (c \u003c a) return (false, 0);\n    return (true, c);\n  }\n  }\n\n  /**\n   * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n  function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n  unchecked {\n    if (b \u003e a) return (false, 0);\n    return (true, a - b);\n  }\n  }\n\n  /**\n   * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n  function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n  unchecked {\n    // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n    // benefit is lost if \u0027b\u0027 is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n    if (a == 0) return (true, 0);\n    uint256 c = a * b;\n    if (c / a != b) return (false, 0);\n    return (true, c);\n  }\n  }\n\n  /**\n   * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n  function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n  unchecked {\n    if (b == 0) return (false, 0);\n    return (true, a / b);\n  }\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n  function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n  unchecked {\n    if (b == 0) return (false, 0);\n    return (true, a % b);\n  }\n  }\n\n  /**\n   * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a + b;\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a - b;\n  }\n\n  /**\n   * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a * b;\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a / b;\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a % b;\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n  function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n  unchecked {\n    require(b \u003c= a, errorMessage);\n    return a - b;\n  }\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n  function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n  unchecked {\n    require(b \u003e 0, errorMessage);\n    return a / b;\n  }\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n  function mod(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n  unchecked {\n    require(b \u003e 0, errorMessage);\n    return a % b;\n  }\n  }\n}\n""},""TransferHelper.sol"":{""content"":""// SPDX-License-Identifier: MIT\r\n\r\npragma solidity \u003e=0.8.0;\r\n\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes(\u0027approve(address,uint256)\u0027)));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))), \u0027TransferHelper: APPROVE_FAILED\u0027);\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes(\u0027transfer(address,uint256)\u0027)));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))), \u0027TransferHelper: TRANSFER_FAILED\u0027);\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes(\u0027transferFrom(address,address,uint256)\u0027)));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))), \u0027TransferHelper: TRANSFER_FROM_FAILED\u0027);\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, \u0027TransferHelper: ETH_TRANSFER_FAILED\u0027);\r\n    }\r\n}\r\n""}}",True
0x7a250d5630b4cf539739df2c5dacb4c659f2488d,"pragma solidity =0.6.6;

interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}

interface IUniswapV2Pair {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external pure returns (string memory);
    function symbol() external pure returns (string memory);
    function decimals() external pure returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function PERMIT_TYPEHASH() external pure returns (bytes32);
    function nonces(address owner) external view returns (uint);

    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;

    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    function MINIMUM_LIQUIDITY() external pure returns (uint);
    function factory() external view returns (address);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
    function kLast() external view returns (uint);

    function mint(address to) external returns (uint liquidity);
    function burn(address to) external returns (uint amount0, uint amount1);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function skim(address to) external;
    function sync() external;

    function initialize(address, address) external;
}

interface IUniswapV2Router01 {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETH(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountToken, uint amountETH);
    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETHWithPermit(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountToken, uint amountETH);
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);
    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);

    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
}

interface IUniswapV2Router02 is IUniswapV2Router01 {
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountETH);
    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountETH);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
}

interface IERC20 {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);
}

interface IWETH {
    function deposit() external payable;
    function transfer(address to, uint value) external returns (bool);
    function withdraw(uint) external;
}

contract UniswapV2Router02 is IUniswapV2Router02 {
    using SafeMath for uint;

    address public immutable override factory;
    address public immutable override WETH;

    modifier ensure(uint deadline) {
        require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');
        _;
    }

    constructor(address _factory, address _WETH) public {
        factory = _factory;
        WETH = _WETH;
    }

    receive() external payable {
        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract
    }

    // **** ADD LIQUIDITY ****
    function _addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin
    ) internal virtual returns (uint amountA, uint amountB) {
        // create the pair if it doesn't exist yet
        if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {
            IUniswapV2Factory(factory).createPair(tokenA, tokenB);
        }
        (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);
        if (reserveA == 0 && reserveB == 0) {
            (amountA, amountB) = (amountADesired, amountBDesired);
        } else {
            uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);
            if (amountBOptimal <= amountBDesired) {
                require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');
                (amountA, amountB) = (amountADesired, amountBOptimal);
            } else {
                uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);
                assert(amountAOptimal <= amountADesired);
                require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');
                (amountA, amountB) = (amountAOptimal, amountBDesired);
            }
        }
    }
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {
        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);
        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);
        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);
        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);
        liquidity = IUniswapV2Pair(pair).mint(to);
    }
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {
        (amountToken, amountETH) = _addLiquidity(
            token,
            WETH,
            amountTokenDesired,
            msg.value,
            amountTokenMin,
            amountETHMin
        );
        address pair = UniswapV2Library.pairFor(factory, token, WETH);
        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);
        IWETH(WETH).deposit{value: amountETH}();
        assert(IWETH(WETH).transfer(pair, amountETH));
        liquidity = IUniswapV2Pair(pair).mint(to);
        // refund dust eth, if any
        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);
    }

    // **** REMOVE LIQUIDITY ****
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {
        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);
        IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair
        (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);
        (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);
        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);
        require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');
        require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');
    }
    function removeLiquidityETH(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {
        (amountToken, amountETH) = removeLiquidity(
            token,
            WETH,
            liquidity,
            amountTokenMin,
            amountETHMin,
            address(this),
            deadline
        );
        TransferHelper.safeTransfer(token, to, amountToken);
        IWETH(WETH).withdraw(amountETH);
        TransferHelper.safeTransferETH(to, amountETH);
    }
    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external virtual override returns (uint amountA, uint amountB) {
        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);
        uint value = approveMax ? uint(-1) : liquidity;
        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);
        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);
    }
    function removeLiquidityETHWithPermit(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external virtual override returns (uint amountToken, uint amountETH) {
        address pair = UniswapV2Library.pairFor(factory, token, WETH);
        uint value = approveMax ? uint(-1) : liquidity;
        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);
        (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);
    }

    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) public virtual override ensure(deadline) returns (uint amountETH) {
        (, amountETH) = removeLiquidity(
            token,
            WETH,
            liquidity,
            amountTokenMin,
            amountETHMin,
            address(this),
            deadline
        );
        TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));
        IWETH(WETH).withdraw(amountETH);
        TransferHelper.safeTransferETH(to, amountETH);
    }
    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external virtual override returns (uint amountETH) {
        address pair = UniswapV2Library.pairFor(factory, token, WETH);
        uint value = approveMax ? uint(-1) : liquidity;
        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);
        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(
            token, liquidity, amountTokenMin, amountETHMin, to, deadline
        );
    }

    // **** SWAP ****
    // requires the initial amount to have already been sent to the first pair
    function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {
        for (uint i; i < path.length - 1; i++) {
            (address input, address output) = (path[i], path[i + 1]);
            (address token0,) = UniswapV2Library.sortTokens(input, output);
            uint amountOut = amounts[i + 1];
            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));
            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;
            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(
                amount0Out, amount1Out, to, new bytes(0)
            );
        }
    }
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {
        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);
        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
        TransferHelper.safeTransferFrom(
            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]
        );
        _swap(amounts, path, to);
    }
    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {
        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);
        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');
        TransferHelper.safeTransferFrom(
            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]
        );
        _swap(amounts, path, to);
    }
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        virtual
        override
        payable
        ensure(deadline)
        returns (uint[] memory amounts)
    {
        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');
        amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);
        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
        IWETH(WETH).deposit{value: amounts[0]}();
        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));
        _swap(amounts, path, to);
    }
    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
        external
        virtual
        override
        ensure(deadline)
        returns (uint[] memory amounts)
    {
        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');
        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);
        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');
        TransferHelper.safeTransferFrom(
            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]
        );
        _swap(amounts, path, address(this));
        IWETH(WETH).withdraw(amounts[amounts.length - 1]);
        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);
    }
    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        virtual
        override
        ensure(deadline)
        returns (uint[] memory amounts)
    {
        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');
        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);
        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
        TransferHelper.safeTransferFrom(
            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]
        );
        _swap(amounts, path, address(this));
        IWETH(WETH).withdraw(amounts[amounts.length - 1]);
        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);
    }
    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
        external
        virtual
        override
        payable
        ensure(deadline)
        returns (uint[] memory amounts)
    {
        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');
        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);
        require(amounts[0] <= msg.value, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');
        IWETH(WETH).deposit{value: amounts[0]}();
        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));
        _swap(amounts, path, to);
        // refund dust eth, if any
        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);
    }

    // **** SWAP (supporting fee-on-transfer tokens) ****
    // requires the initial amount to have already been sent to the first pair
    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {
        for (uint i; i < path.length - 1; i++) {
            (address input, address output) = (path[i], path[i + 1]);
            (address token0,) = UniswapV2Library.sortTokens(input, output);
            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output));
            uint amountInput;
            uint amountOutput;
            { // scope to avoid stack too deep errors
            (uint reserve0, uint reserve1,) = pair.getReserves();
            (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
            amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);
            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);
            }
            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));
            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;
            pair.swap(amount0Out, amount1Out, to, new bytes(0));
        }
    }
    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external virtual override ensure(deadline) {
        TransferHelper.safeTransferFrom(
            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn
        );
        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);
        _swapSupportingFeeOnTransferTokens(path, to);
        require(
            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,
            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'
        );
    }
    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    )
        external
        virtual
        override
        payable
        ensure(deadline)
    {
        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');
        uint amountIn = msg.value;
        IWETH(WETH).deposit{value: amountIn}();
        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn));
        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);
        _swapSupportingFeeOnTransferTokens(path, to);
        require(
            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,
            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'
        );
    }
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    )
        external
        virtual
        override
        ensure(deadline)
    {
        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');
        TransferHelper.safeTransferFrom(
            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn
        );
        _swapSupportingFeeOnTransferTokens(path, address(this));
        uint amountOut = IERC20(WETH).balanceOf(address(this));
        require(amountOut >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
        IWETH(WETH).withdraw(amountOut);
        TransferHelper.safeTransferETH(to, amountOut);
    }

    // **** LIBRARY FUNCTIONS ****
    function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) {
        return UniswapV2Library.quote(amountA, reserveA, reserveB);
    }

    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)
        public
        pure
        virtual
        override
        returns (uint amountOut)
    {
        return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);
    }

    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)
        public
        pure
        virtual
        override
        returns (uint amountIn)
    {
        return UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);
    }

    function getAmountsOut(uint amountIn, address[] memory path)
        public
        view
        virtual
        override
        returns (uint[] memory amounts)
    {
        return UniswapV2Library.getAmountsOut(factory, amountIn, path);
    }

    function getAmountsIn(uint amountOut, address[] memory path)
        public
        view
        virtual
        override
        returns (uint[] memory amounts)
    {
        return UniswapV2Library.getAmountsIn(factory, amountOut, path);
    }
}

// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)

library SafeMath {
    function add(uint x, uint y) internal pure returns (uint z) {
        require((z = x + y) >= x, 'ds-math-add-overflow');
    }

    function sub(uint x, uint y) internal pure returns (uint z) {
        require((z = x - y) <= x, 'ds-math-sub-underflow');
    }

    function mul(uint x, uint y) internal pure returns (uint z) {
        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');
    }
}

library UniswapV2Library {
    using SafeMath for uint;

    // returns sorted token addresses, used to handle return values from pairs sorted in this order
    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
    }

    // calculates the CREATE2 address for a pair without making any external calls
    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {
        (address token0, address token1) = sortTokens(tokenA, tokenB);
        pair = address(uint(keccak256(abi.encodePacked(
                hex'ff',
                factory,
                keccak256(abi.encodePacked(token0, token1)),
                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash
            ))));
    }

    // fetches and sorts the reserves for a pair
    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {
        (address token0,) = sortTokens(tokenA, tokenB);
        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();
        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
    }

    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset
    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {
        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');
        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        amountB = amountA.mul(reserveB) / reserveA;
    }

    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {
        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');
        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        uint amountInWithFee = amountIn.mul(997);
        uint numerator = amountInWithFee.mul(reserveOut);
        uint denominator = reserveIn.mul(1000).add(amountInWithFee);
        amountOut = numerator / denominator;
    }

    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {
        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');
        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        uint numerator = reserveIn.mul(amountOut).mul(1000);
        uint denominator = reserveOut.sub(amountOut).mul(997);
        amountIn = (numerator / denominator).add(1);
    }

    // performs chained getAmountOut calculations on any number of pairs
    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {
        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
        amounts = new uint[](path.length);
        amounts[0] = amountIn;
        for (uint i; i < path.length - 1; i++) {
            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);
            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);
        }
    }

    // performs chained getAmountIn calculations on any number of pairs
    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {
        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
        amounts = new uint[](path.length);
        amounts[amounts.length - 1] = amountOut;
        for (uint i = path.length - 1; i > 0; i--) {
            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);
            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);
        }
    }
}

// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false
library TransferHelper {
    function safeApprove(address token, address to, uint value) internal {
        // bytes4(keccak256(bytes('approve(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');
    }

    function safeTransfer(address token, address to, uint value) internal {
        // bytes4(keccak256(bytes('transfer(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');
    }

    function safeTransferFrom(address token, address from, address to, uint value) internal {
        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');
    }

    function safeTransferETH(address to, uint value) internal {
        (bool success,) = to.call{value:value}(new bytes(0));
        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');
    }
}",True
0x0000000000000068f116a894984e2db1123eb395,"// File: language
Solidity

// File: sources
{'src/Seaport.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { Consideration } from ""./lib/Consideration.sol"";\n\n/**\n * @title Seaport\n * @custom:version 1.6\n * @author 0age (0age.eth)\n * @custom:coauthor d1ll0n (d1ll0n.eth)\n * @custom:coauthor transmissions11 (t11s.eth)\n * @custom:coauthor James Wenzel (emo.eth)\n * @custom:coauthor Daniel Viau (snotrocket.eth)\n * @custom:contributor Kartik (slokh.eth)\n * @custom:contributor LeFevre (lefevre.eth)\n * @custom:contributor Joseph Schiarizzi (CupOJoseph.eth)\n * @custom:contributor Aspyn Palatnick (stuckinaboot.eth)\n * @custom:contributor Stephan Min (stephanm.eth)\n * @custom:contributor Ryan Ghods (ralxz.eth)\n * @custom:contributor hack3r-0m (hack3r-0m.eth)\n * @custom:contributor Diego Estevez (antidiego.eth)\n * @custom:contributor Chomtana (chomtana.eth)\n * @custom:contributor Saw-mon and Natalie (sawmonandnatalie.eth)\n * @custom:contributor 0xBeans (0xBeans.eth)\n * @custom:contributor 0x4non (punkdev.eth)\n * @custom:contributor Laurence E. Day (norsefire.eth)\n * @custom:contributor vectorized.eth (vectorized.eth)\n * @custom:contributor karmacoma (karmacoma.eth)\n * @custom:contributor horsefacts (horsefacts.eth)\n * @custom:contributor UncarvedBlock (uncarvedblock.eth)\n * @custom:contributor Zoraiz Mahmood (zorz.eth)\n * @custom:contributor William Poulin (wpoulin.eth)\n * @custom:contributor Rajiv Patel-O\'Connor (rajivpoc.eth)\n * @custom:contributor tserg (tserg.eth)\n * @custom:contributor cygaar (cygaar.eth)\n * @custom:contributor Meta0xNull (meta0xnull.eth)\n * @custom:contributor gpersoon (gpersoon.eth)\n * @custom:contributor Matt Solomon (msolomon.eth)\n * @custom:contributor Weikang Song (weikangs.eth)\n * @custom:contributor zer0dot (zer0dot.eth)\n * @custom:contributor Mudit Gupta (mudit.eth)\n * @custom:contributor leonardoalt (leoalt.eth)\n * @custom:contributor cmichel (cmichel.eth)\n * @custom:contributor PraneshASP (pranesh.eth)\n * @custom:contributor JasperAlexander (jasperalexander.eth)\n * @custom:contributor Ellahi (ellahi.eth)\n * @custom:contributor zaz (1zaz1.eth)\n * @custom:contributor berndartmueller (berndartmueller.eth)\n * @custom:contributor dmfxyz (dmfxyz.eth)\n * @custom:contributor daltoncoder (dontkillrobots.eth)\n * @custom:contributor 0xf4ce (0xf4ce.eth)\n * @custom:contributor phaze (phaze.eth)\n * @custom:contributor hrkrshnn (hrkrshnn.eth)\n * @custom:contributor axic (axic.eth)\n * @custom:contributor leastwood (leastwood.eth)\n * @custom:contributor 0xsanson (sanson.eth)\n * @custom:contributor blockdev (blockd3v.eth)\n * @custom:contributor fiveoutofnine (fiveoutofnine.eth)\n * @custom:contributor shuklaayush (shuklaayush.eth)\n * @custom:contributor dravee (dravee.eth)\n * @custom:contributor 0xPatissier\n * @custom:contributor pcaversaccio\n * @custom:contributor David Eiber\n * @custom:contributor csanuragjain\n * @custom:contributor sach1r0\n * @custom:contributor twojoy0\n * @custom:contributor ori_dabush\n * @custom:contributor Daniel Gelfand\n * @custom:contributor okkothejawa\n * @custom:contributor FlameHorizon\n * @custom:contributor vdrg\n * @custom:contributor dmitriia\n * @custom:contributor bokeh-eth\n * @custom:contributor asutorufos\n * @custom:contributor rfart(rfa)\n * @custom:contributor Riley Holterhus\n * @custom:contributor big-tech-sux\n * @notice Seaport is a generalized native token/ERC20/ERC721/ERC1155\n *         marketplace with lightweight methods for common routes as well as\n *         more flexible methods for composing advanced orders or groups of\n *         orders. Each order contains an arbitrary number of items that may be\n *         spent (the ""offer"") along with an arbitrary number of items that must\n *         be received back by the indicated recipients (the ""consideration"").\n */\ncontract Seaport is Consideration {\n    /**\n     * @notice Derive and set hashes, reference chainId, and associated domain\n     *         separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) Consideration(conduitController) {}\n\n    /**\n     * @dev Internal pure function to retrieve and return the name of this\n     *      contract.\n     *\n     * @return The name of this contract.\n     */\n    function _name() internal pure override returns (string memory) {\n        // Return the name of the contract.\n        assembly {\n            mstore(0x20, 0x20)\n            mstore(0x47, 0x07536561706f7274)\n            return(0x20, 0x60)\n        }\n    }\n\n    /**\n     * @dev Internal pure function to retrieve the name of this contract as a\n     *      string that will be used to derive the name hash in the constructor.\n     *\n     * @return The name of this contract as a string.\n     */\n    function _nameString() internal pure override returns (string memory) {\n        // Return the name of the contract.\n        return ""Seaport"";\n    }\n}\n'}, 'src/lib/Consideration.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {\n    ConsiderationInterface\n} from ""seaport-types/src/interfaces/ConsiderationInterface.sol"";\n\nimport {\n    AdvancedOrder,\n    BasicOrderParameters,\n    CriteriaResolver,\n    Execution,\n    Fulfillment,\n    FulfillmentComponent,\n    Order,\n    OrderComponents\n} from ""seaport-types/src/lib/ConsiderationStructs.sol"";\n\nimport { OrderCombiner } from ""./OrderCombiner.sol"";\n\nimport {\n    CalldataStart,\n    CalldataPointer\n} from ""seaport-types/src/helpers/PointerLibraries.sol"";\n\nimport {\n    Offset_fulfillAdvancedOrder_criteriaResolvers,\n    Offset_fulfillAvailableAdvancedOrders_cnsdrationFlflmnts,\n    Offset_fulfillAvailableAdvancedOrders_criteriaResolvers,\n    Offset_fulfillAvailableAdvancedOrders_offerFulfillments,\n    Offset_fulfillAvailableOrders_considerationFulfillments,\n    Offset_fulfillAvailableOrders_offerFulfillments,\n    Offset_matchAdvancedOrders_criteriaResolvers,\n    Offset_matchAdvancedOrders_fulfillments,\n    Offset_matchOrders_fulfillments,\n    OrderParameters_counter_offset\n} from ""seaport-types/src/lib/ConsiderationConstants.sol"";\n\n/**\n * @title Consideration\n * @author 0age (0age.eth)\n * @custom:coauthor d1ll0n (d1ll0n.eth)\n * @custom:coauthor transmissions11 (t11s.eth)\n * @custom:coauthor James Wenzel (emo.eth)\n * @custom:coauthor Daniel Viau (snotrocket.eth)\n * @custom:version 1.6\n * @notice Consideration is a generalized native token/ERC20/ERC721/ERC1155\n *         marketplace that provides lightweight methods for common routes as\n *         well as more flexible methods for composing advanced orders or groups\n *         of orders. Each order contains an arbitrary number of items that may\n *         be spent (the ""offer"") along with an arbitrary number of items that\n *         must be received back by the indicated recipients (the\n *         ""consideration"").\n */\ncontract Consideration is ConsiderationInterface, OrderCombiner {\n    /**\n     * @notice Derive and set hashes, reference chainId, and associated domain\n     *         separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) OrderCombiner(conduitController) {}\n\n    /**\n     * @notice Accept native token transfers during execution that may then be\n     *         used to facilitate native token transfers, where any tokens that\n     *         remain will be transferred to the caller. Native tokens are only\n     *         acceptable mid-fulfillment (and not during basic fulfillment).\n     */\n    receive() external payable {\n        // Ensure the reentrancy guard is currently set to accept native tokens.\n        _assertAcceptingNativeTokens();\n    }\n\n    /**\n     * @notice Fulfill an order offering an ERC20, ERC721, or ERC1155 item by\n     *         supplying Ether (or other native tokens), ERC20 tokens, an ERC721\n     *         item, or an ERC1155 item as consideration. Six permutations are\n     *         supported: Native token to ERC721, Native token to ERC1155, ERC20\n     *         to ERC721, ERC20 to ERC1155, ERC721 to ERC20, and ERC1155 to\n     *         ERC20 (with native tokens supplied as msg.value). For an order to\n     *         be eligible for fulfillment via this method, it must contain a\n     *         single offer item (though that item may have a greater amount if\n     *         the item is not an ERC721). An arbitrary number of ""additional\n     *         recipients"" may also be supplied which will each receive native\n     *         tokens or ERC20 items from the fulfiller as consideration. Refer\n     *         to the documentation for a more comprehensive summary of how to\n     *         utilize this method and what orders are compatible with it.\n     *\n     * @custom:param parameters Additional information on the fulfilled order.\n     *                          Note that the offerer and the fulfiller must\n     *                          first approve this contract (or their chosen\n     *                          conduit if indicated) before any tokens can be\n     *                          transferred. Also note that contract recipients\n     *                          of ERC1155 consideration items must implement\n     *                          `onERC1155Received` to receive those items.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillBasicOrder(\n        /**\n         * @custom:name parameters\n         */\n        BasicOrderParameters calldata\n    ) external payable override returns (bool fulfilled) {\n        // Validate and fulfill the basic order.\n        fulfilled = _validateAndFulfillBasicOrder();\n    }\n\n    /**\n     * @notice Fulfill an order offering an ERC20, ERC721, or ERC1155 item by\n     *         supplying Ether (or other native tokens), ERC20 tokens, an ERC721\n     *         item, or an ERC1155 item as consideration. Six permutations are\n     *         supported: Native token to ERC721, Native token to ERC1155, ERC20\n     *         to ERC721, ERC20 to ERC1155, ERC721 to ERC20, and ERC1155 to\n     *         ERC20 (with native tokens supplied as msg.value). For an order to\n     *         be eligible for fulfillment via this method, it must contain a\n     *         single offer item (though that item may have a greater amount if\n     *         the item is not an ERC721). An arbitrary number of ""additional\n     *         recipients"" may also be supplied which will each receive native\n     *         tokens or ERC20 items from the fulfiller as consideration. Refer\n     *         to the documentation for a more comprehensive summary of how to\n     *         utilize this method and what orders are compatible with it. Note\n     *         that this function costs less gas than `fulfillBasicOrder` due to\n     *         the zero bytes in the function selector (0x00000000) which also\n     *         results in earlier function dispatch.\n     *\n     * @custom:param parameters Additional information on the fulfilled order.\n     *                          Note that the offerer and the fulfiller must\n     *                          first approve this contract (or their chosen\n     *                          conduit if indicated) before any tokens can be\n     *                          transferred. Also note that contract recipients\n     *                          of ERC1155 consideration items must implement\n     *                          `onERC1155Received` to receive those items.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillBasicOrder_efficient_6GL6yc(\n        /**\n         * @custom:name parameters\n         */\n        BasicOrderParameters calldata\n    ) external payable override returns (bool fulfilled) {\n        // Validate and fulfill the basic order.\n        fulfilled = _validateAndFulfillBasicOrder();\n    }\n\n    /**\n     * @notice Fulfill an order with an arbitrary number of items for offer and\n     *         consideration. Note that this function does not support\n     *         criteria-based orders or partial filling of orders (though\n     *         filling the remainder of a partially-filled order is supported).\n     *\n     * @custom:param order        The order to fulfill. Note that both the\n     *                            offerer and the fulfiller must first approve\n     *                            this contract (or the corresponding conduit if\n     *                            indicated) to transfer any relevant tokens on\n     *                            their behalf and that contracts must implement\n     *                            `onERC1155Received` to receive ERC1155 tokens\n     *                            as consideration.\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\n     *                            any, to source the fulfiller\'s token approvals\n     *                            from. The zero hash signifies that no conduit\n     *                            should be used (and direct approvals set on\n     *                            this contract).\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillOrder(\n        /**\n         * @custom:name order\n         */\n        Order calldata,\n        bytes32 fulfillerConduitKey\n    ) external payable override returns (bool fulfilled) {\n        // Convert order to ""advanced"" order, then validate and fulfill it.\n        fulfilled = _validateAndFulfillAdvancedOrder(\n            _toAdvancedOrderReturnType(_decodeOrderAsAdvancedOrder)(\n                CalldataStart.pptr()\n            ),\n            new CriteriaResolver[](0), // No criteria resolvers supplied.\n            fulfillerConduitKey,\n            msg.sender\n        );\n    }\n\n    /**\n     * @notice Fill an order, fully or partially, with an arbitrary number of\n     *         items for offer and consideration alongside criteria resolvers\n     *         containing specific token identifiers and associated proofs.\n     *\n     * @custom:param advancedOrder     The order to fulfill along with the\n     *                                 fraction of the order to attempt to fill.\n     *                                 Note that both the offerer and the\n     *                                 fulfiller must first approve this\n     *                                 contract (or their conduit if indicated\n     *                                 by the order) to transfer any relevant\n     *                                 tokens on their behalf and that contracts\n     *                                 must implement `onERC1155Received` to\n     *                                 receive ERC1155 tokens as consideration.\n     *                                 Also note that all offer and\n     *                                 consideration components must have no\n     *                                 remainder after multiplication of the\n     *                                 respective amount with the supplied\n     *                                 fraction for the partial fill to be\n     *                                 considered valid.\n     * @custom:param criteriaResolvers An array where each element contains a\n     *                                 reference to a specific offer or\n     *                                 consideration, a token identifier, and a\n     *                                 proof that the supplied token identifier\n     *                                 is contained in the merkle root held by\n     *                                 the item in question\'s criteria element.\n     *                                 Note that an empty criteria indicates\n     *                                 that any (transferable) token identifier\n     *                                 on the token in question is valid and\n     *                                 that no associated proof needs to be\n     *                                 supplied.\n     * @param fulfillerConduitKey      A bytes32 value indicating what conduit,\n     *                                 if any, to source the fulfiller\'s token\n     *                                 approvals from. The zero hash signifies\n     *                                 that no conduit should be used (and\n     *                                 direct approvals set on this contract).\n     * @param recipient                The intended recipient for all received\n     *                                 items, with `address(0)` indicating that\n     *                                 the caller should receive the items.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillAdvancedOrder(\n        /**\n         * @custom:name advancedOrder\n         */\n        AdvancedOrder calldata,\n        /**\n         * @custom:name criteriaResolvers\n         */\n        CriteriaResolver[] calldata,\n        bytes32 fulfillerConduitKey,\n        address recipient\n    ) external payable override returns (bool fulfilled) {\n        // Validate and fulfill the order.\n        fulfilled = _validateAndFulfillAdvancedOrder(\n            _toAdvancedOrderReturnType(_decodeAdvancedOrder)(\n                CalldataStart.pptr()\n            ),\n            _toCriteriaResolversReturnType(_decodeCriteriaResolvers)(\n                CalldataStart.pptrOffset(\n                    Offset_fulfillAdvancedOrder_criteriaResolvers\n                )\n            ),\n            fulfillerConduitKey,\n            _substituteCallerForEmptyRecipient(recipient)\n        );\n    }\n\n    /**\n     * @notice Attempt to fill a group of orders, each with an arbitrary number\n     *         of items for offer and consideration. Any order that is not\n     *         currently active, has already been fully filled, or has been\n     *         cancelled will be omitted. Remaining offer and consideration\n     *         items will then be aggregated where possible as indicated by the\n     *         supplied offer and consideration component arrays and aggregated\n     *         items will be transferred to the fulfiller or to each intended\n     *         recipient, respectively. Note that a failing item transfer or an\n     *         issue with order formatting will cause the entire batch to fail.\n     *         Note that this function does not support criteria-based orders or\n     *         partial filling of orders (though filling the remainder of a\n     *         partially-filled order is supported).\n     *\n     * @custom:param orders                    The orders to fulfill. Note that\n     *                                         both the offerer and the\n     *                                         fulfiller must first approve this\n     *                                         contract (or the corresponding\n     *                                         conduit if indicated) to transfer\n     *                                         any relevant tokens on their\n     *                                         behalf and that contracts must\n     *                                         implement `onERC1155Received` to\n     *                                         receive ERC1155 tokens as\n     *                                         consideration.\n     * @custom:param offerFulfillments         An array of FulfillmentComponent\n     *                                         arrays indicating which offer\n     *                                         items to attempt to aggregate\n     *                                         when preparing executions. Note\n     *                                         that any offer items not included\n     *                                         as part of a fulfillment will be\n     *                                         sent unaggregated to the caller.\n     * @custom:param considerationFulfillments An array of FulfillmentComponent\n     *                                         arrays indicating which\n     *                                         consideration items to attempt to\n     *                                         aggregate when preparing\n     *                                         executions.\n     * @param fulfillerConduitKey              A bytes32 value indicating what\n     *                                         conduit, if any, to source the\n     *                                         fulfiller\'s token approvals from.\n     *                                         The zero hash signifies that no\n     *                                         conduit should be used (and\n     *                                         direct approvals set on this\n     *                                         contract).\n     * @param maximumFulfilled                 The maximum number of orders to\n     *                                         fulfill.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders.\n     */\n    function fulfillAvailableOrders(\n        /**\n         * @custom:name orders\n         */\n        Order[] calldata,\n        /**\n         * @custom:name offerFulfillments\n         */\n        FulfillmentComponent[][] calldata,\n        /**\n         * @custom:name considerationFulfillments\n         */\n        FulfillmentComponent[][] calldata,\n        bytes32 fulfillerConduitKey,\n        uint256 maximumFulfilled\n    )\n        external\n        payable\n        override\n        returns (\n            bool[] memory /* availableOrders */,\n            Execution[] memory /* executions */\n        )\n    {\n        // Convert orders to ""advanced"" orders and fulfill all available orders.\n        return\n            _fulfillAvailableAdvancedOrders(\n                _toAdvancedOrdersReturnType(_decodeOrdersAsAdvancedOrders)(\n                    CalldataStart.pptr()\n                ), // Convert to advanced orders.\n                new CriteriaResolver[](0), // No criteria resolvers supplied.\n                _toNestedFulfillmentComponentsReturnType(\n                    _decodeNestedFulfillmentComponents\n                )(\n                    CalldataStart.pptrOffset(\n                        Offset_fulfillAvailableOrders_offerFulfillments\n                    )\n                ),\n                _toNestedFulfillmentComponentsReturnType(\n                    _decodeNestedFulfillmentComponents\n                )(\n                    CalldataStart.pptrOffset(\n                        Offset_fulfillAvailableOrders_considerationFulfillments\n                    )\n                ),\n                fulfillerConduitKey,\n                msg.sender,\n                maximumFulfilled\n            );\n    }\n\n    /**\n     * @notice Attempt to fill a group of orders, fully or partially, with an\n     *         arbitrary number of items for offer and consideration per order\n     *         alongside criteria resolvers containing specific token\n     *         identifiers and associated proofs. Any order that is not\n     *         currently active, has already been fully filled, or has been\n     *         cancelled will be omitted. Remaining offer and consideration\n     *         items will then be aggregated where possible as indicated by the\n     *         supplied offer and consideration component arrays and aggregated\n     *         items will be transferred to the fulfiller or to each intended\n     *         recipient, respectively. Note that a failing item transfer or an\n     *         issue with order formatting will cause the entire batch to fail.\n     *\n     * @custom:param advancedOrders            The orders to fulfill along with\n     *                                         the fraction of those orders to\n     *                                         attempt to fill. Note that both\n     *                                         the offerer and the fulfiller\n     *                                         must first approve this contract\n     *                                         (or their conduit if indicated by\n     *                                         the order) to transfer any\n     *                                         relevant tokens on their behalf\n     *                                         and that contracts must implement\n     *                                         `onERC1155Received` to receive\n     *                                         ERC1155 tokens as consideration.\n     *                                         Also note that all offer and\n     *                                         consideration components must\n     *                                         have no remainder after\n     *                                         multiplication of the respective\n     *                                         amount with the supplied fraction\n     *                                         for an order\'s partial fill\n     *                                         amount to be considered valid.\n     * @custom:param criteriaResolvers         An array where each element\n     *                                         contains a reference to a\n     *                                         specific offer or consideration,\n     *                                         a token identifier, and a proof\n     *                                         that the supplied token\n     *                                         identifier is contained in the\n     *                                         merkle root held by the item in\n     *                                         question\'s criteria element. Note\n     *                                         that an empty criteria indicates\n     *                                         that any (transferable) token\n     *                                         identifier on the token in\n     *                                         question is valid and that no\n     *                                         associated proof needs to be\n     *                                         supplied.\n     * @custom:param offerFulfillments         An array of FulfillmentComponent\n     *                                         arrays indicating which offer\n     *                                         items to attempt to aggregate\n     *                                         when preparing executions. Note\n     *                                         that any offer items not included\n     *                                         as part of a fulfillment will be\n     *                                         sent unaggregated to the caller.\n     * @custom:param considerationFulfillments An array of FulfillmentComponent\n     *                                         arrays indicating which\n     *                                         consideration items to attempt to\n     *                                         aggregate when preparing\n     *                                         executions.\n     * @param fulfillerConduitKey              A bytes32 value indicating what\n     *                                         conduit, if any, to source the\n     *                                         fulfiller\'s token approvals from.\n     *                                         The zero hash signifies that no\n     *                                         conduit should be used (and\n     *                                         direct approvals set on this\n     *                                         contract).\n     * @param recipient                        The intended recipient for all\n     *                                         received items, with `address(0)`\n     *                                         indicating that the caller should\n     *                                         receive the offer items.\n     * @param maximumFulfilled                 The maximum number of orders to\n     *                                         fulfill.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders.\n     */\n    function fulfillAvailableAdvancedOrders(\n        /**\n         * @custom:name advancedOrders\n         */\n        AdvancedOrder[] calldata,\n        /**\n         * @custom:name criteriaResolvers\n         */\n        CriteriaResolver[] calldata,\n        /**\n         * @custom:name offerFulfillments\n         */\n        FulfillmentComponent[][] calldata,\n        /**\n         * @custom:name considerationFulfillments\n         */\n        FulfillmentComponent[][] calldata,\n        bytes32 fulfillerConduitKey,\n        address recipient,\n        uint256 maximumFulfilled\n    )\n        external\n        payable\n        override\n        returns (\n            bool[] memory /* availableOrders */,\n            Execution[] memory /* executions */\n        )\n    {\n        // Fulfill all available orders.\n        return\n            _fulfillAvailableAdvancedOrders(\n                _toAdvancedOrdersReturnType(_decodeAdvancedOrders)(\n                    CalldataStart.pptr()\n                ),\n                _toCriteriaResolversReturnType(_decodeCriteriaResolvers)(\n                    CalldataStart.pptrOffset(\n                        Offset_fulfillAvailableAdvancedOrders_criteriaResolvers\n                    )\n                ),\n                _toNestedFulfillmentComponentsReturnType(\n                    _decodeNestedFulfillmentComponents\n                )(\n                    CalldataStart.pptrOffset(\n                        Offset_fulfillAvailableAdvancedOrders_offerFulfillments\n                    )\n                ),\n                _toNestedFulfillmentComponentsReturnType(\n                    _decodeNestedFulfillmentComponents\n                )(\n                    CalldataStart.pptrOffset(\n                        Offset_fulfillAvailableAdvancedOrders_cnsdrationFlflmnts\n                    )\n                ),\n                fulfillerConduitKey,\n                _substituteCallerForEmptyRecipient(recipient),\n                maximumFulfilled\n            );\n    }\n\n    /**\n     * @notice Match an arbitrary number of orders, each with an arbitrary\n     *         number of items for offer and consideration along with a set of\n     *         fulfillments allocating offer components to consideration\n     *         components. Note that this function does not support\n     *         criteria-based or partial filling of orders (though filling the\n     *         remainder of a partially-filled order is supported). Any unspent\n     *         offer item amounts or native tokens will be transferred to the\n     *         caller.\n     *\n     * @custom:param orders       The orders to match. Note that both the\n     *                            offerer and fulfiller on each order must first\n     *                            approve this contract (or their conduit if\n     *                            indicated by the order) to transfer any\n     *                            relevant tokens on their behalf and each\n     *                            consideration recipient must implement\n     *                            `onERC1155Received` to receive ERC1155 tokens.\n     * @custom:param fulfillments An array of elements allocating offer\n     *                            components to consideration components. Note\n     *                            that each consideration component must be\n     *                            fully met for the match operation to be valid,\n     *                            and that any unspent offer items will be sent\n     *                            unaggregated to the caller.\n     *\n     * @return executions An array of elements indicating the sequence of\n     *                    transfers performed as part of matching the given\n     *                    orders. Note that unspent offer item amounts or native\n     *                    tokens will not be reflected as part of this array.\n     */\n    function matchOrders(\n        /**\n         * @custom:name orders\n         */\n        Order[] calldata,\n        /**\n         * @custom:name fulfillments\n         */\n        Fulfillment[] calldata\n    ) external payable override returns (Execution[] memory /* executions */) {\n        // Convert to advanced, validate, and match orders using fulfillments.\n        return\n            _matchAdvancedOrders(\n                _toAdvancedOrdersReturnType(_decodeOrdersAsAdvancedOrders)(\n                    CalldataStart.pptr()\n                ),\n                new CriteriaResolver[](0), // No criteria resolvers supplied.\n                _toFulfillmentsReturnType(_decodeFulfillments)(\n                    CalldataStart.pptrOffset(Offset_matchOrders_fulfillments)\n                ),\n                msg.sender\n            );\n    }\n\n    /**\n     * @notice Match an arbitrary number of full, partial, or contract orders,\n     *         each with an arbitrary number of items for offer and\n     *         consideration, supplying criteria resolvers containing specific\n     *         token identifiers and associated proofs as well as fulfillments\n     *         allocating offer components to consideration components. Any\n     *         unspent offer item amounts will be transferred to the designated\n     *         recipient (with the null address signifying to use the caller)\n     *         and any unspent native tokens will be returned to the caller.\n     *\n     * @custom:param advancedOrders    The advanced orders to match. Note that\n     *                                 both the offerer and fulfiller on each\n     *                                 order must first approve this contract\n     *                                 (or their conduit if indicated by the\n     *                                 order) to transfer any relevant tokens on\n     *                                 their behalf and each consideration\n     *                                 recipient must implement\n     *                                 `onERC1155Received` to receive ERC1155\n     *                                 tokens. Also note that the offer and\n     *                                 consideration components for each order\n     *                                 must have no remainder after multiplying\n     *                                 the respective amount with the supplied\n     *                                 fraction for the group of partial fills\n     *                                 to be considered valid.\n     * @custom:param criteriaResolvers An array where each element contains a\n     *                                 reference to a specific offer or\n     *                                 consideration, a token identifier, and a\n     *                                 proof that the supplied token identifier\n     *                                 is contained in the merkle root held by\n     *                                 the item in question\'s criteria element.\n     *                                 Note that an empty criteria indicates\n     *                                 that any (transferable) token identifier\n     *                                 on the token in question is valid and\n     *                                 that no associated proof needs to be\n     *                                 supplied.\n     * @custom:param fulfillments      An array of elements allocating offer\n     *                                 components to consideration components.\n     *                                 Note that each consideration component\n     *                                 must be fully met for the match operation\n     *                                 to be valid, and that any unspent offer\n     *                                 items will be sent unaggregated to the\n     *                                 designated recipient.\n     * @param recipient                The intended recipient for all unspent\n     *                                 offer item amounts, or the caller if the\n     *                                 null address is supplied.\n     *\n     * @return executions An array of elements indicating the sequence of\n     *                     transfers performed as part of matching the given\n     *                     orders. Note that unspent offer item amounts or\n     *                     native tokens will not be reflected as part of this\n     *                     array.\n     */\n    function matchAdvancedOrders(\n        /**\n         * @custom:name advancedOrders\n         */\n        AdvancedOrder[] calldata,\n        /**\n         * @custom:name criteriaResolvers\n         */\n        CriteriaResolver[] calldata,\n        /**\n         * @custom:name fulfillments\n         */\n        Fulfillment[] calldata,\n        address recipient\n    ) external payable override returns (Execution[] memory /* executions */) {\n        // Validate and match the advanced orders using supplied fulfillments.\n        return\n            _matchAdvancedOrders(\n                _toAdvancedOrdersReturnType(_decodeAdvancedOrders)(\n                    CalldataStart.pptr()\n                ),\n                _toCriteriaResolversReturnType(_decodeCriteriaResolvers)(\n                    CalldataStart.pptrOffset(\n                        Offset_matchAdvancedOrders_criteriaResolvers\n                    )\n                ),\n                _toFulfillmentsReturnType(_decodeFulfillments)(\n                    CalldataStart.pptrOffset(\n                        Offset_matchAdvancedOrders_fulfillments\n                    )\n                ),\n                _substituteCallerForEmptyRecipient(recipient)\n            );\n    }\n\n    /**\n     * @notice Cancel an arbitrary number of orders. Note that only the offerer\n     *         or the zone of a given order may cancel it. Callers should ensure\n     *         that the intended order was cancelled by calling `getOrderStatus`\n     *         and confirming that `isCancelled` returns `true`.\n     *\n     * @param orders The orders to cancel.\n     *\n     * @return cancelled A boolean indicating whether the supplied orders have\n     *                   been successfully cancelled.\n     */\n    function cancel(\n        OrderComponents[] calldata orders\n    ) external override returns (bool cancelled) {\n        // Cancel the orders.\n        cancelled = _cancel(orders);\n    }\n\n    /**\n     * @notice Validate an arbitrary number of orders, thereby registering their\n     *         signatures as valid and allowing the fulfiller to skip signature\n     *         verification on fulfillment. Note that validated orders may still\n     *         be unfulfillable due to invalid item amounts or other factors;\n     *         callers should determine whether validated orders are fulfillable\n     *         by simulating the fulfillment call prior to execution. Also note\n     *         that anyone can validate a signed order, but only the offerer can\n     *         validate an order without supplying a signature.\n     *\n     * @custom:param orders The orders to validate.\n     *\n     * @return validated A boolean indicating whether the supplied orders have\n     *                   been successfully validated.\n     */\n    function validate(\n        /**\n         * @custom:name orders\n         */\n        Order[] calldata\n    ) external override returns (bool /* validated */) {\n        return\n            _validate(_toOrdersReturnType(_decodeOrders)(CalldataStart.pptr()));\n    }\n\n    /**\n     * @notice Cancel all orders from a given offerer with a given zone in bulk\n     *         by incrementing a counter. Note that only the offerer may\n     *         increment the counter.\n     *\n     * @return newCounter The new counter.\n     */\n    function incrementCounter() external override returns (uint256 newCounter) {\n        // Increment current counter for the supplied offerer.  Note that the\n        // counter is incremented by a large, quasi-random interval.\n        newCounter = _incrementCounter();\n    }\n\n    /**\n     * @notice Retrieve the order hash for a given order.\n     *\n     * @custom:param order The components of the order.\n     *\n     * @return orderHash The order hash.\n     */\n    function getOrderHash(\n        /**\n         * @custom:name order\n         */\n        OrderComponents calldata\n    ) external view override returns (bytes32 orderHash) {\n        CalldataPointer orderPointer = CalldataStart.pptr();\n\n        // Derive order hash by supplying order parameters along with counter.\n        orderHash = _deriveOrderHash(\n            _toOrderParametersReturnType(\n                _decodeOrderComponentsAsOrderParameters\n            )(orderPointer),\n            // Read order counter\n            orderPointer.offset(OrderParameters_counter_offset).readUint256()\n        );\n    }\n\n    /**\n     * @notice Retrieve the status of a given order by hash, including whether\n     *         the order has been cancelled or validated and the fraction of the\n     *         order that has been filled. Since the _orderStatus[orderHash]\n     *         does not get set for contract orders, getOrderStatus will always\n     *         return (false, false, 0, 0) for those hashes. Note that this\n     *         function is susceptible to view reentrancy and so should be used\n     *         with care when calling from other contracts.\n     *\n     * @param orderHash The order hash in question.\n     *\n     * @return isValidated A boolean indicating whether the order in question\n     *                     has been validated (i.e. previously approved or\n     *                     partially filled).\n     * @return isCancelled A boolean indicating whether the order in question\n     *                     has been cancelled.\n     * @return totalFilled The total portion of the order that has been filled\n     *                     (i.e. the ""numerator"").\n     * @return totalSize   The total size of the order that is either filled or\n     *                     unfilled (i.e. the ""denominator"").\n     */\n    function getOrderStatus(\n        bytes32 orderHash\n    )\n        external\n        view\n        override\n        returns (\n            bool isValidated,\n            bool isCancelled,\n            uint256 totalFilled,\n            uint256 totalSize\n        )\n    {\n        // Retrieve the order status using the order hash.\n        return _getOrderStatus(orderHash);\n    }\n\n    /**\n     * @notice Retrieve the current counter for a given offerer.\n     *\n     * @param offerer The offerer in question.\n     *\n     * @return counter The current counter.\n     */\n    function getCounter(\n        address offerer\n    ) external view override returns (uint256 counter) {\n        // Return the counter for the supplied offerer.\n        counter = _getCounter(offerer);\n    }\n\n    /**\n     * @notice Retrieve configuration information for this contract.\n     *\n     * @return version           The contract version.\n     * @return domainSeparator   The domain separator for this contract.\n     * @return conduitController The conduit Controller set for this contract.\n     */\n    function information()\n        external\n        view\n        override\n        returns (\n            string memory version,\n            bytes32 domainSeparator,\n            address conduitController\n        )\n    {\n        // Return the information for this contract.\n        return _information();\n    }\n\n    /**\n     * @dev Gets the contract offerer nonce for the specified contract offerer.\n     *      Note that this function is susceptible to view reentrancy and so\n     *      should be used with care when calling from other contracts.\n     *\n     * @param contractOfferer The contract offerer for which to get the nonce.\n     *\n     * @return nonce The contract offerer nonce.\n     */\n    function getContractOffererNonce(\n        address contractOfferer\n    ) external view override returns (uint256 nonce) {\n        nonce = _contractNonces[contractOfferer];\n    }\n\n    /**\n     * @notice Retrieve the name of this contract.\n     *\n     * @return contractName The name of this contract.\n     */\n    function name()\n        external\n        pure\n        override\n        returns (string memory /* contractName */)\n    {\n        // Return the name of the contract.\n        return _name();\n    }\n}\n'}, 'lib/seaport-types/src/interfaces/ConsiderationInterface.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {\n    AdvancedOrder,\n    BasicOrderParameters,\n    CriteriaResolver,\n    Execution,\n    Fulfillment,\n    FulfillmentComponent,\n    Order,\n    OrderComponents\n} from ""../lib/ConsiderationStructs.sol"";\n\n/**\n * @title ConsiderationInterface\n * @author 0age\n * @custom:version 1.6\n * @notice Consideration is a generalized native token/ERC20/ERC721/ERC1155\n *         marketplace. It minimizes external calls to the greatest extent\n *         possible and provides lightweight methods for common routes as well\n *         as more flexible methods for composing advanced orders.\n *\n * @dev ConsiderationInterface contains all external function interfaces for\n *      Consideration.\n */\ninterface ConsiderationInterface {\n    /**\n     * @notice Fulfill an order offering an ERC721 token by supplying Ether (or\n     *         the native token for the given chain) as consideration for the\n     *         order. An arbitrary number of ""additional recipients"" may also be\n     *         supplied which will each receive native tokens from the fulfiller\n     *         as consideration.\n     *\n     * @param parameters Additional information on the fulfilled order. Note\n     *                   that the offerer must first approve this contract (or\n     *                   their preferred conduit if indicated by the order) for\n     *                   their offered ERC721 token to be transferred.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillBasicOrder(\n        BasicOrderParameters calldata parameters\n    ) external payable returns (bool fulfilled);\n\n    /**\n     * @notice Fulfill an order with an arbitrary number of items for offer and\n     *         consideration. Note that this function does not support\n     *         criteria-based orders or partial filling of orders (though\n     *         filling the remainder of a partially-filled order is supported).\n     *\n     * @param order               The order to fulfill. Note that both the\n     *                            offerer and the fulfiller must first approve\n     *                            this contract (or the corresponding conduit if\n     *                            indicated) to transfer any relevant tokens on\n     *                            their behalf and that contracts must implement\n     *                            `onERC1155Received` to receive ERC1155 tokens\n     *                            as consideration.\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\n     *                            any, to source the fulfiller\'s token approvals\n     *                            from. The zero hash signifies that no conduit\n     *                            should be used, with direct approvals set on\n     *                            Consideration.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillOrder(\n        Order calldata order,\n        bytes32 fulfillerConduitKey\n    ) external payable returns (bool fulfilled);\n\n    /**\n     * @notice Fill an order, fully or partially, with an arbitrary number of\n     *         items for offer and consideration alongside criteria resolvers\n     *         containing specific token identifiers and associated proofs.\n     *\n     * @param advancedOrder       The order to fulfill along with the fraction\n     *                            of the order to attempt to fill. Note that\n     *                            both the offerer and the fulfiller must first\n     *                            approve this contract (or their preferred\n     *                            conduit if indicated by the order) to transfer\n     *                            any relevant tokens on their behalf and that\n     *                            contracts must implement `onERC1155Received`\n     *                            to receive ERC1155 tokens as consideration.\n     *                            Also note that all offer and consideration\n     *                            components must have no remainder after\n     *                            multiplication of the respective amount with\n     *                            the supplied fraction for the partial fill to\n     *                            be considered valid.\n     * @param criteriaResolvers   An array where each element contains a\n     *                            reference to a specific offer or\n     *                            consideration, a token identifier, and a proof\n     *                            that the supplied token identifier is\n     *                            contained in the merkle root held by the item\n     *                            in question\'s criteria element. Note that an\n     *                            empty criteria indicates that any\n     *                            (transferable) token identifier on the token\n     *                            in question is valid and that no associated\n     *                            proof needs to be supplied.\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\n     *                            any, to source the fulfiller\'s token approvals\n     *                            from. The zero hash signifies that no conduit\n     *                            should be used, with direct approvals set on\n     *                            Consideration.\n     * @param recipient           The intended recipient for all received items,\n     *                            with `address(0)` indicating that the caller\n     *                            should receive the items.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillAdvancedOrder(\n        AdvancedOrder calldata advancedOrder,\n        CriteriaResolver[] calldata criteriaResolvers,\n        bytes32 fulfillerConduitKey,\n        address recipient\n    ) external payable returns (bool fulfilled);\n\n    /**\n     * @notice Attempt to fill a group of orders, each with an arbitrary number\n     *         of items for offer and consideration. Any order that is not\n     *         currently active, has already been fully filled, or has been\n     *         cancelled will be omitted. Remaining offer and consideration\n     *         items will then be aggregated where possible as indicated by the\n     *         supplied offer and consideration component arrays and aggregated\n     *         items will be transferred to the fulfiller or to each intended\n     *         recipient, respectively. Note that a failing item transfer or an\n     *         issue with order formatting will cause the entire batch to fail.\n     *         Note that this function does not support criteria-based orders or\n     *         partial filling of orders (though filling the remainder of a\n     *         partially-filled order is supported).\n     *\n     * @param orders                    The orders to fulfill. Note that both\n     *                                  the offerer and the fulfiller must first\n     *                                  approve this contract (or the\n     *                                  corresponding conduit if indicated) to\n     *                                  transfer any relevant tokens on their\n     *                                  behalf and that contracts must implement\n     *                                  `onERC1155Received` to receive ERC1155\n     *                                  tokens as consideration.\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\n     *                                  indicating which offer items to attempt\n     *                                  to aggregate when preparing executions.\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\n     *                                  indicating which consideration items to\n     *                                  attempt to aggregate when preparing\n     *                                  executions.\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\n     *                                  if any, to source the fulfiller\'s token\n     *                                  approvals from. The zero hash signifies\n     *                                  that no conduit should be used, with\n     *                                  direct approvals set on this contract.\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders. Note that unspent offer item amounts or\n     *                         native tokens will not be reflected as part of\n     *                         this array.\n     */\n    function fulfillAvailableOrders(\n        Order[] calldata orders,\n        FulfillmentComponent[][] calldata offerFulfillments,\n        FulfillmentComponent[][] calldata considerationFulfillments,\n        bytes32 fulfillerConduitKey,\n        uint256 maximumFulfilled\n    )\n        external\n        payable\n        returns (bool[] memory availableOrders, Execution[] memory executions);\n\n    /**\n     * @notice Attempt to fill a group of orders, fully or partially, with an\n     *         arbitrary number of items for offer and consideration per order\n     *         alongside criteria resolvers containing specific token\n     *         identifiers and associated proofs. Any order that is not\n     *         currently active, has already been fully filled, or has been\n     *         cancelled will be omitted. Remaining offer and consideration\n     *         items will then be aggregated where possible as indicated by the\n     *         supplied offer and consideration component arrays and aggregated\n     *         items will be transferred to the fulfiller or to each intended\n     *         recipient, respectively. Note that a failing item transfer or an\n     *         issue with order formatting will cause the entire batch to fail.\n     *\n     * @param advancedOrders            The orders to fulfill along with the\n     *                                  fraction of those orders to attempt to\n     *                                  fill. Note that both the offerer and the\n     *                                  fulfiller must first approve this\n     *                                  contract (or their preferred conduit if\n     *                                  indicated by the order) to transfer any\n     *                                  relevant tokens on their behalf and that\n     *                                  contracts must implement\n     *                                  `onERC1155Received` to enable receipt of\n     *                                  ERC1155 tokens as consideration. Also\n     *                                  note that all offer and consideration\n     *                                  components must have no remainder after\n     *                                  multiplication of the respective amount\n     *                                  with the supplied fraction for an\n     *                                  order\'s partial fill amount to be\n     *                                  considered valid.\n     * @param criteriaResolvers         An array where each element contains a\n     *                                  reference to a specific offer or\n     *                                  consideration, a token identifier, and a\n     *                                  proof that the supplied token identifier\n     *                                  is contained in the merkle root held by\n     *                                  the item in question\'s criteria element.\n     *                                  Note that an empty criteria indicates\n     *                                  that any (transferable) token\n     *                                  identifier on the token in question is\n     *                                  valid and that no associated proof needs\n     *                                  to be supplied.\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\n     *                                  indicating which offer items to attempt\n     *                                  to aggregate when preparing executions.\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\n     *                                  indicating which consideration items to\n     *                                  attempt to aggregate when preparing\n     *                                  executions.\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\n     *                                  if any, to source the fulfiller\'s token\n     *                                  approvals from. The zero hash signifies\n     *                                  that no conduit should be used, with\n     *                                  direct approvals set on this contract.\n     * @param recipient                 The intended recipient for all received\n     *                                  items, with `address(0)` indicating that\n     *                                  the caller should receive the items.\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders. Note that unspent offer item amounts or\n     *                         native tokens will not be reflected as part of\n     *                         this array.\n     */\n    function fulfillAvailableAdvancedOrders(\n        AdvancedOrder[] calldata advancedOrders,\n        CriteriaResolver[] calldata criteriaResolvers,\n        FulfillmentComponent[][] calldata offerFulfillments,\n        FulfillmentComponent[][] calldata considerationFulfillments,\n        bytes32 fulfillerConduitKey,\n        address recipient,\n        uint256 maximumFulfilled\n    )\n        external\n        payable\n        returns (bool[] memory availableOrders, Execution[] memory executions);\n\n    /**\n     * @notice Match an arbitrary number of orders, each with an arbitrary\n     *         number of items for offer and consideration along with a set of\n     *         fulfillments allocating offer components to consideration\n     *         components. Note that this function does not support\n     *         criteria-based or partial filling of orders (though filling the\n     *         remainder of a partially-filled order is supported). Any unspent\n     *         offer item amounts or native tokens will be transferred to the\n     *         caller.\n     *\n     * @param orders       The orders to match. Note that both the offerer and\n     *                     fulfiller on each order must first approve this\n     *                     contract (or their conduit if indicated by the order)\n     *                     to transfer any relevant tokens on their behalf and\n     *                     each consideration recipient must implement\n     *                     `onERC1155Received` to enable ERC1155 token receipt.\n     * @param fulfillments An array of elements allocating offer components to\n     *                     consideration components. Note that each\n     *                     consideration component must be fully met for the\n     *                     match operation to be valid.\n     *\n     * @return executions An array of elements indicating the sequence of\n     *                    transfers performed as part of matching the given\n     *                    orders. Note that unspent offer item amounts or\n     *                    native tokens will not be reflected as part of this\n     *                    array.\n     */\n    function matchOrders(\n        Order[] calldata orders,\n        Fulfillment[] calldata fulfillments\n    ) external payable returns (Execution[] memory executions);\n\n    /**\n     * @notice Match an arbitrary number of full or partial orders, each with an\n     *         arbitrary number of items for offer and consideration, supplying\n     *         criteria resolvers containing specific token identifiers and\n     *         associated proofs as well as fulfillments allocating offer\n     *         components to consideration components. Any unspent offer item\n     *         amounts will be transferred to the designated recipient (with the\n     *         null address signifying to use the caller) and any unspent native\n     *         tokens will be returned to the caller.\n     *\n     * @param orders            The advanced orders to match. Note that both the\n     *                          offerer and fulfiller on each order must first\n     *                          approve this contract (or a preferred conduit if\n     *                          indicated by the order) to transfer any relevant\n     *                          tokens on their behalf and each consideration\n     *                          recipient must implement `onERC1155Received` in\n     *                          order to receive ERC1155 tokens. Also note that\n     *                          the offer and consideration components for each\n     *                          order must have no remainder after multiplying\n     *                          the respective amount with the supplied fraction\n     *                          in order for the group of partial fills to be\n     *                          considered valid.\n     * @param criteriaResolvers An array where each element contains a reference\n     *                          to a specific order as well as that order\'s\n     *                          offer or consideration, a token identifier, and\n     *                          a proof that the supplied token identifier is\n     *                          contained in the order\'s merkle root. Note that\n     *                          an empty root indicates that any (transferable)\n     *                          token identifier is valid and that no associated\n     *                          proof needs to be supplied.\n     * @param fulfillments      An array of elements allocating offer components\n     *                          to consideration components. Note that each\n     *                          consideration component must be fully met in\n     *                          order for the match operation to be valid.\n     * @param recipient         The intended recipient for all unspent offer\n     *                          item amounts, or the caller if the null address\n     *                          is supplied.\n     *\n     * @return executions An array of elements indicating the sequence of\n     *                    transfers performed as part of matching the given\n     *                    orders. Note that unspent offer item amounts or native\n     *                    tokens will not be reflected as part of this array.\n     */\n    function matchAdvancedOrders(\n        AdvancedOrder[] calldata orders,\n        CriteriaResolver[] calldata criteriaResolvers,\n        Fulfillment[] calldata fulfillments,\n        address recipient\n    ) external payable returns (Execution[] memory executions);\n\n    /**\n     * @notice Cancel an arbitrary number of orders. Note that only the offerer\n     *         or the zone of a given order may cancel it. Callers should ensure\n     *         that the intended order was cancelled by calling `getOrderStatus`\n     *         and confirming that `isCancelled` returns `true`.\n     *\n     * @param orders The orders to cancel.\n     *\n     * @return cancelled A boolean indicating whether the supplied orders have\n     *                   been successfully cancelled.\n     */\n    function cancel(\n        OrderComponents[] calldata orders\n    ) external returns (bool cancelled);\n\n    /**\n     * @notice Validate an arbitrary number of orders, thereby registering their\n     *         signatures as valid and allowing the fulfiller to skip signature\n     *         verification on fulfillment. Note that validated orders may still\n     *         be unfulfillable due to invalid item amounts or other factors;\n     *         callers should determine whether validated orders are fulfillable\n     *         by simulating the fulfillment call prior to execution. Also note\n     *         that anyone can validate a signed order, but only the offerer can\n     *         validate an order without supplying a signature.\n     *\n     * @param orders The orders to validate.\n     *\n     * @return validated A boolean indicating whether the supplied orders have\n     *                   been successfully validated.\n     */\n    function validate(\n        Order[] calldata orders\n    ) external returns (bool validated);\n\n    /**\n     * @notice Cancel all orders from a given offerer with a given zone in bulk\n     *         by incrementing a counter. Note that only the offerer may\n     *         increment the counter.\n     *\n     * @return newCounter The new counter.\n     */\n    function incrementCounter() external returns (uint256 newCounter);\n\n    /**\n     * @notice Fulfill an order offering an ERC721 token by supplying Ether (or\n     *         the native token for the given chain) as consideration for the\n     *         order. An arbitrary number of ""additional recipients"" may also be\n     *         supplied which will each receive native tokens from the fulfiller\n     *         as consideration. Note that this function costs less gas than\n     *         `fulfillBasicOrder` due to the zero bytes in the function\n     *         selector (0x00000000) which also results in earlier function\n     *         dispatch.\n     *\n     * @param parameters Additional information on the fulfilled order. Note\n     *                   that the offerer must first approve this contract (or\n     *                   their preferred conduit if indicated by the order) for\n     *                   their offered ERC721 token to be transferred.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillBasicOrder_efficient_6GL6yc(\n        BasicOrderParameters calldata parameters\n    ) external payable returns (bool fulfilled);\n\n    /**\n     * @notice Retrieve the order hash for a given order.\n     *\n     * @param order The components of the order.\n     *\n     * @return orderHash The order hash.\n     */\n    function getOrderHash(\n        OrderComponents calldata order\n    ) external view returns (bytes32 orderHash);\n\n    /**\n     * @notice Retrieve the status of a given order by hash, including whether\n     *         the order has been cancelled or validated and the fraction of the\n     *         order that has been filled.\n     *\n     * @param orderHash The order hash in question.\n     *\n     * @return isValidated A boolean indicating whether the order in question\n     *                     has been validated (i.e. previously approved or\n     *                     partially filled).\n     * @return isCancelled A boolean indicating whether the order in question\n     *                     has been cancelled.\n     * @return totalFilled The total portion of the order that has been filled\n     *                     (i.e. the ""numerator"").\n     * @return totalSize   The total size of the order that is either filled or\n     *                     unfilled (i.e. the ""denominator"").\n     */\n    function getOrderStatus(\n        bytes32 orderHash\n    )\n        external\n        view\n        returns (\n            bool isValidated,\n            bool isCancelled,\n            uint256 totalFilled,\n            uint256 totalSize\n        );\n\n    /**\n     * @notice Retrieve the current counter for a given offerer.\n     *\n     * @param offerer The offerer in question.\n     *\n     * @return counter The current counter.\n     */\n    function getCounter(\n        address offerer\n    ) external view returns (uint256 counter);\n\n    /**\n     * @notice Retrieve configuration information for this contract.\n     *\n     * @return version           The contract version.\n     * @return domainSeparator   The domain separator for this contract.\n     * @return conduitController The conduit Controller set for this contract.\n     */\n    function information()\n        external\n        view\n        returns (\n            string memory version,\n            bytes32 domainSeparator,\n            address conduitController\n        );\n\n    function getContractOffererNonce(\n        address contractOfferer\n    ) external view returns (uint256 nonce);\n\n    /**\n     * @notice Retrieve the name of this contract.\n     *\n     * @return contractName The name of this contract.\n     */\n    function name() external view returns (string memory contractName);\n}\n'}, 'lib/seaport-types/src/lib/ConsiderationStructs.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {\n    BasicOrderType,\n    ItemType,\n    OrderType,\n    Side\n} from ""./ConsiderationEnums.sol"";\n\nimport {\n    CalldataPointer,\n    MemoryPointer\n} from ""../helpers/PointerLibraries.sol"";\n\n/**\n * @dev An order contains eleven components: an offerer, a zone (or account that\n *      can cancel the order or restrict who can fulfill the order depending on\n *      the type), the order type (specifying partial fill support as well as\n *      restricted order status), the start and end time, a hash that will be\n *      provided to the zone when validating restricted orders, a salt, a key\n *      corresponding to a given conduit, a counter, and an arbitrary number of\n *      offer items that can be spent along with consideration items that must\n *      be received by their respective recipient.\n */\nstruct OrderComponents {\n    address offerer;\n    address zone;\n    OfferItem[] offer;\n    ConsiderationItem[] consideration;\n    OrderType orderType;\n    uint256 startTime;\n    uint256 endTime;\n    bytes32 zoneHash;\n    uint256 salt;\n    bytes32 conduitKey;\n    uint256 counter;\n}\n\n/**\n * @dev An offer item has five components: an item type (ETH or other native\n *      tokens, ERC20, ERC721, and ERC1155, as well as criteria-based ERC721 and\n *      ERC1155), a token address, a dual-purpose ""identifierOrCriteria""\n *      component that will either represent a tokenId or a merkle root\n *      depending on the item type, and a start and end amount that support\n *      increasing or decreasing amounts over the duration of the respective\n *      order.\n */\nstruct OfferItem {\n    ItemType itemType;\n    address token;\n    uint256 identifierOrCriteria;\n    uint256 startAmount;\n    uint256 endAmount;\n}\n\n/**\n * @dev A consideration item has the same five components as an offer item and\n *      an additional sixth component designating the required recipient of the\n *      item.\n */\nstruct ConsiderationItem {\n    ItemType itemType;\n    address token;\n    uint256 identifierOrCriteria;\n    uint256 startAmount;\n    uint256 endAmount;\n    address payable recipient;\n}\n\n/**\n * @dev A spent item is translated from a utilized offer item and has four\n *      components: an item type (ETH or other native tokens, ERC20, ERC721, and\n *      ERC1155), a token address, a tokenId, and an amount.\n */\nstruct SpentItem {\n    ItemType itemType;\n    address token;\n    uint256 identifier;\n    uint256 amount;\n}\n\n/**\n * @dev A received item is translated from a utilized consideration item and has\n *      the same four components as a spent item, as well as an additional fifth\n *      component designating the required recipient of the item.\n */\nstruct ReceivedItem {\n    ItemType itemType;\n    address token;\n    uint256 identifier;\n    uint256 amount;\n    address payable recipient;\n}\n\n/**\n * @dev For basic orders involving ETH / native / ERC20 <=> ERC721 / ERC1155\n *      matching, a group of six functions may be called that only requires a\n *      subset of the usual order arguments. Note the use of a ""basicOrderType""\n *      enum; this represents both the usual order type as well as the ""route""\n *      of the basic order (a simple derivation function for the basic order\n *      type is `basicOrderType = orderType + (4 * basicOrderRoute)`.)\n */\nstruct BasicOrderParameters {\n    // calldata offset\n    address considerationToken; // 0x24\n    uint256 considerationIdentifier; // 0x44\n    uint256 considerationAmount; // 0x64\n    address payable offerer; // 0x84\n    address zone; // 0xa4\n    address offerToken; // 0xc4\n    uint256 offerIdentifier; // 0xe4\n    uint256 offerAmount; // 0x104\n    BasicOrderType basicOrderType; // 0x124\n    uint256 startTime; // 0x144\n    uint256 endTime; // 0x164\n    bytes32 zoneHash; // 0x184\n    uint256 salt; // 0x1a4\n    bytes32 offererConduitKey; // 0x1c4\n    bytes32 fulfillerConduitKey; // 0x1e4\n    uint256 totalOriginalAdditionalRecipients; // 0x204\n    AdditionalRecipient[] additionalRecipients; // 0x224\n    bytes signature; // 0x244\n    // Total length, excluding dynamic array data: 0x264 (580)\n}\n\n/**\n * @dev Basic orders can supply any number of additional recipients, with the\n *      implied assumption that they are supplied from the offered ETH (or other\n *      native token) or ERC20 token for the order.\n */\nstruct AdditionalRecipient {\n    uint256 amount;\n    address payable recipient;\n}\n\n/**\n * @dev The full set of order components, with the exception of the counter,\n *      must be supplied when fulfilling more sophisticated orders or groups of\n *      orders. The total number of original consideration items must also be\n *      supplied, as the caller may specify additional consideration items.\n */\nstruct OrderParameters {\n    address offerer; // 0x00\n    address zone; // 0x20\n    OfferItem[] offer; // 0x40\n    ConsiderationItem[] consideration; // 0x60\n    OrderType orderType; // 0x80\n    uint256 startTime; // 0xa0\n    uint256 endTime; // 0xc0\n    bytes32 zoneHash; // 0xe0\n    uint256 salt; // 0x100\n    bytes32 conduitKey; // 0x120\n    uint256 totalOriginalConsiderationItems; // 0x140\n    // offer.length                          // 0x160\n}\n\n/**\n * @dev Orders require a signature in addition to the other order parameters.\n */\nstruct Order {\n    OrderParameters parameters;\n    bytes signature;\n}\n\n/**\n * @dev Advanced orders include a numerator (i.e. a fraction to attempt to fill)\n *      and a denominator (the total size of the order) in addition to the\n *      signature and other order parameters. It also supports an optional field\n *      for supplying extra data; this data will be provided to the zone if the\n *      order type is restricted and the zone is not the caller, or will be\n *      provided to the offerer as context for contract order types.\n */\nstruct AdvancedOrder {\n    OrderParameters parameters;\n    uint120 numerator;\n    uint120 denominator;\n    bytes signature;\n    bytes extraData;\n}\n\n/**\n * @dev Orders can be validated (either explicitly via `validate`, or as a\n *      consequence of a full or partial fill), specifically cancelled (they can\n *      also be cancelled in bulk via incrementing a per-zone counter), and\n *      partially or fully filled (with the fraction filled represented by a\n *      numerator and denominator).\n */\nstruct OrderStatus {\n    bool isValidated;\n    bool isCancelled;\n    uint120 numerator;\n    uint120 denominator;\n}\n\n/**\n * @dev A criteria resolver specifies an order, side (offer vs. consideration),\n *      and item index. It then provides a chosen identifier (i.e. tokenId)\n *      alongside a merkle proof demonstrating the identifier meets the required\n *      criteria.\n */\nstruct CriteriaResolver {\n    uint256 orderIndex;\n    Side side;\n    uint256 index;\n    uint256 identifier;\n    bytes32[] criteriaProof;\n}\n\n/**\n * @dev A fulfillment is applied to a group of orders. It decrements a series of\n *      offer and consideration items, then generates a single execution\n *      element. A given fulfillment can be applied to as many offer and\n *      consideration items as desired, but must contain at least one offer and\n *      at least one consideration that match. The fulfillment must also remain\n *      consistent on all key parameters across all offer items (same offerer,\n *      token, type, tokenId, and conduit preference) as well as across all\n *      consideration items (token, type, tokenId, and recipient).\n */\nstruct Fulfillment {\n    FulfillmentComponent[] offerComponents;\n    FulfillmentComponent[] considerationComponents;\n}\n\n/**\n * @dev Each fulfillment component contains one index referencing a specific\n *      order and another referencing a specific offer or consideration item.\n */\nstruct FulfillmentComponent {\n    uint256 orderIndex;\n    uint256 itemIndex;\n}\n\n/**\n * @dev An execution is triggered once all consideration items have been zeroed\n *      out. It sends the item in question from the offerer to the item\'s\n *      recipient, optionally sourcing approvals from either this contract\n *      directly or from the offerer\'s chosen conduit if one is specified. An\n *      execution is not provided as an argument, but rather is derived via\n *      orders, criteria resolvers, and fulfillments (where the total number of\n *      executions will be less than or equal to the total number of indicated\n *      fulfillments) and returned as part of `matchOrders`.\n */\nstruct Execution {\n    ReceivedItem item;\n    address offerer;\n    bytes32 conduitKey;\n}\n\n/**\n * @dev Restricted orders are validated post-execution by calling validateOrder\n *      on the zone. This struct provides context about the order fulfillment\n *      and any supplied extraData, as well as all order hashes fulfilled in a\n *      call to a match or fulfillAvailable method.\n */\nstruct ZoneParameters {\n    bytes32 orderHash;\n    address fulfiller;\n    address offerer;\n    SpentItem[] offer;\n    ReceivedItem[] consideration;\n    bytes extraData;\n    bytes32[] orderHashes;\n    uint256 startTime;\n    uint256 endTime;\n    bytes32 zoneHash;\n}\n\n/**\n * @dev Zones and contract offerers can communicate which schemas they implement\n *      along with any associated metadata related to each schema.\n */\nstruct Schema {\n    uint256 id;\n    bytes metadata;\n}\n\nusing StructPointers for OrderComponents global;\nusing StructPointers for OfferItem global;\nusing StructPointers for ConsiderationItem global;\nusing StructPointers for SpentItem global;\nusing StructPointers for ReceivedItem global;\nusing StructPointers for BasicOrderParameters global;\nusing StructPointers for AdditionalRecipient global;\nusing StructPointers for OrderParameters global;\nusing StructPointers for Order global;\nusing StructPointers for AdvancedOrder global;\nusing StructPointers for OrderStatus global;\nusing StructPointers for CriteriaResolver global;\nusing StructPointers for Fulfillment global;\nusing StructPointers for FulfillmentComponent global;\nusing StructPointers for Execution global;\nusing StructPointers for ZoneParameters global;\n\n/**\n * @dev This library provides a set of functions for converting structs to\n *      pointers.\n */\nlibrary StructPointers {\n    /**\n     * @dev Get a MemoryPointer from OrderComponents.\n     *\n     * @param obj The OrderComponents object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        OrderComponents memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from OrderComponents.\n     *\n     * @param obj The OrderComponents object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        OrderComponents calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from OfferItem.\n     *\n     * @param obj The OfferItem object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        OfferItem memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from OfferItem.\n     *\n     * @param obj The OfferItem object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        OfferItem calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from ConsiderationItem.\n     *\n     * @param obj The ConsiderationItem object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        ConsiderationItem memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from ConsiderationItem.\n     *\n     * @param obj The ConsiderationItem object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        ConsiderationItem calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from SpentItem.\n     *\n     * @param obj The SpentItem object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        SpentItem memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from SpentItem.\n     *\n     * @param obj The SpentItem object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        SpentItem calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from ReceivedItem.\n     *\n     * @param obj The ReceivedItem object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        ReceivedItem memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from ReceivedItem.\n     *\n     * @param obj The ReceivedItem object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        ReceivedItem calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from BasicOrderParameters.\n     *\n     * @param obj The BasicOrderParameters object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        BasicOrderParameters memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from BasicOrderParameters.\n     *\n     * @param obj The BasicOrderParameters object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        BasicOrderParameters calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from AdditionalRecipient.\n     *\n     * @param obj The AdditionalRecipient object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        AdditionalRecipient memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from AdditionalRecipient.\n     *\n     * @param obj The AdditionalRecipient object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        AdditionalRecipient calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from OrderParameters.\n     *\n     * @param obj The OrderParameters object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        OrderParameters memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from OrderParameters.\n     *\n     * @param obj The OrderParameters object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        OrderParameters calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from Order.\n     *\n     * @param obj The Order object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        Order memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from Order.\n     *\n     * @param obj The Order object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        Order calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from AdvancedOrder.\n     *\n     * @param obj The AdvancedOrder object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        AdvancedOrder memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from AdvancedOrder.\n     *\n     * @param obj The AdvancedOrder object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        AdvancedOrder calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from OrderStatus.\n     *\n     * @param obj The OrderStatus object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        OrderStatus memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from OrderStatus.\n     *\n     * @param obj The OrderStatus object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        OrderStatus calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from CriteriaResolver.\n     *\n     * @param obj The CriteriaResolver object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        CriteriaResolver memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from CriteriaResolver.\n     *\n     * @param obj The CriteriaResolver object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        CriteriaResolver calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from Fulfillment.\n     *\n     * @param obj The Fulfillment object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        Fulfillment memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from Fulfillment.\n     *\n     * @param obj The Fulfillment object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        Fulfillment calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from FulfillmentComponent.\n     *\n     * @param obj The FulfillmentComponent object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        FulfillmentComponent memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from FulfillmentComponent.\n     *\n     * @param obj The FulfillmentComponent object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        FulfillmentComponent calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from Execution.\n     *\n     * @param obj The Execution object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        Execution memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from Execution.\n     *\n     * @param obj The Execution object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        Execution calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from ZoneParameters.\n     *\n     * @param obj The ZoneParameters object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        ZoneParameters memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from ZoneParameters.\n     *\n     * @param obj The ZoneParameters object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        ZoneParameters calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n}\n'}, 'src/lib/OrderCombiner.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {\n    Side,\n    ItemType,\n    OrderType\n} from ""seaport-types/src/lib/ConsiderationEnums.sol"";\n\nimport {\n    AdvancedOrder,\n    ConsiderationItem,\n    CriteriaResolver,\n    Execution,\n    Fulfillment,\n    FulfillmentComponent,\n    OfferItem,\n    OrderParameters,\n    ReceivedItem\n} from ""seaport-types/src/lib/ConsiderationStructs.sol"";\n\nimport { OrderFulfiller } from ""./OrderFulfiller.sol"";\n\nimport { FulfillmentApplier } from ""./FulfillmentApplier.sol"";\n\nimport {\n    _revertConsiderationNotMet,\n    _revertInvalidNativeOfferItem,\n    _revertNoSpecifiedOrdersAvailable\n} from ""seaport-types/src/lib/ConsiderationErrors.sol"";\n\nimport {\n    Error_selector_offset,\n    InsufficientNativeTokensSupplied_error_selector,\n    InsufficientNativeTokensSupplied_error_length\n} from ""seaport-types/src/lib/ConsiderationErrorConstants.sol"";\n\nimport {\n    AccumulatorDisarmed,\n    ConsiderationItem_recipient_offset,\n    Execution_offerer_offset,\n    NonMatchSelector_InvalidErrorValue,\n    NonMatchSelector_MagicMask,\n    OneWord,\n    OneWordShift,\n    OrdersMatchedTopic0,\n    ReceivedItem_amount_offset,\n    ReceivedItem_recipient_offset,\n    TwoWords\n} from ""seaport-types/src/lib/ConsiderationConstants.sol"";\n\nimport {\n    MemoryPointer,\n    MemoryPointerLib,\n    ZeroSlotPtr\n} from ""seaport-types/src/helpers/PointerLibraries.sol"";\n\n/**\n * @title OrderCombiner\n * @author 0age\n * @notice OrderCombiner contains logic for fulfilling combinations of orders,\n *         either by matching offer items to consideration items or by\n *         fulfilling orders where available.\n */\ncontract OrderCombiner is OrderFulfiller, FulfillmentApplier {\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) OrderFulfiller(conduitController) {}\n\n    /**\n     * @notice Internal function to attempt to fill a group of orders, fully or\n     *         partially, with an arbitrary number of items for offer and\n     *         consideration per order alongside criteria resolvers containing\n     *         specific token identifiers and associated proofs. Any order that\n     *         is not currently active, has already been fully filled, or has\n     *         been cancelled will be omitted. Remaining offer and consideration\n     *         items will then be aggregated where possible as indicated by the\n     *         supplied offer and consideration component arrays and aggregated\n     *         items will be transferred to the fulfiller or to each intended\n     *         recipient, respectively. Note that a failing item transfer or an\n     *         issue with order formatting will cause the entire batch to fail.\n     *\n     * @param advancedOrders            The orders to fulfill along with the\n     *                                  fraction of those orders to attempt to\n     *                                  fill. Note that both the offerer and the\n     *                                  fulfiller must first approve this\n     *                                  contract (or a conduit if indicated by\n     *                                  the order) to transfer any relevant\n     *                                  tokens on their behalf and that\n     *                                  contracts must implement\n     *                                  `onERC1155Received` in order to receive\n     *                                  ERC1155 tokens as consideration. Also\n     *                                  note that all offer and consideration\n     *                                  components must have no remainder after\n     *                                  multiplication of the respective amount\n     *                                  with the supplied fraction for an\n     *                                  order\'s partial fill amount to be\n     *                                  considered valid.\n     * @param criteriaResolvers         An array where each element contains a\n     *                                  reference to a specific offer or\n     *                                  consideration, a token identifier, and a\n     *                                  proof that the supplied token identifier\n     *                                  is contained in the merkle root held by\n     *                                  the item in question\'s criteria element.\n     *                                  Note that an empty criteria indicates\n     *                                  that any (transferable) token\n     *                                  identifier on the token in question is\n     *                                  valid and that no associated proof needs\n     *                                  to be supplied.\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\n     *                                  indicating which offer items to attempt\n     *                                  to aggregate when preparing executions.\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\n     *                                  indicating which consideration items to\n     *                                  attempt to aggregate when preparing\n     *                                  executions.\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\n     *                                  if any, to source the fulfiller\'s token\n     *                                  approvals from. The zero hash signifies\n     *                                  that no conduit should be used (and\n     *                                  direct approvals set on Consideration).\n     * @param recipient                 The intended recipient for all received\n     *                                  items.\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders.\n     */\n    function _fulfillAvailableAdvancedOrders(\n        AdvancedOrder[] memory advancedOrders,\n        CriteriaResolver[] memory criteriaResolvers,\n        FulfillmentComponent[][] memory offerFulfillments,\n        FulfillmentComponent[][] memory considerationFulfillments,\n        bytes32 fulfillerConduitKey,\n        address recipient,\n        uint256 maximumFulfilled\n    )\n        internal\n        returns (\n            bool[] memory /* availableOrders */,\n            Execution[] memory /* executions */\n        )\n    {\n        // Create a `false` boolean variable to indicate that invalid orders\n        // should NOT revert. Does not use a constant to avoid function\n        // specialization in solc that would increase contract size.\n        bool revertOnInvalid = _runTimeConstantFalse();\n        // Validate orders, apply amounts, & determine if they use conduits.\n        (\n            bytes32[] memory orderHashes,\n            bool containsNonOpen\n        ) = _validateOrdersAndPrepareToFulfill(\n                advancedOrders,\n                criteriaResolvers,\n                revertOnInvalid,\n                maximumFulfilled,\n                recipient\n            );\n\n        // Aggregate used offer and consideration items and execute transfers.\n        return\n            _executeAvailableFulfillments(\n                advancedOrders,\n                offerFulfillments,\n                considerationFulfillments,\n                fulfillerConduitKey,\n                recipient,\n                orderHashes,\n                containsNonOpen\n            );\n    }\n\n    /**\n     * @dev Internal function to validate a group of orders, update their\n     *      statuses, reduce amounts by their previously filled fractions, apply\n     *      criteria resolvers, and emit OrderFulfilled events. Note that this\n     *      function needs to be called before\n     *      _aggregateValidFulfillmentConsiderationItems to set the memory\n     *      layout that _aggregateValidFulfillmentConsiderationItems depends on.\n     *\n     * @param advancedOrders    The advanced orders to validate and reduce by\n     *                          their previously filled amounts.\n     * @param criteriaResolvers An array where each element contains a reference\n     *                          to a specific order as well as that order\'s\n     *                          offer or consideration, a token identifier, and\n     *                          a proof that the supplied token identifier is\n     *                          contained in the order\'s merkle root. Note that\n     *                          a root of zero indicates that any transferable\n     *                          token identifier is valid and that no proof\n     *                          needs to be supplied.\n     * @param revertOnInvalid   A boolean indicating whether to revert on any\n     *                          order being invalid; setting this to false will\n     *                          instead cause the invalid order to be skipped.\n     * @param maximumFulfilled  The maximum number of orders to fulfill.\n     * @param recipient         The intended recipient for all items that do not\n     *                          already have a designated recipient and are not\n     *                          already used as part of a provided fulfillment.\n     *\n     * @return orderHashes     The hashes of the orders being fulfilled.\n     * @return containsNonOpen A boolean indicating whether any restricted or\n     *                         contract orders are present within the provided\n     *                         array of advanced orders.\n     */\n    function _validateOrdersAndPrepareToFulfill(\n        AdvancedOrder[] memory advancedOrders,\n        CriteriaResolver[] memory criteriaResolvers,\n        bool revertOnInvalid,\n        uint256 maximumFulfilled,\n        address recipient\n    ) internal returns (bytes32[] memory orderHashes, bool containsNonOpen) {\n        // Ensure this function cannot be triggered during a reentrant call.\n        _setReentrancyGuard(true); // Native tokens accepted during execution.\n\n        // Declare ""terminal memory offset"" variable for use in efficient loops.\n        uint256 terminalMemoryOffset;\n\n        {\n            // Declare an error buffer indicating status of any native offer\n            // items. Native tokens may only be provided as part of contract\n            // orders or when fulfilling via matchOrders or matchAdvancedOrders;\n            // throw if bits indicating the conditions aren\'t met have been set.\n            uint256 invalidNativeOfferItemErrorBuffer;\n\n            // Use assembly to set the value for the second bit of error buffer.\n            assembly {\n                /**\n                 * Use the 231st bit of the error buffer to indicate whether the\n                 * current function is not matchAdvancedOrders or matchOrders.\n                 *\n                 * sig                                func\n                 * -------------------------------------------------------------\n                 * 1010100000010111010001000 0 000100 matchOrders\n                 * 1111001011010001001010110 0 010010 matchAdvancedOrders\n                 * 1110110110011000101001010 1 110100 fulfillAvailableOrders\n                 * 1000011100100000000110110 1 000001 fulfillAvailableAdvanced\n                 *                           ^ 7th bit\n                 */\n                invalidNativeOfferItemErrorBuffer := and(\n                    NonMatchSelector_MagicMask,\n                    calldataload(0)\n                )\n            }\n\n            unchecked {\n                // Read length of orders array and place on the stack.\n                uint256 totalOrders = advancedOrders.length;\n\n                // Track the order hash for each order being fulfilled.\n                orderHashes = new bytes32[](totalOrders);\n\n                // Determine the memory offset to terminate on during loops.\n                terminalMemoryOffset = (totalOrders + 1) << OneWordShift;\n            }\n\n            // Skip overflow checks as for loops are indexed starting at zero.\n            unchecked {\n                // Declare variable to track if order is not a contract order.\n                bool isNonContract;\n\n                // Iterate over each order.\n                for (\n                    uint256 i = OneWord;\n                    i < terminalMemoryOffset;\n                    i += OneWord\n                ) {\n                    // Retrieve order via pointer to bypass out-of-range check &\n                    // cast function to avoid additional memory allocation.\n                    AdvancedOrder memory advancedOrder = (\n                        _getReadAdvancedOrderByOffset()(advancedOrders, i)\n                    );\n\n                    // Validate it, update status, & determine fraction to fill.\n                    (\n                        bytes32 orderHash,\n                        uint256 numerator,\n                        uint256 denominator\n                    ) = _validateOrder(advancedOrder, revertOnInvalid);\n\n                    // Update the numerator on the order in question.\n                    advancedOrder.numerator = uint120(numerator);\n\n                    // Do not track hash or adjust prices if order is skipped.\n                    if (numerator == 0) {\n                        // Continue iterating through the remaining orders.\n                        continue;\n                    }\n\n                    // Update the denominator on the order in question.\n                    advancedOrder.denominator = uint120(denominator);\n\n                    // Otherwise, track the order hash in question.\n                    assembly {\n                        mstore(add(orderHashes, i), orderHash)\n                    }\n\n                    // Place the start time for the order on the stack.\n                    uint256 startTime = advancedOrder.parameters.startTime;\n\n                    // Place the end time for the order on the stack.\n                    uint256 endTime = advancedOrder.parameters.endTime;\n\n                    {\n                        // Determine order type, used to check for eligibility\n                        // for native token offer items as well as for presence\n                        // of restricted and contract orders or non-open orders.\n                        OrderType orderType = (\n                            advancedOrder.parameters.orderType\n                        );\n\n                        // Utilize assembly to efficiently check order types.\n                        // Note these checks expect that there are no order\n                        // types beyond current set (0-4) and will need to be\n                        // modified if more order types are added.\n                        assembly {\n                            // Assign the variable indicating if the order is\n                            // not a contract order.\n                            isNonContract := lt(orderType, 4)\n\n                            // Update the variable indicating if order is not an\n                            // open order & keep set if it has been set already.\n                            containsNonOpen := or(\n                                containsNonOpen,\n                                gt(orderType, 1)\n                            )\n                        }\n                    }\n\n                    // Retrieve array of offer items for the order in question.\n                    OfferItem[] memory offer = advancedOrder.parameters.offer;\n\n                    // Read length of offer array and place on the stack.\n                    uint256 totalOfferItems = offer.length;\n\n                    // Iterate over each offer item on the order.\n                    for (uint256 j = 0; j < totalOfferItems; ++j) {\n                        // Retrieve the offer item.\n                        OfferItem memory offerItem = offer[j];\n\n                        // If the offer item is for the native token and the\n                        // order type is not a contract order type, set the\n                        // first bit of the error buffer to true.\n                        assembly {\n                            invalidNativeOfferItemErrorBuffer := or(\n                                invalidNativeOfferItemErrorBuffer,\n                                lt(mload(offerItem), isNonContract)\n                            )\n                        }\n\n                        // Apply order fill fraction to offer item end amount.\n                        uint256 endAmount = _getFraction(\n                            numerator,\n                            denominator,\n                            offerItem.endAmount\n                        );\n\n                        // Reuse same fraction if start & end amounts are equal.\n                        if (offerItem.startAmount == offerItem.endAmount) {\n                            // Apply derived amount to both start & end amount.\n                            offerItem.startAmount = endAmount;\n                        } else {\n                            // Apply order fill fraction to item start amount.\n                            offerItem.startAmount = _getFraction(\n                                numerator,\n                                denominator,\n                                offerItem.startAmount\n                            );\n                        }\n\n                        // Adjust offer amount using current time; round down.\n                        uint256 currentAmount = _locateCurrentAmount(\n                            offerItem.startAmount,\n                            endAmount,\n                            startTime,\n                            endTime,\n                            _runTimeConstantFalse() // round down\n                        );\n\n                        // Update amounts in memory to match the current amount.\n                        // Note the end amount is used to track spent amounts.\n                        offerItem.startAmount = currentAmount;\n                        offerItem.endAmount = currentAmount;\n                    }\n\n                    // Retrieve consideration item array for order in question.\n                    ConsiderationItem[] memory consideration = (\n                        advancedOrder.parameters.consideration\n                    );\n\n                    // Read length of consideration array and place on stack.\n                    uint256 totalConsiderationItems = consideration.length;\n\n                    // Iterate over each consideration item on the order.\n                    for (uint256 j = 0; j < totalConsiderationItems; ++j) {\n                        // Retrieve the consideration item.\n                        ConsiderationItem memory considerationItem = (\n                            consideration[j]\n                        );\n\n                        // Apply fraction to consideration item end amount.\n                        uint256 endAmount = _getFraction(\n                            numerator,\n                            denominator,\n                            considerationItem.endAmount\n                        );\n\n                        // Reuse same fraction if start & end amounts are equal.\n                        if (\n                            considerationItem.startAmount ==\n                            considerationItem.endAmount\n                        ) {\n                            // Apply derived amount to both start & end amount.\n                            considerationItem.startAmount = endAmount;\n                        } else {\n                            // Apply fraction to item start amount.\n                            considerationItem.startAmount = _getFraction(\n                                numerator,\n                                denominator,\n                                considerationItem.startAmount\n                            );\n                        }\n\n                        // Adjust amount using current time; round up.\n                        uint256 currentAmount = (\n                            _locateCurrentAmount(\n                                considerationItem.startAmount,\n                                endAmount,\n                                startTime,\n                                endTime,\n                                _runTimeConstantTrue() // round up\n                            )\n                        );\n\n                        // Set the start amount as equal to the current amount.\n                        considerationItem.startAmount = currentAmount;\n\n                        // Utilize assembly to manually ""shift"" the recipient\n                        // value, then copy the start amount to the recipient.\n                        // Note that this sets up the memory layout that is\n                        // subsequently relied upon by\n                        // _aggregateValidFulfillmentConsiderationItems as well\n                        // as during comparison to generated contract orders.\n                        assembly {\n                            // Derive pointer to the recipient using the item\n                            // pointer along with the offset to the recipient.\n                            let considerationItemRecipientPtr := add(\n                                considerationItem,\n                                ConsiderationItem_recipient_offset\n                            )\n\n                            // Write recipient to endAmount, as endAmount is not\n                            // used from this point on and can be repurposed to\n                            // fit the layout of a ReceivedItem.\n                            mstore(\n                                add(\n                                    considerationItem,\n                                    // Note that this value used to be endAmount\n                                    ReceivedItem_recipient_offset\n                                ),\n                                mload(considerationItemRecipientPtr)\n                            )\n\n                            // Write startAmount to recipient, as recipient is\n                            // not used from this point on and can be repurposed\n                            // to track received amounts.\n                            mstore(considerationItemRecipientPtr, currentAmount)\n                        }\n                    }\n                }\n            }\n\n            // If the first bit is set, a native offer item was encountered on\n            // an order that is not a contract order. If the 231st bit is set in\n            // the error buffer, the current function is not matchOrders or\n            // matchAdvancedOrders. If the value is 1 + (1 << 230), then both\n            // 1st and 231st bits were set; in that case, revert with an error.\n            if (\n                invalidNativeOfferItemErrorBuffer ==\n                NonMatchSelector_InvalidErrorValue\n            ) {\n                _revertInvalidNativeOfferItem();\n            }\n        }\n\n        // Apply criteria resolvers to each order as applicable.\n        _applyCriteriaResolvers(advancedOrders, criteriaResolvers);\n\n        // Iterate over each order to check authorization status (for restricted\n        // orders), generate orders (for contract orders), and emit events (for\n        // all available orders) signifying that they have been fulfilled.\n        // Skip overflow checks as all for loops are indexed starting at zero.\n        unchecked {\n            // Declare stack variable outside of the loop to track order hash.\n            bytes32 orderHash;\n\n            // Track whether any orders are still available for fulfillment.\n            bool someOrderAvailable = false;\n\n            // Iterate over each order.\n            for (uint256 i = OneWord; i < terminalMemoryOffset; i += OneWord) {\n                // Retrieve order hash, bypassing out-of-range check.\n                assembly {\n                    orderHash := mload(add(orderHashes, i))\n                }\n\n                // Do not emit an event if no order hash is present.\n                if (orderHash == bytes32(0)) {\n                    continue;\n                }\n\n                // Retrieve order using pointer libraries to bypass out-of-range\n                // check & cast function to avoid additional memory allocation.\n                AdvancedOrder memory advancedOrder = (\n                    _getReadAdvancedOrderByOffset()(advancedOrders, i)\n                );\n\n                // Determine if max number orders have already been fulfilled.\n                if (maximumFulfilled == 0) {\n                    // If so, set the order hash to zero.\n                    assembly {\n                        mstore(add(orderHashes, i), 0)\n                    }\n\n                    // Set the numerator to zero to signal to skip the order.\n                    advancedOrder.numerator = 0;\n\n                    // Continue iterating through the remaining orders.\n                    continue;\n                }\n\n                // Handle final checks and status updates based on order type.\n                if (advancedOrder.parameters.orderType != OrderType.CONTRACT) {\n                    // Check authorization for restricted orders.\n                    if (\n                        !_checkRestrictedAdvancedOrderAuthorization(\n                            advancedOrder,\n                            orderHashes,\n                            orderHash,\n                            (i >> OneWordShift) - 1,\n                            revertOnInvalid\n                        )\n                    ) {\n                        // If authorization check fails, set order hash to zero.\n                        assembly {\n                            mstore(add(orderHashes, i), 0)\n                        }\n\n                        // Set numerator to zero to signal to skip the order.\n                        advancedOrder.numerator = 0;\n\n                        // Continue iterating through the remaining orders.\n                        continue;\n                    }\n\n                    // Update status as long as some fraction is available.\n                    if (\n                        !_updateStatus(\n                            orderHash,\n                            advancedOrder.numerator,\n                            advancedOrder.denominator,\n                            _revertOnFailedUpdate(\n                                advancedOrder.parameters,\n                                revertOnInvalid\n                            )\n                        )\n                    ) {\n                        // If status update fails, set the order hash to zero.\n                        assembly {\n                            mstore(add(orderHashes, i), 0)\n                        }\n\n                        // Set numerator to zero to signal to skip the order.\n                        advancedOrder.numerator = 0;\n\n                        // Continue iterating through the remaining orders.\n                        continue;\n                    }\n                } else {\n                    // Return the generated order based on the order params and\n                    // the provided extra data. If revertOnInvalid is true, the\n                    // function will revert if the input is invalid.\n                    orderHash = _getGeneratedOrder(\n                        advancedOrder.parameters,\n                        advancedOrder.extraData,\n                        revertOnInvalid\n                    );\n\n                    // Write the derived order hash to the order hashes array.\n                    assembly {\n                        mstore(add(orderHashes, i), orderHash)\n                    }\n\n                    // Handle invalid orders, indicated by a zero order hash.\n                    if (orderHash == bytes32(0)) {\n                        // Set numerator to zero to signal to skip the order.\n                        advancedOrder.numerator = 0;\n\n                        // Continue iterating through the remaining orders.\n                        continue;\n                    }\n                }\n\n                // Decrement the number of fulfilled orders.\n                // Skip underflow check as the condition before\n                // implies that maximumFulfilled > 0.\n                --maximumFulfilled;\n\n                // Retrieve parameters for the order in question.\n                OrderParameters memory orderParameters = (\n                    advancedOrder.parameters\n                );\n\n                // Emit an OrderFulfilled event.\n                _emitOrderFulfilledEvent(\n                    orderHash,\n                    orderParameters.offerer,\n                    orderParameters.zone,\n                    recipient,\n                    orderParameters.offer,\n                    orderParameters.consideration\n                );\n\n                // Set the flag indicating that some order is available.\n                someOrderAvailable = true;\n            }\n\n            // Revert if no orders are available.\n            if (!someOrderAvailable) {\n                _revertNoSpecifiedOrdersAvailable();\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function to fulfill a group of validated orders, fully or\n     *      partially, with an arbitrary number of items for offer and\n     *      consideration per order and to execute transfers. Any order that is\n     *      not currently active, has already been fully filled, or has been\n     *      cancelled will be omitted. Remaining offer and consideration items\n     *      will then be aggregated where possible as indicated by the supplied\n     *      offer and consideration component arrays and aggregated items will\n     *      be transferred to the fulfiller or to each intended recipient,\n     *      respectively. Note that a failing item transfer or an issue with\n     *      order formatting will cause the entire batch to fail.\n     *\n     * @param advancedOrders            The orders to fulfill along with the\n     *                                  fraction of those orders to attempt to\n     *                                  fill. Note that both the offerer and the\n     *                                  fulfiller must first approve this\n     *                                  contract (or the conduit if indicated by\n     *                                  the order) to transfer any relevant\n     *                                  tokens on their behalf and that\n     *                                  contracts must implement\n     *                                  `onERC1155Received` in order to receive\n     *                                  ERC1155 tokens as consideration. Also\n     *                                  note that all offer and consideration\n     *                                  components must have no remainder after\n     *                                  multiplication of the respective amount\n     *                                  with the supplied fraction for an\n     *                                  order\'s partial fill amount to be\n     *                                  considered valid.\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\n     *                                  indicating which offer items to attempt\n     *                                  to aggregate when preparing executions.\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\n     *                                  indicating which consideration items to\n     *                                  attempt to aggregate when preparing\n     *                                  executions.\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\n     *                                  if any, to source the fulfiller\'s token\n     *                                  approvals from. The zero hash signifies\n     *                                  that no conduit should be used, with\n     *                                  direct approvals set on Consideration.\n     * @param recipient                 The intended recipient for all items\n     *                                  that do not already have a designated\n     *                                  recipient and are not already used as\n     *                                  part of a provided fulfillment.\n     * @param orderHashes               An array of order hashes for each order.\n     * @param containsNonOpen           A boolean indicating whether any\n     *                                  restricted or contract orders are\n     *                                  present within the provided array of\n     *                                  advanced orders.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders.\n     */\n    function _executeAvailableFulfillments(\n        AdvancedOrder[] memory advancedOrders,\n        FulfillmentComponent[][] memory offerFulfillments,\n        FulfillmentComponent[][] memory considerationFulfillments,\n        bytes32 fulfillerConduitKey,\n        address recipient,\n        bytes32[] memory orderHashes,\n        bool containsNonOpen\n    )\n        internal\n        returns (bool[] memory availableOrders, Execution[] memory executions)\n    {\n        // Retrieve length of offer fulfillments array and place on the stack.\n        uint256 totalOfferFulfillments = offerFulfillments.length;\n\n        // Retrieve length of consideration fulfillments array & place on stack.\n        uint256 totalConsiderationFulfillments = (\n            considerationFulfillments.length\n        );\n\n        // Allocate an execution for each offer and consideration fulfillment.\n        executions = new Execution[](\n            totalOfferFulfillments + totalConsiderationFulfillments\n        );\n\n        // Skip overflow checks as all for loops are indexed starting at zero.\n        unchecked {\n            // Iterate over each offer fulfillment.\n            for (uint256 i = 0; i < totalOfferFulfillments; ++i) {\n                // Derive aggregated execution corresponding with fulfillment\n                // and assign it to the executions array.\n                executions[i] = _aggregateAvailable(\n                    advancedOrders,\n                    Side.OFFER,\n                    offerFulfillments[i],\n                    fulfillerConduitKey,\n                    recipient\n                );\n            }\n\n            // Iterate over each consideration fulfillment.\n            for (uint256 i = 0; i < totalConsiderationFulfillments; ++i) {\n                // Derive aggregated execution corresponding with fulfillment\n                // and assign it to the executions array.\n                executions[i + totalOfferFulfillments] = _aggregateAvailable(\n                    advancedOrders,\n                    Side.CONSIDERATION,\n                    considerationFulfillments[i],\n                    fulfillerConduitKey,\n                    address(0) // unused\n                );\n            }\n        }\n\n        // Perform final checks and return.\n        availableOrders = _performFinalChecksAndExecuteOrders(\n            advancedOrders,\n            executions,\n            orderHashes,\n            recipient,\n            containsNonOpen\n        );\n\n        return (availableOrders, executions);\n    }\n\n    /**\n     * @dev Internal function to perform a final check that each consideration\n     *      item for an arbitrary number of fulfilled orders has been met and to\n     *      trigger associated executions, transferring the respective items.\n     *\n     * @param advancedOrders  The orders to check and perform executions for.\n     * @param executions      An array of elements indicating the sequence of\n     *                        transfers to perform when fulfilling the given\n     *                        orders.\n     * @param orderHashes     An array of order hashes for each order.\n     * @param recipient       The intended recipient for all items that do not\n     *                        already have a designated recipient and are not\n     *                        used as part of a provided fulfillment.\n     * @param containsNonOpen A boolean indicating whether any restricted or\n     *                        contract orders are present within the provided\n     *                        array of advanced orders.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     */\n    function _performFinalChecksAndExecuteOrders(\n        AdvancedOrder[] memory advancedOrders,\n        Execution[] memory executions,\n        bytes32[] memory orderHashes,\n        address recipient,\n        bool containsNonOpen\n    ) internal returns (bool[] memory /* availableOrders */) {\n        // Retrieve the length of the advanced orders array and place on stack.\n        uint256 totalOrders = advancedOrders.length;\n\n        // Initialize array for tracking available orders.\n        bool[] memory availableOrders = new bool[](totalOrders);\n\n        // Initialize an accumulator array. From this point forward, no new\n        // memory regions can be safely allocated until the accumulator is no\n        // longer being utilized, as the accumulator operates in an open-ended\n        // fashion from this memory pointer; existing memory may still be\n        // accessed and modified, however.\n        bytes memory accumulator = new bytes(AccumulatorDisarmed);\n\n        // Skip overflow check: loop index & executions length are both bounded.\n        unchecked {\n            // Determine the memory offset to terminate on during loops.\n            uint256 terminalMemoryOffset = ((executions.length + 1) <<\n                OneWordShift);\n\n            // Iterate over each execution.\n            for (uint256 i = OneWord; i < terminalMemoryOffset; i += OneWord) {\n                // Get execution using pointer libraries to bypass out-of-range\n                // check & cast function to avoid additional memory allocation.\n                Execution memory execution = (\n                    _getReadExecutionByOffset()(executions, i)\n                );\n\n                // Retrieve the associated received item and amount.\n                ReceivedItem memory item = execution.item;\n                uint256 amount = item.amount;\n\n                // Transfer the item specified by the execution as long as the\n                // execution is not a zero-amount execution (which can occur if\n                // the corresponding fulfillment contained only items on orders\n                // that are unavailable or are out of range of the respective\n                // item array).\n                if (amount != 0) {\n                    // Utilize assembly to check for native token balance.\n                    assembly {\n                        // Ensure a sufficient native balance if relevant.\n                        if and(\n                            iszero(mload(item)), // itemType == ItemType.NATIVE\n                            // item.amount > address(this).balance\n                            gt(amount, selfbalance())\n                        ) {\n                            // Store left-padded selector with push4,\n                            // mem[28:32] = selector\n                            mstore(\n                                0,\n                                InsufficientNativeTokensSupplied_error_selector\n                            )\n\n                            // revert(abi.encodeWithSignature(\n                            //   ""InsufficientNativeTokensSupplied()""\n                            // ))\n                            revert(\n                                Error_selector_offset,\n                                InsufficientNativeTokensSupplied_error_length\n                            )\n                        }\n                    }\n\n                    // Transfer the item specified by the execution.\n                    _transfer(\n                        item,\n                        execution.offerer,\n                        execution.conduitKey,\n                        accumulator\n                    );\n                }\n            }\n        }\n\n        // Skip overflow checks as all for loops are indexed starting at zero.\n        unchecked {\n            // Iterate over each order.\n            for (uint256 i = 0; i < totalOrders; ++i) {\n                // Retrieve the order in question.\n                AdvancedOrder memory advancedOrder = advancedOrders[i];\n\n                // Skip the order in question if not being not fulfilled.\n                if (advancedOrder.numerator == 0) {\n                    // Explicitly set availableOrders at the given index to\n                    // guard against the possibility of dirtied memory.\n                    availableOrders[i] = false;\n                    continue;\n                }\n\n                // Mark the order as available.\n                availableOrders[i] = true;\n\n                // Retrieve the order parameters.\n                OrderParameters memory parameters = advancedOrder.parameters;\n\n                {\n                    // Retrieve offer items.\n                    OfferItem[] memory offer = parameters.offer;\n\n                    // Read length of offer array & place on the stack.\n                    uint256 totalOfferItems = offer.length;\n\n                    // Iterate over each offer item to restore it.\n                    for (uint256 j = 0; j < totalOfferItems; ++j) {\n                        // Retrieve the offer item in question.\n                        OfferItem memory offerItem = offer[j];\n\n                        // Transfer to recipient if unspent amount is not zero.\n                        // Note that the transfer will not be reflected in the\n                        // executions array.\n                        if (offerItem.startAmount != 0) {\n                            // Replace endAmount parameter with the recipient to\n                            // make offerItem compatible with the ReceivedItem\n                            // input to _transfer & cache the original endAmount\n                            // so it can be restored after the transfer.\n                            uint256 originalEndAmount = (\n                                _replaceEndAmountWithRecipient(\n                                    offerItem,\n                                    recipient\n                                )\n                            );\n\n                            // Transfer excess offer item amount to recipient.\n                            _toOfferItemInput(_transfer)(\n                                offerItem,\n                                parameters.offerer,\n                                parameters.conduitKey,\n                                accumulator\n                            );\n\n                            // Restore the original endAmount in offerItem.\n                            assembly {\n                                mstore(\n                                    add(\n                                        offerItem,\n                                        ReceivedItem_recipient_offset\n                                    ),\n                                    originalEndAmount\n                                )\n                            }\n                        }\n\n                        // Restore original amount on the offer item.\n                        offerItem.startAmount = offerItem.endAmount;\n                    }\n                }\n\n                {\n                    // Read consideration items & ensure they are fulfilled.\n                    ConsiderationItem[] memory consideration = (\n                        parameters.consideration\n                    );\n\n                    // Read length of consideration array & place on stack.\n                    uint256 totalConsiderationItems = consideration.length;\n\n                    // Iterate over each consideration item.\n                    for (uint256 j = 0; j < totalConsiderationItems; ++j) {\n                        ConsiderationItem memory considerationItem = (\n                            consideration[j]\n                        );\n\n                        // Retrieve remaining amount on consideration item.\n                        uint256 unmetAmount = considerationItem.startAmount;\n\n                        // Revert if the remaining amount is not zero.\n                        if (unmetAmount != 0) {\n                            _revertConsiderationNotMet(i, j, unmetAmount);\n                        }\n\n                        // Utilize assembly to restore the original value.\n                        assembly {\n                            // Write recipient to startAmount.\n                            mstore(\n                                add(\n                                    considerationItem,\n                                    ReceivedItem_amount_offset\n                                ),\n                                mload(\n                                    add(\n                                        considerationItem,\n                                        ConsiderationItem_recipient_offset\n                                    )\n                                )\n                            )\n                        }\n                    }\n                }\n            }\n        }\n\n        // Trigger any accumulated transfers via call to the conduit.\n        _triggerIfArmed(accumulator);\n\n        // Determine whether any native token balance remains.\n        uint256 remainingNativeTokenBalance;\n        assembly {\n            remainingNativeTokenBalance := selfbalance()\n        }\n\n        // Return any remaining native token balance to the caller.\n        if (remainingNativeTokenBalance != 0) {\n            _transferNativeTokens(\n                payable(msg.sender),\n                remainingNativeTokenBalance\n            );\n        }\n\n        // If any restricted or contract orders are present in the group of\n        // orders being fulfilled, perform any validateOrder or ratifyOrder\n        // calls after all executions and related transfers are complete.\n        if (containsNonOpen) {\n            // Iterate over each order a second time.\n            for (uint256 i = 0; i < totalOrders; ) {\n                // Ensure the order in question is being fulfilled.\n                if (availableOrders[i]) {\n                    // Check restricted orders and contract orders.\n                    _assertRestrictedAdvancedOrderValidity(\n                        advancedOrders[i],\n                        orderHashes,\n                        orderHashes[i]\n                    );\n                }\n\n                // Skip overflow checks as for loop is indexed starting at zero.\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        // Clear the reentrancy guard.\n        _clearReentrancyGuard();\n\n        // Return the array containing available orders.\n        return availableOrders;\n    }\n\n    /**\n     * @dev Internal function to emit an OrdersMatched event using the same\n     *      memory region as the existing order hash array.\n     *\n     * @param orderHashes An array of order hashes to include as an argument for\n     *                    the OrdersMatched event.\n     */\n    function _emitOrdersMatched(bytes32[] memory orderHashes) internal {\n        assembly {\n            // Load the array length from memory.\n            let length := mload(orderHashes)\n\n            // Get the full size of the event data - one word for the offset,\n            // one for the array length and one per hash.\n            let dataSize := add(TwoWords, shl(OneWordShift, length))\n\n            // Get pointer to start of data, reusing word before array length\n            // for the offset.\n            let dataPointer := sub(orderHashes, OneWord)\n\n            // Cache the existing word in memory at the offset pointer.\n            let cache := mload(dataPointer)\n\n            // Write an offset of 32.\n            mstore(dataPointer, OneWord)\n\n            // Emit the OrdersMatched event.\n            log1(dataPointer, dataSize, OrdersMatchedTopic0)\n\n            // Restore the cached word.\n            mstore(dataPointer, cache)\n        }\n    }\n\n    /**\n     * @dev Internal function to match an arbitrary number of full or partial\n     *      orders, each with an arbitrary number of items for offer and\n     *      consideration, supplying criteria resolvers containing specific\n     *      token identifiers and associated proofs as well as fulfillments\n     *      allocating offer components to consideration components.\n     *\n     * @param advancedOrders    The advanced orders to match. Note that both the\n     *                          offerer and fulfiller on each order must first\n     *                          approve this contract (or their conduit if\n     *                          indicated by the order) to transfer any relevant\n     *                          tokens on their behalf and each consideration\n     *                          recipient must implement `onERC1155Received` in\n     *                          order to receive ERC1155 tokens. Also note that\n     *                          the offer and consideration components for each\n     *                          order must have no remainder after multiplying\n     *                          the respective amount with the supplied fraction\n     *                          in order for the group of partial fills to be\n     *                          considered valid.\n     * @param criteriaResolvers An array where each element contains a reference\n     *                          to a specific order as well as that order\'s\n     *                          offer or consideration, a token identifier, and\n     *                          a proof that the supplied token identifier is\n     *                          contained in the order\'s merkle root. Note that\n     *                          an empty root indicates that any (transferable)\n     *                          token identifier is valid and that no associated\n     *                          proof needs to be supplied.\n     * @param fulfillments      An array of elements allocating offer components\n     *                          to consideration components. Note that each\n     *                          consideration component must be fully met in\n     *                          order for the match operation to be valid.\n     * @param recipient         The intended recipient for all unspent offer\n     *                          item amounts.\n     *\n     * @return executions An array of elements indicating the sequence of\n     *                    transfers performed as part of matching the given\n     *                    orders.\n     */\n    function _matchAdvancedOrders(\n        AdvancedOrder[] memory advancedOrders,\n        CriteriaResolver[] memory criteriaResolvers,\n        Fulfillment[] memory fulfillments,\n        address recipient\n    ) internal returns (Execution[] memory /* executions */) {\n        // Create a `true` boolean variable to indicate that invalid orders\n        // should revert. Does not use a constant to avoid function\n        // specialization in solc that would increase contract size.\n        bool revertOnInvalid = _runTimeConstantTrue();\n        // Validate orders, update order status, and determine item amounts.\n        (\n            bytes32[] memory orderHashes,\n            bool containsNonOpen\n        ) = _validateOrdersAndPrepareToFulfill(\n                advancedOrders,\n                criteriaResolvers,\n                revertOnInvalid,\n                advancedOrders.length,\n                recipient\n            );\n\n        // Emit OrdersMatched event, providing an array of matched order hashes.\n        _emitOrdersMatched(orderHashes);\n\n        // Fulfill the orders using the supplied fulfillments and recipient.\n        return\n            _fulfillAdvancedOrders(\n                advancedOrders,\n                fulfillments,\n                orderHashes,\n                recipient,\n                containsNonOpen\n            );\n    }\n\n    /**\n     * @dev Internal function to fulfill an arbitrary number of orders, either\n     *      full or partial, after validating, adjusting amounts, and applying\n     *      criteria resolvers.\n     *\n     * @param advancedOrders  The orders to match, including a fraction to\n     *                        attempt to fill for each order.\n     * @param fulfillments    An array of elements allocating offer components\n     *                        to consideration components. Note that the final\n     *                        amount of each consideration component must be\n     *                        zero for a match operation to be considered valid.\n     * @param orderHashes     An array of order hashes for each order.\n     * @param recipient       The intended recipient for all items that do not\n     *                        already have a designated recipient and are not\n     *                        used as part of a provided fulfillment.\n     * @param containsNonOpen A boolean indicating whether any restricted or\n     *                        contract orders are present within the provided\n     *                        array of advanced orders.\n     *\n     * @return executions An array of elements indicating the sequence of\n     *                    transfers performed as part of matching the given\n     *                    orders.\n     */\n    function _fulfillAdvancedOrders(\n        AdvancedOrder[] memory advancedOrders,\n        Fulfillment[] memory fulfillments,\n        bytes32[] memory orderHashes,\n        address recipient,\n        bool containsNonOpen\n    ) internal returns (Execution[] memory executions) {\n        // Retrieve fulfillments array length and place on the stack.\n        uint256 totalFulfillments = fulfillments.length;\n\n        // Allocate executions by fulfillment and apply them to each execution.\n        executions = new Execution[](totalFulfillments);\n\n        // Skip overflow checks as all for loops are indexed starting at zero.\n        unchecked {\n            // Iterate over each fulfillment.\n            for (uint256 i = 0; i < totalFulfillments; ++i) {\n                /// Retrieve the fulfillment in question.\n                Fulfillment memory fulfillment = fulfillments[i];\n\n                // Derive the execution corresponding with the fulfillment and\n                // assign it to the executions array.\n                executions[i] = _applyFulfillment(\n                    advancedOrders,\n                    fulfillment.offerComponents,\n                    fulfillment.considerationComponents,\n                    i\n                );\n            }\n        }\n\n        // Perform final checks and execute orders.\n        _performFinalChecksAndExecuteOrders(\n            advancedOrders,\n            executions,\n            orderHashes,\n            recipient,\n            containsNonOpen\n        );\n\n        // Return the executions array.\n        return executions;\n    }\n\n    /**\n     * @dev Internal view function to determine whether a status update failure\n     *      should cause a revert or allow a skipped order. The call must revert\n     *      if an `authorizeOrder` call has been successfully performed and the\n     *      status update cannot be performed, regardless of whether the order\n     *      could be otherwise marked as skipped. Note that a revert is not\n     *      required on a failed update if the call originates from the zone, as\n     *      no `authorizeOrder` call is performed in that case.\n     *\n     * @param orderParameters The order parameters in question.\n     * @param revertOnInvalid A boolean indicating whether the call should\n     *                        revert for non-restricted order types.\n     *\n     * @return revertOnFailedUpdate A boolean indicating whether the order\n     *                              should revert on a failed status update.\n     */\n    function _revertOnFailedUpdate(\n        OrderParameters memory orderParameters,\n        bool revertOnInvalid\n    ) internal view returns (bool revertOnFailedUpdate) {\n        OrderType orderType = orderParameters.orderType;\n        address zone = orderParameters.zone;\n        assembly {\n            revertOnFailedUpdate := or(\n                revertOnInvalid,\n                and(gt(orderType, 1), iszero(eq(caller(), zone)))\n            )\n        }\n    }\n}\n'}, 'lib/seaport-types/src/helpers/PointerLibraries.sol': {'content': ""// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ntype CalldataPointer is uint256;\n\ntype ReturndataPointer is uint256;\n\ntype MemoryPointer is uint256;\n\nusing CalldataPointerLib for CalldataPointer global;\nusing MemoryPointerLib for MemoryPointer global;\nusing ReturndataPointerLib for ReturndataPointer global;\n\nusing CalldataReaders for CalldataPointer global;\nusing ReturndataReaders for ReturndataPointer global;\nusing MemoryReaders for MemoryPointer global;\nusing MemoryWriters for MemoryPointer global;\n\nCalldataPointer constant CalldataStart = CalldataPointer.wrap(0x04);\nMemoryPointer constant FreeMemoryPPtr = MemoryPointer.wrap(0x40);\nMemoryPointer constant ZeroSlotPtr = MemoryPointer.wrap(0x60);\nuint256 constant IdentityPrecompileAddress = 0x4;\nuint256 constant OffsetOrLengthMask = 0xffffffff;\nuint256 constant _OneWord = 0x20;\nuint256 constant _FreeMemoryPointerSlot = 0x40;\n\n/// @dev Allocates `size` bytes in memory by increasing the free memory pointer\n///    and returns the memory pointer to the first byte of the allocated region.\n// (Free functions cannot have visibility.)\n// solhint-disable-next-line func-visibility\nfunction malloc(uint256 size) pure returns (MemoryPointer mPtr) {\n    assembly {\n        mPtr := mload(_FreeMemoryPointerSlot)\n        mstore(_FreeMemoryPointerSlot, add(mPtr, size))\n    }\n}\n\n// (Free functions cannot have visibility.)\n// solhint-disable-next-line func-visibility\nfunction getFreeMemoryPointer() pure returns (MemoryPointer mPtr) {\n    mPtr = FreeMemoryPPtr.readMemoryPointer();\n}\n\n// (Free functions cannot have visibility.)\n// solhint-disable-next-line func-visibility\nfunction setFreeMemoryPointer(MemoryPointer mPtr) pure {\n    FreeMemoryPPtr.write(mPtr);\n}\n\nlibrary CalldataPointerLib {\n    function lt(\n        CalldataPointer a,\n        CalldataPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := lt(a, b)\n        }\n    }\n\n    function gt(\n        CalldataPointer a,\n        CalldataPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := gt(a, b)\n        }\n    }\n\n    function eq(\n        CalldataPointer a,\n        CalldataPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := eq(a, b)\n        }\n    }\n\n    function isNull(CalldataPointer a) internal pure returns (bool b) {\n        assembly {\n            b := iszero(a)\n        }\n    }\n\n    /// @dev Resolves an offset stored at `cdPtr + headOffset` to a calldata.\n    ///      pointer `cdPtr` must point to some parent object with a dynamic\n    ///      type's head stored at `cdPtr + headOffset`.\n    function pptrOffset(\n        CalldataPointer cdPtr,\n        uint256 headOffset\n    ) internal pure returns (CalldataPointer cdPtrChild) {\n        cdPtrChild = cdPtr.offset(\n            cdPtr.offset(headOffset).readUint256() & OffsetOrLengthMask\n        );\n    }\n\n    /// @dev Resolves an offset stored at `cdPtr` to a calldata pointer.\n    ///      `cdPtr` must point to some parent object with a dynamic type as its\n    ///      first member, e.g. `struct { bytes data; }`\n    function pptr(\n        CalldataPointer cdPtr\n    ) internal pure returns (CalldataPointer cdPtrChild) {\n        cdPtrChild = cdPtr.offset(cdPtr.readUint256() & OffsetOrLengthMask);\n    }\n\n    /// @dev Returns the calldata pointer one word after `cdPtr`.\n    function next(\n        CalldataPointer cdPtr\n    ) internal pure returns (CalldataPointer cdPtrNext) {\n        assembly {\n            cdPtrNext := add(cdPtr, _OneWord)\n        }\n    }\n\n    /// @dev Returns the calldata pointer `_offset` bytes after `cdPtr`.\n    function offset(\n        CalldataPointer cdPtr,\n        uint256 _offset\n    ) internal pure returns (CalldataPointer cdPtrNext) {\n        assembly {\n            cdPtrNext := add(cdPtr, _offset)\n        }\n    }\n\n    /// @dev Copies `size` bytes from calldata starting at `src` to memory at\n    ///      `dst`.\n    function copy(\n        CalldataPointer src,\n        MemoryPointer dst,\n        uint256 size\n    ) internal pure {\n        assembly {\n            calldatacopy(dst, src, size)\n        }\n    }\n}\n\nlibrary ReturndataPointerLib {\n    function lt(\n        ReturndataPointer a,\n        ReturndataPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := lt(a, b)\n        }\n    }\n\n    function gt(\n        ReturndataPointer a,\n        ReturndataPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := gt(a, b)\n        }\n    }\n\n    function eq(\n        ReturndataPointer a,\n        ReturndataPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := eq(a, b)\n        }\n    }\n\n    function isNull(ReturndataPointer a) internal pure returns (bool b) {\n        assembly {\n            b := iszero(a)\n        }\n    }\n\n    /// @dev Resolves an offset stored at `rdPtr + headOffset` to a returndata\n    ///      pointer. `rdPtr` must point to some parent object with a dynamic\n    ///      type's head stored at `rdPtr + headOffset`.\n    function pptrOffset(\n        ReturndataPointer rdPtr,\n        uint256 headOffset\n    ) internal pure returns (ReturndataPointer rdPtrChild) {\n        rdPtrChild = rdPtr.offset(\n            rdPtr.offset(headOffset).readUint256() & OffsetOrLengthMask\n        );\n    }\n\n    /// @dev Resolves an offset stored at `rdPtr` to a returndata pointer.\n    ///    `rdPtr` must point to some parent object with a dynamic type as its\n    ///    first member, e.g. `struct { bytes data; }`\n    function pptr(\n        ReturndataPointer rdPtr\n    ) internal pure returns (ReturndataPointer rdPtrChild) {\n        rdPtrChild = rdPtr.offset(rdPtr.readUint256() & OffsetOrLengthMask);\n    }\n\n    /// @dev Returns the returndata pointer one word after `cdPtr`.\n    function next(\n        ReturndataPointer rdPtr\n    ) internal pure returns (ReturndataPointer rdPtrNext) {\n        assembly {\n            rdPtrNext := add(rdPtr, _OneWord)\n        }\n    }\n\n    /// @dev Returns the returndata pointer `_offset` bytes after `cdPtr`.\n    function offset(\n        ReturndataPointer rdPtr,\n        uint256 _offset\n    ) internal pure returns (ReturndataPointer rdPtrNext) {\n        assembly {\n            rdPtrNext := add(rdPtr, _offset)\n        }\n    }\n\n    /// @dev Copies `size` bytes from returndata starting at `src` to memory at\n    /// `dst`.\n    function copy(\n        ReturndataPointer src,\n        MemoryPointer dst,\n        uint256 size\n    ) internal pure {\n        assembly {\n            returndatacopy(dst, src, size)\n        }\n    }\n}\n\nlibrary MemoryPointerLib {\n    function copy(\n        MemoryPointer src,\n        MemoryPointer dst,\n        uint256 size\n    ) internal view {\n        assembly {\n            let success := staticcall(\n                gas(),\n                IdentityPrecompileAddress,\n                src,\n                size,\n                dst,\n                size\n            )\n            if or(iszero(returndatasize()), iszero(success)) {\n                revert(0, 0)\n            }\n        }\n    }\n\n    function lt(\n        MemoryPointer a,\n        MemoryPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := lt(a, b)\n        }\n    }\n\n    function gt(\n        MemoryPointer a,\n        MemoryPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := gt(a, b)\n        }\n    }\n\n    function eq(\n        MemoryPointer a,\n        MemoryPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := eq(a, b)\n        }\n    }\n\n    function isNull(MemoryPointer a) internal pure returns (bool b) {\n        assembly {\n            b := iszero(a)\n        }\n    }\n\n    function hash(\n        MemoryPointer ptr,\n        uint256 length\n    ) internal pure returns (bytes32 _hash) {\n        assembly {\n            _hash := keccak256(ptr, length)\n        }\n    }\n\n    /// @dev Returns the memory pointer one word after `mPtr`.\n    function next(\n        MemoryPointer mPtr\n    ) internal pure returns (MemoryPointer mPtrNext) {\n        assembly {\n            mPtrNext := add(mPtr, _OneWord)\n        }\n    }\n\n    /// @dev Returns the memory pointer `_offset` bytes after `mPtr`.\n    function offset(\n        MemoryPointer mPtr,\n        uint256 _offset\n    ) internal pure returns (MemoryPointer mPtrNext) {\n        assembly {\n            mPtrNext := add(mPtr, _offset)\n        }\n    }\n\n    /// @dev Resolves a pointer at `mPtr + headOffset` to a memory\n    ///    pointer. `mPtr` must point to some parent object with a dynamic\n    ///    type's pointer stored at `mPtr + headOffset`.\n    function pptrOffset(\n        MemoryPointer mPtr,\n        uint256 headOffset\n    ) internal pure returns (MemoryPointer mPtrChild) {\n        mPtrChild = mPtr.offset(headOffset).readMemoryPointer();\n    }\n\n    /// @dev Resolves a pointer stored at `mPtr` to a memory pointer.\n    ///    `mPtr` must point to some parent object with a dynamic type as its\n    ///    first member, e.g. `struct { bytes data; }`\n    function pptr(\n        MemoryPointer mPtr\n    ) internal pure returns (MemoryPointer mPtrChild) {\n        mPtrChild = mPtr.readMemoryPointer();\n    }\n}\n\nlibrary CalldataReaders {\n    /// @dev Reads the value at `cdPtr` and applies a mask to return only the\n    ///    last 4 bytes.\n    function readMaskedUint256(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint256 value) {\n        value = cdPtr.readUint256() & OffsetOrLengthMask;\n    }\n\n    /// @dev Reads the bool at `cdPtr` in calldata.\n    function readBool(\n        CalldataPointer cdPtr\n    ) internal pure returns (bool value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the address at `cdPtr` in calldata.\n    function readAddress(\n        CalldataPointer cdPtr\n    ) internal pure returns (address value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes1 at `cdPtr` in calldata.\n    function readBytes1(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes1 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes2 at `cdPtr` in calldata.\n    function readBytes2(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes2 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes3 at `cdPtr` in calldata.\n    function readBytes3(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes3 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes4 at `cdPtr` in calldata.\n    function readBytes4(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes4 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes5 at `cdPtr` in calldata.\n    function readBytes5(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes5 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes6 at `cdPtr` in calldata.\n    function readBytes6(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes6 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes7 at `cdPtr` in calldata.\n    function readBytes7(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes7 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes8 at `cdPtr` in calldata.\n    function readBytes8(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes8 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes9 at `cdPtr` in calldata.\n    function readBytes9(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes9 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes10 at `cdPtr` in calldata.\n    function readBytes10(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes10 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes11 at `cdPtr` in calldata.\n    function readBytes11(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes11 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes12 at `cdPtr` in calldata.\n    function readBytes12(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes12 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes13 at `cdPtr` in calldata.\n    function readBytes13(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes13 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes14 at `cdPtr` in calldata.\n    function readBytes14(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes14 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes15 at `cdPtr` in calldata.\n    function readBytes15(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes15 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes16 at `cdPtr` in calldata.\n    function readBytes16(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes16 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes17 at `cdPtr` in calldata.\n    function readBytes17(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes17 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes18 at `cdPtr` in calldata.\n    function readBytes18(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes18 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes19 at `cdPtr` in calldata.\n    function readBytes19(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes19 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes20 at `cdPtr` in calldata.\n    function readBytes20(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes20 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes21 at `cdPtr` in calldata.\n    function readBytes21(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes21 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes22 at `cdPtr` in calldata.\n    function readBytes22(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes22 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes23 at `cdPtr` in calldata.\n    function readBytes23(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes23 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes24 at `cdPtr` in calldata.\n    function readBytes24(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes24 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes25 at `cdPtr` in calldata.\n    function readBytes25(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes25 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes26 at `cdPtr` in calldata.\n    function readBytes26(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes26 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes27 at `cdPtr` in calldata.\n    function readBytes27(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes27 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes28 at `cdPtr` in calldata.\n    function readBytes28(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes28 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes29 at `cdPtr` in calldata.\n    function readBytes29(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes29 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes30 at `cdPtr` in calldata.\n    function readBytes30(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes30 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes31 at `cdPtr` in calldata.\n    function readBytes31(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes31 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes32 at `cdPtr` in calldata.\n    function readBytes32(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes32 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint8 at `cdPtr` in calldata.\n    function readUint8(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint8 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint16 at `cdPtr` in calldata.\n    function readUint16(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint16 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint24 at `cdPtr` in calldata.\n    function readUint24(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint24 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint32 at `cdPtr` in calldata.\n    function readUint32(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint32 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint40 at `cdPtr` in calldata.\n    function readUint40(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint40 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint48 at `cdPtr` in calldata.\n    function readUint48(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint48 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint56 at `cdPtr` in calldata.\n    function readUint56(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint56 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint64 at `cdPtr` in calldata.\n    function readUint64(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint64 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint72 at `cdPtr` in calldata.\n    function readUint72(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint72 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint80 at `cdPtr` in calldata.\n    function readUint80(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint80 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint88 at `cdPtr` in calldata.\n    function readUint88(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint88 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint96 at `cdPtr` in calldata.\n    function readUint96(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint96 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint104 at `cdPtr` in calldata.\n    function readUint104(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint104 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint112 at `cdPtr` in calldata.\n    function readUint112(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint112 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint120 at `cdPtr` in calldata.\n    function readUint120(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint120 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint128 at `cdPtr` in calldata.\n    function readUint128(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint128 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint136 at `cdPtr` in calldata.\n    function readUint136(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint136 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint144 at `cdPtr` in calldata.\n    function readUint144(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint144 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint152 at `cdPtr` in calldata.\n    function readUint152(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint152 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint160 at `cdPtr` in calldata.\n    function readUint160(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint160 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint168 at `cdPtr` in calldata.\n    function readUint168(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint168 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint176 at `cdPtr` in calldata.\n    function readUint176(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint176 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint184 at `cdPtr` in calldata.\n    function readUint184(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint184 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint192 at `cdPtr` in calldata.\n    function readUint192(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint192 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint200 at `cdPtr` in calldata.\n    function readUint200(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint200 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint208 at `cdPtr` in calldata.\n    function readUint208(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint208 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint216 at `cdPtr` in calldata.\n    function readUint216(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint216 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint224 at `cdPtr` in calldata.\n    function readUint224(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint224 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint232 at `cdPtr` in calldata.\n    function readUint232(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint232 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint240 at `cdPtr` in calldata.\n    function readUint240(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint240 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint248 at `cdPtr` in calldata.\n    function readUint248(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint248 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint256 at `cdPtr` in calldata.\n    function readUint256(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint256 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int8 at `cdPtr` in calldata.\n    function readInt8(\n        CalldataPointer cdPtr\n    ) internal pure returns (int8 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int16 at `cdPtr` in calldata.\n    function readInt16(\n        CalldataPointer cdPtr\n    ) internal pure returns (int16 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int24 at `cdPtr` in calldata.\n    function readInt24(\n        CalldataPointer cdPtr\n    ) internal pure returns (int24 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int32 at `cdPtr` in calldata.\n    function readInt32(\n        CalldataPointer cdPtr\n    ) internal pure returns (int32 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int40 at `cdPtr` in calldata.\n    function readInt40(\n        CalldataPointer cdPtr\n    ) internal pure returns (int40 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int48 at `cdPtr` in calldata.\n    function readInt48(\n        CalldataPointer cdPtr\n    ) internal pure returns (int48 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int56 at `cdPtr` in calldata.\n    function readInt56(\n        CalldataPointer cdPtr\n    ) internal pure returns (int56 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int64 at `cdPtr` in calldata.\n    function readInt64(\n        CalldataPointer cdPtr\n    ) internal pure returns (int64 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int72 at `cdPtr` in calldata.\n    function readInt72(\n        CalldataPointer cdPtr\n    ) internal pure returns (int72 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int80 at `cdPtr` in calldata.\n    function readInt80(\n        CalldataPointer cdPtr\n    ) internal pure returns (int80 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int88 at `cdPtr` in calldata.\n    function readInt88(\n        CalldataPointer cdPtr\n    ) internal pure returns (int88 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int96 at `cdPtr` in calldata.\n    function readInt96(\n        CalldataPointer cdPtr\n    ) internal pure returns (int96 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int104 at `cdPtr` in calldata.\n    function readInt104(\n        CalldataPointer cdPtr\n    ) internal pure returns (int104 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int112 at `cdPtr` in calldata.\n    function readInt112(\n        CalldataPointer cdPtr\n    ) internal pure returns (int112 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int120 at `cdPtr` in calldata.\n    function readInt120(\n        CalldataPointer cdPtr\n    ) internal pure returns (int120 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int128 at `cdPtr` in calldata.\n    function readInt128(\n        CalldataPointer cdPtr\n    ) internal pure returns (int128 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int136 at `cdPtr` in calldata.\n    function readInt136(\n        CalldataPointer cdPtr\n    ) internal pure returns (int136 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int144 at `cdPtr` in calldata.\n    function readInt144(\n        CalldataPointer cdPtr\n    ) internal pure returns (int144 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int152 at `cdPtr` in calldata.\n    function readInt152(\n        CalldataPointer cdPtr\n    ) internal pure returns (int152 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int160 at `cdPtr` in calldata.\n    function readInt160(\n        CalldataPointer cdPtr\n    ) internal pure returns (int160 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int168 at `cdPtr` in calldata.\n    function readInt168(\n        CalldataPointer cdPtr\n    ) internal pure returns (int168 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int176 at `cdPtr` in calldata.\n    function readInt176(\n        CalldataPointer cdPtr\n    ) internal pure returns (int176 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int184 at `cdPtr` in calldata.\n    function readInt184(\n        CalldataPointer cdPtr\n    ) internal pure returns (int184 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int192 at `cdPtr` in calldata.\n    function readInt192(\n        CalldataPointer cdPtr\n    ) internal pure returns (int192 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int200 at `cdPtr` in calldata.\n    function readInt200(\n        CalldataPointer cdPtr\n    ) internal pure returns (int200 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int208 at `cdPtr` in calldata.\n    function readInt208(\n        CalldataPointer cdPtr\n    ) internal pure returns (int208 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int216 at `cdPtr` in calldata.\n    function readInt216(\n        CalldataPointer cdPtr\n    ) internal pure returns (int216 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int224 at `cdPtr` in calldata.\n    function readInt224(\n        CalldataPointer cdPtr\n    ) internal pure returns (int224 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int232 at `cdPtr` in calldata.\n    function readInt232(\n        CalldataPointer cdPtr\n    ) internal pure returns (int232 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int240 at `cdPtr` in calldata.\n    function readInt240(\n        CalldataPointer cdPtr\n    ) internal pure returns (int240 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int248 at `cdPtr` in calldata.\n    function readInt248(\n        CalldataPointer cdPtr\n    ) internal pure returns (int248 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int256 at `cdPtr` in calldata.\n    function readInt256(\n        CalldataPointer cdPtr\n    ) internal pure returns (int256 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n}\n\nlibrary ReturndataReaders {\n    /// @dev Reads value at `rdPtr` & applies a mask to return only last 4 bytes\n    function readMaskedUint256(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint256 value) {\n        value = rdPtr.readUint256() & OffsetOrLengthMask;\n    }\n\n    /// @dev Reads the bool at `rdPtr` in returndata.\n    function readBool(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bool value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the address at `rdPtr` in returndata.\n    function readAddress(\n        ReturndataPointer rdPtr\n    ) internal pure returns (address value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes1 at `rdPtr` in returndata.\n    function readBytes1(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes1 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes2 at `rdPtr` in returndata.\n    function readBytes2(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes2 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes3 at `rdPtr` in returndata.\n    function readBytes3(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes3 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes4 at `rdPtr` in returndata.\n    function readBytes4(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes4 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes5 at `rdPtr` in returndata.\n    function readBytes5(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes5 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes6 at `rdPtr` in returndata.\n    function readBytes6(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes6 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes7 at `rdPtr` in returndata.\n    function readBytes7(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes7 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes8 at `rdPtr` in returndata.\n    function readBytes8(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes8 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes9 at `rdPtr` in returndata.\n    function readBytes9(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes9 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes10 at `rdPtr` in returndata.\n    function readBytes10(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes10 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes11 at `rdPtr` in returndata.\n    function readBytes11(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes11 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes12 at `rdPtr` in returndata.\n    function readBytes12(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes12 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes13 at `rdPtr` in returndata.\n    function readBytes13(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes13 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes14 at `rdPtr` in returndata.\n    function readBytes14(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes14 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes15 at `rdPtr` in returndata.\n    function readBytes15(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes15 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes16 at `rdPtr` in returndata.\n    function readBytes16(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes16 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes17 at `rdPtr` in returndata.\n    function readBytes17(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes17 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes18 at `rdPtr` in returndata.\n    function readBytes18(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes18 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes19 at `rdPtr` in returndata.\n    function readBytes19(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes19 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes20 at `rdPtr` in returndata.\n    function readBytes20(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes20 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes21 at `rdPtr` in returndata.\n    function readBytes21(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes21 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes22 at `rdPtr` in returndata.\n    function readBytes22(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes22 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes23 at `rdPtr` in returndata.\n    function readBytes23(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes23 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes24 at `rdPtr` in returndata.\n    function readBytes24(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes24 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes25 at `rdPtr` in returndata.\n    function readBytes25(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes25 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes26 at `rdPtr` in returndata.\n    function readBytes26(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes26 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes27 at `rdPtr` in returndata.\n    function readBytes27(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes27 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes28 at `rdPtr` in returndata.\n    function readBytes28(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes28 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes29 at `rdPtr` in returndata.\n    function readBytes29(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes29 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes30 at `rdPtr` in returndata.\n    function readBytes30(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes30 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes31 at `rdPtr` in returndata.\n    function readBytes31(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes31 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes32 at `rdPtr` in returndata.\n    function readBytes32(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes32 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint8 at `rdPtr` in returndata.\n    function readUint8(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint8 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint16 at `rdPtr` in returndata.\n    function readUint16(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint16 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint24 at `rdPtr` in returndata.\n    function readUint24(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint24 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint32 at `rdPtr` in returndata.\n    function readUint32(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint32 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint40 at `rdPtr` in returndata.\n    function readUint40(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint40 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint48 at `rdPtr` in returndata.\n    function readUint48(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint48 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint56 at `rdPtr` in returndata.\n    function readUint56(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint56 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint64 at `rdPtr` in returndata.\n    function readUint64(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint64 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint72 at `rdPtr` in returndata.\n    function readUint72(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint72 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint80 at `rdPtr` in returndata.\n    function readUint80(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint80 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint88 at `rdPtr` in returndata.\n    function readUint88(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint88 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint96 at `rdPtr` in returndata.\n    function readUint96(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint96 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint104 at `rdPtr` in returndata.\n    function readUint104(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint104 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint112 at `rdPtr` in returndata.\n    function readUint112(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint112 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint120 at `rdPtr` in returndata.\n    function readUint120(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint120 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint128 at `rdPtr` in returndata.\n    function readUint128(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint128 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint136 at `rdPtr` in returndata.\n    function readUint136(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint136 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint144 at `rdPtr` in returndata.\n    function readUint144(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint144 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint152 at `rdPtr` in returndata.\n    function readUint152(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint152 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint160 at `rdPtr` in returndata.\n    function readUint160(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint160 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint168 at `rdPtr` in returndata.\n    function readUint168(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint168 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint176 at `rdPtr` in returndata.\n    function readUint176(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint176 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint184 at `rdPtr` in returndata.\n    function readUint184(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint184 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint192 at `rdPtr` in returndata.\n    function readUint192(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint192 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint200 at `rdPtr` in returndata.\n    function readUint200(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint200 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint208 at `rdPtr` in returndata.\n    function readUint208(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint208 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint216 at `rdPtr` in returndata.\n    function readUint216(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint216 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint224 at `rdPtr` in returndata.\n    function readUint224(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint224 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint232 at `rdPtr` in returndata.\n    function readUint232(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint232 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint240 at `rdPtr` in returndata.\n    function readUint240(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint240 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint248 at `rdPtr` in returndata.\n    function readUint248(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint248 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint256 at `rdPtr` in returndata.\n    function readUint256(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint256 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int8 at `rdPtr` in returndata.\n    function readInt8(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int8 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int16 at `rdPtr` in returndata.\n    function readInt16(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int16 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int24 at `rdPtr` in returndata.\n    function readInt24(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int24 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int32 at `rdPtr` in returndata.\n    function readInt32(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int32 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int40 at `rdPtr` in returndata.\n    function readInt40(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int40 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int48 at `rdPtr` in returndata.\n    function readInt48(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int48 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int56 at `rdPtr` in returndata.\n    function readInt56(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int56 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int64 at `rdPtr` in returndata.\n    function readInt64(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int64 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int72 at `rdPtr` in returndata.\n    function readInt72(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int72 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int80 at `rdPtr` in returndata.\n    function readInt80(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int80 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int88 at `rdPtr` in returndata.\n    function readInt88(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int88 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int96 at `rdPtr` in returndata.\n    function readInt96(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int96 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int104 at `rdPtr` in returndata.\n    function readInt104(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int104 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int112 at `rdPtr` in returndata.\n    function readInt112(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int112 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int120 at `rdPtr` in returndata.\n    function readInt120(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int120 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int128 at `rdPtr` in returndata.\n    function readInt128(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int128 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int136 at `rdPtr` in returndata.\n    function readInt136(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int136 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int144 at `rdPtr` in returndata.\n    function readInt144(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int144 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int152 at `rdPtr` in returndata.\n    function readInt152(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int152 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int160 at `rdPtr` in returndata.\n    function readInt160(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int160 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int168 at `rdPtr` in returndata.\n    function readInt168(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int168 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int176 at `rdPtr` in returndata.\n    function readInt176(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int176 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int184 at `rdPtr` in returndata.\n    function readInt184(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int184 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int192 at `rdPtr` in returndata.\n    function readInt192(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int192 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int200 at `rdPtr` in returndata.\n    function readInt200(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int200 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int208 at `rdPtr` in returndata.\n    function readInt208(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int208 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int216 at `rdPtr` in returndata.\n    function readInt216(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int216 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int224 at `rdPtr` in returndata.\n    function readInt224(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int224 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int232 at `rdPtr` in returndata.\n    function readInt232(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int232 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int240 at `rdPtr` in returndata.\n    function readInt240(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int240 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int248 at `rdPtr` in returndata.\n    function readInt248(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int248 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int256 at `rdPtr` in returndata.\n    function readInt256(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int256 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n}\n\nlibrary MemoryReaders {\n    /// @dev Reads the memory pointer at `mPtr` in memory.\n    function readMemoryPointer(\n        MemoryPointer mPtr\n    ) internal pure returns (MemoryPointer value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads value at `mPtr` & applies a mask to return only last 4 bytes\n    function readMaskedUint256(\n        MemoryPointer mPtr\n    ) internal pure returns (uint256 value) {\n        value = mPtr.readUint256() & OffsetOrLengthMask;\n    }\n\n    /// @dev Reads the bool at `mPtr` in memory.\n    function readBool(MemoryPointer mPtr) internal pure returns (bool value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the address at `mPtr` in memory.\n    function readAddress(\n        MemoryPointer mPtr\n    ) internal pure returns (address value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes1 at `mPtr` in memory.\n    function readBytes1(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes1 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes2 at `mPtr` in memory.\n    function readBytes2(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes2 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes3 at `mPtr` in memory.\n    function readBytes3(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes3 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes4 at `mPtr` in memory.\n    function readBytes4(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes4 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes5 at `mPtr` in memory.\n    function readBytes5(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes5 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes6 at `mPtr` in memory.\n    function readBytes6(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes6 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes7 at `mPtr` in memory.\n    function readBytes7(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes7 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes8 at `mPtr` in memory.\n    function readBytes8(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes8 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes9 at `mPtr` in memory.\n    function readBytes9(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes9 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes10 at `mPtr` in memory.\n    function readBytes10(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes10 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes11 at `mPtr` in memory.\n    function readBytes11(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes11 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes12 at `mPtr` in memory.\n    function readBytes12(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes12 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes13 at `mPtr` in memory.\n    function readBytes13(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes13 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes14 at `mPtr` in memory.\n    function readBytes14(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes14 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes15 at `mPtr` in memory.\n    function readBytes15(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes15 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes16 at `mPtr` in memory.\n    function readBytes16(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes16 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes17 at `mPtr` in memory.\n    function readBytes17(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes17 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes18 at `mPtr` in memory.\n    function readBytes18(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes18 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes19 at `mPtr` in memory.\n    function readBytes19(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes19 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes20 at `mPtr` in memory.\n    function readBytes20(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes20 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes21 at `mPtr` in memory.\n    function readBytes21(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes21 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes22 at `mPtr` in memory.\n    function readBytes22(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes22 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes23 at `mPtr` in memory.\n    function readBytes23(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes23 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes24 at `mPtr` in memory.\n    function readBytes24(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes24 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes25 at `mPtr` in memory.\n    function readBytes25(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes25 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes26 at `mPtr` in memory.\n    function readBytes26(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes26 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes27 at `mPtr` in memory.\n    function readBytes27(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes27 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes28 at `mPtr` in memory.\n    function readBytes28(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes28 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes29 at `mPtr` in memory.\n    function readBytes29(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes29 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes30 at `mPtr` in memory.\n    function readBytes30(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes30 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes31 at `mPtr` in memory.\n    function readBytes31(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes31 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes32 at `mPtr` in memory.\n    function readBytes32(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes32 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint8 at `mPtr` in memory.\n    function readUint8(MemoryPointer mPtr) internal pure returns (uint8 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint16 at `mPtr` in memory.\n    function readUint16(\n        MemoryPointer mPtr\n    ) internal pure returns (uint16 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint24 at `mPtr` in memory.\n    function readUint24(\n        MemoryPointer mPtr\n    ) internal pure returns (uint24 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint32 at `mPtr` in memory.\n    function readUint32(\n        MemoryPointer mPtr\n    ) internal pure returns (uint32 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint40 at `mPtr` in memory.\n    function readUint40(\n        MemoryPointer mPtr\n    ) internal pure returns (uint40 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint48 at `mPtr` in memory.\n    function readUint48(\n        MemoryPointer mPtr\n    ) internal pure returns (uint48 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint56 at `mPtr` in memory.\n    function readUint56(\n        MemoryPointer mPtr\n    ) internal pure returns (uint56 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint64 at `mPtr` in memory.\n    function readUint64(\n        MemoryPointer mPtr\n    ) internal pure returns (uint64 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint72 at `mPtr` in memory.\n    function readUint72(\n        MemoryPointer mPtr\n    ) internal pure returns (uint72 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint80 at `mPtr` in memory.\n    function readUint80(\n        MemoryPointer mPtr\n    ) internal pure returns (uint80 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint88 at `mPtr` in memory.\n    function readUint88(\n        MemoryPointer mPtr\n    ) internal pure returns (uint88 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint96 at `mPtr` in memory.\n    function readUint96(\n        MemoryPointer mPtr\n    ) internal pure returns (uint96 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint104 at `mPtr` in memory.\n    function readUint104(\n        MemoryPointer mPtr\n    ) internal pure returns (uint104 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint112 at `mPtr` in memory.\n    function readUint112(\n        MemoryPointer mPtr\n    ) internal pure returns (uint112 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint120 at `mPtr` in memory.\n    function readUint120(\n        MemoryPointer mPtr\n    ) internal pure returns (uint120 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint128 at `mPtr` in memory.\n    function readUint128(\n        MemoryPointer mPtr\n    ) internal pure returns (uint128 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint136 at `mPtr` in memory.\n    function readUint136(\n        MemoryPointer mPtr\n    ) internal pure returns (uint136 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint144 at `mPtr` in memory.\n    function readUint144(\n        MemoryPointer mPtr\n    ) internal pure returns (uint144 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint152 at `mPtr` in memory.\n    function readUint152(\n        MemoryPointer mPtr\n    ) internal pure returns (uint152 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint160 at `mPtr` in memory.\n    function readUint160(\n        MemoryPointer mPtr\n    ) internal pure returns (uint160 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint168 at `mPtr` in memory.\n    function readUint168(\n        MemoryPointer mPtr\n    ) internal pure returns (uint168 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint176 at `mPtr` in memory.\n    function readUint176(\n        MemoryPointer mPtr\n    ) internal pure returns (uint176 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint184 at `mPtr` in memory.\n    function readUint184(\n        MemoryPointer mPtr\n    ) internal pure returns (uint184 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint192 at `mPtr` in memory.\n    function readUint192(\n        MemoryPointer mPtr\n    ) internal pure returns (uint192 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint200 at `mPtr` in memory.\n    function readUint200(\n        MemoryPointer mPtr\n    ) internal pure returns (uint200 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint208 at `mPtr` in memory.\n    function readUint208(\n        MemoryPointer mPtr\n    ) internal pure returns (uint208 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint216 at `mPtr` in memory.\n    function readUint216(\n        MemoryPointer mPtr\n    ) internal pure returns (uint216 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint224 at `mPtr` in memory.\n    function readUint224(\n        MemoryPointer mPtr\n    ) internal pure returns (uint224 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint232 at `mPtr` in memory.\n    function readUint232(\n        MemoryPointer mPtr\n    ) internal pure returns (uint232 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint240 at `mPtr` in memory.\n    function readUint240(\n        MemoryPointer mPtr\n    ) internal pure returns (uint240 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint248 at `mPtr` in memory.\n    function readUint248(\n        MemoryPointer mPtr\n    ) internal pure returns (uint248 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint256 at `mPtr` in memory.\n    function readUint256(\n        MemoryPointer mPtr\n    ) internal pure returns (uint256 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int8 at `mPtr` in memory.\n    function readInt8(MemoryPointer mPtr) internal pure returns (int8 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int16 at `mPtr` in memory.\n    function readInt16(MemoryPointer mPtr) internal pure returns (int16 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int24 at `mPtr` in memory.\n    function readInt24(MemoryPointer mPtr) internal pure returns (int24 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int32 at `mPtr` in memory.\n    function readInt32(MemoryPointer mPtr) internal pure returns (int32 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int40 at `mPtr` in memory.\n    function readInt40(MemoryPointer mPtr) internal pure returns (int40 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int48 at `mPtr` in memory.\n    function readInt48(MemoryPointer mPtr) internal pure returns (int48 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int56 at `mPtr` in memory.\n    function readInt56(MemoryPointer mPtr) internal pure returns (int56 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int64 at `mPtr` in memory.\n    function readInt64(MemoryPointer mPtr) internal pure returns (int64 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int72 at `mPtr` in memory.\n    function readInt72(MemoryPointer mPtr) internal pure returns (int72 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int80 at `mPtr` in memory.\n    function readInt80(MemoryPointer mPtr) internal pure returns (int80 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int88 at `mPtr` in memory.\n    function readInt88(MemoryPointer mPtr) internal pure returns (int88 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int96 at `mPtr` in memory.\n    function readInt96(MemoryPointer mPtr) internal pure returns (int96 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int104 at `mPtr` in memory.\n    function readInt104(\n        MemoryPointer mPtr\n    ) internal pure returns (int104 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int112 at `mPtr` in memory.\n    function readInt112(\n        MemoryPointer mPtr\n    ) internal pure returns (int112 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int120 at `mPtr` in memory.\n    function readInt120(\n        MemoryPointer mPtr\n    ) internal pure returns (int120 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int128 at `mPtr` in memory.\n    function readInt128(\n        MemoryPointer mPtr\n    ) internal pure returns (int128 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int136 at `mPtr` in memory.\n    function readInt136(\n        MemoryPointer mPtr\n    ) internal pure returns (int136 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int144 at `mPtr` in memory.\n    function readInt144(\n        MemoryPointer mPtr\n    ) internal pure returns (int144 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int152 at `mPtr` in memory.\n    function readInt152(\n        MemoryPointer mPtr\n    ) internal pure returns (int152 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int160 at `mPtr` in memory.\n    function readInt160(\n        MemoryPointer mPtr\n    ) internal pure returns (int160 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int168 at `mPtr` in memory.\n    function readInt168(\n        MemoryPointer mPtr\n    ) internal pure returns (int168 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int176 at `mPtr` in memory.\n    function readInt176(\n        MemoryPointer mPtr\n    ) internal pure returns (int176 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int184 at `mPtr` in memory.\n    function readInt184(\n        MemoryPointer mPtr\n    ) internal pure returns (int184 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int192 at `mPtr` in memory.\n    function readInt192(\n        MemoryPointer mPtr\n    ) internal pure returns (int192 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int200 at `mPtr` in memory.\n    function readInt200(\n        MemoryPointer mPtr\n    ) internal pure returns (int200 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int208 at `mPtr` in memory.\n    function readInt208(\n        MemoryPointer mPtr\n    ) internal pure returns (int208 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int216 at `mPtr` in memory.\n    function readInt216(\n        MemoryPointer mPtr\n    ) internal pure returns (int216 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int224 at `mPtr` in memory.\n    function readInt224(\n        MemoryPointer mPtr\n    ) internal pure returns (int224 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int232 at `mPtr` in memory.\n    function readInt232(\n        MemoryPointer mPtr\n    ) internal pure returns (int232 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int240 at `mPtr` in memory.\n    function readInt240(\n        MemoryPointer mPtr\n    ) internal pure returns (int240 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int248 at `mPtr` in memory.\n    function readInt248(\n        MemoryPointer mPtr\n    ) internal pure returns (int248 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int256 at `mPtr` in memory.\n    function readInt256(\n        MemoryPointer mPtr\n    ) internal pure returns (int256 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n}\n\nlibrary MemoryWriters {\n    /// @dev Writes `valuePtr` to memory at `mPtr`.\n    function write(MemoryPointer mPtr, MemoryPointer valuePtr) internal pure {\n        assembly {\n            mstore(mPtr, valuePtr)\n        }\n    }\n\n    /// @dev Writes a boolean `value` to `mPtr` in memory.\n    function write(MemoryPointer mPtr, bool value) internal pure {\n        assembly {\n            mstore(mPtr, value)\n        }\n    }\n\n    /// @dev Writes an address `value` to `mPtr` in memory.\n    function write(MemoryPointer mPtr, address value) internal pure {\n        assembly {\n            mstore(mPtr, value)\n        }\n    }\n\n    /// @dev Writes a bytes32 `value` to `mPtr` in memory.\n    /// Separate name to disambiguate literal write parameters.\n    function writeBytes32(MemoryPointer mPtr, bytes32 value) internal pure {\n        assembly {\n            mstore(mPtr, value)\n        }\n    }\n\n    /// @dev Writes a uint256 `value` to `mPtr` in memory.\n    function write(MemoryPointer mPtr, uint256 value) internal pure {\n        assembly {\n            mstore(mPtr, value)\n        }\n    }\n\n    /// @dev Writes an int256 `value` to `mPtr` in memory.\n    /// Separate name to disambiguate literal write parameters.\n    function writeInt(MemoryPointer mPtr, int256 value) internal pure {\n        assembly {\n            mstore(mPtr, value)\n        }\n    }\n}\n""}, 'lib/seaport-types/src/lib/ConsiderationConstants.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/*\n * -------------------------- Disambiguation & Other Notes ---------------------\n *    - The term ""head"" is used as it is in the documentation for ABI encoding,\n *      but only in reference to dynamic types, i.e. it always refers to the\n *      offset or pointer to the body of a dynamic type. In calldata, the head\n *      is always an offset (relative to the parent object), while in memory,\n *      the head is always the pointer to the body. More information found here:\n *      https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#argument-encoding\n *        - Note that the length of an array is separate from and precedes the\n *          head of the array.\n *\n *    - The term ""body"" is used in place of the term ""head"" used in the ABI\n *      documentation. It refers to the start of the data for a dynamic type,\n *      e.g. the first word of a struct or the first word of the first element\n *      in an array.\n *\n *    - The term ""pointer"" is used to describe the absolute position of a value\n *      and never an offset relative to another value.\n *        - The suffix ""_ptr"" refers to a memory pointer.\n *        - The suffix ""_cdPtr"" refers to a calldata pointer.\n *\n *    - The term ""offset"" is used to describe the position of a value relative\n *      to some parent value. For example, OrderParameters_conduit_offset is the\n *      offset to the ""conduit"" value in the OrderParameters struct relative to\n *      the start of the body.\n *        - Note: Offsets are used to derive pointers.\n *\n *    - Some structs have pointers defined for all of their fields in this file.\n *      Lines which are commented out are fields that are not used in the\n *      codebase but have been left in for readability.\n */\n\n// Declare constants for name, version, and reentrancy sentinel values.\n\n// Name is right padded, so it touches the length which is left padded. This\n// enables writing both values at once. Length goes at byte 95 in memory, and\n// name fills bytes 96-109, so both values can be written left-padded to 77.\nuint256 constant NameLengthPtr = 0x4D;\nuint256 constant NameWithLength = 0x0d436F6E73696465726174696F6E;\n\nuint256 constant information_version_offset = 0;\nuint256 constant information_version_cd_offset = 0x60;\nuint256 constant information_domainSeparator_offset = 0x20;\nuint256 constant information_conduitController_offset = 0x40;\nuint256 constant information_versionLengthPtr = 0x63;\nuint256 constant information_versionWithLength = 0x03312e36; // 1.6\nuint256 constant information_length = 0xa0;\n\n// uint256(uint32(bytes4(keccak256(""_REENTRANCY_GUARD_SLOT""))))\nuint256 constant _REENTRANCY_GUARD_SLOT = 0x929eee14;\n\n/*\n *\n * --------------------------------------------------------------------------+\n * Opcode      | Mnemonic         | Stack               | Memory             |\n * --------------------------------------------------------------------------|\n * 60 0x02     | PUSH1 0x02       | 0x02                |                    |\n * 60 0x1e     | PUSH1 0x1e       | 0x1e 0x02           |                    |\n * 61 0x3d5c   | PUSH2 0x3d5c     | 0x3d5c 0x1e 0x02    |                    |\n * 3d          | RETURNDATASIZE   | 0 0x3d5c 0x1e 0x02  |                    |\n *                                                                           |\n * ::: store deployed bytecode in memory: (3d) RETURNDATASIZE (5c) TLOAD ::: |\n * 52          | MSTORE           | 0x1e 0x02           | [0..0x20): 0x3d5c  |\n * f3          | RETURN           |                     | [0..0x20): 0x3d5c  |\n * --------------------------------------------------------------------------+\n */\nuint256 constant _TLOAD_TEST_PAYLOAD = 0x6002_601e_613d5c_3d_52_f3;\nuint256 constant _TLOAD_TEST_PAYLOAD_LENGTH = 0x0a;\nuint256 constant _TLOAD_TEST_PAYLOAD_OFFSET = 0x16;\nuint256 constant _NOT_ENTERED_TSTORE = 0;\nuint256 constant _ENTERED_TSTORE = 1;\nuint256 constant _ENTERED_AND_ACCEPTING_NATIVE_TOKENS_TSTORE = 2;\nuint256 constant _TSTORE_ENABLED_SSTORE = 0;\nuint256 constant _NOT_ENTERED_SSTORE = 1;\nuint256 constant _ENTERED_SSTORE = 2;\nuint256 constant _ENTERED_AND_ACCEPTING_NATIVE_TOKENS_SSTORE = 3;\n\nuint256 constant Offset_fulfillAdvancedOrder_criteriaResolvers = 0x20;\nuint256 constant Offset_fulfillAvailableOrders_offerFulfillments = 0x20;\nuint256 constant Offset_fulfillAvailableOrders_considerationFulfillments = 0x40;\nuint256 constant Offset_fulfillAvailableAdvancedOrders_criteriaResolvers = 0x20;\nuint256 constant Offset_fulfillAvailableAdvancedOrders_offerFulfillments = 0x40;\nuint256 constant Offset_fulfillAvailableAdvancedOrders_cnsdrationFlflmnts =\n    (0x60);\n\nuint256 constant Offset_matchOrders_fulfillments = 0x20;\n\nuint256 constant Offset_matchAdvancedOrders_criteriaResolvers = 0x20;\nuint256 constant Offset_matchAdvancedOrders_fulfillments = 0x40;\n\n// Common Offsets\n// Offsets for identically positioned fields shared by:\n// OfferItem, ConsiderationItem, SpentItem, ReceivedItem\n\nuint256 constant Selector_length = 0x4;\n\nuint256 constant Common_token_offset = 0x20;\nuint256 constant Common_identifier_offset = 0x40;\nuint256 constant Common_amount_offset = 0x60;\nuint256 constant Common_endAmount_offset = 0x80;\n\nuint256 constant SpentItem_size = 0x80;\nuint256 constant SpentItem_size_shift = 0x7;\n\nuint256 constant OfferItem_size = 0xa0;\nuint256 constant OfferItem_size_with_head_pointer = 0xc0;\n\nuint256 constant ReceivedItem_size_excluding_recipient = 0x80;\nuint256 constant ReceivedItem_size = 0xa0;\nuint256 constant ReceivedItem_amount_offset = 0x60;\nuint256 constant ReceivedItem_recipient_offset = 0x80;\n\nuint256 constant ReceivedItem_CommonParams_size = 0x60;\n\nuint256 constant ConsiderationItem_size = 0xc0;\nuint256 constant ConsiderationItem_size_with_head_pointer = 0xe0;\n\nuint256 constant ConsiderationItem_recipient_offset = 0xa0;\n// Store the same constant in an abbreviated format for a line length fix.\nuint256 constant ConsiderItem_recipient_offset = 0xa0;\n\nuint256 constant Execution_offerer_offset = 0x20;\nuint256 constant Execution_conduit_offset = 0x40;\n\n// uint256 constant OrderParameters_offerer_offset = 0x00;\nuint256 constant OrderParameters_zone_offset = 0x20;\nuint256 constant OrderParameters_offer_head_offset = 0x40;\nuint256 constant OrderParameters_consideration_head_offset = 0x60;\n// uint256 constant OrderParameters_orderType_offset = 0x80;\nuint256 constant OrderParameters_startTime_offset = 0xa0;\nuint256 constant OrderParameters_endTime_offset = 0xc0;\nuint256 constant OrderParameters_zoneHash_offset = 0xe0;\nuint256 constant OrderParameters_salt_offset = 0x100;\nuint256 constant OrderParameters_conduit_offset = 0x120;\nuint256 constant OrderParameters_counter_offset = 0x140;\n\nuint256 constant Fulfillment_itemIndex_offset = 0x20;\n\nuint256 constant AdvancedOrder_head_size = 0xa0;\nuint256 constant AdvancedOrder_numerator_offset = 0x20;\nuint256 constant AdvancedOrder_denominator_offset = 0x40;\nuint256 constant AdvancedOrder_signature_offset = 0x60;\nuint256 constant AdvancedOrder_extraData_offset = 0x80;\n\nuint256 constant OrderStatus_ValidatedAndNotCancelled = 1;\nuint256 constant OrderStatus_filledNumerator_offset = 0x10;\nuint256 constant OrderStatus_filledDenominator_offset = 0x88;\nuint256 constant OrderStatus_ValidatedAndNotCancelledAndFullyFilled = (\n    0x0000000000000000000000000000010000000000000000000000000000010001\n);\n\nuint256 constant ThirtyOneBytes = 0x1f;\nuint256 constant OneWord = 0x20;\nuint256 constant TwoWords = 0x40;\nuint256 constant ThreeWords = 0x60;\nuint256 constant FourWords = 0x80;\nuint256 constant FiveWords = 0xa0;\n\nuint256 constant OneWordShift = 0x5;\nuint256 constant TwoWordsShift = 0x6;\n\nuint256 constant SixtyThreeBytes = 0x3f;\nuint256 constant OnlyFullWordMask = 0xffffffe0;\n\nuint256 constant FreeMemoryPointerSlot = 0x40;\nuint256 constant ZeroSlot = 0x60;\nuint256 constant DefaultFreeMemoryPointer = 0x80;\n\nuint256 constant Slot0x80 = 0x80;\nuint256 constant Slot0xA0 = 0xa0;\n\nuint256 constant BasicOrder_common_params_size = 0xa0;\nuint256 constant BasicOrder_considerationHashesArray_ptr = 0x160;\nuint256 constant BasicOrder_receivedItemByteMap =\n    (0x0000010102030000000000000000000000000000000000000000000000000000);\nuint256 constant BasicOrder_offeredItemByteMap =\n    (0x0203020301010000000000000000000000000000000000000000000000000000);\nuint256 constant BasicOrder_consideration_offset_from_offer = 0xa0;\n\nbytes32 constant OrdersMatchedTopic0 =\n    (0x4b9f2d36e1b4c93de62cc077b00b1a91d84b6c31b4a14e012718dcca230689e7);\n\nuint256 constant EIP712_Order_size = 0x180;\nuint256 constant EIP712_OfferItem_size = 0xc0;\nuint256 constant EIP712_ConsiderationItem_size = 0xe0;\nuint256 constant AdditionalRecipient_size = 0x40;\nuint256 constant AdditionalRecipient_size_shift = 0x6;\n\nuint256 constant EIP712_DomainSeparator_offset = 0x02;\nuint256 constant EIP712_OrderHash_offset = 0x22;\nuint256 constant EIP712_DigestPayload_size = 0x42;\n\nuint256 constant EIP712_domainData_nameHash_offset = 0x20;\nuint256 constant EIP712_domainData_versionHash_offset = 0x40;\nuint256 constant EIP712_domainData_chainId_offset = 0x60;\nuint256 constant EIP712_domainData_verifyingContract_offset = 0x80;\nuint256 constant EIP712_domainData_size = 0xa0;\n\n// Minimum BulkOrder proof size: 64 bytes for signature + 3 for key + 32 for 1\n// sibling. Maximum BulkOrder proof size: 65 bytes for signature + 3 for key +\n// 768 for 24 siblings.\n\nuint256 constant BulkOrderProof_minSize = 0x63;\nuint256 constant BulkOrderProof_rangeSize = 0x2e2;\nuint256 constant BulkOrderProof_lengthAdjustmentBeforeMask = 0x1d;\nuint256 constant BulkOrderProof_lengthRangeAfterMask = 0x2;\nuint256 constant BulkOrderProof_keyShift = 0xe8;\nuint256 constant BulkOrderProof_keySize = 0x3;\n\nuint256 constant BulkOrder_Typehash_Height_One =\n    (0x3ca2711d29384747a8f61d60aad3c450405f7aaff5613541dee28df2d6986d32);\nuint256 constant BulkOrder_Typehash_Height_Two =\n    (0xbf8e29b89f29ed9b529c154a63038ffca562f8d7cd1e2545dda53a1b582dde30);\nuint256 constant BulkOrder_Typehash_Height_Three =\n    (0x53c6f6856e13104584dd0797ca2b2779202dc2597c6066a42e0d8fe990b0024d);\nuint256 constant BulkOrder_Typehash_Height_Four =\n    (0xa02eb7ff164c884e5e2c336dc85f81c6a93329d8e9adf214b32729b894de2af1);\nuint256 constant BulkOrder_Typehash_Height_Five =\n    (0x39c9d33c18e050dda0aeb9a8086fb16fc12d5d64536780e1da7405a800b0b9f6);\nuint256 constant BulkOrder_Typehash_Height_Six =\n    (0x1c19f71958cdd8f081b4c31f7caf5c010b29d12950be2fa1c95070dc47e30b55);\nuint256 constant BulkOrder_Typehash_Height_Seven =\n    (0xca74fab2fece9a1d58234a274220ad05ca096a92ef6a1ca1750b9d90c948955c);\nuint256 constant BulkOrder_Typehash_Height_Eight =\n    (0x7ff98d9d4e55d876c5cfac10b43c04039522f3ddfb0ea9bfe70c68cfb5c7cc14);\nuint256 constant BulkOrder_Typehash_Height_Nine =\n    (0xbed7be92d41c56f9e59ac7a6272185299b815ddfabc3f25deb51fe55fe2f9e8a);\nuint256 constant BulkOrder_Typehash_Height_Ten =\n    (0xd1d97d1ef5eaa37a4ee5fbf234e6f6d64eb511eb562221cd7edfbdde0848da05);\nuint256 constant BulkOrder_Typehash_Height_Eleven =\n    (0x896c3f349c4da741c19b37fec49ed2e44d738e775a21d9c9860a69d67a3dae53);\nuint256 constant BulkOrder_Typehash_Height_Twelve =\n    (0xbb98d87cc12922b83759626c5f07d72266da9702d19ffad6a514c73a89002f5f);\nuint256 constant BulkOrder_Typehash_Height_Thirteen =\n    (0xe6ae19322608dd1f8a8d56aab48ed9c28be489b689f4b6c91268563efc85f20e);\nuint256 constant BulkOrder_Typehash_Height_Fourteen =\n    (0x6b5b04cbae4fcb1a9d78e7b2dfc51a36933d023cf6e347e03d517b472a852590);\nuint256 constant BulkOrder_Typehash_Height_Fifteen =\n    (0xd1eb68309202b7106b891e109739dbbd334a1817fe5d6202c939e75cf5e35ca9);\nuint256 constant BulkOrder_Typehash_Height_Sixteen =\n    (0x1da3eed3ecef6ebaa6e5023c057ec2c75150693fd0dac5c90f4a142f9879fde8);\nuint256 constant BulkOrder_Typehash_Height_Seventeen =\n    (0xeee9a1392aa395c7002308119a58f2582777a75e54e0c1d5d5437bd2e8bf6222);\nuint256 constant BulkOrder_Typehash_Height_Eighteen =\n    (0xc3939feff011e53ab8c35ca3370aad54c5df1fc2938cd62543174fa6e7d85877);\nuint256 constant BulkOrder_Typehash_Height_Nineteen =\n    (0x0efca7572ac20f5ae84db0e2940674f7eca0a4726fa1060ffc2d18cef54b203d);\nuint256 constant BulkOrder_Typehash_Height_Twenty =\n    (0x5a4f867d3d458dabecad65f6201ceeaba0096df2d0c491cc32e6ea4e64350017);\nuint256 constant BulkOrder_Typehash_Height_TwentyOne =\n    (0x80987079d291feebf21c2230e69add0f283cee0b8be492ca8050b4185a2ff719);\nuint256 constant BulkOrder_Typehash_Height_TwentyTwo =\n    (0x3bd8cff538aba49a9c374c806d277181e9651624b3e31111bc0624574f8bca1d);\nuint256 constant BulkOrder_Typehash_Height_TwentyThree =\n    (0x5d6a3f098a0bc373f808c619b1bb4028208721b3c4f8d6bc8a874d659814eb76);\nuint256 constant BulkOrder_Typehash_Height_TwentyFour =\n    (0x1d51df90cba8de7637ca3e8fe1e3511d1dc2f23487d05dbdecb781860c21ac1c);\n\nuint256 constant receivedItemsHash_ptr = 0x60;\n\n/*\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\n *  data for OrderFulfilled\n *\n *   event OrderFulfilled(\n *     bytes32 orderHash,\n *     address indexed offerer,\n *     address indexed zone,\n *     address fulfiller,\n *     SpentItem[] offer,\n *       > (itemType, token, id, amount)\n *     ReceivedItem[] consideration\n *       > (itemType, token, id, amount, recipient)\n *   )\n *\n *  - 0x00: orderHash\n *  - 0x20: fulfiller\n *  - 0x40: offer offset (0x80)\n *  - 0x60: consideration offset (0x120)\n *  - 0x80: offer.length (1)\n *  - 0xa0: offerItemType\n *  - 0xc0: offerToken\n *  - 0xe0: offerIdentifier\n *  - 0x100: offerAmount\n *  - 0x120: consideration.length (1 + additionalRecipients.length)\n *  - 0x140: considerationItemType\n *  - 0x160: considerationToken\n *  - 0x180: considerationIdentifier\n *  - 0x1a0: considerationAmount\n *  - 0x1c0: considerationRecipient\n *  - ...\n */\n\n// Minimum length of the OrderFulfilled event data.\n// Must be added to the size of the ReceivedItem array for additionalRecipients\n// (0xa0 * additionalRecipients.length) to calculate full size of the buffer.\nuint256 constant OrderFulfilled_baseSize = 0x1e0;\nuint256 constant OrderFulfilled_selector =\n    (0x9d9af8e38d66c62e2c12f0225249fd9d721c54b83f48d9352c97c6cacdcb6f31);\n\n// Minimum offset in memory to OrderFulfilled event data.\n// Must be added to the size of the EIP712 hash array for additionalRecipients\n// (32 * additionalRecipients.length) to calculate the pointer to event data.\nuint256 constant OrderFulfilled_baseOffset = 0x180;\nuint256 constant OrderFulfilled_consideration_length_baseOffset = 0x2a0;\nuint256 constant OrderFulfilled_offer_length_baseOffset = 0x200;\n\nuint256 constant OrderFulfilled_offer_length_offset_relativeTo_baseOffset = (\n    0x80\n);\nuint256 constant OrderFulfilled_offer_itemType_offset_relativeTo_baseOffset = (\n    0xa0\n);\nuint256 constant OrderFulfilled_offer_token_offset_relativeTo_baseOffset = 0xc0;\n\n// Related constants used for restricted order checks on basic orders.\nuint256 constant OrderFulfilled_baseDataSize = 0x160;\n// uint256 constant ValidateOrder_offerDataOffset = 0x184;\n// uint256 constant RatifyOrder_offerDataOffset = 0xc4;\n\n// uint256 constant OrderFulfilled_orderHash_offset = 0x00;\nuint256 constant OrderFulfilled_fulfiller_offset = 0x20;\nuint256 constant OrderFulfilled_offer_head_offset = 0x40;\nuint256 constant OrderFulfilled_offer_body_offset = 0x80;\nuint256 constant OrderFulfilled_consideration_head_offset = 0x60;\nuint256 constant OrderFulfilled_consideration_body_offset = 0x120;\n\n/*\n * 3 memory slots/words for `authorizeOrder` and `validateOrder` calldata\n * to be used for tails of extra data (length 0) and order hashes (length 1)\n */\nuint256 constant OrderFulfilled_post_memory_region_reservedBytes = 0x60;\n\n/*\n * OrderFulfilled_offer_length_baseOffset - 12 * 0x20\n * we back up 12 words from where the `OrderFulfilled`\'s data\n * for spent items start to be rewritten for `authorizeOrder`\n * and `validateOrder`. Let the reference pointer be `ptr`\n * pointing to the `OrderFulfilled`\'s spent item array\'s length memory\n * position then we would have:\n *\n * ptr - 0x0180 : zero-padded calldata selector\n * ptr - 0x0160 : ZoneParameter\'s struct head (0x20)\n * ptr - 0x0140 : order hash\n * ptr - 0x0120 : fulfiller (msg.sender)\n * ptr - 0x0100 : offerer\n * ptr - 0x00e0 : spent items\' head\n * ptr - 0x00c0 : received items\' head\n * ptr - 0x00a0 : extra data / context head\n * ptr - 0x0080 : order hashes head\n * ptr - 0x0060 : start time\n * ptr - 0x0040 : end time\n * ptr - 0x0020 : zone hash\n * ptr - 0x0000 : offer.length (1)\n * ...\n *\n * Note that the padded calldata selector will be at minimum at the\n * 0x80 memory slot.\n */\nuint256 constant authorizeOrder_calldata_baseOffset = (\n    OrderFulfilled_offer_length_baseOffset - 0x180\n);\n\n// BasicOrderParameters\nuint256 constant BasicOrder_parameters_cdPtr = 0x04;\nuint256 constant BasicOrder_considerationToken_cdPtr = 0x24;\nuint256 constant BasicOrder_considerationIdentifier_cdPtr = 0x44;\nuint256 constant BasicOrder_considerationAmount_cdPtr = 0x64;\nuint256 constant BasicOrder_offerer_cdPtr = 0x84;\nuint256 constant BasicOrder_zone_cdPtr = 0xa4;\nuint256 constant BasicOrder_offerToken_cdPtr = 0xc4;\nuint256 constant BasicOrder_offerIdentifier_cdPtr = 0xe4;\nuint256 constant BasicOrder_offerAmount_cdPtr = 0x104;\nuint256 constant BasicOrder_basicOrderParameters_cd_offset = 0x24;\nuint256 constant BasicOrder_basicOrderType_cdPtr = 0x124;\nuint256 constant BasicOrder_startTime_cdPtr = 0x144;\nuint256 constant BasicOrder_endTime_cdPtr = 0x164;\n// uint256 constant BasicOrder_zoneHash_cdPtr = 0x184;\n// uint256 constant BasicOrder_salt_cdPtr = 0x1a4;\nuint256 constant BasicOrder_offererConduit_cdPtr = 0x1c4;\nuint256 constant BasicOrder_fulfillerConduit_cdPtr = 0x1e4;\nuint256 constant BasicOrder_totalOriginalAdditionalRecipients_cdPtr = 0x204;\nuint256 constant BasicOrder_additionalRecipients_head_cdPtr = 0x224;\nuint256 constant BasicOrder_signature_cdPtr = 0x244;\nuint256 constant BasicOrder_additionalRecipients_length_cdPtr = 0x264;\nuint256 constant BasicOrder_addlRecipients_length_cdPtr = 0x264;\nuint256 constant BasicOrder_additionalRecipients_data_cdPtr = 0x284;\nuint256 constant BasicOrder_parameters_ptr = 0x20;\nuint256 constant BasicOrder_basicOrderType_range = 0x18; // 24 values\n\n/*\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\n *  EIP712 data for ConsiderationItem\n *   - 0x80: ConsiderationItem EIP-712 typehash (constant)\n *   - 0xa0: itemType\n *   - 0xc0: token\n *   - 0xe0: identifier\n *   - 0x100: startAmount\n *   - 0x120: endAmount\n *   - 0x140: recipient\n */\nuint256 constant BasicOrder_considerationItem_typeHash_ptr = 0x80; // memoryPtr\nuint256 constant BasicOrder_considerationItem_itemType_ptr = 0xa0;\nuint256 constant BasicOrder_considerationItem_token_ptr = 0xc0;\nuint256 constant BasicOrder_considerationItem_identifier_ptr = 0xe0;\nuint256 constant BasicOrder_considerationItem_startAmount_ptr = 0x100;\nuint256 constant BasicOrder_considerationItem_endAmount_ptr = 0x120;\n// uint256 constant BasicOrder_considerationItem_recipient_ptr = 0x140;\n\n/*\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\n *  EIP712 data for OfferItem\n *   - 0x80:  OfferItem EIP-712 typehash (constant)\n *   - 0xa0:  itemType\n *   - 0xc0:  token\n *   - 0xe0:  identifier (reused for offeredItemsHash)\n *   - 0x100: startAmount\n *   - 0x120: endAmount\n */\nuint256 constant BasicOrder_offerItem_typeHash_ptr = 0x80;\nuint256 constant BasicOrder_offerItem_itemType_ptr = 0xa0;\nuint256 constant BasicOrder_offerItem_token_ptr = 0xc0;\n// uint256 constant BasicOrder_offerItem_identifier_ptr = 0xe0;\n// uint256 constant BasicOrder_offerItem_startAmount_ptr = 0x100;\nuint256 constant BasicOrder_offerItem_endAmount_ptr = 0x120;\n\n/*\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\n *  EIP712 data for Order\n *   - 0x80:   Order EIP-712 typehash (constant)\n *   - 0xa0:   orderParameters.offerer\n *   - 0xc0:   orderParameters.zone\n *   - 0xe0:   keccak256(abi.encodePacked(offerHashes))\n *   - 0x100:  keccak256(abi.encodePacked(considerationHashes))\n *   - 0x120:  orderType\n *   - 0x140:  startTime\n *   - 0x160:  endTime\n *   - 0x180:  zoneHash\n *   - 0x1a0:  salt\n *   - 0x1c0:  conduit\n *   - 0x1e0:  _counters[orderParameters.offerer] (from storage)\n */\nuint256 constant BasicOrder_order_typeHash_ptr = 0x80;\nuint256 constant BasicOrder_order_offerer_ptr = 0xa0;\n// uint256 constant BasicOrder_order_zone_ptr = 0xc0;\nuint256 constant BasicOrder_order_offerHashes_ptr = 0xe0;\nuint256 constant BasicOrder_order_considerationHashes_ptr = 0x100;\nuint256 constant BasicOrder_order_orderType_ptr = 0x120;\nuint256 constant BasicOrder_order_startTime_ptr = 0x140;\n// uint256 constant BasicOrder_order_endTime_ptr = 0x160;\n// uint256 constant BasicOrder_order_zoneHash_ptr = 0x180;\n// uint256 constant BasicOrder_order_salt_ptr = 0x1a0;\n// uint256 constant BasicOrder_order_conduitKey_ptr = 0x1c0;\nuint256 constant BasicOrder_order_counter_ptr = 0x1e0;\nuint256 constant BasicOrder_additionalRecipients_head_ptr = 0x240;\nuint256 constant BasicOrder_signature_ptr = 0x260;\nuint256 constant BasicOrder_startTimeThroughZoneHash_size = 0x60;\n\nuint256 constant ContractOrder_orderHash_offerer_shift = 0x60;\n\nuint256 constant Counter_blockhash_shift = 0x80;\n\n// Signature-related\nbytes32 constant EIP2098_allButHighestBitMask =\n    (0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\nbytes32 constant ECDSA_twentySeventhAndTwentyEighthBytesSet =\n    (0x0000000000000000000000000000000000000000000000000000000101000000);\nuint256 constant ECDSA_MaxLength = 65;\nuint256 constant ECDSA_signature_s_offset = 0x40;\nuint256 constant ECDSA_signature_v_offset = 0x60;\n\nbytes32 constant EIP1271_isValidSignature_selector =\n    (0x1626ba7e00000000000000000000000000000000000000000000000000000000);\nuint256 constant EIP1271_isValidSignature_digest_negativeOffset = 0x40;\nuint256 constant EIP1271_isValidSignature_selector_negativeOffset = 0x44;\nuint256 constant EIP1271_isValidSignature_calldata_baseLength = 0x64;\nuint256 constant EIP1271_isValidSignature_signature_head_offset = 0x40;\n\nuint256 constant EIP_712_PREFIX =\n    (0x1901000000000000000000000000000000000000000000000000000000000000);\n\nuint256 constant ExtraGasBuffer = 0x20;\nuint256 constant CostPerWord = 0x3;\nuint256 constant MemoryExpansionCoefficientShift = 0x9;\n\nuint256 constant Create2AddressDerivation_ptr = 0x0b;\nuint256 constant Create2AddressDerivation_length = 0x55;\n\nuint256 constant MaskOverByteTwelve =\n    (0x0000000000000000000000ff0000000000000000000000000000000000000000);\nuint256 constant MaskOverLastTwentyBytes =\n    (0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff);\nuint256 constant AddressDirtyUpperBitThreshold =\n    (0x0000000000000000000000010000000000000000000000000000000000000000);\nuint256 constant MaskOverFirstFourBytes =\n    (0xffffffff00000000000000000000000000000000000000000000000000000000);\n\nuint256 constant Conduit_execute_signature =\n    (0x4ce34aa200000000000000000000000000000000000000000000000000000000);\n\nuint256 constant MaxUint8 = 0xff;\nuint256 constant MaxUint120 = 0xffffffffffffffffffffffffffffff;\n\nuint256 constant Conduit_execute_ConduitTransfer_ptr = 0x20;\nuint256 constant Conduit_execute_ConduitTransfer_length = 0x01;\nuint256 constant Conduit_execute_ConduitTransfer_offset_ptr = 0x04;\nuint256 constant Conduit_execute_ConduitTransfer_length_ptr = 0x24;\nuint256 constant Conduit_execute_transferItemType_ptr = 0x44;\nuint256 constant Conduit_execute_transferToken_ptr = 0x64;\nuint256 constant Conduit_execute_transferFrom_ptr = 0x84;\nuint256 constant Conduit_execute_transferTo_ptr = 0xa4;\nuint256 constant Conduit_execute_transferIdentifier_ptr = 0xc4;\nuint256 constant Conduit_execute_transferAmount_ptr = 0xe4;\n\nuint256 constant OneConduitExecute_size = 0x104;\n\n// Sentinel value to indicate that the conduit accumulator is not armed.\nuint256 constant AccumulatorDisarmed = 0x20;\nuint256 constant AccumulatorArmed = 0x40;\nuint256 constant Accumulator_conduitKey_ptr = 0x20;\nuint256 constant Accumulator_selector_ptr = 0x40;\nuint256 constant Accumulator_array_offset_ptr = 0x44;\nuint256 constant Accumulator_array_length_ptr = 0x64;\nuint256 constant Accumulator_itemSizeOffsetDifference = 0x3c;\nuint256 constant Accumulator_array_offset = 0x20;\n\nuint256 constant Conduit_transferItem_size = 0xc0;\nuint256 constant Conduit_transferItem_token_ptr = 0x20;\nuint256 constant Conduit_transferItem_from_ptr = 0x40;\nuint256 constant Conduit_transferItem_to_ptr = 0x60;\nuint256 constant Conduit_transferItem_identifier_ptr = 0x80;\nuint256 constant Conduit_transferItem_amount_ptr = 0xa0;\n\nuint256 constant Ecrecover_precompile = 0x1;\nuint256 constant Ecrecover_args_size = 0x80;\nuint256 constant Signature_lower_v = 27;\n\n// Bitmask that only gives a non-zero value if masked with a non-match selector.\nuint256 constant NonMatchSelector_MagicMask =\n    (0x4000000000000000000000000000000000000000000000000000000000);\n\n// First bit indicates that a NATIVE offer items has been used and the 231st bit\n// indicates that a non match selector has been called.\nuint256 constant NonMatchSelector_InvalidErrorValue =\n    (0x4000000000000000000000000000000000000000000000000000000001);\n\n/**\n * @dev Selector and offsets for generateOrder\n *\n * function generateOrder(\n *   address fulfiller,\n *   SpentItem[] calldata minimumReceived,\n *   SpentItem[] calldata maximumSpent,\n *   bytes calldata context\n * )\n */\nuint256 constant generateOrder_selector = 0x98919765;\nuint256 constant generateOrder_selector_offset = 0x1c;\nuint256 constant generateOrder_head_offset = 0x04;\nuint256 constant generateOrder_minimumReceived_head_offset = 0x20;\nuint256 constant generateOrder_maximumSpent_head_offset = 0x40;\nuint256 constant generateOrder_context_head_offset = 0x60;\nuint256 constant generateOrder_base_tail_offset = 0x80;\nuint256 constant generateOrder_maximum_returned_array_length = 0xffff;\n\nuint256 constant ratifyOrder_selector = 0xf4dd92ce;\nuint256 constant ratifyOrder_selector_offset = 0x1c;\nuint256 constant ratifyOrder_head_offset = 0x04;\n// uint256 constant ratifyOrder_offer_head_offset = 0x00;\nuint256 constant ratifyOrder_consideration_head_offset = 0x20;\nuint256 constant ratifyOrder_context_head_offset = 0x40;\nuint256 constant ratifyOrder_orderHashes_head_offset = 0x60;\nuint256 constant ratifyOrder_contractNonce_offset = 0x80;\nuint256 constant ratifyOrder_base_tail_offset = 0xa0;\n\nuint256 constant validateOrder_selector = 0x17b1f942;\nuint256 constant validateOrder_selector_offset = 0x1c;\nuint256 constant validateOrder_head_offset = 0x04;\nuint256 constant validateOrder_zoneParameters_offset = 0x20;\n\nuint256 constant authorizeOrder_selector = 0x01e4d72a;\nuint256 constant authorizeOrder_selector_offset = 0x1c;\nuint256 constant authorizeOrder_head_offset = 0x04;\nuint256 constant authorizeOrder_zoneParameters_offset = 0x20;\n\n// uint256 constant ZoneParameters_orderHash_offset = 0x00;\nuint256 constant ZoneParameters_fulfiller_offset = 0x20;\nuint256 constant ZoneParameters_offerer_offset = 0x40;\nuint256 constant ZoneParameters_offer_head_offset = 0x60;\nuint256 constant ZoneParameters_consideration_head_offset = 0x80;\nuint256 constant ZoneParameters_extraData_head_offset = 0xa0;\nuint256 constant ZoneParameters_orderHashes_head_offset = 0xc0;\nuint256 constant ZoneParameters_startTime_offset = 0xe0;\nuint256 constant ZoneParameters_endTime_offset = 0x100;\nuint256 constant ZoneParameters_zoneHash_offset = 0x120;\nuint256 constant ZoneParameters_base_tail_offset = 0x140;\nuint256 constant ZoneParameters_selectorAndPointer_length = 0x24;\nuint256 constant ZoneParameters_basicOrderFixedElements_length = 0x44;\n\n// ConsiderationDecoder Constants\nuint256 constant OrderParameters_head_size = 0x0160;\nuint256 constant OrderParameters_totalOriginalConsiderationItems_offset = (\n    0x0140\n);\nuint256 constant AdvancedOrderPlusOrderParameters_head_size = 0x0200;\n\nuint256 constant Order_signature_offset = 0x20;\nuint256 constant Order_head_size = 0x40;\n\nuint256 constant AdvancedOrder_fixed_segment_0 = 0x40;\n\nuint256 constant CriteriaResolver_head_size = 0xa0;\nuint256 constant CriteriaResolver_fixed_segment_0 = 0x80;\nuint256 constant CriteriaResolver_criteriaProof_offset = 0x80;\n\nuint256 constant FulfillmentComponent_mem_tail_size = 0x40;\nuint256 constant FulfillmentComponent_mem_tail_size_shift = 0x6;\nuint256 constant Fulfillment_head_size = 0x40;\nuint256 constant Fulfillment_considerationComponents_offset = 0x20;\n\nuint256 constant OrderComponents_OrderParameters_common_head_size = 0x0140;\n'}, 'lib/seaport-types/src/lib/ConsiderationEnums.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nenum OrderType {\n    // 0: no partial fills, anyone can execute\n    FULL_OPEN,\n\n    // 1: partial fills supported, anyone can execute\n    PARTIAL_OPEN,\n\n    // 2: no partial fills, only offerer or zone can execute\n    FULL_RESTRICTED,\n\n    // 3: partial fills supported, only offerer or zone can execute\n    PARTIAL_RESTRICTED,\n\n    // 4: contract order type\n    CONTRACT\n}\n\nenum BasicOrderType {\n    // 0: no partial fills, anyone can execute\n    ETH_TO_ERC721_FULL_OPEN,\n\n    // 1: partial fills supported, anyone can execute\n    ETH_TO_ERC721_PARTIAL_OPEN,\n\n    // 2: no partial fills, only offerer or zone can execute\n    ETH_TO_ERC721_FULL_RESTRICTED,\n\n    // 3: partial fills supported, only offerer or zone can execute\n    ETH_TO_ERC721_PARTIAL_RESTRICTED,\n\n    // 4: no partial fills, anyone can execute\n    ETH_TO_ERC1155_FULL_OPEN,\n\n    // 5: partial fills supported, anyone can execute\n    ETH_TO_ERC1155_PARTIAL_OPEN,\n\n    // 6: no partial fills, only offerer or zone can execute\n    ETH_TO_ERC1155_FULL_RESTRICTED,\n\n    // 7: partial fills supported, only offerer or zone can execute\n    ETH_TO_ERC1155_PARTIAL_RESTRICTED,\n\n    // 8: no partial fills, anyone can execute\n    ERC20_TO_ERC721_FULL_OPEN,\n\n    // 9: partial fills supported, anyone can execute\n    ERC20_TO_ERC721_PARTIAL_OPEN,\n\n    // 10: no partial fills, only offerer or zone can execute\n    ERC20_TO_ERC721_FULL_RESTRICTED,\n\n    // 11: partial fills supported, only offerer or zone can execute\n    ERC20_TO_ERC721_PARTIAL_RESTRICTED,\n\n    // 12: no partial fills, anyone can execute\n    ERC20_TO_ERC1155_FULL_OPEN,\n\n    // 13: partial fills supported, anyone can execute\n    ERC20_TO_ERC1155_PARTIAL_OPEN,\n\n    // 14: no partial fills, only offerer or zone can execute\n    ERC20_TO_ERC1155_FULL_RESTRICTED,\n\n    // 15: partial fills supported, only offerer or zone can execute\n    ERC20_TO_ERC1155_PARTIAL_RESTRICTED,\n\n    // 16: no partial fills, anyone can execute\n    ERC721_TO_ERC20_FULL_OPEN,\n\n    // 17: partial fills supported, anyone can execute\n    ERC721_TO_ERC20_PARTIAL_OPEN,\n\n    // 18: no partial fills, only offerer or zone can execute\n    ERC721_TO_ERC20_FULL_RESTRICTED,\n\n    // 19: partial fills supported, only offerer or zone can execute\n    ERC721_TO_ERC20_PARTIAL_RESTRICTED,\n\n    // 20: no partial fills, anyone can execute\n    ERC1155_TO_ERC20_FULL_OPEN,\n\n    // 21: partial fills supported, anyone can execute\n    ERC1155_TO_ERC20_PARTIAL_OPEN,\n\n    // 22: no partial fills, only offerer or zone can execute\n    ERC1155_TO_ERC20_FULL_RESTRICTED,\n\n    // 23: partial fills supported, only offerer or zone can execute\n    ERC1155_TO_ERC20_PARTIAL_RESTRICTED\n}\n\nenum BasicOrderRouteType {\n    // 0: provide Ether (or other native token) to receive offered ERC721 item.\n    ETH_TO_ERC721,\n\n    // 1: provide Ether (or other native token) to receive offered ERC1155 item.\n    ETH_TO_ERC1155,\n\n    // 2: provide ERC20 item to receive offered ERC721 item.\n    ERC20_TO_ERC721,\n\n    // 3: provide ERC20 item to receive offered ERC1155 item.\n    ERC20_TO_ERC1155,\n\n    // 4: provide ERC721 item to receive offered ERC20 item.\n    ERC721_TO_ERC20,\n\n    // 5: provide ERC1155 item to receive offered ERC20 item.\n    ERC1155_TO_ERC20\n}\n\nenum ItemType {\n    // 0: ETH on mainnet, MATIC on polygon, etc.\n    NATIVE,\n\n    // 1: ERC20 items (ERC777 and ERC20 analogues could also technically work)\n    ERC20,\n\n    // 2: ERC721 items\n    ERC721,\n\n    // 3: ERC1155 items\n    ERC1155,\n\n    // 4: ERC721 items where a number of tokenIds are supported\n    ERC721_WITH_CRITERIA,\n\n    // 5: ERC1155 items where a number of ids are supported\n    ERC1155_WITH_CRITERIA\n}\n\nenum Side {\n    // 0: Items that can be spent\n    OFFER,\n\n    // 1: Items that must be received\n    CONSIDERATION\n}\n'}, 'src/lib/OrderFulfiller.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {\n    ItemType,\n    OrderType\n} from ""seaport-types/src/lib/ConsiderationEnums.sol"";\n\nimport {\n    AdvancedOrder,\n    ConsiderationItem,\n    CriteriaResolver,\n    OfferItem,\n    OrderParameters,\n    ReceivedItem,\n    SpentItem\n} from ""seaport-types/src/lib/ConsiderationStructs.sol"";\n\nimport { BasicOrderFulfiller } from ""./BasicOrderFulfiller.sol"";\n\nimport { CriteriaResolution } from ""./CriteriaResolution.sol"";\n\nimport { AmountDeriver } from ""./AmountDeriver.sol"";\n\nimport {\n    _revertInsufficientNativeTokensSupplied,\n    _revertInvalidNativeOfferItem\n} from ""seaport-types/src/lib/ConsiderationErrors.sol"";\n\nimport {\n    AccumulatorDisarmed,\n    ConsiderationItem_recipient_offset,\n    ReceivedItem_amount_offset,\n    ReceivedItem_recipient_offset\n} from ""seaport-types/src/lib/ConsiderationConstants.sol"";\n\n/**\n * @title OrderFulfiller\n * @author 0age\n * @notice OrderFulfiller contains logic related to order fulfillment where a\n *         single order is being fulfilled and where basic order fulfillment is\n *         not available as an option.\n */\ncontract OrderFulfiller is\n    BasicOrderFulfiller,\n    CriteriaResolution,\n    AmountDeriver\n{\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(\n        address conduitController\n    ) BasicOrderFulfiller(conduitController) {}\n\n    /**\n     * @dev Internal function to validate an order and update its status, adjust\n     *      prices based on current time, apply criteria resolvers, determine\n     *      what portion to fill, and transfer relevant tokens.\n     *\n     * @param advancedOrder       The order to fulfill as well as the fraction\n     *                            to fill. Note that all offer and consideration\n     *                            components must divide with no remainder for\n     *                            the partial fill to be valid.\n     * @param criteriaResolvers   An array where each element contains a\n     *                            reference to a specific offer or\n     *                            consideration, a token identifier, and a proof\n     *                            that the supplied token identifier is\n     *                            contained in the order\'s merkle root. Note\n     *                            that a criteria of zero indicates that any\n     *                            (transferable) token identifier is valid and\n     *                            that no proof needs to be supplied.\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\n     *                            any, to source the fulfiller\'s token approvals\n     *                            from. The zero hash signifies that no conduit\n     *                            should be used, with direct approvals set on\n     *                            Consideration.\n     * @param recipient           The intended recipient for all received items.\n     *\n     * @return A boolean indicating whether the order has been fulfilled.\n     */\n    function _validateAndFulfillAdvancedOrder(\n        AdvancedOrder memory advancedOrder,\n        CriteriaResolver[] memory criteriaResolvers,\n        bytes32 fulfillerConduitKey,\n        address recipient\n    ) internal returns (bool) {\n        // Retrieve the order parameters and order type.\n        OrderParameters memory orderParameters = advancedOrder.parameters;\n        OrderType orderType = orderParameters.orderType;\n\n        // Ensure this function cannot be triggered during a reentrant call.\n        _setReentrancyGuard(\n            // Native tokens accepted during execution for contract order types.\n            orderType == OrderType.CONTRACT\n        );\n\n        // Validate order, update status, and determine fraction to fill.\n        (\n            bytes32 orderHash,\n            uint256 fillNumerator,\n            uint256 fillDenominator\n        ) = _validateOrder(advancedOrder, _runTimeConstantTrue());\n\n        // Create an array with length 1 containing the order.\n        AdvancedOrder[] memory advancedOrders = new AdvancedOrder[](1);\n\n        // Populate the order as the first and only element of the new array.\n        advancedOrders[0] = advancedOrder;\n\n        // Apply criteria resolvers using generated orders and details arrays.\n        _applyCriteriaResolvers(advancedOrders, criteriaResolvers);\n\n        // Derive each item transfer with the appropriate fractional amount.\n        _applyFractions(\n            orderParameters,\n            fillNumerator,\n            fillDenominator,\n            recipient\n        );\n\n        // Declare an empty length-1 array to hold the order hash, but do not\n        // write to it until after the order has been authorized or generated.\n        bytes32[] memory orderHashes = new bytes32[](1);\n\n        // Declare a boolean that cannot be optimized out by the compiler\n        // outside of the if-else statement so it can be used in either.\n        bool _true = _runTimeConstantTrue();\n        if (orderType != OrderType.CONTRACT) {\n            _assertRestrictedAdvancedOrderAuthorization(\n                advancedOrder,\n                orderHashes,\n                orderHash,\n                0\n            );\n\n            _updateStatus(orderHash, fillNumerator, fillDenominator, _true);\n        } else {\n            // Return the generated order based on the order params and the\n            // provided extra data.\n            orderHash = _getGeneratedOrder(\n                orderParameters,\n                advancedOrder.extraData,\n                _true\n            );\n        }\n\n        _transferEach(orderParameters, fulfillerConduitKey, recipient);\n\n        // Write the order hash to the orderHashes array.\n        orderHashes[0] = orderHash;\n\n        // Ensure restricted orders have a valid submitter or pass a zone check.\n        _assertRestrictedAdvancedOrderValidity(\n            advancedOrder,\n            orderHashes,\n            orderHash\n        );\n\n        // Emit an event signifying that the order has been fulfilled.\n        _emitOrderFulfilledEvent(\n            orderHash,\n            orderParameters.offerer,\n            orderParameters.zone,\n            recipient,\n            orderParameters.offer,\n            orderParameters.consideration\n        );\n\n        // Clear the reentrancy guard.\n        _clearReentrancyGuard();\n\n        return true;\n    }\n\n    /**\n     * @dev Internal function to derive the amount to transfer for each item in\n     *      a given order based on the fraction to fill and the current time.\n     *\n     * @param orderParameters     The parameters for the fulfilled order.\n     * @param numerator           A value indicating the portion of the order\n     *                            that should be filled.\n     * @param denominator         A value indicating the total order size.\n     * @param recipient           The intended recipient for all received items.\n     */\n    function _applyFractions(\n        OrderParameters memory orderParameters,\n        uint256 numerator,\n        uint256 denominator,\n        address recipient\n    ) internal view {\n        // Read start time & end time from order parameters and place on stack.\n        uint256 startTime = orderParameters.startTime;\n        uint256 endTime = orderParameters.endTime;\n\n        // As of solidity 0.6.0, inline assembly cannot directly access function\n        // definitions, but can still access locally scoped function variables.\n        // This means that a local variable to reference the internal function\n        // definition (using the same type), along with a local variable with\n        // the desired type, must first be created. Then, the original function\n        // pointer can be recast to the desired type.\n\n        /**\n         * Repurpose existing OfferItem memory regions on the offer array for\n         * the order by overriding the _transfer function pointer to accept a\n         * modified OfferItem argument in place of the usual ReceivedItem:\n         *\n         *   ========= OfferItem ==========   ====== ReceivedItem ======\n         *   ItemType itemType; ------------> ItemType itemType;\n         *   address token; ----------------> address token;\n         *   uint256 identifierOrCriteria; -> uint256 identifier;\n         *   uint256 startAmount; ----------> uint256 amount;\n         *   uint256 endAmount; ------------> address recipient;\n         */\n\n        // Declare a nested scope to minimize stack depth.\n        unchecked {\n            // Read offer array length from memory and place on stack.\n            uint256 totalOfferItems = orderParameters.offer.length;\n\n            // Create a variable to indicate whether the order has any\n            // native offer items\n            uint256 anyNativeItems;\n\n            // Iterate over each offer on the order.\n            // Skip overflow check as for loop is indexed starting at zero.\n            for (uint256 i = 0; i < totalOfferItems; ++i) {\n                // Retrieve the offer item.\n                OfferItem memory offerItem = orderParameters.offer[i];\n\n                // Offer items for the native token can not be received outside\n                // of a match order function except as part of a contract order.\n                {\n                    ItemType itemType = offerItem.itemType;\n                    assembly {\n                        anyNativeItems := or(anyNativeItems, iszero(itemType))\n                    }\n                }\n\n                // Declare an additional nested scope to minimize stack depth.\n                {\n                    // Apply fill fraction to get offer item amount to transfer.\n                    uint256 amount = _applyFraction(\n                        offerItem.startAmount,\n                        offerItem.endAmount,\n                        numerator,\n                        denominator,\n                        startTime,\n                        endTime,\n                        _runTimeConstantFalse()\n                    );\n\n                    // Utilize assembly to set overloaded offerItem arguments.\n                    assembly {\n                        // Write new fractional amount to startAmount as amount.\n                        mstore(\n                            add(offerItem, ReceivedItem_amount_offset),\n                            amount\n                        )\n\n                        // Write recipient to endAmount.\n                        mstore(\n                            add(offerItem, ReceivedItem_recipient_offset),\n                            recipient\n                        )\n                    }\n                }\n            }\n\n            // If a non-contract order has native offer items, throw with an\n            // `InvalidNativeOfferItem` custom error.\n            {\n                OrderType orderType = orderParameters.orderType;\n                uint256 invalidNativeOfferItem;\n                assembly {\n                    invalidNativeOfferItem := and(\n                        // Note that this check requires that there are no\n                        // order types beyond the current set (0-4). It will\n                        // need to be modified when adding more order types.\n                        lt(orderType, 4),\n                        anyNativeItems\n                    )\n                }\n                if (invalidNativeOfferItem != 0) {\n                    _revertInvalidNativeOfferItem();\n                }\n            }\n        }\n\n        /**\n         * Repurpose existing ConsiderationItem memory regions on the\n         * consideration array for the order by overriding the _transfer\n         * function pointer to accept a modified ConsiderationItem argument in\n         * place of the usual ReceivedItem:\n         *\n         *   ====== ConsiderationItem =====   ====== ReceivedItem ======\n         *   ItemType itemType; ------------> ItemType itemType;\n         *   address token; ----------------> address token;\n         *   uint256 identifierOrCriteria;--> uint256 identifier;\n         *   uint256 startAmount; ----------> uint256 amount;\n         *   uint256 endAmount;        /----> address recipient;\n         *   address recipient; ------/\n         */\n\n        // Declare a nested scope to minimize stack depth.\n        unchecked {\n            // Read consideration array length from memory and place on stack.\n            uint256 totalConsiderationItems = orderParameters\n                .consideration\n                .length;\n\n            // Iterate over each consideration item on the order.\n            // Skip overflow check as for loop is indexed starting at zero.\n            for (uint256 i = 0; i < totalConsiderationItems; ++i) {\n                // Retrieve the consideration item.\n                ConsiderationItem memory considerationItem = (\n                    orderParameters.consideration[i]\n                );\n\n                // Apply fraction & derive considerationItem amount to transfer.\n                uint256 amount = _applyFraction(\n                    considerationItem.startAmount,\n                    considerationItem.endAmount,\n                    numerator,\n                    denominator,\n                    startTime,\n                    endTime,\n                    _runTimeConstantTrue()\n                );\n\n                // Use assembly to set overloaded considerationItem arguments.\n                assembly {\n                    // Write derived fractional amount to startAmount as amount.\n                    mstore(\n                        add(considerationItem, ReceivedItem_amount_offset),\n                        amount\n                    )\n\n                    // Write original recipient to endAmount as recipient.\n                    mstore(\n                        add(considerationItem, ReceivedItem_recipient_offset),\n                        mload(\n                            add(\n                                considerationItem,\n                                ConsiderationItem_recipient_offset\n                            )\n                        )\n                    )\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function to transfer each item contained in a given single\n     *      order fulfillment.\n     *\n     * @param orderParameters     The parameters for the fulfilled order.\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\n     *                            any, to source the fulfiller\'s token approvals\n     *                            from. The zero hash signifies that no conduit\n     *                            should be used, with direct approvals set on\n     *                            Consideration.\n     * @param recipient           The intended recipient for all received items.\n     */\n    function _transferEach(\n        OrderParameters memory orderParameters,\n        bytes32 fulfillerConduitKey,\n        address recipient\n    ) internal {\n        // Initialize an accumulator array. From this point forward, no new\n        // memory regions can be safely allocated until the accumulator is no\n        // longer being utilized, as the accumulator operates in an open-ended\n        // fashion from this memory pointer; existing memory may still be\n        // accessed and modified, however.\n        bytes memory accumulator = new bytes(AccumulatorDisarmed);\n\n        // As of solidity 0.6.0, inline assembly cannot directly access function\n        // definitions, but can still access locally scoped function variables.\n        // This means that a local variable to reference the internal function\n        // definition (using the same type), along with a local variable with\n        // the desired type, must first be created. Then, the original function\n        // pointer can be recast to the desired type.\n\n        /**\n         * Repurpose existing OfferItem memory regions on the offer array for\n         * the order by overriding the _transfer function pointer to accept a\n         * modified OfferItem argument in place of the usual ReceivedItem:\n         *\n         *   ========= OfferItem ==========   ====== ReceivedItem ======\n         *   ItemType itemType; ------------> ItemType itemType;\n         *   address token; ----------------> address token;\n         *   uint256 identifierOrCriteria; -> uint256 identifier;\n         *   uint256 startAmount; ----------> uint256 amount;\n         *   uint256 endAmount; ------------> address recipient;\n         */\n\n        // Declare a nested scope to minimize stack depth.\n        unchecked {\n            // Read offer array length from memory and place on stack.\n            uint256 totalOfferItems = orderParameters.offer.length;\n\n            // Iterate over each offer on the order.\n            // Skip overflow check as for loop is indexed starting at zero.\n            for (uint256 i = 0; i < totalOfferItems; ++i) {\n                // Retrieve the offer item.\n                OfferItem memory offerItem = orderParameters.offer[i];\n\n                // Utilize assembly to set overloaded offerItem arguments.\n                assembly {\n                    // Write recipient to endAmount.\n                    mstore(\n                        add(offerItem, ReceivedItem_recipient_offset),\n                        recipient\n                    )\n                }\n\n                // Transfer the item from the offerer to the recipient.\n                _toOfferItemInput(_transfer)(\n                    offerItem,\n                    orderParameters.offerer,\n                    orderParameters.conduitKey,\n                    accumulator\n                );\n            }\n        }\n\n        // Declare a variable for the available native token balance.\n        uint256 nativeTokenBalance;\n\n        /**\n         * Repurpose existing ConsiderationItem memory regions on the\n         * consideration array for the order by overriding the _transfer\n         * function pointer to accept a modified ConsiderationItem argument in\n         * place of the usual ReceivedItem:\n         *\n         *   ====== ConsiderationItem =====   ====== ReceivedItem ======\n         *   ItemType itemType; ------------> ItemType itemType;\n         *   address token; ----------------> address token;\n         *   uint256 identifierOrCriteria;--> uint256 identifier;\n         *   uint256 startAmount; ----------> uint256 amount;\n         *   uint256 endAmount;        /----> address recipient;\n         *   address recipient; ------/\n         */\n\n        // Declare a nested scope to minimize stack depth.\n        unchecked {\n            // Read consideration array length from memory and place on stack.\n            uint256 totalConsiderationItems = orderParameters\n                .consideration\n                .length;\n\n            // Iterate over each consideration item on the order.\n            // Skip overflow check as for loop is indexed starting at zero.\n            for (uint256 i = 0; i < totalConsiderationItems; ++i) {\n                // Retrieve the consideration item.\n                ConsiderationItem memory considerationItem = (\n                    orderParameters.consideration[i]\n                );\n\n                if (considerationItem.itemType == ItemType.NATIVE) {\n                    // Get the current available balance of native tokens.\n                    assembly {\n                        nativeTokenBalance := selfbalance()\n                    }\n\n                    // Ensure that sufficient native tokens are still available.\n                    if (considerationItem.startAmount > nativeTokenBalance) {\n                        _revertInsufficientNativeTokensSupplied();\n                    }\n                }\n\n                // Transfer item from caller to recipient specified by the item.\n                _toConsiderationItemInput(_transfer)(\n                    considerationItem,\n                    msg.sender,\n                    fulfillerConduitKey,\n                    accumulator\n                );\n            }\n        }\n\n        // Trigger any remaining accumulated transfers via call to the conduit.\n        _triggerIfArmed(accumulator);\n\n        // Determine whether any native token balance remains.\n        assembly {\n            nativeTokenBalance := selfbalance()\n        }\n\n        // Return any remaining native token balance to the caller.\n        if (nativeTokenBalance != 0) {\n            _transferNativeTokens(payable(msg.sender), nativeTokenBalance);\n        }\n    }\n\n    /**\n     * @dev Internal function to emit an OrderFulfilled event. OfferItems are\n     *      translated into SpentItems and ConsiderationItems are translated\n     *      into ReceivedItems.\n     *\n     * @param orderHash     The order hash.\n     * @param offerer       The offerer for the order.\n     * @param zone          The zone for the order.\n     * @param recipient     The recipient of the order, or the null address if\n     *                      the order was fulfilled via order matching.\n     * @param offer         The offer items for the order.\n     * @param consideration The consideration items for the order.\n     */\n    function _emitOrderFulfilledEvent(\n        bytes32 orderHash,\n        address offerer,\n        address zone,\n        address recipient,\n        OfferItem[] memory offer,\n        ConsiderationItem[] memory consideration\n    ) internal {\n        // Cast already-modified offer memory region as spent items.\n        SpentItem[] memory spentItems;\n        assembly {\n            spentItems := offer\n        }\n\n        // Cast already-modified consideration memory region as received items.\n        ReceivedItem[] memory receivedItems;\n        assembly {\n            receivedItems := consideration\n        }\n\n        // Emit an event signifying that the order has been fulfilled.\n        emit OrderFulfilled(\n            orderHash,\n            offerer,\n            zone,\n            recipient,\n            spentItems,\n            receivedItems\n        );\n    }\n}\n'}, 'src/lib/FulfillmentApplier.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { ItemType, Side } from ""seaport-types/src/lib/ConsiderationEnums.sol"";\n\nimport {\n    AdvancedOrder,\n    Execution,\n    FulfillmentComponent,\n    ReceivedItem\n} from ""seaport-types/src/lib/ConsiderationStructs.sol"";\n\nimport {\n    _revertMissingFulfillmentComponentOnAggregation\n} from ""seaport-types/src/lib/ConsiderationErrors.sol"";\n\nimport {\n    FulfillmentApplicationErrors\n} from ""seaport-types/src/interfaces/FulfillmentApplicationErrors.sol"";\n\nimport {\n    AdvancedOrder_numerator_offset,\n    Common_amount_offset,\n    Common_identifier_offset,\n    Common_token_offset,\n    Execution_conduit_offset,\n    Execution_offerer_offset,\n    Fulfillment_itemIndex_offset,\n    OneWord,\n    OneWordShift,\n    OrderParameters_conduit_offset,\n    OrderParameters_consideration_head_offset,\n    OrderParameters_offer_head_offset,\n    ReceivedItem_CommonParams_size,\n    ReceivedItem_recipient_offset,\n    ReceivedItem_size\n} from ""seaport-types/src/lib/ConsiderationConstants.sol"";\n\nimport {\n    Error_selector_offset,\n    InvalidFulfillmentComponentData_error_length,\n    InvalidFulfillmentComponentData_error_selector,\n    MismatchedOfferAndConsiderationComponents_error_idx_ptr,\n    MismatchedOfferAndConsiderationComponents_error_length,\n    MismatchedOfferAndConsiderationComponents_error_selector,\n    MissingItemAmount_error_length,\n    MissingItemAmount_error_selector,\n    OfferAndConsiderationRequiredOnFulfillment_error_length,\n    OfferAndConsiderationRequiredOnFulfillment_error_selector,\n    Panic_arithmetic,\n    Panic_error_code_ptr,\n    Panic_error_length,\n    Panic_error_selector\n} from ""seaport-types/src/lib/ConsiderationErrorConstants.sol"";\n\n/**\n * @title FulfillmentApplier\n * @author 0age\n * @notice FulfillmentApplier contains logic related to applying fulfillments,\n *         both as part of order matching (where offer items are matched to\n *         consideration items) as well as fulfilling available orders (where\n *         order items and consideration items are independently aggregated).\n */\ncontract FulfillmentApplier is FulfillmentApplicationErrors {\n    /**\n     * @dev Internal pure function to match offer items to consideration items\n     *      on a group of orders via a supplied fulfillment.\n     *\n     * @param advancedOrders          The orders to match.\n     * @param offerComponents         An array designating offer components to\n     *                                match to consideration components.\n     * @param considerationComponents An array designating consideration\n     *                                components to match to offer components.\n     *                                Note that each consideration amount must\n     *                                be zero in order for the match operation\n     *                                to be valid.\n     * @param fulfillmentIndex        The index of the fulfillment being\n     *                                applied.\n     *\n     * @return execution The transfer performed as a result of the fulfillment.\n     */\n    function _applyFulfillment(\n        AdvancedOrder[] memory advancedOrders,\n        FulfillmentComponent[] memory offerComponents,\n        FulfillmentComponent[] memory considerationComponents,\n        uint256 fulfillmentIndex\n    ) internal pure returns (Execution memory execution) {\n        // Ensure 1+ of both offer and consideration components are supplied.\n        assembly {\n            if or(\n                iszero(mload(offerComponents)),\n                iszero(mload(considerationComponents))\n            ) {\n                // Store left-padded selector with push4 (reduces bytecode),\n                // mem[28:32] = selector\n                mstore(\n                    0,\n                    OfferAndConsiderationRequiredOnFulfillment_error_selector\n                )\n\n                // revert(abi.encodeWithSignature(\n                //     ""OfferAndConsiderationRequiredOnFulfillment()""\n                // ))\n                revert(\n                    Error_selector_offset,\n                    OfferAndConsiderationRequiredOnFulfillment_error_length\n                )\n            }\n        }\n\n        // Declare a new Execution struct.\n        Execution memory considerationExecution;\n\n        // Validate & aggregate consideration items to new Execution object.\n        _aggregateValidFulfillmentConsiderationItems(\n            advancedOrders,\n            considerationComponents,\n            considerationExecution,\n            address(0),\n            bytes32(0)\n        );\n\n        // Retrieve the consideration item from the execution struct.\n        ReceivedItem memory considerationItem = considerationExecution.item;\n\n        // Skip aggregating offer items if no consideration items are available.\n        if (considerationItem.amount == 0) {\n            return considerationExecution;\n        }\n\n        // Validate & aggregate offer items to Execution object.\n        _aggregateValidFulfillmentOfferItems(\n            advancedOrders,\n            offerComponents,\n            execution,\n            considerationItem.recipient\n        );\n\n        ReceivedItem memory executionItem = execution.item;\n\n        // Ensure offer & consideration item types, tokens, & identifiers match.\n        // (a != b || c != d || e != f) == (((a ^ b) | (c ^ d) | (e ^ f)) != 0),\n        // but the second expression requires less gas to evaluate.\n        assembly {\n            if or(\n                or(\n                    xor(\n                        mload(executionItem), // no offset for item type\n                        mload(considerationItem) // no offset for item type\n                    ),\n                    xor(\n                        mload(add(executionItem, Common_token_offset)),\n                        mload(add(considerationItem, Common_token_offset))\n                    )\n                ),\n                xor(\n                    mload(add(executionItem, Common_identifier_offset)),\n                    mload(add(considerationItem, Common_identifier_offset))\n                )\n            ) {\n                // Store left-padded selector with push4 (reduces bytecode),\n                // mem[28:32] = selector\n                mstore(\n                    0,\n                    MismatchedOfferAndConsiderationComponents_error_selector\n                )\n\n                // Store fulfillment index argument.\n                mstore(\n                    MismatchedOfferAndConsiderationComponents_error_idx_ptr,\n                    fulfillmentIndex\n                )\n\n                // Revert: `MismatchedOfferAndConsiderationComponents(uint256)`\n                revert(\n                    Error_selector_offset,\n                    MismatchedOfferAndConsiderationComponents_error_length\n                )\n            }\n        }\n\n        // If total consideration amount exceeds the offer amount...\n        if (considerationItem.amount > executionItem.amount) {\n            // Retrieve the first consideration component from the fulfillment.\n            FulfillmentComponent memory targetComponent = (\n                considerationComponents[0]\n            );\n\n            // Skip underflow check as the conditional being true implies that\n            // considerationItem.amount > execution.item.amount.\n            unchecked {\n                // Add excess consideration item amount to original order array.\n                advancedOrders[targetComponent.orderIndex]\n                    .parameters\n                    .consideration[targetComponent.itemIndex]\n                    .startAmount = (considerationItem.amount -\n                    executionItem.amount);\n            }\n        } else {\n            // Retrieve the first offer component from the fulfillment.\n            FulfillmentComponent memory targetComponent = offerComponents[0];\n\n            // Skip underflow check as the conditional being false implies that\n            // execution.item.amount >= considerationItem.amount.\n            unchecked {\n                // Add excess offer item amount to the original array of orders.\n                advancedOrders[targetComponent.orderIndex]\n                    .parameters\n                    .offer[targetComponent.itemIndex]\n                    .startAmount = (executionItem.amount -\n                    considerationItem.amount);\n            }\n\n            // Reduce total offer amount to equal the consideration amount.\n            executionItem.amount = considerationItem.amount;\n        }\n\n        // Return the final execution that will be triggered for relevant items.\n        return execution; // Execution(executionItem, offerer, conduitKey);\n    }\n\n    /**\n     * @dev Internal view function to aggregate offer or consideration items\n     *      from a group of orders into a single execution via a supplied array\n     *      of fulfillment components. Items that are not available to aggregate\n     *      will not be included in the aggregated execution.\n     *\n     * @param advancedOrders        The orders to aggregate.\n     * @param side                  The side (i.e. offer or consideration).\n     * @param fulfillmentComponents An array designating item components to\n     *                              aggregate if part of an available order.\n     * @param fulfillerConduitKey   A bytes32 value indicating what conduit, if\n     *                              any, to source the fulfiller\'s token\n     *                              approvals from. The zero hash signifies that\n     *                              no conduit should be used, with approvals\n     *                              set directly on this contract.\n     * @param recipient             The intended recipient for all received\n     *                              items.\n     *\n     * @return execution The transfer performed as a result of the fulfillment.\n     */\n    function _aggregateAvailable(\n        AdvancedOrder[] memory advancedOrders,\n        Side side,\n        FulfillmentComponent[] memory fulfillmentComponents,\n        bytes32 fulfillerConduitKey,\n        address recipient\n    ) internal view returns (Execution memory execution) {\n        // Skip overflow / underflow checks; conditions checked or unreachable.\n        unchecked {\n            // Retrieve fulfillment components array length and place on stack.\n            // Ensure at least one fulfillment component has been supplied.\n            if (fulfillmentComponents.length == 0) {\n                _revertMissingFulfillmentComponentOnAggregation(side);\n            }\n\n            // If the fulfillment components are offer components...\n            if (side == Side.OFFER) {\n                // Return execution for aggregated items provided by offerer.\n                _aggregateValidFulfillmentOfferItems(\n                    advancedOrders,\n                    fulfillmentComponents,\n                    execution,\n                    payable(recipient)\n                );\n            } else {\n                // Otherwise, fulfillment components are consideration\n                // components. Return execution for aggregated items provided by\n                // the fulfiller.\n                _aggregateValidFulfillmentConsiderationItems(\n                    advancedOrders,\n                    fulfillmentComponents,\n                    execution,\n                    msg.sender,\n                    fulfillerConduitKey\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Internal pure function to aggregate a group of offer items using\n     *      supplied directives on which component items are candidates for\n     *      aggregation, skipping items on orders that are not available.\n     *\n     * @param advancedOrders  The orders to aggregate offer items from.\n     * @param offerComponents An array of FulfillmentComponent structs\n     *                        indicating the order index and item index of each\n     *                        candidate offer item for aggregation.\n     * @param execution       The execution to apply the aggregation to.\n     * @param recipient       The intended recipient for the received item.\n     */\n    function _aggregateValidFulfillmentOfferItems(\n        AdvancedOrder[] memory advancedOrders,\n        FulfillmentComponent[] memory offerComponents,\n        Execution memory execution,\n        address payable recipient\n    ) internal pure {\n        assembly {\n            // Declare a variable for the final aggregated item amount.\n            let amount\n\n            // Declare a variable to track errors encountered with amount.\n            let errorBuffer\n\n            // Declare a variable for the hash of itemType, token, & identifier.\n            let dataHash\n\n            // Iterate over each offer component.\n            for {\n                // Create variable to track position in offerComponents head.\n                let fulfillmentHeadPtr := offerComponents\n\n                // Get position of the last element in head of array.\n                let endPtr := add(\n                    offerComponents,\n                    shl(OneWordShift, mload(offerComponents))\n                )\n            } lt(fulfillmentHeadPtr, endPtr) {\n\n            } {\n                // Increment position in considerationComponents head.\n                fulfillmentHeadPtr := add(fulfillmentHeadPtr, OneWord)\n\n                // Ensure that the order index is not out of range.\n                if iszero(\n                    lt(mload(mload(fulfillmentHeadPtr)), mload(advancedOrders))\n                ) {\n                    throwInvalidFulfillmentComponentData()\n                }\n\n                // Read advancedOrders[orderIndex] pointer from its array head.\n                let orderPtr := mload(\n                    // Calculate head position of advancedOrders[orderIndex]\n                    add(\n                        add(advancedOrders, OneWord),\n                        shl(OneWordShift, mload(mload(fulfillmentHeadPtr)))\n                    )\n                )\n\n                // Read the pointer to OrderParameters from the AdvancedOrder.\n                let paramsPtr := mload(orderPtr)\n\n                // Retrieve item index using an offset of fulfillment pointer.\n                let itemIndex := mload(\n                    add(mload(fulfillmentHeadPtr), Fulfillment_itemIndex_offset)\n                )\n\n                let offerItemPtr\n                {\n                    // Load the offer array pointer.\n                    let offerArrPtr := mload(\n                        add(paramsPtr, OrderParameters_offer_head_offset)\n                    )\n\n                    // If the offer item index is out of range or the numerator\n                    // is zero, skip this item.\n                    if or(\n                        iszero(lt(itemIndex, mload(offerArrPtr))),\n                        iszero(\n                            mload(add(orderPtr, AdvancedOrder_numerator_offset))\n                        )\n                    ) {\n                        continue\n                    }\n\n                    // Retrieve offer item pointer using the item index.\n                    offerItemPtr := mload(\n                        add(\n                            // Get pointer to beginning of receivedItem.\n                            add(offerArrPtr, OneWord),\n                            // Calculate offset to pointer for the order.\n                            shl(OneWordShift, itemIndex)\n                        )\n                    )\n                }\n\n                // Declare a separate scope for the amount update.\n                {\n                    // Retrieve amount pointer using consideration item pointer.\n                    let amountPtr := add(offerItemPtr, Common_amount_offset)\n\n                    // Add offer item amount to execution amount.\n                    let newAmount := add(amount, mload(amountPtr))\n\n                    // Update error buffer:\n                    // 1 = zero amount, 2 = overflow, 3 = both.\n                    errorBuffer := or(\n                        errorBuffer,\n                        or(\n                            shl(1, lt(newAmount, amount)),\n                            iszero(mload(amountPtr))\n                        )\n                    )\n\n                    // Update the amount to the new, summed amount.\n                    amount := newAmount\n\n                    // Zero out amount on original item to indicate it is spent.\n                    mstore(amountPtr, 0)\n                }\n\n                // Retrieve ReceivedItem pointer from Execution.\n                let receivedItem := mload(execution)\n\n                // Check if this is the first valid fulfillment item.\n                switch iszero(dataHash)\n                case 1 {\n                    // On first valid item, populate the received item in memory\n                    // for later comparison.\n\n                    // Set the item type on the received item.\n                    mstore(receivedItem, mload(offerItemPtr))\n\n                    // Set the token on the received item.\n                    mstore(\n                        add(receivedItem, Common_token_offset),\n                        mload(add(offerItemPtr, Common_token_offset))\n                    )\n\n                    // Set the identifier on the received item.\n                    mstore(\n                        add(receivedItem, Common_identifier_offset),\n                        mload(add(offerItemPtr, Common_identifier_offset))\n                    )\n\n                    // Set the recipient on the received item.\n                    mstore(\n                        add(receivedItem, ReceivedItem_recipient_offset),\n                        recipient\n                    )\n\n                    // Set offerer on returned execution using order pointer.\n                    mstore(\n                        add(execution, Execution_offerer_offset),\n                        mload(paramsPtr)\n                    )\n\n                    // Set execution conduitKey via order pointer offset.\n                    mstore(\n                        add(execution, Execution_conduit_offset),\n                        mload(add(paramsPtr, OrderParameters_conduit_offset))\n                    )\n\n                    // Calculate the hash of (itemType, token, identifier).\n                    dataHash := keccak256(\n                        receivedItem,\n                        ReceivedItem_CommonParams_size\n                    )\n\n                    // If component index > 0, swap component pointer with\n                    // pointer to first component so that any remainder after\n                    // fulfillment can be added back to the first item.\n                    let firstFulfillmentHeadPtr := add(offerComponents, OneWord)\n                    if xor(firstFulfillmentHeadPtr, fulfillmentHeadPtr) {\n                        let fulfillmentPtr := mload(fulfillmentHeadPtr)\n                        mstore(firstFulfillmentHeadPtr, fulfillmentPtr)\n                    }\n                }\n                default {\n                    // Compare every subsequent item to the first.\n                    if or(\n                        or(\n                            // The offerer must match on both items.\n                            xor(\n                                mload(paramsPtr),\n                                mload(add(execution, Execution_offerer_offset))\n                            ),\n                            // The conduit key must match on both items.\n                            xor(\n                                mload(\n                                    add(\n                                        paramsPtr,\n                                        OrderParameters_conduit_offset\n                                    )\n                                ),\n                                mload(add(execution, Execution_conduit_offset))\n                            )\n                        ),\n                        // The itemType, token, and identifier must match.\n                        xor(\n                            dataHash,\n                            keccak256(\n                                offerItemPtr,\n                                ReceivedItem_CommonParams_size\n                            )\n                        )\n                    ) {\n                        // Throw if any of the requirements are not met.\n                        throwInvalidFulfillmentComponentData()\n                    }\n                }\n            }\n\n            // Write final amount to execution.\n            mstore(add(mload(execution), Common_amount_offset), amount)\n\n            // Determine whether the error buffer contains a nonzero error code.\n            if errorBuffer {\n                // If errorBuffer is 1, an item had an amount of zero.\n                if eq(errorBuffer, 1) {\n                    // Store left-padded selector with push4 (reduces bytecode)\n                    // mem[28:32] = selector\n                    mstore(0, MissingItemAmount_error_selector)\n\n                    // revert(abi.encodeWithSignature(""MissingItemAmount()""))\n                    revert(\n                        Error_selector_offset,\n                        MissingItemAmount_error_length\n                    )\n                }\n\n                // If errorBuffer is not 1 or 0, the sum overflowed.\n                // Panic!\n                throwOverflow()\n            }\n\n            // Declare function for reverts on invalid fulfillment data.\n            function throwInvalidFulfillmentComponentData() {\n                // Store left-padded selector (uses push4 and reduces code size)\n                mstore(0, InvalidFulfillmentComponentData_error_selector)\n\n                // revert(abi.encodeWithSignature(\n                //     ""InvalidFulfillmentComponentData()""\n                // ))\n                revert(\n                    Error_selector_offset,\n                    InvalidFulfillmentComponentData_error_length\n                )\n            }\n\n            // Declare function for reverts due to arithmetic overflows.\n            function throwOverflow() {\n                // Store the Panic error signature.\n                mstore(0, Panic_error_selector)\n                // Store the arithmetic (0x11) panic code.\n                mstore(Panic_error_code_ptr, Panic_arithmetic)\n                // revert(abi.encodeWithSignature(""Panic(uint256)"", 0x11))\n                revert(Error_selector_offset, Panic_error_length)\n            }\n        }\n    }\n\n    /**\n     * @dev Internal pure function to aggregate a group of consideration items\n     *      using supplied directives on which component items are candidates\n     *      for aggregation, skipping items on orders that are not available.\n     *      Note that this function depends on memory layout affected by an\n     *      earlier call to _validateOrdersAndPrepareToFulfill. The memory for\n     *      the consideration arrays needs to be updated before calling\n     *      _aggregateValidFulfillmentConsiderationItems.\n     *      _validateOrdersAndPrepareToFulfill is called in _matchAdvancedOrders\n     *      and _fulfillAvailableAdvancedOrders in the current version.\n     *\n     * @param advancedOrders          The orders to aggregate consideration\n     *                                items from.\n     * @param considerationComponents An array of FulfillmentComponent structs\n     *                                indicating the order index and item index\n     *                                of each candidate consideration item for\n     *                                aggregation.\n     * @param execution               The execution to apply the aggregation to.\n     * @param offerer                 The address of the offerer to set on the\n     *                                execution.\n     * @param conduitKey              A bytes32 value indicating the conduit key\n     *                                to set on the execution.\n     */\n    function _aggregateValidFulfillmentConsiderationItems(\n        AdvancedOrder[] memory advancedOrders,\n        FulfillmentComponent[] memory considerationComponents,\n        Execution memory execution,\n        address offerer,\n        bytes32 conduitKey\n    ) internal pure {\n        // Utilize assembly in order to efficiently aggregate the items.\n        assembly {\n            // Declare a variable for the final aggregated item amount.\n            let amount\n\n            // Create variable to track errors encountered with amount.\n            let errorBuffer\n\n            // Declare variable for hash(itemType, token, identifier, recipient)\n            let dataHash\n\n            // Iterate over each consideration component.\n            for {\n                // Track position in considerationComponents head.\n                let fulfillmentHeadPtr := considerationComponents\n\n                // Get position of the last element in head of array.\n                let endPtr := add(\n                    considerationComponents,\n                    shl(OneWordShift, mload(considerationComponents))\n                )\n            } lt(fulfillmentHeadPtr, endPtr) {\n\n            } {\n                // Increment position in considerationComponents head.\n                fulfillmentHeadPtr := add(fulfillmentHeadPtr, OneWord)\n\n                // Retrieve the order index using the fulfillment pointer.\n                let orderIndex := mload(mload(fulfillmentHeadPtr))\n\n                // Ensure that the order index is not out of range.\n                if iszero(lt(orderIndex, mload(advancedOrders))) {\n                    throwInvalidFulfillmentComponentData()\n                }\n\n                // Read advancedOrders[orderIndex] pointer from its array head.\n                let orderPtr := mload(\n                    // Derive head position of advancedOrders[orderIndex].\n                    add(\n                        add(advancedOrders, OneWord),\n                        shl(OneWordShift, orderIndex)\n                    )\n                )\n\n                // Retrieve item index using an offset of fulfillment pointer.\n                let itemIndex := mload(\n                    add(mload(fulfillmentHeadPtr), Fulfillment_itemIndex_offset)\n                )\n\n                let considerationItemPtr\n                {\n                    // Load consideration array pointer.\n                    let considerationArrPtr := mload(\n                        add(\n                            // Read OrderParameters pointer from the order.\n                            mload(orderPtr),\n                            OrderParameters_consideration_head_offset\n                        )\n                    )\n\n                    // If the consideration item index is out of range or the\n                    // numerator is zero, skip this item.\n                    if or(\n                        iszero(lt(itemIndex, mload(considerationArrPtr))),\n                        iszero(\n                            mload(add(orderPtr, AdvancedOrder_numerator_offset))\n                        )\n                    ) {\n                        continue\n                    }\n\n                    // Retrieve consideration item pointer using the item index.\n                    considerationItemPtr := mload(\n                        add(\n                            // Get pointer to beginning of receivedItem.\n                            add(considerationArrPtr, OneWord),\n                            // Calculate offset to pointer for the order.\n                            shl(OneWordShift, itemIndex)\n                        )\n                    )\n                }\n\n                // Declare a separate scope for the amount update.\n                {\n                    // Retrieve amount pointer using consideration item pointer.\n                    let amountPtr := add(\n                        considerationItemPtr,\n                        Common_amount_offset\n                    )\n\n                    // Add consideration item amount to execution amount.\n                    let newAmount := add(amount, mload(amountPtr))\n\n                    // Update error buffer:\n                    // 1 = zero amount, 2 = overflow, 3 = both.\n                    errorBuffer := or(\n                        errorBuffer,\n                        or(\n                            shl(1, lt(newAmount, amount)),\n                            iszero(mload(amountPtr))\n                        )\n                    )\n\n                    // Update the amount to the new, summed amount.\n                    amount := newAmount\n\n                    // Zero out original item amount to indicate it is credited.\n                    mstore(amountPtr, 0)\n                }\n\n                // Retrieve ReceivedItem pointer from Execution.\n                let receivedItem := mload(execution)\n\n                switch iszero(dataHash)\n                case 1 {\n                    // On first valid item, populate the received item in\n                    // memory for later comparison.\n\n                    // Set the item type on the received item.\n                    mstore(receivedItem, mload(considerationItemPtr))\n\n                    // Set the token on the received item.\n                    mstore(\n                        add(receivedItem, Common_token_offset),\n                        mload(add(considerationItemPtr, Common_token_offset))\n                    )\n\n                    // Set the identifier on the received item.\n                    mstore(\n                        add(receivedItem, Common_identifier_offset),\n                        mload(\n                            add(considerationItemPtr, Common_identifier_offset)\n                        )\n                    )\n\n                    // Set the recipient on the received item. Note that this\n                    // depends on the memory layout established by the\n                    // _validateOrdersAndPrepareToFulfill function.\n                    mstore(\n                        add(receivedItem, ReceivedItem_recipient_offset),\n                        mload(\n                            add(\n                                considerationItemPtr,\n                                ReceivedItem_recipient_offset\n                            )\n                        )\n                    )\n\n                    // Set provided offerer on the execution.\n                    mstore(add(execution, Execution_offerer_offset), offerer)\n\n                    // Set provided conduitKey on the execution.\n                    mstore(add(execution, Execution_conduit_offset), conduitKey)\n\n                    // Calculate the hash of (itemType, token, identifier,\n                    // recipient). This is run after amount is set to zero, so\n                    // there will be one blank word after identifier included in\n                    // the hash buffer.\n                    dataHash := keccak256(\n                        considerationItemPtr,\n                        ReceivedItem_size\n                    )\n\n                    // If component index > 0, swap component pointer with\n                    // pointer to first component so that any remainder after\n                    // fulfillment can be added back to the first item.\n                    let firstFulfillmentHeadPtr := add(\n                        considerationComponents,\n                        OneWord\n                    )\n                    if xor(firstFulfillmentHeadPtr, fulfillmentHeadPtr) {\n                        let fulfillmentPtr := mload(fulfillmentHeadPtr)\n                        mstore(firstFulfillmentHeadPtr, fulfillmentPtr)\n                    }\n                }\n                default {\n                    // Compare every subsequent item to the first; the item\n                    // type, token, identifier and recipient must match.\n                    if xor(\n                        dataHash,\n                        // Calculate the hash of (itemType, token, identifier,\n                        // recipient). This is run after amount is set to zero,\n                        // so there will be one blank word after identifier\n                        // included in the hash buffer.\n                        keccak256(considerationItemPtr, ReceivedItem_size)\n                    ) {\n                        // Throw if any of the requirements are not met.\n                        throwInvalidFulfillmentComponentData()\n                    }\n                }\n            }\n\n            // Retrieve ReceivedItem pointer from Execution.\n            let receivedItem := mload(execution)\n\n            // Write final amount to execution.\n            mstore(add(receivedItem, Common_amount_offset), amount)\n\n            // Determine whether the error buffer contains a nonzero error code.\n            if errorBuffer {\n                // If errorBuffer is 1, an item had an amount of zero.\n                if eq(errorBuffer, 1) {\n                    // Store left-padded selector with push4, mem[28:32]\n                    mstore(0, MissingItemAmount_error_selector)\n\n                    // revert(abi.encodeWithSignature(""MissingItemAmount()""))\n                    revert(\n                        Error_selector_offset,\n                        MissingItemAmount_error_length\n                    )\n                }\n\n                // If errorBuffer is not 1 or 0, `amount` overflowed.\n                // Panic!\n                throwOverflow()\n            }\n\n            // Declare function for reverts on invalid fulfillment data.\n            function throwInvalidFulfillmentComponentData() {\n                // Store the InvalidFulfillmentComponentData error signature.\n                mstore(0, InvalidFulfillmentComponentData_error_selector)\n\n                // revert(abi.encodeWithSignature(\n                //     ""InvalidFulfillmentComponentData()""\n                // ))\n                revert(\n                    Error_selector_offset,\n                    InvalidFulfillmentComponentData_error_length\n                )\n            }\n\n            // Declare function for reverts due to arithmetic overflows.\n            function throwOverflow() {\n                // Store the Panic error signature.\n                mstore(0, Panic_error_selector)\n                // Store the arithmetic (0x11) panic code.\n                mstore(Panic_error_code_ptr, Panic_arithmetic)\n                // revert(abi.encodeWithSignature(""Panic(uint256)"", 0x11))\n                revert(Error_selector_offset, Panic_error_length)\n            }\n        }\n    }\n}\n'}, 'lib/seaport-types/src/lib/ConsiderationErrors.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { Side } from ""./ConsiderationEnums.sol"";\n\nimport {\n    BadFraction_error_length,\n    BadFraction_error_selector,\n    CannotCancelOrder_error_length,\n    CannotCancelOrder_error_selector,\n    ConsiderationLengthNotEqualToTotalOriginal_error_length,\n    ConsiderationLengthNotEqualToTotalOriginal_error_selector,\n    ConsiderationNotMet_error_considerationIndex_ptr,\n    ConsiderationNotMet_error_length,\n    ConsiderationNotMet_error_orderIndex_ptr,\n    ConsiderationNotMet_error_selector,\n    ConsiderationNotMet_error_shortfallAmount_ptr,\n    CriteriaNotEnabledForItem_error_length,\n    CriteriaNotEnabledForItem_error_selector,\n    Error_selector_offset,\n    InsufficientNativeTokensSupplied_error_length,\n    InsufficientNativeTokensSupplied_error_selector,\n    InvalidBasicOrderParameterEncoding_error_length,\n    InvalidBasicOrderParameterEncoding_error_selector,\n    InvalidCallToConduit_error_conduit_ptr,\n    InvalidCallToConduit_error_length,\n    InvalidCallToConduit_error_selector,\n    InvalidConduit_error_conduit_ptr,\n    InvalidConduit_error_conduitKey_ptr,\n    InvalidConduit_error_length,\n    InvalidConduit_error_selector,\n    InvalidContractOrder_error_length,\n    InvalidContractOrder_error_orderHash_ptr,\n    InvalidContractOrder_error_selector,\n    InvalidERC721TransferAmount_error_amount_ptr,\n    InvalidERC721TransferAmount_error_length,\n    InvalidERC721TransferAmount_error_selector,\n    InvalidMsgValue_error_length,\n    InvalidMsgValue_error_selector,\n    InvalidMsgValue_error_value_ptr,\n    InvalidNativeOfferItem_error_length,\n    InvalidNativeOfferItem_error_selector,\n    InvalidProof_error_length,\n    InvalidProof_error_selector,\n    InvalidTime_error_endTime_ptr,\n    InvalidTime_error_length,\n    InvalidTime_error_selector,\n    InvalidTime_error_startTime_ptr,\n    MismatchedOfferAndConsiderationComponents_error_idx_ptr,\n    MismatchedOfferAndConsiderationComponents_error_length,\n    MismatchedOfferAndConsiderationComponents_error_selector,\n    MissingFulfillmentComponentOnAggregation_error_length,\n    MissingFulfillmentComponentOnAggregation_error_selector,\n    MissingFulfillmentComponentOnAggregation_error_side_ptr,\n    MissingOriginalConsiderationItems_error_length,\n    MissingOriginalConsiderationItems_error_selector,\n    NoReentrantCalls_error_length,\n    NoReentrantCalls_error_selector,\n    NoSpecifiedOrdersAvailable_error_length,\n    NoSpecifiedOrdersAvailable_error_selector,\n    OfferAndConsiderationRequiredOnFulfillment_error_length,\n    OfferAndConsiderationRequiredOnFulfillment_error_selector,\n    OrderAlreadyFilled_error_length,\n    OrderAlreadyFilled_error_orderHash_ptr,\n    OrderAlreadyFilled_error_selector,\n    OrderCriteriaResolverOutOfRange_error_length,\n    OrderCriteriaResolverOutOfRange_error_selector,\n    OrderCriteriaResolverOutOfRange_error_side_ptr,\n    OrderIsCancelled_error_length,\n    OrderIsCancelled_error_orderHash_ptr,\n    OrderIsCancelled_error_selector,\n    OrderPartiallyFilled_error_length,\n    OrderPartiallyFilled_error_orderHash_ptr,\n    OrderPartiallyFilled_error_selector,\n    PartialFillsNotEnabledForOrder_error_length,\n    PartialFillsNotEnabledForOrder_error_selector,\n    UnresolvedConsiderationCriteria_error_length,\n    UnresolvedConsiderationCriteria_error_orderIndex_ptr,\n    UnresolvedConsiderationCriteria_error_selector,\n    UnresolvedOfferCriteria_error_length,\n    UnresolvedOfferCriteria_error_offerIndex_ptr,\n    UnresolvedOfferCriteria_error_orderIndex_ptr,\n    UnresolvedOfferCriteria_error_selector,\n    UnusedItemParameters_error_length,\n    UnusedItemParameters_error_selector\n} from ""./ConsiderationErrorConstants.sol"";\n\n/**\n * @dev Reverts the current transaction with a ""BadFraction"" error message.\n */\nfunction _revertBadFraction() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, BadFraction_error_selector)\n\n        // revert(abi.encodeWithSignature(""BadFraction()""))\n        revert(Error_selector_offset, BadFraction_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with a ""ConsiderationNotMet"" error\n *      message, including the provided order index, consideration index, and\n *      shortfall amount.\n *\n * @param orderIndex         The index of the order that did not meet the\n *                           consideration criteria.\n * @param considerationIndex The index of the consideration item that did not\n *                           meet its criteria.\n * @param shortfallAmount    The amount by which the consideration criteria were\n *                           not met.\n */\nfunction _revertConsiderationNotMet(\n    uint256 orderIndex,\n    uint256 considerationIndex,\n    uint256 shortfallAmount\n) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, ConsiderationNotMet_error_selector)\n\n        // Store arguments.\n        mstore(ConsiderationNotMet_error_orderIndex_ptr, orderIndex)\n        mstore(\n            ConsiderationNotMet_error_considerationIndex_ptr, considerationIndex\n        )\n        mstore(ConsiderationNotMet_error_shortfallAmount_ptr, shortfallAmount)\n\n        // revert(abi.encodeWithSignature(\n        //     ""ConsiderationNotMet(uint256,uint256,uint256)"",\n        //     orderIndex,\n        //     considerationIndex,\n        //     shortfallAmount\n        // ))\n        revert(Error_selector_offset, ConsiderationNotMet_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with a ""CriteriaNotEnabledForItem"" error\n *      message.\n */\nfunction _revertCriteriaNotEnabledForItem() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, CriteriaNotEnabledForItem_error_selector)\n\n        // revert(abi.encodeWithSignature(""CriteriaNotEnabledForItem()""))\n        revert(Error_selector_offset, CriteriaNotEnabledForItem_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an\n *      ""InsufficientNativeTokensSupplied"" error message.\n */\nfunction _revertInsufficientNativeTokensSupplied() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InsufficientNativeTokensSupplied_error_selector)\n\n        // revert(abi.encodeWithSignature(""InsufficientNativeTokensSupplied()""))\n        revert(\n            Error_selector_offset, InsufficientNativeTokensSupplied_error_length\n        )\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an\n *      ""InvalidBasicOrderParameterEncoding"" error message.\n */\nfunction _revertInvalidBasicOrderParameterEncoding() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidBasicOrderParameterEncoding_error_selector)\n\n        // revert(abi.encodeWithSignature(\n        //     ""InvalidBasicOrderParameterEncoding()""\n        // ))\n        revert(\n            Error_selector_offset,\n            InvalidBasicOrderParameterEncoding_error_length\n        )\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an ""InvalidCallToConduit"" error\n *      message, including the provided address of the conduit that was called\n *      improperly.\n *\n * @param conduit The address of the conduit that was called improperly.\n */\nfunction _revertInvalidCallToConduit(address conduit) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidCallToConduit_error_selector)\n\n        // Store argument.\n        mstore(InvalidCallToConduit_error_conduit_ptr, conduit)\n\n        // revert(abi.encodeWithSignature(\n        //     ""InvalidCallToConduit(address)"",\n        //     conduit\n        // ))\n        revert(Error_selector_offset, InvalidCallToConduit_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an ""CannotCancelOrder"" error\n *      message.\n */\nfunction _revertCannotCancelOrder() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, CannotCancelOrder_error_selector)\n\n        // revert(abi.encodeWithSignature(""CannotCancelOrder()""))\n        revert(Error_selector_offset, CannotCancelOrder_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an ""InvalidConduit"" error message,\n *      including the provided key and address of the invalid conduit.\n *\n * @param conduitKey    The key of the invalid conduit.\n * @param conduit       The address of the invalid conduit.\n */\nfunction _revertInvalidConduit(bytes32 conduitKey, address conduit) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidConduit_error_selector)\n\n        // Store arguments.\n        mstore(InvalidConduit_error_conduitKey_ptr, conduitKey)\n        mstore(InvalidConduit_error_conduit_ptr, conduit)\n\n        // revert(abi.encodeWithSignature(\n        //     ""InvalidConduit(bytes32,address)"",\n        //     conduitKey,\n        //     conduit\n        // ))\n        revert(Error_selector_offset, InvalidConduit_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an ""InvalidERC721TransferAmount""\n *      error message.\n *\n * @param amount The invalid amount.\n */\nfunction _revertInvalidERC721TransferAmount(uint256 amount) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidERC721TransferAmount_error_selector)\n\n        // Store argument.\n        mstore(InvalidERC721TransferAmount_error_amount_ptr, amount)\n\n        // revert(abi.encodeWithSignature(\n        //     ""InvalidERC721TransferAmount(uint256)"",\n        //     amount\n        // ))\n        revert(Error_selector_offset, InvalidERC721TransferAmount_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an ""InvalidMsgValue"" error message,\n *      including the invalid value that was sent in the transaction\'s\n *      `msg.value` field.\n *\n * @param value The invalid value that was sent in the transaction\'s `msg.value`\n *              field.\n */\nfunction _revertInvalidMsgValue(uint256 value) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidMsgValue_error_selector)\n\n        // Store argument.\n        mstore(InvalidMsgValue_error_value_ptr, value)\n\n        // revert(abi.encodeWithSignature(""InvalidMsgValue(uint256)"", value))\n        revert(Error_selector_offset, InvalidMsgValue_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an ""InvalidNativeOfferItem"" error\n *      message.\n */\nfunction _revertInvalidNativeOfferItem() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidNativeOfferItem_error_selector)\n\n        // revert(abi.encodeWithSignature(""InvalidNativeOfferItem()""))\n        revert(Error_selector_offset, InvalidNativeOfferItem_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an ""InvalidProof"" error message.\n */\nfunction _revertInvalidProof() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidProof_error_selector)\n\n        // revert(abi.encodeWithSignature(""InvalidProof()""))\n        revert(Error_selector_offset, InvalidProof_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an ""InvalidContractOrder"" error\n *      message.\n *\n * @param orderHash The hash of the contract order that caused the error.\n */\nfunction _revertInvalidContractOrder(bytes32 orderHash) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidContractOrder_error_selector)\n\n        // Store arguments.\n        mstore(InvalidContractOrder_error_orderHash_ptr, orderHash)\n\n        // revert(abi.encodeWithSignature(\n        //     ""InvalidContractOrder(bytes32)"",\n        //     orderHash\n        // ))\n        revert(Error_selector_offset, InvalidContractOrder_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an ""InvalidTime"" error message.\n *\n * @param startTime       The time at which the order becomes active.\n * @param endTime         The time at which the order becomes inactive.\n */\nfunction _revertInvalidTime(uint256 startTime, uint256 endTime) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidTime_error_selector)\n\n        // Store arguments.\n        mstore(InvalidTime_error_startTime_ptr, startTime)\n        mstore(InvalidTime_error_endTime_ptr, endTime)\n\n        // revert(abi.encodeWithSignature(\n        //     ""InvalidTime(uint256,uint256)"",\n        //     startTime,\n        //     endTime\n        // ))\n        revert(Error_selector_offset, InvalidTime_error_length)\n    }\n}\n\n/**\n * @dev Reverts execution with a ""MissingFulfillmentComponentOnAggregation""\n *       error message.\n *\n * @param side The side of the fulfillment component that is missing (0 for\n *             offer, 1 for consideration).\n *\n */\nfunction _revertMissingFulfillmentComponentOnAggregation(Side side) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, MissingFulfillmentComponentOnAggregation_error_selector)\n\n        // Store argument.\n        mstore(MissingFulfillmentComponentOnAggregation_error_side_ptr, side)\n\n        // revert(abi.encodeWithSignature(\n        //     ""MissingFulfillmentComponentOnAggregation(uint8)"",\n        //     side\n        // ))\n        revert(\n            Error_selector_offset,\n            MissingFulfillmentComponentOnAggregation_error_length\n        )\n    }\n}\n\n/**\n * @dev Reverts execution with a ""MissingOriginalConsiderationItems"" error\n *      message.\n */\nfunction _revertMissingOriginalConsiderationItems() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, MissingOriginalConsiderationItems_error_selector)\n\n        // revert(abi.encodeWithSignature(\n        //     ""MissingOriginalConsiderationItems()""\n        // ))\n        revert(\n            Error_selector_offset,\n            MissingOriginalConsiderationItems_error_length\n        )\n    }\n}\n\n/**\n * @dev Reverts execution with a ""NoReentrantCalls"" error message.\n */\nfunction _revertNoReentrantCalls() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, NoReentrantCalls_error_selector)\n\n        // revert(abi.encodeWithSignature(""NoReentrantCalls()""))\n        revert(Error_selector_offset, NoReentrantCalls_error_length)\n    }\n}\n\n/**\n * @dev Reverts execution with a ""NoSpecifiedOrdersAvailable"" error message.\n */\nfunction _revertNoSpecifiedOrdersAvailable() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, NoSpecifiedOrdersAvailable_error_selector)\n\n        // revert(abi.encodeWithSignature(""NoSpecifiedOrdersAvailable()""))\n        revert(Error_selector_offset, NoSpecifiedOrdersAvailable_error_length)\n    }\n}\n\n/**\n * @dev Reverts execution with an ""OrderAlreadyFilled"" error message.\n *\n * @param orderHash The hash of the order that has already been filled.\n */\nfunction _revertOrderAlreadyFilled(bytes32 orderHash) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, OrderAlreadyFilled_error_selector)\n\n        // Store argument.\n        mstore(OrderAlreadyFilled_error_orderHash_ptr, orderHash)\n\n        // revert(abi.encodeWithSignature(\n        //     ""OrderAlreadyFilled(bytes32)"",\n        //     orderHash\n        // ))\n        revert(Error_selector_offset, OrderAlreadyFilled_error_length)\n    }\n}\n\n/**\n * @dev Reverts execution with an ""OrderCriteriaResolverOutOfRange"" error\n *      message.\n *\n * @param side The side of the criteria that is missing (0 for offer, 1 for\n *             consideration).\n *\n */\nfunction _revertOrderCriteriaResolverOutOfRange(Side side) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, OrderCriteriaResolverOutOfRange_error_selector)\n\n        // Store argument.\n        mstore(OrderCriteriaResolverOutOfRange_error_side_ptr, side)\n\n        // revert(abi.encodeWithSignature(\n        //     ""OrderCriteriaResolverOutOfRange(uint8)"",\n        //     side\n        // ))\n        revert(\n            Error_selector_offset, OrderCriteriaResolverOutOfRange_error_length\n        )\n    }\n}\n\n/**\n * @dev Reverts execution with an ""OrderIsCancelled"" error message.\n *\n * @param orderHash The hash of the order that has already been cancelled.\n */\nfunction _revertOrderIsCancelled(bytes32 orderHash) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, OrderIsCancelled_error_selector)\n\n        // Store argument.\n        mstore(OrderIsCancelled_error_orderHash_ptr, orderHash)\n\n        // revert(abi.encodeWithSignature(\n        //     ""OrderIsCancelled(bytes32)"",\n        //     orderHash\n        // ))\n        revert(Error_selector_offset, OrderIsCancelled_error_length)\n    }\n}\n\n/**\n * @dev Reverts execution with an ""OrderPartiallyFilled"" error message.\n *\n * @param orderHash The hash of the order that has already been partially\n *                  filled.\n */\nfunction _revertOrderPartiallyFilled(bytes32 orderHash) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, OrderPartiallyFilled_error_selector)\n\n        // Store argument.\n        mstore(OrderPartiallyFilled_error_orderHash_ptr, orderHash)\n\n        // revert(abi.encodeWithSignature(\n        //     ""OrderPartiallyFilled(bytes32)"",\n        //     orderHash\n        // ))\n        revert(Error_selector_offset, OrderPartiallyFilled_error_length)\n    }\n}\n\n/**\n * @dev Reverts execution with a ""PartialFillsNotEnabledForOrder"" error message.\n */\nfunction _revertPartialFillsNotEnabledForOrder() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, PartialFillsNotEnabledForOrder_error_selector)\n\n        // revert(abi.encodeWithSignature(""PartialFillsNotEnabledForOrder()""))\n        revert(\n            Error_selector_offset, PartialFillsNotEnabledForOrder_error_length\n        )\n    }\n}\n\n/**\n * @dev Reverts execution with an ""UnusedItemParameters"" error message.\n */\nfunction _revertUnusedItemParameters() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, UnusedItemParameters_error_selector)\n\n        // revert(abi.encodeWithSignature(""UnusedItemParameters()""))\n        revert(Error_selector_offset, UnusedItemParameters_error_length)\n    }\n}\n\n/**\n * @dev Reverts execution with a ""ConsiderationLengthNotEqualToTotalOriginal""\n *      error message.\n */\nfunction _revertConsiderationLengthNotEqualToTotalOriginal() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, ConsiderationLengthNotEqualToTotalOriginal_error_selector)\n\n        // revert(abi.encodeWithSignature(\n        //     ""ConsiderationLengthNotEqualToTotalOriginal()""\n        // ))\n        revert(\n            Error_selector_offset,\n            ConsiderationLengthNotEqualToTotalOriginal_error_length\n        )\n    }\n}\n'}, 'lib/seaport-types/src/lib/ConsiderationErrorConstants.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nuint256 constant Error_selector_offset = 0x1c;\n\n/*\n *  error MissingFulfillmentComponentOnAggregation(uint8 side)\n *    - Defined in FulfillmentApplicationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: side\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant MissingFulfillmentComponentOnAggregation_error_selector = (\n    0x375c24c1\n);\nuint256 constant MissingFulfillmentComponentOnAggregation_error_side_ptr = 0x20;\nuint256 constant MissingFulfillmentComponentOnAggregation_error_length = 0x24;\n\n/*\n *  error OfferAndConsiderationRequiredOnFulfillment()\n *    - Defined in FulfillmentApplicationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant OfferAndConsiderationRequiredOnFulfillment_error_selector = (\n    0x98e9db6e\n);\nuint256 constant OfferAndConsiderationRequiredOnFulfillment_error_length = 0x04;\n\n/*\n *  error MismatchedFulfillmentOfferAndConsiderationComponents(\n *      uint256 fulfillmentIndex\n *  )\n *    - Defined in FulfillmentApplicationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: fulfillmentIndex\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant MismatchedOfferAndConsiderationComponents_error_selector = (\n    0xbced929d\n);\nuint256 constant MismatchedOfferAndConsiderationComponents_error_idx_ptr = 0x20;\nuint256 constant MismatchedOfferAndConsiderationComponents_error_length = 0x24;\n\n/*\n *  error InvalidFulfillmentComponentData()\n *    - Defined in FulfillmentApplicationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InvalidFulfillmentComponentData_error_selector = 0x7fda7279;\nuint256 constant InvalidFulfillmentComponentData_error_length = 0x04;\n\n/*\n *  error InexactFraction()\n *    - Defined in AmountDerivationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InexactFraction_error_selector = 0xc63cf089;\nuint256 constant InexactFraction_error_length = 0x04;\n\n/*\n *  error OrderCriteriaResolverOutOfRange(uint8 side)\n *    - Defined in CriteriaResolutionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: side\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant OrderCriteriaResolverOutOfRange_error_selector = 0x133c37c6;\nuint256 constant OrderCriteriaResolverOutOfRange_error_side_ptr = 0x20;\nuint256 constant OrderCriteriaResolverOutOfRange_error_length = 0x24;\n\n/*\n *  error UnresolvedOfferCriteria(uint256 orderIndex, uint256 offerIndex)\n *    - Defined in CriteriaResolutionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderIndex\n *    - 0x40: offerIndex\n * Revert buffer is memory[0x1c:0x60]\n */\nuint256 constant UnresolvedOfferCriteria_error_selector = 0xd6929332;\nuint256 constant UnresolvedOfferCriteria_error_orderIndex_ptr = 0x20;\nuint256 constant UnresolvedOfferCriteria_error_offerIndex_ptr = 0x40;\nuint256 constant UnresolvedOfferCriteria_error_length = 0x44;\n\n/*\n *  error UnresolvedConsiderationCriteria(\n *      uint256 orderIndex,\n *      uint256 considerationIndex\n *  )\n *    - Defined in CriteriaResolutionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderIndex\n *    - 0x40: considerationIndex\n * Revert buffer is memory[0x1c:0x60]\n */\nuint256 constant UnresolvedConsiderationCriteria_error_selector = 0xa8930e9a;\nuint256 constant UnresolvedConsiderationCriteria_error_orderIndex_ptr = 0x20;\nuint256 constant UnresolvedConsiderationCriteria_error_itemIndex_ptr = 0x40;\nuint256 constant UnresolvedConsiderationCriteria_error_length = 0x44;\n\n/*\n *  error OfferCriteriaResolverOutOfRange()\n *    - Defined in CriteriaResolutionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant OfferCriteriaResolverOutOfRange_error_selector = 0xbfb3f8ce;\n// uint256 constant OfferCriteriaResolverOutOfRange_error_length = 0x04;\n\n/*\n *  error ConsiderationCriteriaResolverOutOfRange()\n *    - Defined in CriteriaResolutionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant ConsiderationCriteriaResolverOutOfRange_error_selector = (\n    0x6088d7de\n);\nuint256 constant ConsiderationCriteriaResolverOutOfRange_err_selector = (\n    0x6088d7de\n);\n// uint256 constant ConsiderationCriteriaResolverOutOfRange_error_length = 0x04;\n\n/*\n *  error CriteriaNotEnabledForItem()\n *    - Defined in CriteriaResolutionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant CriteriaNotEnabledForItem_error_selector = 0x94eb6af6;\nuint256 constant CriteriaNotEnabledForItem_error_length = 0x04;\n\n/*\n *  error InvalidProof()\n *    - Defined in CriteriaResolutionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InvalidProof_error_selector = 0x09bde339;\nuint256 constant InvalidProof_error_length = 0x04;\n\n/*\n *  error InvalidRestrictedOrder(bytes32 orderHash)\n *    - Defined in ZoneInteractionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderHash\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant InvalidRestrictedOrder_error_selector = 0xfb5014fc;\nuint256 constant InvalidRestrictedOrder_error_orderHash_ptr = 0x20;\nuint256 constant InvalidRestrictedOrder_error_length = 0x24;\n\n/*\n *  error InvalidContractOrder(bytes32 orderHash)\n *    - Defined in ZoneInteractionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderHash\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant InvalidContractOrder_error_selector = 0x93979285;\nuint256 constant InvalidContractOrder_error_orderHash_ptr = 0x20;\nuint256 constant InvalidContractOrder_error_length = 0x24;\n\n/*\n *  error BadSignatureV(uint8 v)\n *    - Defined in SignatureVerificationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: v\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant BadSignatureV_error_selector = 0x1f003d0a;\nuint256 constant BadSignatureV_error_v_ptr = 0x20;\nuint256 constant BadSignatureV_error_length = 0x24;\n\n/*\n *  error InvalidSigner()\n *    - Defined in SignatureVerificationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InvalidSigner_error_selector = 0x815e1d64;\nuint256 constant InvalidSigner_error_length = 0x04;\n\n/*\n *  error InvalidSignature()\n *    - Defined in SignatureVerificationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InvalidSignature_error_selector = 0x8baa579f;\nuint256 constant InvalidSignature_error_length = 0x04;\n\n/*\n *  error BadContractSignature()\n *    - Defined in SignatureVerificationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant BadContractSignature_error_selector = 0x4f7fb80d;\nuint256 constant BadContractSignature_error_length = 0x04;\n\n/*\n *  error InvalidERC721TransferAmount(uint256 amount)\n *    - Defined in TokenTransferrerErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: amount\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant InvalidERC721TransferAmount_error_selector = 0x69f95827;\nuint256 constant InvalidERC721TransferAmount_error_amount_ptr = 0x20;\nuint256 constant InvalidERC721TransferAmount_error_length = 0x24;\n\n/*\n *  error MissingItemAmount()\n *    - Defined in TokenTransferrerErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant MissingItemAmount_error_selector = 0x91b3e514;\nuint256 constant MissingItemAmount_error_length = 0x04;\n\n/*\n *  error UnusedItemParameters()\n *    - Defined in TokenTransferrerErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant UnusedItemParameters_error_selector = 0x6ab37ce7;\nuint256 constant UnusedItemParameters_error_length = 0x04;\n\n/*\n *  error NoReentrantCalls()\n *    - Defined in ReentrancyErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant NoReentrantCalls_error_selector = 0x7fa8a987;\nuint256 constant NoReentrantCalls_error_length = 0x04;\n\n/*\n *  error OrderAlreadyFilled(bytes32 orderHash)\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderHash\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant OrderAlreadyFilled_error_selector = 0x10fda3e1;\nuint256 constant OrderAlreadyFilled_error_orderHash_ptr = 0x20;\nuint256 constant OrderAlreadyFilled_error_length = 0x24;\n\n/*\n *  error InvalidTime(uint256 startTime, uint256 endTime)\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: startTime\n *    - 0x40: endTime\n * Revert buffer is memory[0x1c:0x60]\n */\nuint256 constant InvalidTime_error_selector = 0x21ccfeb7;\nuint256 constant InvalidTime_error_startTime_ptr = 0x20;\nuint256 constant InvalidTime_error_endTime_ptr = 0x40;\nuint256 constant InvalidTime_error_length = 0x44;\n\n/*\n *  error InvalidConduit(bytes32 conduitKey, address conduit)\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: conduitKey\n *    - 0x40: conduit\n * Revert buffer is memory[0x1c:0x60]\n */\nuint256 constant InvalidConduit_error_selector = 0x1cf99b26;\nuint256 constant InvalidConduit_error_conduitKey_ptr = 0x20;\nuint256 constant InvalidConduit_error_conduit_ptr = 0x40;\nuint256 constant InvalidConduit_error_length = 0x44;\n\n/*\n *  error MissingOriginalConsiderationItems()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant MissingOriginalConsiderationItems_error_selector = 0x466aa616;\nuint256 constant MissingOriginalConsiderationItems_error_length = 0x04;\n\n/*\n *  error InvalidCallToConduit(address conduit)\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: conduit\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant InvalidCallToConduit_error_selector = 0xd13d53d4;\nuint256 constant InvalidCallToConduit_error_conduit_ptr = 0x20;\nuint256 constant InvalidCallToConduit_error_length = 0x24;\n\n/*\n *  error ConsiderationNotMet(\n *      uint256 orderIndex,\n *      uint256 considerationIndex,\n *      uint256 shortfallAmount\n *  )\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderIndex\n *    - 0x40: considerationIndex\n *    - 0x60: shortfallAmount\n * Revert buffer is memory[0x1c:0x80]\n */\nuint256 constant ConsiderationNotMet_error_selector = 0xa5f54208;\nuint256 constant ConsiderationNotMet_error_orderIndex_ptr = 0x20;\nuint256 constant ConsiderationNotMet_error_considerationIndex_ptr = 0x40;\nuint256 constant ConsiderationNotMet_error_shortfallAmount_ptr = 0x60;\nuint256 constant ConsiderationNotMet_error_length = 0x64;\n\n/*\n *  error InsufficientNativeTokensSupplied()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InsufficientNativeTokensSupplied_error_selector = 0x8ffff980;\nuint256 constant InsufficientNativeTokensSupplied_error_length = 0x04;\n\n/*\n *  error NativeTokenTransferGenericFailure(address account, uint256 amount)\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: account\n *    - 0x40: amount\n * Revert buffer is memory[0x1c:0x60]\n */\nuint256 constant NativeTokenTransferGenericFailure_error_selector = 0xbc806b96;\nuint256 constant NativeTokenTransferGenericFailure_error_account_ptr = 0x20;\nuint256 constant NativeTokenTransferGenericFailure_error_amount_ptr = 0x40;\nuint256 constant NativeTokenTransferGenericFailure_error_length = 0x44;\n\n/*\n *  error PartialFillsNotEnabledForOrder()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant PartialFillsNotEnabledForOrder_error_selector = 0xa11b63ff;\nuint256 constant PartialFillsNotEnabledForOrder_error_length = 0x04;\n\n/*\n *  error OrderIsCancelled(bytes32 orderHash)\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderHash\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant OrderIsCancelled_error_selector = 0x1a515574;\nuint256 constant OrderIsCancelled_error_orderHash_ptr = 0x20;\nuint256 constant OrderIsCancelled_error_length = 0x24;\n\n/*\n *  error OrderPartiallyFilled(bytes32 orderHash)\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderHash\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant OrderPartiallyFilled_error_selector = 0xee9e0e63;\nuint256 constant OrderPartiallyFilled_error_orderHash_ptr = 0x20;\nuint256 constant OrderPartiallyFilled_error_length = 0x24;\n\n/*\n *  error CannotCancelOrder()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant CannotCancelOrder_error_selector = 0xfed398fc;\nuint256 constant CannotCancelOrder_error_length = 0x04;\n\n/*\n *  error BadFraction()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant BadFraction_error_selector = 0x5a052b32;\nuint256 constant BadFraction_error_length = 0x04;\n\n/*\n *  error InvalidMsgValue(uint256 value)\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: value\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant InvalidMsgValue_error_selector = 0xa61be9f0;\nuint256 constant InvalidMsgValue_error_value_ptr = 0x20;\nuint256 constant InvalidMsgValue_error_length = 0x24;\n\n/*\n *  error InvalidBasicOrderParameterEncoding()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InvalidBasicOrderParameterEncoding_error_selector = 0x39f3e3fd;\nuint256 constant InvalidBasicOrderParameterEncoding_error_length = 0x04;\n\n/*\n *  error NoSpecifiedOrdersAvailable()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant NoSpecifiedOrdersAvailable_error_selector = 0xd5da9a1b;\nuint256 constant NoSpecifiedOrdersAvailable_error_length = 0x04;\n\n/*\n *  error InvalidNativeOfferItem()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InvalidNativeOfferItem_error_selector = 0x12d3f5a3;\nuint256 constant InvalidNativeOfferItem_error_length = 0x04;\n\n/*\n *  error ConsiderationLengthNotEqualToTotalOriginal()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant ConsiderationLengthNotEqualToTotalOriginal_error_selector = (\n    0x2165628a\n);\nuint256 constant ConsiderationLengthNotEqualToTotalOriginal_error_length = 0x04;\n\n/*\n *  error Panic(uint256 code)\n *    - Built-in Solidity error\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: code\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant Panic_error_selector = 0x4e487b71;\nuint256 constant Panic_error_code_ptr = 0x20;\nuint256 constant Panic_error_length = 0x24;\n\nuint256 constant Panic_arithmetic = 0x11;\n// uint256 constant Panic_resource = 0x41;\n'}, 'src/lib/BasicOrderFulfiller.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {\n    BasicOrderRouteType,\n    ItemType,\n    OrderType\n} from ""seaport-types/src/lib/ConsiderationEnums.sol"";\n\nimport {\n    BasicOrderParameters,\n    OrderStatus\n} from ""seaport-types/src/lib/ConsiderationStructs.sol"";\n\nimport { OrderValidator } from ""./OrderValidator.sol"";\n\nimport {\n    _revertInsufficientNativeTokensSupplied,\n    _revertInvalidMsgValue,\n    _revertInvalidERC721TransferAmount,\n    _revertUnusedItemParameters\n} from ""seaport-types/src/lib/ConsiderationErrors.sol"";\n\nimport {\n    AccumulatorDisarmed,\n    AdditionalRecipient_size_shift,\n    AdditionalRecipient_size,\n    BasicOrder_additionalRecipients_data_cdPtr,\n    BasicOrder_addlRecipients_length_cdPtr,\n    BasicOrder_basicOrderType_cdPtr,\n    BasicOrder_common_params_size,\n    BasicOrder_considerationAmount_cdPtr,\n    BasicOrder_considerationHashesArray_ptr,\n    BasicOrder_considerationIdentifier_cdPtr,\n    BasicOrder_considerationItem_endAmount_ptr,\n    BasicOrder_considerationItem_identifier_ptr,\n    BasicOrder_considerationItem_itemType_ptr,\n    BasicOrder_considerationItem_startAmount_ptr,\n    BasicOrder_considerationItem_token_ptr,\n    BasicOrder_considerationItem_typeHash_ptr,\n    BasicOrder_considerationToken_cdPtr,\n    BasicOrder_endTime_cdPtr,\n    BasicOrder_fulfillerConduit_cdPtr,\n    BasicOrder_offerAmount_cdPtr,\n    BasicOrder_offeredItemByteMap,\n    BasicOrder_offerer_cdPtr,\n    BasicOrder_offererConduit_cdPtr,\n    BasicOrder_offerIdentifier_cdPtr,\n    BasicOrder_offerItem_endAmount_ptr,\n    BasicOrder_offerItem_itemType_ptr,\n    BasicOrder_offerItem_token_ptr,\n    BasicOrder_offerItem_typeHash_ptr,\n    BasicOrder_offerToken_cdPtr,\n    BasicOrder_order_considerationHashes_ptr,\n    BasicOrder_order_counter_ptr,\n    BasicOrder_order_offerer_ptr,\n    BasicOrder_order_offerHashes_ptr,\n    BasicOrder_order_orderType_ptr,\n    BasicOrder_order_startTime_ptr,\n    BasicOrder_order_typeHash_ptr,\n    BasicOrder_receivedItemByteMap,\n    BasicOrder_startTime_cdPtr,\n    BasicOrder_totalOriginalAdditionalRecipients_cdPtr,\n    BasicOrder_zone_cdPtr,\n    Common_token_offset,\n    Conduit_execute_ConduitTransfer_length_ptr,\n    Conduit_execute_ConduitTransfer_length,\n    Conduit_execute_ConduitTransfer_offset_ptr,\n    Conduit_execute_ConduitTransfer_ptr,\n    Conduit_execute_signature,\n    Conduit_execute_transferAmount_ptr,\n    Conduit_execute_transferIdentifier_ptr,\n    Conduit_execute_transferFrom_ptr,\n    Conduit_execute_transferItemType_ptr,\n    Conduit_execute_transferTo_ptr,\n    Conduit_execute_transferToken_ptr,\n    EIP712_ConsiderationItem_size,\n    EIP712_OfferItem_size,\n    EIP712_Order_size,\n    FiveWords,\n    FourWords,\n    FreeMemoryPointerSlot,\n    MaskOverLastTwentyBytes,\n    OneConduitExecute_size,\n    OneWord,\n    OneWordShift,\n    OrderFulfilled_baseOffset,\n    OrderFulfilled_baseSize,\n    OrderFulfilled_consideration_body_offset,\n    OrderFulfilled_consideration_head_offset,\n    OrderFulfilled_consideration_length_baseOffset,\n    OrderFulfilled_fulfiller_offset,\n    OrderFulfilled_offer_body_offset,\n    OrderFulfilled_offer_head_offset,\n    OrderFulfilled_offer_length_baseOffset,\n    OrderFulfilled_offer_length_offset_relativeTo_baseOffset,\n    OrderFulfilled_offer_itemType_offset_relativeTo_baseOffset,\n    OrderFulfilled_offer_token_offset_relativeTo_baseOffset,\n    OrderFulfilled_post_memory_region_reservedBytes,\n    OrderFulfilled_selector,\n    ReceivedItem_amount_offset,\n    ReceivedItem_size,\n    receivedItemsHash_ptr,\n    ThreeWords,\n    TwoWords,\n    ZeroSlot\n} from ""seaport-types/src/lib/ConsiderationConstants.sol"";\n\nimport {\n    Error_selector_offset,\n    InvalidBasicOrderParameterEncoding_error_length,\n    InvalidBasicOrderParameterEncoding_error_selector,\n    InvalidTime_error_endTime_ptr,\n    InvalidTime_error_length,\n    InvalidTime_error_selector,\n    InvalidTime_error_startTime_ptr,\n    MissingOriginalConsiderationItems_error_length,\n    MissingOriginalConsiderationItems_error_selector,\n    UnusedItemParameters_error_length,\n    UnusedItemParameters_error_selector\n} from ""seaport-types/src/lib/ConsiderationErrorConstants.sol"";\n\nimport {\n    CalldataPointer\n} from ""seaport-types/src/helpers/PointerLibraries.sol"";\n\n/**\n * @title BasicOrderFulfiller\n * @author 0age\n * @notice BasicOrderFulfiller contains functionality for fulfilling ""basic""\n *         orders with minimal overhead. See documentation for details on what\n *         qualifies as a basic order.\n */\ncontract BasicOrderFulfiller is OrderValidator {\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) OrderValidator(conduitController) {}\n\n    /**\n     * @dev Internal function to fulfill an order offering an ERC20, ERC721, or\n     *      ERC1155 item by supplying Ether (or other native tokens), ERC20\n     *      tokens, an ERC721 item, or an ERC1155 item as consideration. Six\n     *      permutations are supported: Native token to ERC721, Native token to\n     *      ERC1155, ERC20 to ERC721, ERC20 to ERC1155, ERC721 to ERC20, and\n     *      ERC1155 to ERC20 (with native tokens supplied as msg.value). For an\n     *      order to be eligible for fulfillment via this method, it must\n     *      contain a single offer item (though that item may have a greater\n     *      amount if the item is not an ERC721). An arbitrary number of\n     *      ""additional recipients"" may also be supplied which will each receive\n     *      native tokens or ERC20 items from the fulfiller as consideration.\n     *      Refer to the documentation for a more comprehensive summary of how\n     *      to utilize this method and what orders are compatible with it.\n     *\n     * @return A boolean indicating whether the order has been fulfilled.\n     */\n    function _validateAndFulfillBasicOrder() internal returns (bool) {\n        // Declare enums for order type & route to extract from basicOrderType.\n        BasicOrderRouteType route;\n        OrderType orderType;\n\n        // Declare additional recipient item type to derive from the route type.\n        ItemType additionalRecipientsItemType;\n\n        bytes32 orderHash;\n\n        // Utilize assembly to extract the order type and the basic order route.\n        assembly {\n            // Read basicOrderType from calldata.\n            let basicOrderType := calldataload(BasicOrder_basicOrderType_cdPtr)\n\n            // Mask all but 2 least-significant bits to derive the order type.\n            orderType := and(basicOrderType, 3)\n\n            // Divide basicOrderType by four to derive the route.\n            route := shr(2, basicOrderType)\n\n            // If route > 1 additionalRecipient items are ERC20 (1) else native\n            // token (0).\n            additionalRecipientsItemType := gt(route, 1)\n        }\n\n        {\n            // Declare temporary variable for enforcing payable status.\n            bool correctPayableStatus;\n\n            // Utilize assembly to compare the route to the callvalue.\n            assembly {\n                // route 0 and 1 are payable, otherwise route is not payable.\n                correctPayableStatus := eq(\n                    additionalRecipientsItemType,\n                    iszero(callvalue())\n                )\n            }\n\n            // Revert if msg.value has not been supplied as part of payable\n            // routes or has been supplied as part of non-payable routes.\n            if (!correctPayableStatus) {\n                _revertInvalidMsgValue(msg.value);\n            }\n        }\n\n        // Declare more arguments that will be derived from route and calldata.\n        address additionalRecipientsToken;\n        ItemType offeredItemType;\n        bool offerTypeIsAdditionalRecipientsType;\n        uint256 callDataPointer;\n\n        // Declare scope for received item type to manage stack pressure.\n        {\n            ItemType receivedItemType;\n\n            // Utilize assembly to retrieve function arguments and cast types.\n            assembly {\n                // Check if offered item type == additional recipient item type.\n                offerTypeIsAdditionalRecipientsType := gt(route, 3)\n\n                // If route > 3 additionalRecipientsToken is at 0xc4 else 0x24.\n                additionalRecipientsToken := calldataload(\n                    add(\n                        BasicOrder_considerationToken_cdPtr,\n                        mul(\n                            offerTypeIsAdditionalRecipientsType,\n                            BasicOrder_common_params_size\n                        )\n                    )\n                )\n\n                // If route > 2, receivedItemType is route - 2. If route is 2,\n                // the receivedItemType is ERC20 (1). Otherwise, it is native\n                // token (0).\n                receivedItemType := byte(route, BasicOrder_receivedItemByteMap)\n\n                // If route > 3, offeredItemType is ERC20 (1). Route is 2 or 3,\n                // offeredItemType = route. Route is 0 or 1, it is route + 2.\n                offeredItemType := byte(route, BasicOrder_offeredItemByteMap)\n            }\n\n            // Derive & validate order using parameters and update order status.\n            (orderHash, callDataPointer) = _prepareBasicFulfillmentFromCalldata(\n                orderType,\n                receivedItemType,\n                additionalRecipientsItemType,\n                additionalRecipientsToken,\n                offeredItemType\n            );\n        }\n\n        // Declare conduitKey argument used by transfer functions.\n        bytes32 conduitKey;\n\n        // Utilize assembly to derive conduit (if relevant) based on route.\n        assembly {\n            // use offerer conduit for routes 0-3, fulfiller conduit otherwise.\n            conduitKey := calldataload(\n                add(\n                    BasicOrder_offererConduit_cdPtr,\n                    shl(OneWordShift, offerTypeIsAdditionalRecipientsType)\n                )\n            )\n        }\n\n        // Transfer tokens based on the route.\n        if (additionalRecipientsItemType == ItemType.NATIVE) {\n            // Ensure neither consideration token nor identifier are set. Note\n            // that dirty upper bits in the consideration token will still cause\n            // this error to be thrown.\n            assembly {\n                if or(\n                    calldataload(BasicOrder_considerationToken_cdPtr),\n                    calldataload(BasicOrder_considerationIdentifier_cdPtr)\n                ) {\n                    // Store left-padded selector with push4 (reduces bytecode),\n                    // mem[28:32] = selector\n                    mstore(0, UnusedItemParameters_error_selector)\n\n                    // revert(abi.encodeWithSignature(""UnusedItemParameters()""))\n                    revert(\n                        Error_selector_offset,\n                        UnusedItemParameters_error_length\n                    )\n                }\n            }\n\n            // Transfer the ERC721 or ERC1155 item, bypassing the accumulator.\n            _transferIndividual721Or1155Item(offeredItemType, conduitKey);\n\n            // Transfer native to recipients, return excess to caller & wrap up.\n            _transferNativeTokensAndFinalize();\n        } else {\n            // Initialize an accumulator array. From this point forward, no new\n            // memory regions can be safely allocated until the accumulator is\n            // no longer being utilized, as the accumulator operates in an\n            // open-ended fashion from this memory pointer; existing memory may\n            // still be accessed and modified, however.\n            bytes memory accumulator = new bytes(AccumulatorDisarmed);\n\n            // Choose transfer method for ERC721 or ERC1155 item based on route.\n            if (route == BasicOrderRouteType.ERC20_TO_ERC721) {\n                // Transfer ERC721 to caller using offerer\'s conduit preference.\n                _transferERC721(\n                    CalldataPointer\n                        .wrap(BasicOrder_offerToken_cdPtr)\n                        .readAddress(),\n                    CalldataPointer\n                        .wrap(BasicOrder_offerer_cdPtr)\n                        .readAddress(),\n                    msg.sender,\n                    CalldataPointer\n                        .wrap(BasicOrder_offerIdentifier_cdPtr)\n                        .readUint256(),\n                    CalldataPointer\n                        .wrap(BasicOrder_offerAmount_cdPtr)\n                        .readUint256(),\n                    conduitKey,\n                    accumulator\n                );\n            } else if (route == BasicOrderRouteType.ERC20_TO_ERC1155) {\n                // Transfer ERC1155 to caller with offerer\'s conduit preference.\n                _transferERC1155(\n                    CalldataPointer\n                        .wrap(BasicOrder_offerToken_cdPtr)\n                        .readAddress(),\n                    CalldataPointer\n                        .wrap(BasicOrder_offerer_cdPtr)\n                        .readAddress(),\n                    msg.sender,\n                    CalldataPointer\n                        .wrap(BasicOrder_offerIdentifier_cdPtr)\n                        .readUint256(),\n                    CalldataPointer\n                        .wrap(BasicOrder_offerAmount_cdPtr)\n                        .readUint256(),\n                    conduitKey,\n                    accumulator\n                );\n            } else if (route == BasicOrderRouteType.ERC721_TO_ERC20) {\n                // Transfer ERC721 to offerer using caller\'s conduit preference.\n                _transferERC721(\n                    CalldataPointer\n                        .wrap(BasicOrder_considerationToken_cdPtr)\n                        .readAddress(),\n                    msg.sender,\n                    CalldataPointer\n                        .wrap(BasicOrder_offerer_cdPtr)\n                        .readAddress(),\n                    CalldataPointer\n                        .wrap(BasicOrder_considerationIdentifier_cdPtr)\n                        .readUint256(),\n                    CalldataPointer\n                        .wrap(BasicOrder_considerationAmount_cdPtr)\n                        .readUint256(),\n                    conduitKey,\n                    accumulator\n                );\n            } else {\n                // route == BasicOrderRouteType.ERC1155_TO_ERC20\n\n                // Transfer ERC1155 to offerer with caller\'s conduit preference.\n                _transferERC1155(\n                    CalldataPointer\n                        .wrap(BasicOrder_considerationToken_cdPtr)\n                        .readAddress(),\n                    msg.sender,\n                    CalldataPointer\n                        .wrap(BasicOrder_offerer_cdPtr)\n                        .readAddress(),\n                    CalldataPointer\n                        .wrap(BasicOrder_considerationIdentifier_cdPtr)\n                        .readUint256(),\n                    CalldataPointer\n                        .wrap(BasicOrder_considerationAmount_cdPtr)\n                        .readUint256(),\n                    conduitKey,\n                    accumulator\n                );\n            }\n\n            // Transfer ERC20 tokens to all recipients and wrap up.\n            _transferERC20AndFinalize(\n                offerTypeIsAdditionalRecipientsType,\n                accumulator\n            );\n\n            // Trigger any remaining accumulated transfers via call to conduit.\n            _triggerIfArmed(accumulator);\n        }\n\n        // Determine whether order is restricted and, if so, that it is valid.\n        _assertRestrictedBasicOrderValidity(\n            orderHash,\n            orderType,\n            callDataPointer\n        );\n\n        // Clear the reentrancy guard.\n        _clearReentrancyGuard();\n\n        return true;\n    }\n\n    /**\n     * @dev Internal function to prepare fulfillment of a basic order with\n     *      manual calldata and memory access. This calculates the order hash,\n     *      emits an OrderFulfilled event, and asserts basic order validity.\n     *      Note that calldata offsets must be validated as this function\n     *      accesses constant calldata pointers for dynamic types that match\n     *      default ABI encoding, but valid ABI encoding can use arbitrary\n     *      offsets. Checking that the offsets were produced by default encoding\n     *      will ensure that other functions using Solidity\'s calldata accessors\n     *      (which calculate pointers from the stored offsets) are reading the\n     *      same data as the order hash is derived from. Also note that this\n     *      function accesses memory directly.\n     *\n     * @param orderType                    The order type.\n     * @param receivedItemType             The item type of the initial\n     *                                     consideration item on the order.\n     * @param additionalRecipientsItemType The item type of any additional\n     *                                     consideration item on the order.\n     * @param additionalRecipientsToken    The ERC20 token contract address (if\n     *                                     applicable) for any additional\n     *                                     consideration item on the order.\n     * @param offeredItemType              The item type of the offered item on\n     *                                     the order.\n     * @return orderHash The calculated order hash.\n     */\n    function _prepareBasicFulfillmentFromCalldata(\n        OrderType orderType,\n        ItemType receivedItemType,\n        ItemType additionalRecipientsItemType,\n        address additionalRecipientsToken,\n        ItemType offeredItemType\n    ) internal returns (bytes32 orderHash, uint256 callDataPointer) {\n        // Ensure this function cannot be triggered during a reentrant call.\n        _setReentrancyGuard(false); // Native tokens rejected during execution.\n\n        // Verify that calldata offsets for all dynamic types were produced by\n        // default encoding. This ensures that the constants used for calldata\n        // pointers to dynamic types are the same as those calculated by\n        // Solidity using their offsets. Also verify that the basic order type\n        // is within range.\n        _assertValidBasicOrderParameters();\n\n        // Check for invalid time and missing original consideration items.\n        // Utilize assembly so that constant calldata pointers can be applied.\n        assembly {\n            // Ensure current timestamp is between order start time & end time.\n            if or(\n                gt(calldataload(BasicOrder_startTime_cdPtr), timestamp()),\n                iszero(gt(calldataload(BasicOrder_endTime_cdPtr), timestamp()))\n            ) {\n                // Store left-padded selector with push4 (reduces bytecode),\n                // mem[28:32] = selector\n                mstore(0, InvalidTime_error_selector)\n\n                // Store arguments.\n                mstore(\n                    InvalidTime_error_startTime_ptr,\n                    calldataload(BasicOrder_startTime_cdPtr)\n                )\n                mstore(\n                    InvalidTime_error_endTime_ptr,\n                    calldataload(BasicOrder_endTime_cdPtr)\n                )\n\n                // revert(abi.encodeWithSignature(\n                //     ""InvalidTime(uint256,uint256)"",\n                //     startTime,\n                //     endTime\n                // ))\n                revert(Error_selector_offset, InvalidTime_error_length)\n            }\n\n            // Ensure consideration array length isn\'t less than total original.\n            if lt(\n                calldataload(BasicOrder_addlRecipients_length_cdPtr),\n                calldataload(BasicOrder_totalOriginalAdditionalRecipients_cdPtr)\n            ) {\n                // Store left-padded selector with push4 (reduces bytecode),\n                // mem[28:32] = selector\n                mstore(0, MissingOriginalConsiderationItems_error_selector)\n\n                // revert(abi.encodeWithSignature(\n                //     ""MissingOriginalConsiderationItems()""\n                // ))\n                revert(\n                    Error_selector_offset,\n                    MissingOriginalConsiderationItems_error_length\n                )\n            }\n        }\n\n        {\n            /**\n             * First, handle consideration items. Memory Layout:\n             *  0x60: final hash of the array of consideration item hashes\n             *  0x80-0x160: reused space for EIP712 hashing of each item\n             *   - 0x80: ConsiderationItem EIP-712 typehash (constant)\n             *   - 0xa0: itemType\n             *   - 0xc0: token\n             *   - 0xe0: identifier\n             *   - 0x100: startAmount\n             *   - 0x120: endAmount\n             *   - 0x140: recipient\n             *  0x160-END_ARR: array of consideration item hashes\n             *   - 0x160: primary consideration item EIP712 hash\n             *   - 0x180-END_ARR: additional recipient item EIP712 hashes\n             *  END_ARR: beginning of data for OrderFulfilled event\n             *   - END_ARR + 0x120: length of ReceivedItem array\n             *   - END_ARR + 0x140: beginning of data for first ReceivedItem\n             * (Note: END_ARR = 0x180 + RECIPIENTS_LENGTH * 0x20)\n             */\n\n            // Load consideration item typehash from runtime and place on stack.\n            bytes32 typeHash = _CONSIDERATION_ITEM_TYPEHASH;\n\n            // Utilize assembly to enable reuse of memory regions and use\n            // constant pointers when possible.\n            assembly {\n                /*\n                 * 1. Calculate the EIP712 ConsiderationItem hash for the\n                 * primary consideration item of the basic order.\n                 */\n\n                // Write ConsiderationItem type hash and item type to memory.\n                mstore(BasicOrder_considerationItem_typeHash_ptr, typeHash)\n                mstore(\n                    BasicOrder_considerationItem_itemType_ptr,\n                    receivedItemType\n                )\n\n                // Copy calldata region with (token, identifier, amount) from\n                // BasicOrderParameters to ConsiderationItem. The\n                // considerationAmount is written to startAmount and endAmount\n                // as basic orders do not have dynamic amounts.\n                calldatacopy(\n                    BasicOrder_considerationItem_token_ptr,\n                    BasicOrder_considerationToken_cdPtr,\n                    ThreeWords\n                )\n\n                // Copy calldata region with considerationAmount and offerer\n                // from BasicOrderParameters to endAmount and recipient in\n                // ConsiderationItem.\n                calldatacopy(\n                    BasicOrder_considerationItem_endAmount_ptr,\n                    BasicOrder_considerationAmount_cdPtr,\n                    TwoWords\n                )\n\n                // Calculate EIP712 ConsiderationItem hash and store it in the\n                // array of EIP712 consideration hashes.\n                mstore(\n                    BasicOrder_considerationHashesArray_ptr,\n                    keccak256(\n                        BasicOrder_considerationItem_typeHash_ptr,\n                        EIP712_ConsiderationItem_size\n                    )\n                )\n\n                /*\n                 * 2. Write a ReceivedItem struct for the primary consideration\n                 * item to the consideration array in OrderFulfilled.\n                 */\n\n                // Get the additional recipients array length from calldata.\n                // This variable will later be repurposed to track the total\n                // original additional recipients instead of the total supplied.\n                let totalAdditionalRecipients := calldataload(\n                    BasicOrder_addlRecipients_length_cdPtr\n                )\n\n                // Calculate pointer to length of OrderFulfilled consideration\n                // array. Note that this is based on total original additional\n                // recipients and not the supplied additional recipients, since\n                // the pointer only needs to be offset based on the size of the\n                // EIP-712 hashes used to derive the order hash (and the order\n                // hash does not take tips into account as part of derivation).\n                let eventConsiderationArrPtr := add(\n                    OrderFulfilled_consideration_length_baseOffset,\n                    shl(\n                        OneWordShift,\n                        calldataload(\n                            BasicOrder_totalOriginalAdditionalRecipients_cdPtr\n                        )\n                    )\n                )\n\n                // Set the length of the consideration array to the number of\n                // additional recipients, plus one for the primary consideration\n                // item.\n                mstore(\n                    eventConsiderationArrPtr,\n                    add(totalAdditionalRecipients, 1)\n                )\n\n                // Overwrite the consideration array pointer so it points to the\n                // body of the first element\n                eventConsiderationArrPtr := add(\n                    eventConsiderationArrPtr,\n                    OneWord\n                )\n\n                // Set itemType at start of the ReceivedItem memory region.\n                mstore(eventConsiderationArrPtr, receivedItemType)\n\n                // Copy calldata region (token, identifier, amount & recipient)\n                // from BasicOrderParameters to ReceivedItem memory.\n                calldatacopy(\n                    add(eventConsiderationArrPtr, Common_token_offset),\n                    BasicOrder_considerationToken_cdPtr,\n                    FourWords\n                )\n\n                /*\n                 * 3. Calculate EIP712 ConsiderationItem hashes for original\n                 * additional recipients and add a ReceivedItem for each to the\n                 * consideration array in the OrderFulfilled event. The original\n                 * additional recipients are all the consideration items signed\n                 * by the offerer aside from the primary consideration items of\n                 * the order. Uses memory region from 0x80-0x160 as a buffer for\n                 * calculating EIP712 ConsiderationItem hashes.\n                 */\n\n                // Put pointer to consideration hashes array on the stack.\n                // This will be updated as each additional recipient is hashed\n                let\n                    considerationHashesPtr\n                := BasicOrder_considerationHashesArray_ptr\n\n                // Write item type, token, & identifier for additional recipient\n                // to memory region for hashing EIP712 ConsiderationItem; these\n                // values will be reused for each recipient.\n                mstore(\n                    BasicOrder_considerationItem_itemType_ptr,\n                    additionalRecipientsItemType\n                )\n                mstore(\n                    BasicOrder_considerationItem_token_ptr,\n                    additionalRecipientsToken\n                )\n                mstore(BasicOrder_considerationItem_identifier_ptr, 0)\n\n                // Declare a stack variable where all additional recipients will\n                // be combined to guard against providing dirty upper bits.\n                let combinedAdditionalRecipients\n\n                // Only iterate over the total original additional recipients\n                // (not the total supplied additional recipients) when deriving\n                // the order hash.\n                totalAdditionalRecipients := calldataload(\n                    BasicOrder_totalOriginalAdditionalRecipients_cdPtr\n                )\n                let i := 0\n                for {\n\n                } lt(i, totalAdditionalRecipients) {\n                    i := add(i, 1)\n                } {\n                    /*\n                     * Calculate EIP712 ConsiderationItem hash for recipient.\n                     */\n\n                    // Retrieve calldata pointer for additional recipient.\n                    let additionalRecipientCdPtr := add(\n                        BasicOrder_additionalRecipients_data_cdPtr,\n                        mul(AdditionalRecipient_size, i)\n                    )\n\n                    // Copy startAmount from calldata to the ConsiderationItem\n                    // struct.\n                    calldatacopy(\n                        BasicOrder_considerationItem_startAmount_ptr,\n                        additionalRecipientCdPtr,\n                        OneWord\n                    )\n\n                    // Copy endAmount and recipient from calldata to the\n                    // ConsiderationItem struct.\n                    calldatacopy(\n                        BasicOrder_considerationItem_endAmount_ptr,\n                        additionalRecipientCdPtr,\n                        AdditionalRecipient_size\n                    )\n\n                    // Include the recipient as part of combined recipients.\n                    combinedAdditionalRecipients := or(\n                        combinedAdditionalRecipients,\n                        calldataload(add(additionalRecipientCdPtr, OneWord))\n                    )\n\n                    // Add 1 word to the pointer as part of each loop to reduce\n                    // operations needed to get local offset into the array.\n                    considerationHashesPtr := add(\n                        considerationHashesPtr,\n                        OneWord\n                    )\n\n                    // Calculate EIP712 ConsiderationItem hash and store it in\n                    // the array of consideration hashes.\n                    mstore(\n                        considerationHashesPtr,\n                        keccak256(\n                            BasicOrder_considerationItem_typeHash_ptr,\n                            EIP712_ConsiderationItem_size\n                        )\n                    )\n\n                    /*\n                     * Write ReceivedItem to OrderFulfilled data.\n                     */\n\n                    // At this point, eventConsiderationArrPtr points to the\n                    // beginning of the ReceivedItem struct of the previous\n                    // element in the array. Increase it by the size of the\n                    // struct to arrive at the pointer for the current element.\n                    eventConsiderationArrPtr := add(\n                        eventConsiderationArrPtr,\n                        ReceivedItem_size\n                    )\n\n                    // Write itemType to the ReceivedItem struct.\n                    mstore(\n                        eventConsiderationArrPtr,\n                        additionalRecipientsItemType\n                    )\n\n                    // Write token to the next word of the ReceivedItem struct.\n                    mstore(\n                        add(eventConsiderationArrPtr, OneWord),\n                        additionalRecipientsToken\n                    )\n\n                    // Copy endAmount & recipient words to ReceivedItem struct.\n                    calldatacopy(\n                        add(\n                            eventConsiderationArrPtr,\n                            ReceivedItem_amount_offset\n                        ),\n                        additionalRecipientCdPtr,\n                        TwoWords\n                    )\n                }\n\n                /*\n                 * 4. Hash packed array of ConsiderationItem EIP712 hashes:\n                 *   `keccak256(abi.encodePacked(receivedItemHashes))`\n                 * Note that it is set at 0x60 — all other memory begins at\n                 * 0x80. 0x60 is the ""zero slot"" and will be restored at the end\n                 * of the assembly section and before required by the compiler.\n                 */\n                mstore(\n                    receivedItemsHash_ptr,\n                    keccak256(\n                        BasicOrder_considerationHashesArray_ptr,\n                        shl(OneWordShift, add(totalAdditionalRecipients, 1))\n                    )\n                )\n\n                /*\n                 * 5. Add a ReceivedItem for each tip to the consideration array\n                 * in the OrderFulfilled event. The tips are all the\n                 * consideration items that were not signed by the offerer and\n                 * were provided by the fulfiller.\n                 */\n\n                // Overwrite length to length of the additionalRecipients array.\n                totalAdditionalRecipients := calldataload(\n                    BasicOrder_addlRecipients_length_cdPtr\n                )\n\n                for {\n\n                } lt(i, totalAdditionalRecipients) {\n                    i := add(i, 1)\n                } {\n                    // Retrieve calldata pointer for additional recipient.\n                    let additionalRecipientCdPtr := add(\n                        BasicOrder_additionalRecipients_data_cdPtr,\n                        mul(AdditionalRecipient_size, i)\n                    )\n\n                    // At this point, eventConsiderationArrPtr points to the\n                    // beginning of the ReceivedItem struct of the previous\n                    // element in the array. Increase it by the size of the\n                    // struct to arrive at the pointer for the current element.\n                    eventConsiderationArrPtr := add(\n                        eventConsiderationArrPtr,\n                        ReceivedItem_size\n                    )\n\n                    // Write itemType to the ReceivedItem struct.\n                    mstore(\n                        eventConsiderationArrPtr,\n                        additionalRecipientsItemType\n                    )\n\n                    // Write token to the next word of the ReceivedItem struct.\n                    mstore(\n                        add(eventConsiderationArrPtr, OneWord),\n                        additionalRecipientsToken\n                    )\n\n                    // Copy endAmount & recipient words to ReceivedItem struct.\n                    calldatacopy(\n                        add(\n                            eventConsiderationArrPtr,\n                            ReceivedItem_amount_offset\n                        ),\n                        additionalRecipientCdPtr,\n                        TwoWords\n                    )\n\n                    // Include the recipient as part of combined recipients.\n                    combinedAdditionalRecipients := or(\n                        combinedAdditionalRecipients,\n                        calldataload(add(additionalRecipientCdPtr, OneWord))\n                    )\n                }\n\n                // Ensure no dirty upper bits on combined additional recipients.\n                if gt(combinedAdditionalRecipients, MaskOverLastTwentyBytes) {\n                    // Store left-padded selector with push4 (reduces bytecode),\n                    // mem[28:32] = selector\n                    mstore(0, InvalidBasicOrderParameterEncoding_error_selector)\n\n                    // revert(abi.encodeWithSignature(\n                    //     ""InvalidBasicOrderParameterEncoding()""\n                    // ))\n                    revert(\n                        Error_selector_offset,\n                        InvalidBasicOrderParameterEncoding_error_length\n                    )\n                }\n            }\n        }\n\n        {\n            /**\n             * Next, handle offered items. Memory Layout:\n             *  EIP712 data for OfferItem\n             *   - 0x80:  OfferItem EIP-712 typehash (constant)\n             *   - 0xa0:  itemType\n             *   - 0xc0:  token\n             *   - 0xe0:  identifier (reused for offeredItemsHash)\n             *   - 0x100: startAmount\n             *   - 0x120: endAmount\n             */\n\n            // Place offer item typehash on the stack.\n            bytes32 typeHash = _OFFER_ITEM_TYPEHASH;\n\n            // Utilize assembly to enable reuse of memory regions when possible.\n            assembly {\n                /*\n                 * 1. Calculate OfferItem EIP712 hash\n                 */\n\n                // Write the OfferItem typeHash to memory.\n                mstore(BasicOrder_offerItem_typeHash_ptr, typeHash)\n\n                // Write the OfferItem item type to memory.\n                mstore(BasicOrder_offerItem_itemType_ptr, offeredItemType)\n\n                // Copy calldata region with (offerToken, offerIdentifier,\n                // offerAmount) from OrderParameters to (token, identifier,\n                // startAmount) in OfferItem struct. The offerAmount is written\n                // to startAmount and endAmount as basic orders do not have\n                // dynamic amounts.\n                calldatacopy(\n                    BasicOrder_offerItem_token_ptr,\n                    BasicOrder_offerToken_cdPtr,\n                    ThreeWords\n                )\n\n                // Copy offerAmount from calldata to endAmount in OfferItem\n                // struct.\n                calldatacopy(\n                    BasicOrder_offerItem_endAmount_ptr,\n                    BasicOrder_offerAmount_cdPtr,\n                    OneWord\n                )\n\n                // Compute EIP712 OfferItem hash, write result to scratch space:\n                //   `keccak256(abi.encode(offeredItem))`\n                mstore(\n                    0,\n                    keccak256(\n                        BasicOrder_offerItem_typeHash_ptr,\n                        EIP712_OfferItem_size\n                    )\n                )\n\n                /*\n                 * 2. Calculate hash of array of EIP712 hashes and write the\n                 * result to the corresponding OfferItem struct:\n                 *   `keccak256(abi.encodePacked(offerItemHashes))`\n                 */\n                mstore(BasicOrder_order_offerHashes_ptr, keccak256(0, OneWord))\n            }\n        }\n\n        {\n            /**\n             * Once consideration items and offer items have been handled,\n             * derive the final order hash. Memory Layout:\n             *  0x80-0x1c0: EIP712 data for order\n             *   - 0x80:   Order EIP-712 typehash (constant)\n             *   - 0xa0:   orderParameters.offerer\n             *   - 0xc0:   orderParameters.zone\n             *   - 0xe0:   keccak256(abi.encodePacked(offerHashes))\n             *   - 0x100:  keccak256(abi.encodePacked(considerationHashes))\n             *   - 0x120:  orderParameters.basicOrderType (% 4 = orderType)\n             *   - 0x140:  orderParameters.startTime\n             *   - 0x160:  orderParameters.endTime\n             *   - 0x180:  orderParameters.zoneHash\n             *   - 0x1a0:  orderParameters.salt\n             *   - 0x1c0:  orderParameters.conduitKey\n             *   - 0x1e0:  _counters[orderParameters.offerer] (from storage)\n             */\n\n            // Read the offerer from calldata and place on the stack.\n            address offerer;\n            assembly {\n                offerer := calldataload(BasicOrder_offerer_cdPtr)\n            }\n\n            // Read offerer\'s current counter from storage and place on stack.\n            uint256 counter = _getCounter(offerer);\n\n            // Load order typehash from runtime code and place on stack.\n            bytes32 typeHash = _ORDER_TYPEHASH;\n\n            assembly {\n                // Set the OrderItem typeHash in memory.\n                mstore(BasicOrder_order_typeHash_ptr, typeHash)\n\n                // Copy offerer and zone from OrderParameters in calldata to the\n                // Order struct.\n                calldatacopy(\n                    BasicOrder_order_offerer_ptr,\n                    BasicOrder_offerer_cdPtr,\n                    TwoWords\n                )\n\n                // Copy receivedItemsHash from zero slot to the Order struct.\n                mstore(\n                    BasicOrder_order_considerationHashes_ptr,\n                    mload(receivedItemsHash_ptr)\n                )\n\n                // Write the supplied orderType to the Order struct.\n                mstore(BasicOrder_order_orderType_ptr, orderType)\n\n                // Copy startTime, endTime, zoneHash, salt & conduit from\n                // calldata to the Order struct.\n                calldatacopy(\n                    BasicOrder_order_startTime_ptr,\n                    BasicOrder_startTime_cdPtr,\n                    FiveWords\n                )\n\n                // Write offerer\'s counter, retrieved from storage, to struct.\n                mstore(BasicOrder_order_counter_ptr, counter)\n\n                // Compute the EIP712 Order hash.\n                orderHash := keccak256(\n                    BasicOrder_order_typeHash_ptr,\n                    EIP712_Order_size\n                )\n            }\n        }\n\n        assembly {\n            /**\n             * After the order hash has been derived, emit OrderFulfilled event:\n             *   event OrderFulfilled(\n             *     bytes32 orderHash,\n             *     address indexed offerer,\n             *     address indexed zone,\n             *     address fulfiller,\n             *     SpentItem[] offer,\n             *       > (itemType, token, id, amount)\n             *     ReceivedItem[] consideration\n             *       > (itemType, token, id, amount, recipient)\n             *   )\n             * topic0 - OrderFulfilled event signature\n             * topic1 - offerer\n             * topic2 - zone\n             * data:\n             *  - 0x00: orderHash\n             *  - 0x20: fulfiller\n             *  - 0x40: offer arr ptr (0x80)\n             *  - 0x60: consideration arr ptr (0x120)\n             *  - 0x80: offer arr len (1)\n             *  - 0xa0: offer.itemType\n             *  - 0xc0: offer.token\n             *  - 0xe0: offer.identifier\n             *  - 0x100: offer.amount\n             *  - 0x120: 1 + recipients.length\n             *  - 0x140: recipient 0\n             */\n\n            // Derive pointer to start of OrderFulfilled event data.\n            let eventDataPtr := add(\n                OrderFulfilled_baseOffset,\n                shl(\n                    OneWordShift,\n                    calldataload(\n                        BasicOrder_totalOriginalAdditionalRecipients_cdPtr\n                    )\n                )\n            )\n\n            // Write the order hash to the head of the event\'s data region.\n            mstore(eventDataPtr, orderHash)\n\n            // Write the fulfiller (i.e. the caller) next for receiver argument.\n            mstore(add(eventDataPtr, OrderFulfilled_fulfiller_offset), caller())\n\n            // Write the SpentItem and ReceivedItem array offsets (constants).\n            mstore(\n                // SpentItem array offset\n                add(eventDataPtr, OrderFulfilled_offer_head_offset),\n                OrderFulfilled_offer_body_offset\n            )\n            mstore(\n                // ReceivedItem array offset\n                add(eventDataPtr, OrderFulfilled_consideration_head_offset),\n                OrderFulfilled_consideration_body_offset\n            )\n\n            // Set a length of 1 for the offer array.\n            mstore(\n                add(\n                    eventDataPtr,\n                    OrderFulfilled_offer_length_offset_relativeTo_baseOffset\n                ),\n                1\n            )\n\n            // Write itemType to the SpentItem struct.\n            mstore(\n                add(\n                    eventDataPtr,\n                    OrderFulfilled_offer_itemType_offset_relativeTo_baseOffset\n                ),\n                offeredItemType\n            )\n\n            // Copy calldata region with (offerToken, offerIdentifier,\n            // offerAmount) from OrderParameters to (token, identifier,\n            // amount) in SpentItem struct.\n            calldatacopy(\n                add(\n                    eventDataPtr,\n                    OrderFulfilled_offer_token_offset_relativeTo_baseOffset\n                ),\n                BasicOrder_offerToken_cdPtr,\n                ThreeWords\n            )\n\n            // Derive total data size including SpentItem and ReceivedItem data.\n            // SpentItem portion is already included in the baseSize constant,\n            // as there can only be one element in the array.\n            let dataSize := add(\n                OrderFulfilled_baseSize,\n                mul(\n                    calldataload(BasicOrder_addlRecipients_length_cdPtr),\n                    ReceivedItem_size\n                )\n            )\n\n            // Emit OrderFulfilled log with three topics (the event signature\n            // as well as the two indexed arguments, the offerer and the zone).\n            log3(\n                // Supply the pointer for event data in memory.\n                eventDataPtr,\n                // Supply the size of event data in memory.\n                dataSize,\n                // Supply the OrderFulfilled event signature.\n                OrderFulfilled_selector,\n                // Supply the first topic (the offerer).\n                calldataload(BasicOrder_offerer_cdPtr),\n                // Supply the second topic (the zone).\n                calldataload(BasicOrder_zone_cdPtr)\n            )\n\n            // Restore the zero slot.\n            mstore(ZeroSlot, 0)\n\n            // Update the free memory pointer so that event data is persisted.\n            mstore(\n                FreeMemoryPointerSlot,\n                add(\n                    eventDataPtr,\n                    // Reserve extra 3 words to be used by `authorizeOrder` and\n                    // `validatateOrder` if pre-post exection hook to the zone\n                    // is required. These 3 memory slots will be used for the\n                    // extra data/context and order hashes of the calldata.\n                    add(\n                        dataSize,\n                        OrderFulfilled_post_memory_region_reservedBytes\n                    )\n                )\n            )\n        }\n\n        // Verify the status of the derived order.\n        OrderStatus storage orderStatus = _validateBasicOrder(orderHash);\n\n        // Determine whether order is restricted and, if so, that it is valid.\n        callDataPointer = _assertRestrictedBasicOrderAuthorization(\n            orderHash,\n            orderType\n        );\n\n        // Update the status of the order and mark as fully filled.\n        _updateBasicOrderStatus(orderStatus);\n\n        // Return the derived order hash.\n        return (orderHash, callDataPointer);\n    }\n\n    /**\n     * @dev Internal function to transfer an individual ERC721 or ERC1155 item\n     *      from a given originator to a given recipient. The accumulator will\n     *      be bypassed, meaning that this function should be utilized in cases\n     *      where multiple item transfers can be accumulated into a single\n     *      conduit call. Sufficient approvals must be set, either on the\n     *      respective conduit or on this contract. Note that this function may\n     *      only be safely called as part of basic orders, as it assumes a\n     *      specific calldata encoding structure that must first be validated.\n     *\n     * @param itemType   The type of item to transfer, either ERC721 or ERC1155.\n     * @param conduitKey A bytes32 value indicating what corresponding conduit,\n     *                   if any, to source token approvals from. The zero hash\n     *                   signifies that no conduit should be used, with direct\n     *                   approvals set on this contract.\n     */\n    function _transferIndividual721Or1155Item(\n        ItemType itemType,\n        bytes32 conduitKey\n    ) internal {\n        // Retrieve token, from, identifier, and amount from calldata using\n        // fixed calldata offsets based on strict basic parameter encoding.\n        address token;\n        address from;\n        uint256 identifier;\n        uint256 amount;\n        assembly {\n            token := calldataload(BasicOrder_offerToken_cdPtr)\n            from := calldataload(BasicOrder_offerer_cdPtr)\n            identifier := calldataload(BasicOrder_offerIdentifier_cdPtr)\n            amount := calldataload(BasicOrder_offerAmount_cdPtr)\n        }\n\n        // Determine if the transfer is to be performed via a conduit.\n        if (conduitKey != bytes32(0)) {\n            // Ensure that the amount is non-zero.\n            _assertNonZeroAmount(amount);\n\n            // Use free memory pointer as calldata offset for the conduit call.\n            uint256 callDataOffset;\n\n            // Utilize assembly to place each argument in free memory.\n            assembly {\n                // Retrieve the free memory pointer and use it as the offset.\n                callDataOffset := mload(FreeMemoryPointerSlot)\n\n                // Write ConduitInterface.execute.selector to memory.\n                mstore(callDataOffset, Conduit_execute_signature)\n\n                // Write the offset to the ConduitTransfer array in memory.\n                mstore(\n                    add(\n                        callDataOffset,\n                        Conduit_execute_ConduitTransfer_offset_ptr\n                    ),\n                    Conduit_execute_ConduitTransfer_ptr\n                )\n\n                // Write the length of the ConduitTransfer array to memory.\n                mstore(\n                    add(\n                        callDataOffset,\n                        Conduit_execute_ConduitTransfer_length_ptr\n                    ),\n                    Conduit_execute_ConduitTransfer_length\n                )\n\n                // Write the item type to memory.\n                mstore(\n                    add(callDataOffset, Conduit_execute_transferItemType_ptr),\n                    itemType\n                )\n\n                // Write the token to memory.\n                mstore(\n                    add(callDataOffset, Conduit_execute_transferToken_ptr),\n                    token\n                )\n\n                // Write the transfer source to memory.\n                mstore(\n                    add(callDataOffset, Conduit_execute_transferFrom_ptr),\n                    from\n                )\n\n                // Write the transfer recipient (the caller) to memory.\n                mstore(\n                    add(callDataOffset, Conduit_execute_transferTo_ptr),\n                    caller()\n                )\n\n                // Write the token identifier to memory.\n                mstore(\n                    add(callDataOffset, Conduit_execute_transferIdentifier_ptr),\n                    identifier\n                )\n\n                // Write the transfer amount to memory.\n                mstore(\n                    add(callDataOffset, Conduit_execute_transferAmount_ptr),\n                    amount\n                )\n            }\n\n            // Perform the call to the conduit.\n            _callConduitUsingOffsets(\n                conduitKey,\n                callDataOffset,\n                OneConduitExecute_size\n            );\n        } else {\n            // Otherwise, determine whether it is an ERC721 or ERC1155 item.\n            if (itemType == ItemType.ERC721) {\n                // Ensure that exactly one 721 item is being transferred.\n                if (amount != 1) {\n                    _revertInvalidERC721TransferAmount(amount);\n                }\n\n                // Perform transfer to caller via the token contract directly.\n                _performERC721Transfer(token, from, msg.sender, identifier);\n            } else {\n                // Ensure that the amount is non-zero.\n                _assertNonZeroAmount(amount);\n\n                // Perform transfer to caller via the token contract directly.\n                _performERC1155Transfer(\n                    token,\n                    from,\n                    msg.sender,\n                    identifier,\n                    amount\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function to transfer Ether (or other native tokens) to a\n     *      given recipient as part of basic order fulfillment. Note that\n     *      conduits are not utilized for native tokens as the transferred\n     *      amount must be provided as msg.value. Also note that this function\n     *      may only be safely called as part of basic orders, as it assumes a\n     *      specific calldata encoding structure that must first be validated.\n     */\n    function _transferNativeTokensAndFinalize() internal {\n        // Put native token value supplied by the caller on the stack.\n        uint256 nativeTokensRemaining = msg.value;\n\n        // Retrieve consideration amount, offerer, and total size of additional\n        // recipients data from calldata using fixed offsets and place on stack.\n        uint256 amount;\n        address payable to;\n        uint256 totalAdditionalRecipientsDataSize;\n        assembly {\n            amount := calldataload(BasicOrder_considerationAmount_cdPtr)\n            to := calldataload(BasicOrder_offerer_cdPtr)\n            totalAdditionalRecipientsDataSize := shl(\n                AdditionalRecipient_size_shift,\n                calldataload(BasicOrder_addlRecipients_length_cdPtr)\n            )\n        }\n\n        uint256 additionalRecipientAmount;\n        address payable recipient;\n\n        // Skip overflow check as for loop is indexed starting at zero.\n        unchecked {\n            // Iterate over additional recipient data by two-word element.\n            for (\n                uint256 i = 0;\n                i < totalAdditionalRecipientsDataSize;\n                i += AdditionalRecipient_size\n            ) {\n                assembly {\n                    // Retrieve calldata pointer for additional recipient.\n                    let additionalRecipientCdPtr := add(\n                        BasicOrder_additionalRecipients_data_cdPtr,\n                        i\n                    )\n\n                    additionalRecipientAmount := calldataload(\n                        additionalRecipientCdPtr\n                    )\n                    recipient := calldataload(\n                        add(OneWord, additionalRecipientCdPtr)\n                    )\n                }\n\n                // Ensure that sufficient native tokens are available.\n                if (additionalRecipientAmount > nativeTokensRemaining) {\n                    _revertInsufficientNativeTokensSupplied();\n                }\n\n                // Reduce native token value available. Skip underflow check as\n                // subtracted value is confirmed above as less than remaining.\n                nativeTokensRemaining -= additionalRecipientAmount;\n\n                // Transfer native tokens to the additional recipient.\n                _transferNativeTokens(recipient, additionalRecipientAmount);\n            }\n        }\n\n        // Ensure that sufficient native tokens are still available.\n        if (amount > nativeTokensRemaining) {\n            _revertInsufficientNativeTokensSupplied();\n        }\n\n        // Transfer native tokens to the offerer.\n        _transferNativeTokens(to, amount);\n\n        // If any native tokens remain after transfers, return to the caller.\n        if (nativeTokensRemaining > amount) {\n            // Skip underflow check as nativeTokensRemaining > amount.\n            unchecked {\n                // Transfer remaining native tokens to the caller.\n                _transferNativeTokens(\n                    payable(msg.sender),\n                    nativeTokensRemaining - amount\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function to transfer ERC20 tokens to a given recipient as\n     *      part of basic order fulfillment. Note that this function may only be\n     *      safely called as part of basic orders, as it assumes a specific\n     *      calldata encoding structure that must first be validated. Also note\n     *      that basic order parameters are retrieved using fixed offsets, this\n     *      requires that strict basic order encoding has already been verified.\n     *\n     * @param fromOfferer A boolean indicating whether to decrement amount from\n     *                    the offered amount.\n     * @param accumulator An open-ended array that collects transfers to execute\n     *                    against a given conduit in a single call.\n     */\n    function _transferERC20AndFinalize(\n        bool fromOfferer,\n        bytes memory accumulator\n    ) internal {\n        // Declare from and to variables determined by fromOfferer value.\n        address from;\n        address to;\n\n        // Declare token and amount variables determined by fromOfferer value.\n        address token;\n        uint256 amount;\n\n        // Declare and check identifier variable within an isolated scope.\n        {\n            // Declare identifier variable determined by fromOfferer value.\n            uint256 identifier;\n\n            // Set ERC20 token transfer variables based on fromOfferer boolean.\n            if (fromOfferer) {\n                // Use offerer as from value, msg.sender as to value, and offer\n                // token, identifier, & amount values if token is from offerer.\n                assembly {\n                    from := calldataload(BasicOrder_offerer_cdPtr)\n                    to := caller()\n                    token := calldataload(BasicOrder_offerToken_cdPtr)\n                    identifier := calldataload(BasicOrder_offerIdentifier_cdPtr)\n                    amount := calldataload(BasicOrder_offerAmount_cdPtr)\n                }\n            } else {\n                // Otherwise, use msg.sender as from value, offerer as to value,\n                // and consideration token, identifier, and amount values.\n                assembly {\n                    from := caller()\n                    to := calldataload(BasicOrder_offerer_cdPtr)\n                    token := calldataload(BasicOrder_considerationToken_cdPtr)\n                    identifier := calldataload(\n                        BasicOrder_considerationIdentifier_cdPtr\n                    )\n                    amount := calldataload(BasicOrder_considerationAmount_cdPtr)\n                }\n            }\n\n            // Ensure that no identifier is supplied.\n            if (identifier != 0) {\n                _revertUnusedItemParameters();\n            }\n        }\n\n        // Determine the appropriate conduit to utilize.\n        bytes32 conduitKey;\n\n        // Utilize assembly to derive conduit (if relevant) based on route.\n        assembly {\n            // Use offerer conduit if fromOfferer, fulfiller conduit otherwise.\n            conduitKey := calldataload(\n                sub(\n                    BasicOrder_fulfillerConduit_cdPtr,\n                    shl(OneWordShift, fromOfferer)\n                )\n            )\n        }\n\n        // Retrieve total size of additional recipients data and place on stack.\n        uint256 totalAdditionalRecipientsDataSize;\n        assembly {\n            totalAdditionalRecipientsDataSize := shl(\n                AdditionalRecipient_size_shift,\n                calldataload(BasicOrder_addlRecipients_length_cdPtr)\n            )\n        }\n\n        uint256 additionalRecipientAmount;\n        address recipient;\n\n        // Iterate over each additional recipient.\n        for (uint256 i = 0; i < totalAdditionalRecipientsDataSize; ) {\n            assembly {\n                // Retrieve calldata pointer for additional recipient.\n                let additionalRecipientCdPtr := add(\n                    BasicOrder_additionalRecipients_data_cdPtr,\n                    i\n                )\n\n                additionalRecipientAmount := calldataload(\n                    additionalRecipientCdPtr\n                )\n                recipient := calldataload(\n                    add(OneWord, additionalRecipientCdPtr)\n                )\n            }\n\n            // Decrement the amount to transfer to fulfiller if indicated.\n            if (fromOfferer) {\n                amount -= additionalRecipientAmount;\n            }\n\n            // Transfer ERC20 tokens to additional recipient given approval.\n            _transferERC20(\n                token,\n                from,\n                recipient,\n                additionalRecipientAmount,\n                conduitKey,\n                accumulator\n            );\n\n            // Skip overflow check as for loop is indexed starting at zero.\n            unchecked {\n                i += AdditionalRecipient_size;\n            }\n        }\n\n        // Transfer ERC20 token amount (from account must have proper approval).\n        _transferERC20(token, from, to, amount, conduitKey, accumulator);\n    }\n}\n'}, 'src/lib/CriteriaResolution.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {\n    ItemType,\n    OrderType,\n    Side\n} from ""seaport-types/src/lib/ConsiderationEnums.sol"";\n\nimport {\n    AdvancedOrder,\n    ConsiderationItem,\n    CriteriaResolver,\n    MemoryPointer,\n    OfferItem,\n    OrderParameters\n} from ""seaport-types/src/lib/ConsiderationStructs.sol"";\n\nimport {\n    _revertCriteriaNotEnabledForItem,\n    _revertInvalidProof,\n    _revertOrderCriteriaResolverOutOfRange\n} from ""seaport-types/src/lib/ConsiderationErrors.sol"";\n\nimport {\n    CriteriaResolutionErrors\n} from ""seaport-types/src/interfaces/CriteriaResolutionErrors.sol"";\n\nimport {\n    OneWord,\n    OneWordShift,\n    OrderParameters_consideration_head_offset,\n    Selector_length,\n    TwoWords\n} from ""seaport-types/src/lib/ConsiderationConstants.sol"";\n\nimport {\n    ConsiderationCriteriaResolverOutOfRange_err_selector,\n    Error_selector_offset,\n    OfferCriteriaResolverOutOfRange_error_selector,\n    UnresolvedConsiderationCriteria_error_itemIndex_ptr,\n    UnresolvedConsiderationCriteria_error_length,\n    UnresolvedConsiderationCriteria_error_orderIndex_ptr,\n    UnresolvedConsiderationCriteria_error_selector,\n    UnresolvedOfferCriteria_error_selector\n} from ""seaport-types/src/lib/ConsiderationErrorConstants.sol"";\n\n/**\n * @title CriteriaResolution\n * @author 0age\n * @notice CriteriaResolution contains a collection of pure functions related to\n *         resolving criteria-based items.\n */\ncontract CriteriaResolution is CriteriaResolutionErrors {\n    /**\n     * @dev Internal pure function to apply criteria resolvers containing\n     *      specific token identifiers and associated proofs to order items.\n     *\n     * @param advancedOrders     The orders to apply criteria resolvers to.\n     * @param criteriaResolvers  An array where each element contains a\n     *                           reference to a specific order as well as that\n     *                           order\'s offer or consideration, a token\n     *                           identifier, and a proof that the supplied token\n     *                           identifier is contained in the order\'s merkle\n     *                           root. Note that a root of zero indicates that\n     *                           any transferable token identifier is valid and\n     *                           that no proof needs to be supplied.\n     */\n    function _applyCriteriaResolvers(\n        AdvancedOrder[] memory advancedOrders,\n        CriteriaResolver[] memory criteriaResolvers\n    ) internal pure {\n        // Skip overflow checks as all for loops are indexed starting at zero.\n        unchecked {\n            // Retrieve length of criteria resolvers array and place on stack.\n            uint256 totalCriteriaResolvers = criteriaResolvers.length;\n\n            // Retrieve length of orders array and place on stack.\n            uint256 totalAdvancedOrders = advancedOrders.length;\n\n            // Iterate over each criteria resolver.\n            for (uint256 i = 0; i < totalCriteriaResolvers; ++i) {\n                // Retrieve the criteria resolver.\n                CriteriaResolver memory criteriaResolver = (\n                    criteriaResolvers[i]\n                );\n\n                // Read the order index from memory and place it on the stack.\n                uint256 orderIndex = criteriaResolver.orderIndex;\n\n                // Ensure that the order index is in range.\n                if (orderIndex >= totalAdvancedOrders) {\n                    _revertOrderCriteriaResolverOutOfRange(\n                        criteriaResolver.side\n                    );\n                }\n\n                // Retrieve the referenced advanced order.\n                AdvancedOrder memory advancedOrder = advancedOrders[orderIndex];\n\n                // Skip criteria resolution for order if not fulfilled.\n                if (advancedOrder.numerator == 0) {\n                    continue;\n                }\n\n                // Retrieve the parameters for the order.\n                OrderParameters memory orderParameters = (\n                    advancedOrder.parameters\n                );\n\n                {\n                    // Get a pointer to the list of items to give to\n                    // _updateCriteriaItem. If the resolver refers to a\n                    // consideration item, this array pointer will be replaced\n                    // with the consideration array.\n                    OfferItem[] memory items = orderParameters.offer;\n\n                    // Read component index from memory and place it on stack.\n                    uint256 componentIndex = criteriaResolver.index;\n\n                    // Get error selector for `OfferCriteriaResolverOutOfRange`.\n                    uint256 errorSelector = (\n                        OfferCriteriaResolverOutOfRange_error_selector\n                    );\n\n                    // If the resolver refers to a consideration item...\n                    if (criteriaResolver.side != Side.OFFER) {\n                        // Get the pointer to `orderParameters.consideration`\n                        // Using the array directly has a significant impact on\n                        // the optimized compiler output.\n                        MemoryPointer considerationPtr = orderParameters\n                            .toMemoryPointer()\n                            .pptrOffset(\n                                OrderParameters_consideration_head_offset\n                            );\n\n                        // Replace the items pointer with a pointer to the\n                        // consideration array.\n                        assembly {\n                            items := considerationPtr\n                        }\n\n                        // Replace the error selector with the selector for\n                        // `ConsiderationCriteriaResolverOutOfRange`.\n                        errorSelector = (\n                            ConsiderationCriteriaResolverOutOfRange_err_selector\n                        );\n                    }\n\n                    // Ensure that the component index is in range.\n                    if (componentIndex >= items.length) {\n                        assembly {\n                            // Revert with either\n                            // `OfferCriteriaResolverOutOfRange()` or\n                            // `ConsiderationCriteriaResolverOutOfRange()`,\n                            // depending on whether the resolver refers to a\n                            // consideration item.\n                            mstore(0, errorSelector)\n                            // revert(abi.encodeWithSignature(\n                            //    ""OfferCriteriaResolverOutOfRange()""\n                            // ))\n                            // or\n                            // revert(abi.encodeWithSignature(\n                            //    ""ConsiderationCriteriaResolverOutOfRange()""\n                            // ))\n                            revert(Error_selector_offset, Selector_length)\n                        }\n                    }\n\n                    // Apply the criteria resolver to the item in question.\n                    _updateCriteriaItem(\n                        items,\n                        componentIndex,\n                        criteriaResolver\n                    );\n                }\n            }\n\n            // Iterate over each advanced order.\n            for (uint256 i = 0; i < totalAdvancedOrders; ++i) {\n                // Retrieve the advanced order.\n                AdvancedOrder memory advancedOrder = advancedOrders[i];\n\n                // Skip criteria resolution for order if not fulfilled.\n                if (advancedOrder.numerator == 0) {\n                    continue;\n                }\n\n                // Retrieve the parameters for the order.\n                OrderParameters memory orderParameters = (\n                    advancedOrder.parameters\n                );\n\n                OrderType orderType = orderParameters.orderType;\n\n                _ensureAllRequiredCriteriaResolved(\n                    i,\n                    orderParameters.consideration,\n                    orderType,\n                    UnresolvedConsiderationCriteria_error_selector\n                );\n\n                _toOfferItemArgumentType(_ensureAllRequiredCriteriaResolved)(\n                    i,\n                    orderParameters.offer,\n                    orderType,\n                    UnresolvedOfferCriteria_error_selector\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Internal pure function to examine an array of items and ensure that\n     *      all criteria-based items (with the exception of wildcard items on\n     *      contract orders) have had a criteria resolver successfully applied.\n     *\n     * @param orderIndex     The index of the order being examined.\n     * @param items          The items to examine. These are consideration items\n     *                       in the default case, but offer items are also\n     *                       casted to consideration items as required.\n     * @param orderType      The type of order being examined.\n     * @param revertSelector The selector to use when reverting.\n     */\n    function _ensureAllRequiredCriteriaResolved(\n        uint256 orderIndex,\n        ConsiderationItem[] memory items,\n        OrderType orderType,\n        uint256 revertSelector\n    ) internal pure {\n        // Read items array length from memory and place on stack.\n        uint256 totalItems = items.length;\n\n        // Iterate over each item on the order.\n        for (uint256 i = 0; i < totalItems; ++i) {\n            ConsiderationItem memory item = items[i];\n\n            // Revert if the item is still a criteria item unless the\n            // order is a contract order and the identifier is 0.\n            ItemType itemType = item.itemType;\n            uint256 identifierOrCriteria = item.identifierOrCriteria;\n\n            assembly {\n                if and(\n                    gt(itemType, 3), // Criteria-based item\n                    or(\n                        iszero(eq(orderType, 4)), // not OrderType.CONTRACT\n                        iszero(iszero(identifierOrCriteria)) // not wildcard\n                    )\n                ) {\n                    // Store left-padded selector with push4 (reduces bytecode),\n                    // mem[28:32] = selector\n                    mstore(0, revertSelector)\n\n                    // Store arguments.\n                    mstore(\n                        UnresolvedConsiderationCriteria_error_orderIndex_ptr,\n                        orderIndex\n                    )\n                    mstore(\n                        UnresolvedConsiderationCriteria_error_itemIndex_ptr,\n                        i\n                    )\n\n                    // Revert with appropriate UnresolvedCriteria error message.\n                    // Unresolved[Offer|Consideration]Criteria(uint256, uint256)\n                    revert(\n                        Error_selector_offset,\n                        UnresolvedConsiderationCriteria_error_length\n                    )\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Internal pure function to perform a function cast from a function\n     *      that accepts consideration items to a function that accepts offer\n     *      items, used by _ensureAllRequiredCriteriaResolved to ensure that\n     *      all necessary criteria items have been resolved for an order.\n     *\n     * @param inFn  The function that accepts consideration items.\n     * @param outFn The function that accepts offer items.\n     */\n    function _toOfferItemArgumentType(\n        function(uint256, ConsiderationItem[] memory, OrderType, uint256)\n            internal\n            pure inFn\n    )\n        internal\n        pure\n        returns (\n            function(uint256, OfferItem[] memory, OrderType, uint256)\n                internal\n                pure outFn\n        )\n    {\n        assembly {\n            outFn := inFn\n        }\n    }\n\n    /**\n     * @dev Internal pure function to update a criteria item.\n     *\n     * @param offer             The offer containing the item to update.\n     * @param componentIndex    The index of the item to update.\n     * @param criteriaResolver  The criteria resolver to use to update the item.\n     */\n    function _updateCriteriaItem(\n        OfferItem[] memory offer,\n        uint256 componentIndex,\n        CriteriaResolver memory criteriaResolver\n    ) internal pure {\n        // Retrieve relevant item using the component index.\n        OfferItem memory offerItem = offer[componentIndex];\n\n        // Read item type and criteria from memory & place on stack.\n        ItemType itemType = offerItem.itemType;\n\n        // Ensure the specified item type indicates criteria usage.\n        if (!_isItemWithCriteria(itemType)) {\n            _revertCriteriaNotEnabledForItem();\n        }\n\n        uint256 identifierOrCriteria = offerItem.identifierOrCriteria;\n\n        // If criteria is not 0 (i.e. a collection-wide criteria-based item)...\n        if (identifierOrCriteria != uint256(0)) {\n            // Verify identifier inclusion in criteria root using proof.\n            _verifyProof(\n                criteriaResolver.identifier,\n                identifierOrCriteria,\n                criteriaResolver.criteriaProof\n            );\n        } else if (criteriaResolver.criteriaProof.length != 0) {\n            // Revert if non-empty proof is supplied for a collection-wide item.\n            _revertInvalidProof();\n        }\n\n        // Update item type to remove criteria usage.\n        // Use assembly to operate on ItemType enum as a number.\n        ItemType newItemType;\n        assembly {\n            // Item type 4 becomes 2 and item type 5 becomes 3.\n            newItemType := sub(itemType, 2)\n        }\n        offerItem.itemType = newItemType;\n\n        // Update identifier w/ supplied identifier.\n        offerItem.identifierOrCriteria = criteriaResolver.identifier;\n    }\n\n    /**\n     * @dev Internal pure function to check whether a given item type represents\n     *      a criteria-based ERC721 or ERC1155 item (e.g. an item that can be\n     *      resolved to one of a number of different identifiers at the time of\n     *      order fulfillment).\n     *\n     * @param itemType The item type in question.\n     *\n     * @return withCriteria A boolean indicating that the item type in question\n     *                      represents a criteria-based item.\n     */\n    function _isItemWithCriteria(\n        ItemType itemType\n    ) internal pure returns (bool withCriteria) {\n        // ERC721WithCriteria is ItemType 4. ERC1155WithCriteria is ItemType 5.\n        assembly {\n            withCriteria := gt(itemType, 3)\n        }\n    }\n\n    /**\n     * @dev Internal pure function to ensure that a given element is contained\n     *      in a merkle root via a supplied proof.\n     *\n     * @param leaf  The element for which to prove inclusion.\n     * @param root  The merkle root that inclusion will be proved against.\n     * @param proof The merkle proof.\n     */\n    function _verifyProof(\n        uint256 leaf,\n        uint256 root,\n        bytes32[] memory proof\n    ) internal pure {\n        // Declare a variable that will be used to determine proof validity.\n        bool isValid;\n\n        // Utilize assembly to efficiently verify the proof against the root.\n        assembly {\n            // Store the leaf at the beginning of scratch space.\n            mstore(0, leaf)\n\n            // Derive the hash of the leaf to use as the initial proof element.\n            let computedHash := keccak256(0, OneWord)\n\n            // Get memory start location of the first element in proof array.\n            let data := add(proof, OneWord)\n\n            // Iterate over each proof element to compute the root hash.\n            for {\n                // Left shift by 5 is equivalent to multiplying by 0x20.\n                let end := add(data, shl(OneWordShift, mload(proof)))\n            } lt(data, end) {\n                // Increment by one word at a time.\n                data := add(data, OneWord)\n            } {\n                // Get the proof element.\n                let loadedData := mload(data)\n\n                // Sort proof elements and place them in scratch space.\n                // Slot of `computedHash` in scratch space.\n                // If the condition is true: 0x20, otherwise: 0x00.\n                let scratch := shl(OneWordShift, gt(computedHash, loadedData))\n\n                // Store elements to hash contiguously in scratch space. Scratch\n                // space is 64 bytes (0x00 - 0x3f) & both elements are 32 bytes.\n                mstore(scratch, computedHash)\n                mstore(xor(scratch, OneWord), loadedData)\n\n                // Derive the updated hash.\n                computedHash := keccak256(0, TwoWords)\n            }\n\n            // Compare the final hash to the supplied root.\n            isValid := eq(computedHash, root)\n        }\n\n        // Revert if computed hash does not equal supplied root.\n        if (!isValid) {\n            _revertInvalidProof();\n        }\n    }\n}\n'}, 'src/lib/AmountDeriver.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {\n    AmountDerivationErrors\n} from ""seaport-types/src/interfaces/AmountDerivationErrors.sol"";\n\nimport {\n    Error_selector_offset,\n    InexactFraction_error_length,\n    InexactFraction_error_selector\n} from ""seaport-types/src/lib/ConsiderationErrorConstants.sol"";\n\n/**\n * @title AmountDeriver\n * @author 0age\n * @notice AmountDeriver contains view and pure functions related to deriving\n *         item amounts based on partial fill quantity and on linear\n *         interpolation based on current time when the start amount and end\n *         amount differ.\n */\ncontract AmountDeriver is AmountDerivationErrors {\n    /**\n     * @dev Internal view function to derive the current amount of a given item\n     *      based on the current price, the starting price, and the ending\n     *      price. If the start and end prices differ, the current price will be\n     *      interpolated on a linear basis. Note that this function expects that\n     *      the startTime parameter of orderParameters is not greater than the\n     *      current block timestamp and that the endTime parameter is greater\n     *      than the current block timestamp. If this condition is not upheld,\n     *      duration / elapsed / remaining variables will underflow.\n     *\n     * @param startAmount The starting amount of the item.\n     * @param endAmount   The ending amount of the item.\n     * @param startTime   The starting time of the order.\n     * @param endTime     The end time of the order.\n     * @param roundUp     A boolean indicating whether the resultant amount\n     *                    should be rounded up or down.\n     *\n     * @return amount The current amount.\n     */\n    function _locateCurrentAmount(\n        uint256 startAmount,\n        uint256 endAmount,\n        uint256 startTime,\n        uint256 endTime,\n        bool roundUp\n    ) internal view returns (uint256 amount) {\n        // Only modify end amount if it doesn\'t already equal start amount.\n        if (startAmount != endAmount) {\n            // Declare variables to derive in the subsequent unchecked scope.\n            uint256 duration;\n            uint256 elapsed;\n            uint256 remaining;\n\n            // Skip underflow checks as startTime <= block.timestamp < endTime.\n            unchecked {\n                // Derive the duration for the order and place it on the stack.\n                duration = endTime - startTime;\n\n                // Derive time elapsed since the order started & place on stack.\n                elapsed = block.timestamp - startTime;\n\n                // Derive time remaining until order expires and place on stack.\n                remaining = duration - elapsed;\n            }\n\n            // Aggregate new amounts weighted by time with rounding factor.\n            uint256 totalBeforeDivision = ((startAmount * remaining) +\n                (endAmount * elapsed));\n\n            // Use assembly to combine operations and skip divide-by-zero check.\n            assembly {\n                // Multiply by iszero(iszero(totalBeforeDivision)) to ensure\n                // amount is set to zero if totalBeforeDivision is zero,\n                // as intermediate overflow can occur if it is zero.\n                amount := mul(\n                    iszero(iszero(totalBeforeDivision)),\n                    // Subtract 1 from the numerator and add 1 to the result\n                    // if roundUp is true to get proper rounding direction.\n                    // Division is performed with no zero check as duration\n                    // cannot be zero as long as startTime < endTime.\n                    add(\n                        div(sub(totalBeforeDivision, roundUp), duration),\n                        roundUp\n                    )\n                )\n            }\n\n            // Return the current amount.\n            return amount;\n        }\n\n        // Return the original amount as startAmount == endAmount.\n        return endAmount;\n    }\n\n    /**\n     * @dev Internal pure function to return a fraction of a given value and to\n     *      ensure the resultant value does not have any fractional component.\n     *      Note that this function assumes that zero will never be supplied as\n     *      the denominator parameter; invalid / undefined behavior will result\n     *      should a denominator of zero be provided.\n     *\n     * @param numerator   A value indicating the portion of the order that\n     *                    should be filled.\n     * @param denominator A value indicating the total size of the order. Note\n     *                    that this value cannot be equal to zero.\n     * @param value       The value for which to compute the fraction.\n     *\n     * @return newValue The value after applying the fraction.\n     */\n    function _getFraction(\n        uint256 numerator,\n        uint256 denominator,\n        uint256 value\n    ) internal pure returns (uint256 newValue) {\n        // Return value early in cases where the fraction resolves to 1.\n        if (numerator == denominator) {\n            return value;\n        }\n\n        // Ensure fraction can be applied to the value with no remainder. Note\n        // that the denominator cannot be zero.\n        assembly {\n            // Ensure new value contains no remainder via mulmod operator.\n            // Credit to @hrkrshnn + @axic for proposing this optimal solution.\n            if mulmod(value, numerator, denominator) {\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, InexactFraction_error_selector)\n\n                // revert(abi.encodeWithSignature(""InexactFraction()""))\n                revert(Error_selector_offset, InexactFraction_error_length)\n            }\n        }\n\n        // Multiply the numerator by the value and ensure no overflow occurs.\n        uint256 valueTimesNumerator = value * numerator;\n\n        // Divide by the denominator (note that denominator cannot be zero).\n        assembly {\n            // Perform division without zero check.\n            newValue := div(valueTimesNumerator, denominator)\n        }\n    }\n\n    /**\n     * @dev Internal view function to apply a fraction to a consideration\n     * or offer item.\n     *\n     * @param startAmount     The starting amount of the item.\n     * @param endAmount       The ending amount of the item.\n     * @param numerator       A value indicating the portion of the order that\n     *                        should be filled.\n     * @param denominator     A value indicating the total size of the order.\n     * @param startTime       The starting time of the order.\n     * @param endTime         The end time of the order.\n     * @param roundUp         A boolean indicating whether the resultant\n     *                        amount should be rounded up or down.\n     *\n     * @return amount The received item to transfer with the final amount.\n     */\n    function _applyFraction(\n        uint256 startAmount,\n        uint256 endAmount,\n        uint256 numerator,\n        uint256 denominator,\n        uint256 startTime,\n        uint256 endTime,\n        bool roundUp\n    ) internal view returns (uint256 amount) {\n        // If start amount equals end amount, apply fraction to end amount.\n        if (startAmount == endAmount) {\n            // Apply fraction to end amount.\n            amount = _getFraction(numerator, denominator, endAmount);\n        } else {\n            // Otherwise, apply fraction to both and interpolated final amount.\n            amount = _locateCurrentAmount(\n                _getFraction(numerator, denominator, startAmount),\n                _getFraction(numerator, denominator, endAmount),\n                startTime,\n                endTime,\n                roundUp\n            );\n        }\n    }\n}\n'}, 'lib/seaport-types/src/interfaces/FulfillmentApplicationErrors.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport { Side } from ""../lib/ConsiderationEnums.sol"";\n\n/**\n * @title FulfillmentApplicationErrors\n * @author 0age\n * @notice FulfillmentApplicationErrors contains errors related to fulfillment\n *         application and aggregation.\n */\ninterface FulfillmentApplicationErrors {\n    /**\n     * @dev Revert with an error when a fulfillment is provided that does not\n     *      declare at least one component as part of a call to fulfill\n     *      available orders.\n     */\n    error MissingFulfillmentComponentOnAggregation(Side side);\n\n    /**\n     * @dev Revert with an error when a fulfillment is provided that does not\n     *      declare at least one offer component and at least one consideration\n     *      component.\n     */\n    error OfferAndConsiderationRequiredOnFulfillment();\n\n    /**\n     * @dev Revert with an error when the initial offer item named by a\n     *      fulfillment component does not match the type, token, identifier,\n     *      or conduit preference of the initial consideration item.\n     *\n     * @param fulfillmentIndex The index of the fulfillment component that\n     *                         does not match the initial offer item.\n     */\n    error MismatchedFulfillmentOfferAndConsiderationComponents(\n        uint256 fulfillmentIndex\n    );\n\n    /**\n     * @dev Revert with an error when an order or item index are out of range\n     *      or a fulfillment component does not match the type, token,\n     *      identifier, or conduit preference of the initial consideration item.\n     */\n    error InvalidFulfillmentComponentData();\n}\n'}, 'src/lib/OrderValidator.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { OrderType } from ""seaport-types/src/lib/ConsiderationEnums.sol"";\n\nimport {\n    AdvancedOrder,\n    ConsiderationItem,\n    OfferItem,\n    Order,\n    OrderComponents,\n    OrderParameters,\n    OrderStatus\n} from ""seaport-types/src/lib/ConsiderationStructs.sol"";\n\nimport {\n    _revertBadFraction,\n    _revertCannotCancelOrder,\n    _revertConsiderationLengthNotEqualToTotalOriginal,\n    _revertInvalidContractOrder,\n    _revertPartialFillsNotEnabledForOrder\n} from ""seaport-types/src/lib/ConsiderationErrors.sol"";\n\nimport { Executor } from ""./Executor.sol"";\n\nimport { ZoneInteraction } from ""./ZoneInteraction.sol"";\n\nimport { MemoryPointer } from ""seaport-types/src/helpers/PointerLibraries.sol"";\n\nimport {\n    AdvancedOrder_denominator_offset,\n    AdvancedOrder_numerator_offset,\n    BasicOrder_basicOrderParameters_cd_offset,\n    BasicOrder_offerer_cdPtr,\n    BasicOrder_signature_cdPtr,\n    Common_amount_offset,\n    Common_endAmount_offset,\n    Common_identifier_offset,\n    Common_token_offset,\n    ConsiderItem_recipient_offset,\n    ContractOrder_orderHash_offerer_shift,\n    MaxUint120,\n    OrderStatus_filledDenominator_offset,\n    OrderStatus_filledNumerator_offset,\n    OrderStatus_ValidatedAndNotCancelled,\n    OrderStatus_ValidatedAndNotCancelledAndFullyFilled,\n    ReceivedItem_recipient_offset\n} from ""seaport-types/src/lib/ConsiderationConstants.sol"";\n\nimport {\n    Error_selector_offset,\n    Panic_arithmetic,\n    Panic_error_code_ptr,\n    Panic_error_length,\n    Panic_error_selector\n} from ""seaport-types/src/lib/ConsiderationErrorConstants.sol"";\n\nimport {\n    CalldataPointer\n} from ""seaport-types/src/helpers/PointerLibraries.sol"";\n\n/**\n * @title OrderValidator\n * @author 0age\n * @notice OrderValidator contains functionality related to validating orders\n *         and updating their status.\n */\ncontract OrderValidator is Executor, ZoneInteraction {\n    // Track status of each order (validated, cancelled, and fraction filled).\n    mapping(bytes32 => OrderStatus) private _orderStatus;\n\n    // Track nonces for contract offerers.\n    mapping(address => uint256) internal _contractNonces;\n\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) Executor(conduitController) {}\n\n    /**\n     * @dev Internal function to verify the status of a basic order.\n     *      Note that this function may only be safely called as part of basic\n     *      orders, as it assumes a specific calldata encoding structure that\n     *      must first be validated.\n     *\n     * @param orderHash The hash of the order.\n     */\n    function _validateBasicOrder(\n        bytes32 orderHash\n    ) internal view returns (OrderStatus storage orderStatus) {\n        // Retrieve offerer directly using fixed calldata offset based on strict\n        // basic parameter encoding.\n        address offerer;\n        assembly {\n            offerer := calldataload(BasicOrder_offerer_cdPtr)\n        }\n\n        // Retrieve the order status for the given order hash.\n        orderStatus = _orderStatus[orderHash];\n\n        // Ensure order is fillable and is not cancelled.\n        _verifyOrderStatus(\n            orderHash,\n            orderStatus,\n            true, // Only allow unused orders when fulfilling basic orders.\n            _runTimeConstantTrue() // Signifies to revert if order is invalid.\n        );\n\n        unchecked {\n            // If the order is not already validated, verify supplied signature.\n            if (!orderStatus.isValidated) {\n                _verifySignature(\n                    offerer,\n                    orderHash,\n                    _toBytesReturnType(_decodeBytes)(\n                        // Wrap the absolute pointer to the order signature as a\n                        // CalldataPointer.\n                        CalldataPointer.wrap(\n                            // Read the relative pointer to the order signature.\n                            CalldataPointer\n                                .wrap(BasicOrder_signature_cdPtr)\n                                .readMaskedUint256() +\n                                // Add the BasicOrderParameters struct offset to\n                                // the relative pointer.\n                                BasicOrder_basicOrderParameters_cd_offset\n                        )\n                    )\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function to update the status of a basic order, assuming\n     *      all validation has already been performed.\n     *\n     * @param orderStatus A storage pointer referencing the order status.\n     */\n    function _updateBasicOrderStatus(OrderStatus storage orderStatus) internal {\n        // Utilize assembly to efficiently update the order status.\n        assembly {\n            // Update order status as validated, not cancelled, & fully filled.\n            sstore(\n                orderStatus.slot,\n                OrderStatus_ValidatedAndNotCancelledAndFullyFilled\n            )\n        }\n    }\n\n    /**\n     * @dev Internal function to validate an order, determine what portion to\n     *      fill, and update its status. The desired fill amount is supplied as\n     *      a fraction, as is the returned amount to fill.\n     *\n     * @param advancedOrder     The order to fulfill as well as the fraction to\n     *                          fill. Note that all offer and consideration\n     *                          amounts must divide with no remainder in order\n     *                          for a partial fill to be valid.\n     * @param revertOnInvalid   A boolean indicating whether to revert if the\n     *                          order is invalid due to the time or status.\n     *\n     * @return orderHash      The order hash.\n     * @return numerator      A value indicating the portion of the order that\n     *                        will be filled.\n     * @return denominator    A value indicating the total size of the order.\n     */\n    function _validateOrder(\n        AdvancedOrder memory advancedOrder,\n        bool revertOnInvalid\n    )\n        internal\n        view\n        returns (bytes32 orderHash, uint256 numerator, uint256 denominator)\n    {\n        // Retrieve the parameters for the order.\n        OrderParameters memory orderParameters = advancedOrder.parameters;\n\n        // Ensure current timestamp falls between order start time and end time.\n        if (\n            !_verifyTime(\n                orderParameters.startTime,\n                orderParameters.endTime,\n                revertOnInvalid\n            )\n        ) {\n            // Assuming an invalid time and no revert, return zeroed out values.\n            return (bytes32(0), 0, 0);\n        }\n\n        // Read numerator and denominator from memory and place on the stack.\n        // Note that overflowed values are masked.\n        assembly {\n            numerator := and(\n                mload(add(advancedOrder, AdvancedOrder_numerator_offset)),\n                MaxUint120\n            )\n\n            denominator := and(\n                mload(add(advancedOrder, AdvancedOrder_denominator_offset)),\n                MaxUint120\n            )\n        }\n\n        // Declare variable for tracking the validity of the supplied fraction.\n        bool invalidFraction;\n\n        // If the order is a contract order, return the generated order.\n        if (orderParameters.orderType == OrderType.CONTRACT) {\n            // Ensure that the numerator and denominator are both equal to 1.\n            assembly {\n                // (1 ^ nd =/= 0) => (nd =/= 1) => (n =/= 1) || (d =/= 1)\n                // It\'s important that the values are 120-bit masked before\n                // multiplication is applied. Otherwise, the last implication\n                // above is not correct (mod 2^256).\n                invalidFraction := xor(mul(numerator, denominator), 1)\n            }\n\n            // Revert if the supplied numerator and denominator are not valid.\n            if (invalidFraction) {\n                _revertBadFraction();\n            }\n            // Return a placeholder orderHash and a fill fraction of 1/1.\n            // The real orderHash will be returned by _getGeneratedOrder.\n            return (bytes32(uint256(1)), 1, 1);\n        }\n\n        // Ensure numerator does not exceed denominator and is not zero.\n        assembly {\n            invalidFraction := or(gt(numerator, denominator), iszero(numerator))\n        }\n\n        // Revert if the supplied numerator and denominator are not valid.\n        if (invalidFraction) {\n            _revertBadFraction();\n        }\n\n        // If attempting partial fill (n < d) check order type & ensure support.\n        if (\n            _doesNotSupportPartialFills(\n                orderParameters.orderType,\n                numerator,\n                denominator\n            )\n        ) {\n            // Revert if partial fill was attempted on an unsupported order.\n            _revertPartialFillsNotEnabledForOrder();\n        }\n\n        // Retrieve current counter & use it w/ parameters to derive order hash.\n        orderHash = _assertConsiderationLengthAndGetOrderHash(orderParameters);\n\n        // Retrieve the order status using the derived order hash.\n        OrderStatus storage orderStatus = _orderStatus[orderHash];\n\n        // Ensure order is fillable and is not cancelled.\n        if (\n            // Allow partially used orders to be filled.\n            !_verifyOrderStatus(orderHash, orderStatus, false, revertOnInvalid)\n        ) {\n            // Assuming an invalid order status and no revert, return zero fill.\n            return (orderHash, 0, 0);\n        }\n\n        // If the order is not already validated, verify the supplied signature.\n        if (!orderStatus.isValidated) {\n            _verifySignature(\n                orderParameters.offerer,\n                orderHash,\n                advancedOrder.signature\n            );\n        }\n\n        // Utilize assembly to determine the fraction to fill and update status.\n        assembly {\n            let orderStatusSlot := orderStatus.slot\n            // Read filled amount as numerator and denominator and put on stack.\n            let filledNumerator := sload(orderStatusSlot)\n            let filledDenominator := shr(\n                OrderStatus_filledDenominator_offset,\n                filledNumerator\n            )\n\n            // ""Loop"" until the appropriate fill fraction has been determined.\n            for {\n\n            } 1 {\n\n            } {\n                // If no portion of the order has been filled yet...\n                if iszero(filledDenominator) {\n                    // fill the full supplied fraction.\n                    filledNumerator := numerator\n\n                    // Exit the ""loop"" early.\n                    break\n                }\n\n                // Shift and mask to calculate the current filled numerator.\n                filledNumerator := and(\n                    shr(OrderStatus_filledNumerator_offset, filledNumerator),\n                    MaxUint120\n                )\n\n                // If denominator of 1 supplied, fill entire remaining amount.\n                if eq(denominator, 1) {\n                    // Set the amount to fill to the remaining amount.\n                    numerator := sub(filledDenominator, filledNumerator)\n\n                    // Set the fill size to the current size.\n                    denominator := filledDenominator\n\n                    // Exit the ""loop"" early.\n                    break\n                }\n\n                // If supplied denominator is equal to the current one:\n                if eq(denominator, filledDenominator) {\n                    // Increment the filled numerator by the new numerator.\n                    filledNumerator := add(numerator, filledNumerator)\n\n                    // Once adjusted, if current + supplied numerator exceeds\n                    // the denominator:\n                    let carry := mul(\n                        sub(filledNumerator, denominator),\n                        gt(filledNumerator, denominator)\n                    )\n\n                    // reduce the amount to fill by the excess.\n                    numerator := sub(numerator, carry)\n\n                    // Exit the ""loop"" early.\n                    break\n                }\n\n                // Otherwise, if supplied denominator differs from current one:\n                // Scale the filled amount up by the supplied size.\n                filledNumerator := mul(filledNumerator, denominator)\n\n                // Scale the supplied amount and size up by the current size.\n                numerator := mul(numerator, filledDenominator)\n                denominator := mul(denominator, filledDenominator)\n\n                // Increment the filled numerator by the new numerator.\n                filledNumerator := add(numerator, filledNumerator)\n\n                // Once adjusted, if current + supplied numerator exceeds\n                // denominator:\n                let carry := mul(\n                    sub(filledNumerator, denominator),\n                    gt(filledNumerator, denominator)\n                )\n\n                // reduce the amount to fill by the excess.\n                numerator := sub(numerator, carry)\n\n                // Reduce the filled amount by the excess as well.\n                filledNumerator := sub(filledNumerator, carry)\n\n                // Check denominator for uint120 overflow.\n                if gt(denominator, MaxUint120) {\n                    // Derive greatest common divisor using euclidean algorithm.\n                    function gcd(_a, _b) -> out {\n                        // ""Loop"" until only one non-zero value remains.\n                        for {\n\n                        } _b {\n\n                        } {\n                            // Assign the second value to a temporary variable.\n                            let _c := _b\n\n                            // Derive the modulus of the two values.\n                            _b := mod(_a, _c)\n\n                            // Set the first value to the temporary value.\n                            _a := _c\n                        }\n\n                        // Return the remaining non-zero value.\n                        out := _a\n                    }\n\n                    // Determine the amount to scale down the fill fractions.\n                    let scaleDown := gcd(\n                        numerator,\n                        gcd(filledNumerator, denominator)\n                    )\n\n                    // Ensure that the divisor is at least one.\n                    let safeScaleDown := add(scaleDown, iszero(scaleDown))\n\n                    // Scale fractional values down by gcd.\n                    numerator := div(numerator, safeScaleDown)\n                    denominator := div(denominator, safeScaleDown)\n\n                    // Perform the overflow check a second time.\n                    if gt(denominator, MaxUint120) {\n                        // Store the Panic error signature.\n                        mstore(0, Panic_error_selector)\n                        // Store the arithmetic (0x11) panic code.\n                        mstore(Panic_error_code_ptr, Panic_arithmetic)\n\n                        // revert(abi.encodeWithSignature(\n                        //     ""Panic(uint256)"", 0x11\n                        // ))\n                        revert(Error_selector_offset, Panic_error_length)\n                    }\n                }\n\n                // Exit the ""loop"" now that all evaluation is complete.\n                break\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function to update the status of an order by applying the\n     *      supplied fill fraction to the remaining order fraction. If\n     *      revertOnInvalid is true, the function will revert if the order is\n     *      unavailable or if it is not possible to apply the supplied fill\n     *      fraction to the remaining amount (e.g., if there is not enough\n     *      of the order remaining to fill the supplied fraction, or if the\n     *      fractions cannot be represented by two uint120 values).\n     *\n     * @param orderHash       The hash of the order.\n     * @param numerator       The numerator of the fraction filled to write to\n     *                        the order status.\n     * @param denominator     The denominator of the fraction filled to write to\n     *                        the order status.\n     * @param revertOnInvalid Whether to revert if an order is already filled.\n     */\n    function _updateStatus(\n        bytes32 orderHash,\n        uint256 numerator,\n        uint256 denominator,\n        bool revertOnInvalid\n    ) internal returns (bool) {\n        // Retrieve the order status using the derived order hash.\n        OrderStatus storage orderStatus = _orderStatus[orderHash];\n\n        bool hasCarry = false;\n\n        uint256 orderStatusSlot;\n        uint256 filledNumerator;\n\n        // Utilize assembly to determine the fraction to fill and update status.\n        assembly {\n            orderStatusSlot := orderStatus.slot\n            // Read filled amount as numerator and denominator and put on stack.\n            filledNumerator := sload(orderStatusSlot)\n            let filledDenominator := shr(\n                OrderStatus_filledDenominator_offset,\n                filledNumerator\n            )\n\n            // ""Loop"" until the appropriate fill fraction has been determined.\n            for {\n\n            } 1 {\n\n            } {\n                // If no portion of the order has been filled yet...\n                if iszero(filledDenominator) {\n                    // fill the full supplied fraction.\n                    filledNumerator := numerator\n\n                    // Exit the ""loop"" early.\n                    break\n                }\n\n                // Shift and mask to calculate the current filled numerator.\n                filledNumerator := and(\n                    shr(OrderStatus_filledNumerator_offset, filledNumerator),\n                    MaxUint120\n                )\n\n                // If supplied denominator is equal to the current one:\n                if eq(denominator, filledDenominator) {\n                    // Increment the filled numerator by the new numerator.\n                    filledNumerator := add(numerator, filledNumerator)\n\n                    hasCarry := gt(filledNumerator, denominator)\n\n                    // Exit the ""loop"" early.\n                    break\n                }\n\n                // Otherwise, if supplied denominator differs from current one:\n                // Scale the filled amount up by the supplied size.\n                filledNumerator := mul(filledNumerator, denominator)\n\n                // Scale the supplied amount and size up by the current size.\n                numerator := mul(numerator, filledDenominator)\n                denominator := mul(denominator, filledDenominator)\n\n                // Increment the filled numerator by the new numerator.\n                filledNumerator := add(numerator, filledNumerator)\n\n                hasCarry := gt(filledNumerator, denominator)\n\n                // Check filledNumerator and denominator for uint120 overflow.\n                if or(\n                    gt(filledNumerator, MaxUint120),\n                    gt(denominator, MaxUint120)\n                ) {\n                    // Derive greatest common divisor using euclidean algorithm.\n                    function gcd(_a, _b) -> out {\n                        // ""Loop"" until only one non-zero value remains.\n                        for {\n\n                        } _b {\n\n                        } {\n                            // Assign the second value to a temporary variable.\n                            let _c := _b\n\n                            // Derive the modulus of the two values.\n                            _b := mod(_a, _c)\n\n                            // Set the first value to the temporary value.\n                            _a := _c\n                        }\n\n                        // Return the remaining non-zero value.\n                        out := _a\n                    }\n\n                    // Determine amount to scale down the new filled fraction.\n                    let scaleDown := gcd(filledNumerator, denominator)\n\n                    // Ensure that the divisor is at least one.\n                    let safeScaleDown := add(scaleDown, iszero(scaleDown))\n\n                    // Scale new filled fractional values down by gcd.\n                    filledNumerator := div(filledNumerator, safeScaleDown)\n                    denominator := div(denominator, safeScaleDown)\n\n                    // Perform the overflow check a second time.\n                    if or(\n                        gt(filledNumerator, MaxUint120),\n                        gt(denominator, MaxUint120)\n                    ) {\n                        // Store the Panic error signature.\n                        mstore(0, Panic_error_selector)\n                        // Store the arithmetic (0x11) panic code.\n                        mstore(Panic_error_code_ptr, Panic_arithmetic)\n\n                        // revert(abi.encodeWithSignature(\n                        //     ""Panic(uint256)"", 0x11\n                        // ))\n                        revert(Error_selector_offset, Panic_error_length)\n                    }\n                }\n\n                // Exit the ""loop"" now that all evaluation is complete.\n                break\n            }\n        }\n\n        if (hasCarry) {\n            if (revertOnInvalid) {\n                revert OrderAlreadyFilled(orderHash);\n            } else {\n                return false;\n            }\n        }\n\n        assembly {\n            // Update order status and fill amount, packing struct values.\n            // [denominator: 15 bytes] [numerator: 15 bytes]\n            // [isCancelled: 1 byte] [isValidated: 1 byte]\n            sstore(\n                orderStatusSlot,\n                or(\n                    OrderStatus_ValidatedAndNotCancelled,\n                    or(\n                        shl(\n                            OrderStatus_filledNumerator_offset,\n                            filledNumerator\n                        ),\n                        shl(OrderStatus_filledDenominator_offset, denominator)\n                    )\n                )\n            )\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Internal function to generate a contract order. When a\n     *      collection-wide criteria-based item (criteria = 0) is provided as an\n     *      input to a contract order, the contract offerer has full latitude to\n     *      choose any identifier it wants mid-flight, which differs from the\n     *      usual behavior.  For regular criteria-based orders with\n     *      identifierOrCriteria = 0, the fulfiller can pick which identifier to\n     *      receive by providing a CriteriaResolver. For contract offers with\n     *      identifierOrCriteria = 0, Seaport does not expect a corresponding\n     *      CriteriaResolver, and will revert if one is provided.\n     *\n     * @param orderParameters The parameters for the order.\n     * @param context         The context for generating the order.\n     * @param revertOnInvalid Whether to revert on invalid input.\n     *\n     * @return orderHash   The order hash.\n     */\n    function _getGeneratedOrder(\n        OrderParameters memory orderParameters,\n        bytes memory context,\n        bool revertOnInvalid\n    ) internal returns (bytes32 orderHash) {\n        // Ensure that consideration array length is equal to the total original\n        // consideration items value.\n        if (\n            orderParameters.consideration.length !=\n            orderParameters.totalOriginalConsiderationItems\n        ) {\n            _revertConsiderationLengthNotEqualToTotalOriginal();\n        }\n\n        {\n            address offerer = orderParameters.offerer;\n            bool success;\n            (MemoryPointer cdPtr, uint256 size) = _encodeGenerateOrder(\n                orderParameters,\n                context\n            );\n            assembly {\n                success := call(gas(), offerer, 0, cdPtr, size, 0, 0)\n            }\n\n            {\n                // Note: overflow impossible; nonce can\'t increment that high.\n                uint256 contractNonce;\n                unchecked {\n                    // Note: nonce will be incremented even for skipped orders,\n                    // and even if generateOrder\'s return data does not satisfy\n                    // all the constraints. This is the case when errorBuffer\n                    // != 0 and revertOnInvalid == false.\n                    contractNonce = _contractNonces[offerer]++;\n                }\n\n                assembly {\n                    // Shift offerer address up 96 bytes and combine with nonce.\n                    orderHash := xor(\n                        contractNonce,\n                        shl(ContractOrder_orderHash_offerer_shift, offerer)\n                    )\n                }\n            }\n\n            // Revert or skip if the call to generate the contract order failed.\n            if (!success) {\n                if (revertOnInvalid) {\n                    _revertWithReasonIfOneIsReturned();\n\n                    _revertInvalidContractOrder(orderHash);\n                }\n\n                return bytes32(0);\n            }\n        }\n\n        // From this point onward, do not allow for skipping orders as the\n        // contract offerer may have modified state in expectation of any named\n        // consideration items being sent to their designated recipients.\n\n        // Decode the returned contract order and/or update the error buffer.\n        (\n            uint256 errorBuffer,\n            OfferItem[] memory offer,\n            ConsiderationItem[] memory consideration\n        ) = _convertGetGeneratedOrderResult(_decodeGenerateOrderReturndata)(\n                orderParameters.offer,\n                orderParameters.consideration\n            );\n\n        // Revert if the returndata could not be decoded correctly.\n        if (errorBuffer != 0) {\n            _revertInvalidContractOrder(orderHash);\n        }\n\n        // Assign the returned offer item in place of the original item.\n        orderParameters.offer = offer;\n\n        // Assign returned consideration item in place of the original item.\n        orderParameters.consideration = consideration;\n\n        // Return the order hash.\n        return orderHash;\n    }\n\n    /**\n     * @dev Internal function to cancel an arbitrary number of orders. Note that\n     *      only the offerer or the zone of a given order may cancel it. Callers\n     *      should ensure that the intended order was cancelled by calling\n     *      `getOrderStatus` and confirming that `isCancelled` returns `true`.\n     *      Also note that contract orders are not cancellable.\n     *\n     * @param orders The orders to cancel.\n     *\n     * @return cancelled A boolean indicating whether the supplied orders were\n     *                   successfully cancelled.\n     */\n    function _cancel(\n        OrderComponents[] calldata orders\n    ) internal returns (bool cancelled) {\n        // Ensure that the reentrancy guard is not currently set.\n        _assertNonReentrant();\n\n        // Declare variables outside of the loop.\n        OrderStatus storage orderStatus;\n\n        // Declare a variable for tracking invariants in the loop.\n        bool anyInvalidCallerOrContractOrder;\n\n        // Skip overflow check as for loop is indexed starting at zero.\n        unchecked {\n            // Read length of the orders array from memory and place on stack.\n            uint256 totalOrders = orders.length;\n\n            // Iterate over each order.\n            for (uint256 i = 0; i < totalOrders; ) {\n                // Retrieve the order.\n                OrderComponents calldata order = orders[i];\n\n                address offerer = order.offerer;\n                address zone = order.zone;\n                OrderType orderType = order.orderType;\n\n                assembly {\n                    // If caller is neither the offerer nor zone, or a contract\n                    // order is present, flag anyInvalidCallerOrContractOrder.\n                    anyInvalidCallerOrContractOrder := or(\n                        anyInvalidCallerOrContractOrder,\n                        // orderType == CONTRACT ||\n                        // !(caller == offerer || caller == zone)\n                        or(\n                            eq(orderType, 4),\n                            iszero(\n                                or(eq(caller(), offerer), eq(caller(), zone))\n                            )\n                        )\n                    )\n                }\n\n                bytes32 orderHash = _deriveOrderHash(\n                    _toOrderParametersReturnType(\n                        _decodeOrderComponentsAsOrderParameters\n                    )(order.toCalldataPointer()),\n                    order.counter\n                );\n\n                // Retrieve the order status using the derived order hash.\n                orderStatus = _orderStatus[orderHash];\n\n                // Update the order status as not valid and cancelled.\n                orderStatus.isValidated = false;\n                orderStatus.isCancelled = true;\n\n                // Emit an event signifying that the order has been cancelled.\n                emit OrderCancelled(orderHash, offerer, zone);\n\n                // Increment counter inside body of loop for gas efficiency.\n                ++i;\n            }\n        }\n\n        if (anyInvalidCallerOrContractOrder) {\n            _revertCannotCancelOrder();\n        }\n\n        // Return a boolean indicating that orders were successfully cancelled.\n        cancelled = true;\n    }\n\n    /**\n     * @dev Internal function to validate an arbitrary number of orders, thereby\n     *      registering their signatures as valid and allowing the fulfiller to\n     *      skip signature verification on fulfillment. Note that validated\n     *      orders may still be unfulfillable due to invalid item amounts or\n     *      other factors; callers should determine whether validated orders are\n     *      fulfillable by simulating the fulfillment call prior to execution.\n     *      Also note that anyone can validate a signed order, but only the\n     *      offerer can validate an order without supplying a signature.\n     *\n     * @param orders The orders to validate.\n     *\n     * @return validated A boolean indicating whether the supplied orders were\n     *                   successfully validated.\n     */\n    function _validate(\n        Order[] memory orders\n    ) internal returns (bool validated) {\n        // Ensure that the reentrancy guard is not currently set.\n        _assertNonReentrant();\n\n        // Declare variables outside of the loop.\n        OrderStatus storage orderStatus;\n        bytes32 orderHash;\n        address offerer;\n\n        // Skip overflow check as for loop is indexed starting at zero.\n        unchecked {\n            // Read length of the orders array from memory and place on stack.\n            uint256 totalOrders = orders.length;\n\n            // Iterate over each order.\n            for (uint256 i = 0; i < totalOrders; ++i) {\n                // Retrieve the order.\n                Order memory order = orders[i];\n\n                // Retrieve the order parameters.\n                OrderParameters memory orderParameters = order.parameters;\n\n                // Skip contract orders.\n                if (orderParameters.orderType == OrderType.CONTRACT) {\n                    continue;\n                }\n\n                // Move offerer from memory to the stack.\n                offerer = orderParameters.offerer;\n\n                // Get current counter & use it w/ params to derive order hash.\n                orderHash = _assertConsiderationLengthAndGetOrderHash(\n                    orderParameters\n                );\n\n                // Retrieve the order status using the derived order hash.\n                orderStatus = _orderStatus[orderHash];\n\n                // Ensure order is fillable and retrieve the filled amount.\n                _verifyOrderStatus(\n                    orderHash,\n                    orderStatus,\n                    false, // Signifies that partially filled orders are valid.\n                    _runTimeConstantTrue() // Revert if order is invalid.\n                );\n\n                // If the order has not already been validated...\n                if (!orderStatus.isValidated) {\n                    // Ensure that consideration array length is equal to the\n                    // total original consideration items value.\n                    if (\n                        orderParameters.consideration.length !=\n                        orderParameters.totalOriginalConsiderationItems\n                    ) {\n                        _revertConsiderationLengthNotEqualToTotalOriginal();\n                    }\n\n                    // Verify the supplied signature.\n                    _verifySignature(offerer, orderHash, order.signature);\n\n                    // Update order status to mark the order as valid.\n                    orderStatus.isValidated = true;\n\n                    // Emit an event signifying the order has been validated.\n                    emit OrderValidated(orderHash, orderParameters);\n                }\n            }\n        }\n\n        // Return a boolean indicating that orders were successfully validated.\n        validated = true;\n    }\n\n    /**\n     * @dev Internal view function to retrieve the status of a given order by\n     *      hash, including whether the order has been cancelled or validated\n     *      and the fraction of the order that has been filled.\n     *\n     * @param orderHash The order hash in question.\n     *\n     * @return isValidated A boolean indicating whether the order in question\n     *                     has been validated (i.e. previously approved or\n     *                     partially filled).\n     * @return isCancelled A boolean indicating whether the order in question\n     *                     has been cancelled.\n     * @return totalFilled The total portion of the order that has been filled\n     *                     (i.e. the ""numerator"").\n     * @return totalSize   The total size of the order that is either filled or\n     *                     unfilled (i.e. the ""denominator"").\n     */\n    function _getOrderStatus(\n        bytes32 orderHash\n    )\n        internal\n        view\n        returns (\n            bool isValidated,\n            bool isCancelled,\n            uint256 totalFilled,\n            uint256 totalSize\n        )\n    {\n        // Retrieve the order status using the order hash.\n        OrderStatus storage orderStatus = _orderStatus[orderHash];\n\n        // Return the fields on the order status.\n        return (\n            orderStatus.isValidated,\n            orderStatus.isCancelled,\n            orderStatus.numerator,\n            orderStatus.denominator\n        );\n    }\n\n    /**\n     * @dev Internal pure function to check whether a given order type indicates\n     *      that partial fills are not supported (e.g. only ""full fills"" are\n     *      allowed for the order in question).\n     *\n     * @param orderType   The order type in question.\n     * @param numerator   The numerator in question.\n     * @param denominator The denominator in question.\n     *\n     * @return isFullOrder A boolean indicating whether the order type only\n     *                     supports full fills.\n     */\n    function _doesNotSupportPartialFills(\n        OrderType orderType,\n        uint256 numerator,\n        uint256 denominator\n    ) internal pure returns (bool isFullOrder) {\n        // The ""full"" order types are even, while ""partial"" order types are odd.\n        // Bitwise and by 1 is equivalent to modulo by 2, but 2 gas cheaper. The\n        // check is only necessary if numerator is less than denominator.\n        assembly {\n            // Equivalent to `uint256(orderType) & 1 == 0`.\n            isFullOrder := and(\n                lt(numerator, denominator),\n                iszero(and(orderType, 1))\n            )\n        }\n    }\n}\n'}, 'lib/seaport-types/src/interfaces/CriteriaResolutionErrors.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport { Side } from ""../lib/ConsiderationEnums.sol"";\n\n/**\n * @title CriteriaResolutionErrors\n * @author 0age\n * @notice CriteriaResolutionErrors contains all errors related to criteria\n *         resolution.\n */\ninterface CriteriaResolutionErrors {\n    /**\n     * @dev Revert with an error when providing a criteria resolver that refers\n     *      to an order that has not been supplied.\n     *\n     * @param side The side of the order that was not supplied.\n     */\n    error OrderCriteriaResolverOutOfRange(Side side);\n\n    /**\n     * @dev Revert with an error if an offer item still has unresolved criteria\n     *      after applying all criteria resolvers.\n     *\n     * @param orderIndex The index of the order that contains the offer item.\n     * @param offerIndex The index of the offer item that still has unresolved\n     *                   criteria.\n     */\n    error UnresolvedOfferCriteria(uint256 orderIndex, uint256 offerIndex);\n\n    /**\n     * @dev Revert with an error if a consideration item still has unresolved\n     *      criteria after applying all criteria resolvers.\n     *\n     * @param orderIndex         The index of the order that contains the\n     *                           consideration item.\n     * @param considerationIndex The index of the consideration item that still\n     *                           has unresolved criteria.\n     */\n    error UnresolvedConsiderationCriteria(\n        uint256 orderIndex,\n        uint256 considerationIndex\n    );\n\n    /**\n     * @dev Revert with an error when providing a criteria resolver that refers\n     *      to an order with an offer item that has not been supplied.\n     */\n    error OfferCriteriaResolverOutOfRange();\n\n    /**\n     * @dev Revert with an error when providing a criteria resolver that refers\n     *      to an order with a consideration item that has not been supplied.\n     */\n    error ConsiderationCriteriaResolverOutOfRange();\n\n    /**\n     * @dev Revert with an error when providing a criteria resolver that refers\n     *      to an order with an item that does not expect a criteria to be\n     *      resolved.\n     */\n    error CriteriaNotEnabledForItem();\n\n    /**\n     * @dev Revert with an error when providing a criteria resolver that\n     *      contains an invalid proof with respect to the given item and\n     *      chosen identifier.\n     */\n    error InvalidProof();\n}\n'}, 'lib/seaport-types/src/interfaces/AmountDerivationErrors.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n * @title AmountDerivationErrors\n * @author 0age\n * @notice AmountDerivationErrors contains errors related to amount derivation.\n */\ninterface AmountDerivationErrors {\n    /**\n     * @dev Revert with an error when attempting to apply a fraction as part of\n     *      a partial fill that does not divide the target amount cleanly.\n     */\n    error InexactFraction();\n}\n'}, 'src/lib/Executor.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {\n    ConduitInterface\n} from ""seaport-types/src/interfaces/ConduitInterface.sol"";\n\nimport {\n    ConduitItemType\n} from ""seaport-types/src/conduit/lib/ConduitEnums.sol"";\n\nimport { ItemType } from ""seaport-types/src/lib/ConsiderationEnums.sol"";\n\nimport { ReceivedItem } from ""seaport-types/src/lib/ConsiderationStructs.sol"";\n\nimport { Verifiers } from ""./Verifiers.sol"";\n\nimport { TokenTransferrer } from ""./TokenTransferrer.sol"";\n\nimport {\n    Accumulator_array_length_ptr,\n    Accumulator_array_offset_ptr,\n    Accumulator_array_offset,\n    Accumulator_conduitKey_ptr,\n    Accumulator_itemSizeOffsetDifference,\n    Accumulator_selector_ptr,\n    AccumulatorArmed,\n    AccumulatorDisarmed,\n    Conduit_transferItem_amount_ptr,\n    Conduit_transferItem_from_ptr,\n    Conduit_transferItem_identifier_ptr,\n    Conduit_transferItem_size,\n    Conduit_transferItem_to_ptr,\n    Conduit_transferItem_token_ptr,\n    FreeMemoryPointerSlot,\n    OneWord,\n    TwoWords\n} from ""seaport-types/src/lib/ConsiderationConstants.sol"";\n\nimport {\n    Error_selector_offset,\n    NativeTokenTransferGenericFailure_error_account_ptr,\n    NativeTokenTransferGenericFailure_error_amount_ptr,\n    NativeTokenTransferGenericFailure_error_length,\n    NativeTokenTransferGenericFailure_error_selector\n} from ""seaport-types/src/lib/ConsiderationErrorConstants.sol"";\n\nimport {\n    _revertInvalidCallToConduit,\n    _revertInvalidConduit,\n    _revertInvalidERC721TransferAmount,\n    _revertUnusedItemParameters\n} from ""seaport-types/src/lib/ConsiderationErrors.sol"";\n\n/**\n * @title Executor\n * @author 0age\n * @notice Executor contains functions related to processing executions (i.e.\n *         transferring items, either directly or via conduits).\n */\ncontract Executor is Verifiers, TokenTransferrer {\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) Verifiers(conduitController) {}\n\n    /**\n     * @dev Internal function to transfer a given item, either directly or via\n     *      a corresponding conduit.\n     *\n     * @param item        The item to transfer, including an amount and a\n     *                    recipient.\n     * @param from        The account supplying the item.\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\n     *                    if any, to source token approvals from. The zero hash\n     *                    signifies that no conduit should be used, with direct\n     *                    approvals set on this contract.\n     * @param accumulator An open-ended array that collects transfers to execute\n     *                    against a given conduit in a single call.\n     */\n    function _transfer(\n        ReceivedItem memory item,\n        address from,\n        bytes32 conduitKey,\n        bytes memory accumulator\n    ) internal {\n        // If the item type indicates Ether or a native token...\n        if (item.itemType == ItemType.NATIVE) {\n            // Ensure neither the token nor the identifier parameters are set.\n            if ((uint160(item.token) | item.identifier) != 0) {\n                _revertUnusedItemParameters();\n            }\n\n            // transfer the native tokens to the recipient.\n            _transferNativeTokens(item.recipient, item.amount);\n        } else if (item.itemType == ItemType.ERC20) {\n            // Ensure that no identifier is supplied.\n            if (item.identifier != 0) {\n                _revertUnusedItemParameters();\n            }\n\n            // Transfer ERC20 tokens from the source to the recipient.\n            _transferERC20(\n                item.token,\n                from,\n                item.recipient,\n                item.amount,\n                conduitKey,\n                accumulator\n            );\n        } else if (item.itemType == ItemType.ERC721) {\n            // Transfer ERC721 token from the source to the recipient.\n            _transferERC721(\n                item.token,\n                from,\n                item.recipient,\n                item.identifier,\n                item.amount,\n                conduitKey,\n                accumulator\n            );\n        } else {\n            // Transfer ERC1155 token from the source to the recipient.\n            _transferERC1155(\n                item.token,\n                from,\n                item.recipient,\n                item.identifier,\n                item.amount,\n                conduitKey,\n                accumulator\n            );\n        }\n    }\n\n    /**\n     * @dev Internal function to transfer Ether or other native tokens to a\n     *      given recipient.\n     *\n     * @param to     The recipient of the transfer.\n     * @param amount The amount to transfer.\n     */\n    function _transferNativeTokens(\n        address payable to,\n        uint256 amount\n    ) internal {\n        // Ensure that the supplied amount is non-zero.\n        _assertNonZeroAmount(amount);\n\n        // Declare a variable indicating whether the call was successful or not.\n        bool success;\n\n        assembly {\n            // Transfer the native token and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        // If the call fails...\n        if (!success) {\n            // Revert and pass the revert reason along if one was returned.\n            _revertWithReasonIfOneIsReturned();\n\n            // Otherwise, revert with a generic error message.\n            assembly {\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, NativeTokenTransferGenericFailure_error_selector)\n\n                // Write `to` and `amount` arguments.\n                mstore(NativeTokenTransferGenericFailure_error_account_ptr, to)\n                mstore(\n                    NativeTokenTransferGenericFailure_error_amount_ptr,\n                    amount\n                )\n\n                // revert(abi.encodeWithSignature(\n                //     ""NativeTokenTransferGenericFailure(address,uint256)"",\n                //     to,\n                //     amount\n                // ))\n                revert(\n                    Error_selector_offset,\n                    NativeTokenTransferGenericFailure_error_length\n                )\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function to transfer ERC20 tokens from a given originator\n     *      to a given recipient using a given conduit if applicable. Sufficient\n     *      approvals must be set on this contract or on a respective conduit.\n     *\n     * @param token       The ERC20 token to transfer.\n     * @param from        The originator of the transfer.\n     * @param to          The recipient of the transfer.\n     * @param amount      The amount to transfer.\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\n     *                    if any, to source token approvals from. The zero hash\n     *                    signifies that no conduit should be used, with direct\n     *                    approvals set on this contract.\n     * @param accumulator An open-ended array that collects transfers to execute\n     *                    against a given conduit in a single call.\n     */\n    function _transferERC20(\n        address token,\n        address from,\n        address to,\n        uint256 amount,\n        bytes32 conduitKey,\n        bytes memory accumulator\n    ) internal {\n        // Ensure that the supplied amount is non-zero.\n        _assertNonZeroAmount(amount);\n\n        // Trigger accumulated transfers if the conduits differ.\n        _triggerIfArmedAndNotAccumulatable(accumulator, conduitKey);\n\n        // If no conduit has been specified...\n        if (conduitKey == bytes32(0)) {\n            // Perform the token transfer directly.\n            _performERC20Transfer(token, from, to, amount);\n        } else {\n            // Insert the call to the conduit into the accumulator.\n            _insert(\n                conduitKey,\n                accumulator,\n                ConduitItemType.ERC20,\n                token,\n                from,\n                to,\n                uint256(0),\n                amount\n            );\n        }\n    }\n\n    /**\n     * @dev Internal function to transfer a single ERC721 token from a given\n     *      originator to a given recipient. Sufficient approvals must be set,\n     *      either on the respective conduit or on this contract itself.\n     *\n     * @param token       The ERC721 token to transfer.\n     * @param from        The originator of the transfer.\n     * @param to          The recipient of the transfer.\n     * @param identifier  The tokenId to transfer.\n     * @param amount      The amount to transfer (must be 1 for ERC721).\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\n     *                    if any, to source token approvals from. The zero hash\n     *                    signifies that no conduit should be used, with direct\n     *                    approvals set on this contract.\n     * @param accumulator An open-ended array that collects transfers to execute\n     *                    against a given conduit in a single call.\n     */\n    function _transferERC721(\n        address token,\n        address from,\n        address to,\n        uint256 identifier,\n        uint256 amount,\n        bytes32 conduitKey,\n        bytes memory accumulator\n    ) internal {\n        // Trigger accumulated transfers if the conduits differ.\n        _triggerIfArmedAndNotAccumulatable(accumulator, conduitKey);\n\n        // If no conduit has been specified...\n        if (conduitKey == bytes32(0)) {\n            // Ensure that exactly one 721 item is being transferred.\n            if (amount != 1) {\n                _revertInvalidERC721TransferAmount(amount);\n            }\n\n            // Perform transfer via the token contract directly.\n            _performERC721Transfer(token, from, to, identifier);\n        } else {\n            // Insert the call to the conduit into the accumulator.\n            _insert(\n                conduitKey,\n                accumulator,\n                ConduitItemType.ERC721,\n                token,\n                from,\n                to,\n                identifier,\n                amount\n            );\n        }\n    }\n\n    /**\n     * @dev Internal function to transfer ERC1155 tokens from a given originator\n     *      to a given recipient. Sufficient approvals must be set, either on\n     *      the respective conduit or on this contract itself.\n     *\n     * @param token       The ERC1155 token to transfer.\n     * @param from        The originator of the transfer.\n     * @param to          The recipient of the transfer.\n     * @param identifier  The id to transfer.\n     * @param amount      The amount to transfer.\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\n     *                    if any, to source token approvals from. The zero hash\n     *                    signifies that no conduit should be used, with direct\n     *                    approvals set on this contract.\n     * @param accumulator An open-ended array that collects transfers to execute\n     *                    against a given conduit in a single call.\n     */\n    function _transferERC1155(\n        address token,\n        address from,\n        address to,\n        uint256 identifier,\n        uint256 amount,\n        bytes32 conduitKey,\n        bytes memory accumulator\n    ) internal {\n        // Ensure that the supplied amount is non-zero.\n        _assertNonZeroAmount(amount);\n\n        // Trigger accumulated transfers if the conduits differ.\n        _triggerIfArmedAndNotAccumulatable(accumulator, conduitKey);\n\n        // If no conduit has been specified...\n        if (conduitKey == bytes32(0)) {\n            // Perform transfer via the token contract directly.\n            _performERC1155Transfer(token, from, to, identifier, amount);\n        } else {\n            // Insert the call to the conduit into the accumulator.\n            _insert(\n                conduitKey,\n                accumulator,\n                ConduitItemType.ERC1155,\n                token,\n                from,\n                to,\n                identifier,\n                amount\n            );\n        }\n    }\n\n    /**\n     * @dev Internal function to trigger a call to the conduit currently held by\n     *      the accumulator if the accumulator contains item transfers (i.e. it\n     *      is ""armed"") and the supplied conduit key does not match the key held\n     *      by the accumulator.\n     *\n     * @param accumulator An open-ended array that collects transfers to execute\n     *                    against a given conduit in a single call.\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\n     *                    if any, to source token approvals from. The zero hash\n     *                    signifies that no conduit should be used, with direct\n     *                    approvals set on this contract.\n     */\n    function _triggerIfArmedAndNotAccumulatable(\n        bytes memory accumulator,\n        bytes32 conduitKey\n    ) internal {\n        // Retrieve the current conduit key from the accumulator.\n        bytes32 accumulatorConduitKey = _getAccumulatorConduitKey(accumulator);\n\n        // Perform conduit call if the set key does not match the supplied key.\n        if (accumulatorConduitKey != conduitKey) {\n            _triggerIfArmed(accumulator);\n        }\n    }\n\n    /**\n     * @dev Internal function to trigger a call to the conduit currently held by\n     *      the accumulator if the accumulator contains item transfers (i.e. it\n     *      is ""armed"").\n     *\n     * @param accumulator An open-ended array that collects transfers to execute\n     *                    against a given conduit in a single call.\n     */\n    function _triggerIfArmed(bytes memory accumulator) internal {\n        // Exit if the accumulator is not ""armed"".\n        if (accumulator.length != AccumulatorArmed) {\n            return;\n        }\n\n        // Retrieve the current conduit key from the accumulator.\n        bytes32 accumulatorConduitKey = _getAccumulatorConduitKey(accumulator);\n\n        // Perform conduit call.\n        _trigger(accumulatorConduitKey, accumulator);\n    }\n\n    /**\n     * @dev Internal function to trigger a call to the conduit corresponding to\n     *      a given conduit key, supplying all accumulated item transfers. The\n     *      accumulator will be ""disarmed"" and reset in the process.\n     *\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\n     *                    if any, to source token approvals from. The zero hash\n     *                    signifies that no conduit should be used, with direct\n     *                    approvals set on this contract.\n     * @param accumulator An open-ended array that collects transfers to execute\n     *                    against a given conduit in a single call.\n     */\n    function _trigger(bytes32 conduitKey, bytes memory accumulator) internal {\n        // Declare variables for offset in memory & size of calldata to conduit.\n        uint256 callDataOffset;\n        uint256 callDataSize;\n\n        // Call the conduit with all the accumulated transfers.\n        assembly {\n            // Call begins at third word; the first is length or ""armed"" status,\n            // and the second is the current conduit key.\n            callDataOffset := add(accumulator, TwoWords)\n\n            // 68 + items * 192\n            callDataSize := add(\n                Accumulator_array_offset_ptr,\n                mul(\n                    mload(add(accumulator, Accumulator_array_length_ptr)),\n                    Conduit_transferItem_size\n                )\n            )\n        }\n\n        // Call conduit derived from conduit key & supply accumulated transfers.\n        _callConduitUsingOffsets(conduitKey, callDataOffset, callDataSize);\n\n        // Reset accumulator length to signal that it is now ""disarmed"".\n        assembly {\n            mstore(accumulator, AccumulatorDisarmed)\n        }\n    }\n\n    /**\n     * @dev Internal function to perform a call to the conduit corresponding to\n     *      a given conduit key based on the offset and size of the calldata in\n     *      question in memory.\n     *\n     * @param conduitKey     A bytes32 value indicating what corresponding\n     *                       conduit, if any, to source token approvals from.\n     *                       The zero hash signifies that no conduit should be\n     *                       used, with direct approvals set on this contract.\n     * @param callDataOffset The memory pointer where calldata is contained.\n     * @param callDataSize   The size of calldata in memory.\n     */\n    function _callConduitUsingOffsets(\n        bytes32 conduitKey,\n        uint256 callDataOffset,\n        uint256 callDataSize\n    ) internal {\n        // Derive the address of the conduit using the conduit key.\n        address conduit = _deriveConduit(conduitKey);\n\n        bool success;\n        bytes4 result;\n\n        // call the conduit.\n        assembly {\n            // Ensure first word of scratch space is empty.\n            mstore(0, 0)\n\n            // Perform call, placing first word of return data in scratch space.\n            success := call(\n                gas(),\n                conduit,\n                0,\n                callDataOffset,\n                callDataSize,\n                0,\n                OneWord\n            )\n\n            // Take value from scratch space and place it on the stack.\n            result := mload(0)\n        }\n\n        // If the call failed...\n        if (!success) {\n            // Pass along whatever revert reason was given by the conduit.\n            _revertWithReasonIfOneIsReturned();\n\n            // Otherwise, revert with a generic error.\n            _revertInvalidCallToConduit(conduit);\n        }\n\n        // Ensure result was extracted and matches magic value.\n        if (result != ConduitInterface.execute.selector) {\n            _revertInvalidConduit(conduitKey, conduit);\n        }\n    }\n\n    /**\n     * @dev Internal pure function to retrieve the current conduit key set for\n     *      the accumulator.\n     *\n     * @param accumulator An open-ended array that collects transfers to execute\n     *                    against a given conduit in a single call.\n     *\n     * @return accumulatorConduitKey The conduit key currently set for the\n     *                               accumulator.\n     */\n    function _getAccumulatorConduitKey(\n        bytes memory accumulator\n    ) internal pure returns (bytes32 accumulatorConduitKey) {\n        // Retrieve the current conduit key from the accumulator.\n        assembly {\n            accumulatorConduitKey := mload(\n                add(accumulator, Accumulator_conduitKey_ptr)\n            )\n        }\n    }\n\n    /**\n     * @dev Internal pure function to place an item transfer into an accumulator\n     *      that collects a series of transfers to execute against a given\n     *      conduit in a single call.\n     *\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\n     *                    if any, to source token approvals from. The zero hash\n     *                    signifies that no conduit should be used, with direct\n     *                    approvals set on this contract.\n     * @param accumulator An open-ended array that collects transfers to execute\n     *                    against a given conduit in a single call.\n     * @param itemType    The type of the item to transfer.\n     * @param token       The token to transfer.\n     * @param from        The originator of the transfer.\n     * @param to          The recipient of the transfer.\n     * @param identifier  The tokenId to transfer.\n     * @param amount      The amount to transfer.\n     */\n    function _insert(\n        bytes32 conduitKey,\n        bytes memory accumulator,\n        ConduitItemType itemType,\n        address token,\n        address from,\n        address to,\n        uint256 identifier,\n        uint256 amount\n    ) internal pure {\n        uint256 elements;\n        // ""Arm"" and prime accumulator if it\'s not already armed. The sentinel\n        // value is held in the length of the accumulator array.\n        if (accumulator.length == AccumulatorDisarmed) {\n            elements = 1;\n            bytes4 selector = ConduitInterface.execute.selector;\n            assembly {\n                mstore(accumulator, AccumulatorArmed) // ""arm"" the accumulator.\n                mstore(add(accumulator, Accumulator_conduitKey_ptr), conduitKey)\n                mstore(add(accumulator, Accumulator_selector_ptr), selector)\n                mstore(\n                    add(accumulator, Accumulator_array_offset_ptr),\n                    Accumulator_array_offset\n                )\n                mstore(add(accumulator, Accumulator_array_length_ptr), elements)\n            }\n        } else {\n            // Otherwise, increase the number of elements by one.\n            assembly {\n                elements := add(\n                    mload(add(accumulator, Accumulator_array_length_ptr)),\n                    1\n                )\n                mstore(add(accumulator, Accumulator_array_length_ptr), elements)\n            }\n        }\n\n        // Insert the item.\n        assembly {\n            let itemPointer := sub(\n                add(accumulator, mul(elements, Conduit_transferItem_size)),\n                Accumulator_itemSizeOffsetDifference\n            )\n            mstore(itemPointer, itemType)\n            mstore(add(itemPointer, Conduit_transferItem_token_ptr), token)\n            mstore(add(itemPointer, Conduit_transferItem_from_ptr), from)\n            mstore(add(itemPointer, Conduit_transferItem_to_ptr), to)\n            mstore(\n                add(itemPointer, Conduit_transferItem_identifier_ptr),\n                identifier\n            )\n            mstore(add(itemPointer, Conduit_transferItem_amount_ptr), amount)\n        }\n    }\n}\n'}, 'src/lib/ZoneInteraction.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { OrderType } from ""seaport-types/src/lib/ConsiderationEnums.sol"";\n\nimport {\n    AdvancedOrder,\n    BasicOrderParameters,\n    OrderParameters\n} from ""seaport-types/src/lib/ConsiderationStructs.sol"";\n\nimport {\n    ZoneInteractionErrors\n} from ""seaport-types/src/interfaces/ZoneInteractionErrors.sol"";\n\nimport { LowLevelHelpers } from ""./LowLevelHelpers.sol"";\n\nimport { ConsiderationEncoder } from ""./ConsiderationEncoder.sol"";\n\nimport {\n    CalldataPointer,\n    MemoryPointer,\n    OffsetOrLengthMask,\n    ZeroSlotPtr\n} from ""seaport-types/src/helpers/PointerLibraries.sol"";\n\nimport {\n    authorizeOrder_selector_offset,\n    BasicOrder_zone_cdPtr,\n    ContractOrder_orderHash_offerer_shift,\n    MaskOverFirstFourBytes,\n    OneWord,\n    OrderParameters_salt_offset,\n    OrderParameters_zone_offset,\n    validateOrder_selector_offset\n} from ""seaport-types/src/lib/ConsiderationConstants.sol"";\n\nimport {\n    Error_selector_offset,\n    InvalidContractOrder_error_selector,\n    InvalidRestrictedOrder_error_length,\n    InvalidRestrictedOrder_error_orderHash_ptr,\n    InvalidRestrictedOrder_error_selector\n} from ""seaport-types/src/lib/ConsiderationErrorConstants.sol"";\n\n/**\n * @title ZoneInteraction\n * @author 0age\n * @notice ZoneInteraction contains logic related to interacting with zones.\n */\ncontract ZoneInteraction is\n    ConsiderationEncoder,\n    ZoneInteractionErrors,\n    LowLevelHelpers\n{\n    /**\n     * @dev Internal function to determine if an order has a restricted order\n     *      type and, if so, to ensure that either the zone is the caller or\n     *      that a call to `validateOrder` on the zone returns a magic value\n     *      indicating that the order is currently valid. Note that contract\n     *      orders are not accessible via the basic fulfillment method.\n     *\n     * @param orderHash  The hash of the order.\n     * @param orderType  The order type.\n     */\n    function _assertRestrictedBasicOrderAuthorization(\n        bytes32 orderHash,\n        OrderType orderType\n    ) internal returns (uint256 callDataPointer) {\n        // Order type 2-3 require zone be caller or zone to approve.\n        // Note that in cases where fulfiller == zone, the restricted order\n        // validation will be skipped.\n        if (\n            _isRestrictedAndCallerNotZone(\n                orderType,\n                CalldataPointer.wrap(BasicOrder_zone_cdPtr).readAddress()\n            )\n        ) {\n            // Encode the `authorizeOrder` call in memory.\n            (\n                MemoryPointer callData,\n                uint256 size,\n                uint256 memoryLocationForOrderHashes\n            ) = _encodeAuthorizeBasicOrder(orderHash);\n\n            // Write the error selector to memory at the zero slot where it can\n            // be used to revert with a specific error message.\n            ZeroSlotPtr.write(InvalidRestrictedOrder_error_selector);\n\n            // Perform `authorizeOrder` call & ensure magic value was returned.\n            _callAndCheckStatus(\n                CalldataPointer.wrap(BasicOrder_zone_cdPtr).readAddress(),\n                orderHash,\n                callData.offset(authorizeOrder_selector_offset),\n                size\n            );\n\n            // Restore the zero slot.\n            ZeroSlotPtr.write(0);\n\n            // Register the calldata pointer for the encoded calldata.\n            callDataPointer = MemoryPointer.unwrap(callData);\n\n            // Utilize unchecked logic as size value cannot be so large as to\n            // cause an overflow.\n            unchecked {\n                // Write the packed encoding of size and memory location for\n                // order hashes to memory at the head of the encoded calldata.\n                callData.write(\n                    ((size + OneWord) << 128) | memoryLocationForOrderHashes\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function to determine if an order has a restricted order\n     *      type and, if so, to ensure that either the zone is the caller or\n     *      that a call to `validateOrder` on the zone returns a magic value\n     *      indicating that the order is currently valid. Note that contract\n     *      orders are not accessible via the basic fulfillment method.\n     *\n     * @param orderHash   The hash of the order.\n     * @param orderType   The order type.\n     * @param callDataPtr The pointer to the call data for the basic order.\n     *                    Note that the initial value will contain the size\n     *                    and the memory location for order hashes length.\n     */\n    function _assertRestrictedBasicOrderValidity(\n        bytes32 orderHash,\n        OrderType orderType,\n        uint256 callDataPtr\n    ) internal {\n        // Order type 2-3 require zone be caller or zone to approve.\n        // Note that in cases where fulfiller == zone, the restricted order\n        // validation will be skipped.\n        if (\n            _isRestrictedAndCallerNotZone(\n                orderType,\n                CalldataPointer.wrap(BasicOrder_zone_cdPtr).readAddress()\n            )\n        ) {\n            // Cast the call data pointer to a memory pointer.\n            MemoryPointer callData = MemoryPointer.wrap(callDataPtr);\n\n            // Retrieve the size and memory location for order hashes from the\n            // head of the encoded calldata where it was previously written.\n            uint256 sizeAndMemoryLocationForOrderHashes = (\n                callData.readUint256()\n            );\n\n            // Split the packed encoding to retrieve size and memory location.\n            uint256 size = sizeAndMemoryLocationForOrderHashes >> 128;\n            uint256 memoryLocationForOrderHashes = (\n                sizeAndMemoryLocationForOrderHashes & OffsetOrLengthMask\n            );\n\n            // Encode the `validateOrder` call in memory.\n            _encodeValidateBasicOrder(callData, memoryLocationForOrderHashes);\n\n            // Account for the offset of the selector in the encoded call data.\n            callData = callData.offset(validateOrder_selector_offset);\n\n            // Write the error selector to memory at the zero slot where it can\n            // be used to revert with a specific error message.\n            ZeroSlotPtr.write(InvalidRestrictedOrder_error_selector);\n\n            // Perform `validateOrder` call and ensure magic value was returned.\n            _callAndCheckStatus(\n                CalldataPointer.wrap(BasicOrder_zone_cdPtr).readAddress(),\n                orderHash,\n                callData,\n                size\n            );\n\n            // Restore the zero slot.\n            ZeroSlotPtr.write(0);\n        }\n    }\n\n    /**\n     * @dev Internal function to determine the pre-execution validity of\n     *      restricted orders, signaling whether or not the order is valid.\n     *      Restricted orders where the caller is not the zone must\n     *      successfully call `authorizeOrder` with the correct magic value\n     *      returned.\n     *\n     * @param advancedOrder   The advanced order in question.\n     * @param orderHashes     The order hashes of each order included as part\n     *                        of the current fulfillment.\n     * @param orderHash       The hash of the order.\n     * @param orderIndex      The index of the order.\n     * @param revertOnInvalid Whether to revert if the call is invalid.\n     *\n     * @return isValid True if the order is valid, false otherwise (unless\n     *                 revertOnInvalid is true, in which case this function\n     *                 will revert).\n     */\n    function _checkRestrictedAdvancedOrderAuthorization(\n        AdvancedOrder memory advancedOrder,\n        bytes32[] memory orderHashes,\n        bytes32 orderHash,\n        uint256 orderIndex,\n        bool revertOnInvalid\n    ) internal returns (bool isValid) {\n        // Retrieve the parameters of the order in question.\n        OrderParameters memory parameters = advancedOrder.parameters;\n\n        // OrderType 2-3 require zone to be caller or approve via validateOrder.\n        if (\n            _isRestrictedAndCallerNotZone(parameters.orderType, parameters.zone)\n        ) {\n            // Encode the `validateOrder` call in memory.\n            (MemoryPointer callData, uint256 size) = _encodeAuthorizeOrder(\n                orderHash,\n                parameters,\n                advancedOrder.extraData,\n                orderHashes,\n                orderIndex\n            );\n\n            // Perform call and ensure a corresponding magic value was returned.\n            return\n                _callAndCheckStatusWithSkip(\n                    parameters.zone,\n                    orderHash,\n                    callData,\n                    size,\n                    InvalidRestrictedOrder_error_selector,\n                    revertOnInvalid\n                );\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Internal function to determine the pre-execution validity of\n     *      restricted orders and to revert if the order is invalid.\n     *      Restricted orders where the caller is not the zone must\n     *      successfully call `authorizeOrder` with the correct magic value\n     *      returned.\n     *\n     * @param advancedOrder   The advanced order in question.\n     * @param orderHashes     The order hashes of each order included as part\n     *                        of the current fulfillment.\n     * @param orderHash       The hash of the order.\n     * @param orderIndex      The index of the order.\n     */\n    function _assertRestrictedAdvancedOrderAuthorization(\n        AdvancedOrder memory advancedOrder,\n        bytes32[] memory orderHashes,\n        bytes32 orderHash,\n        uint256 orderIndex\n    ) internal {\n        // Retrieve the parameters of the order in question.\n        OrderParameters memory parameters = advancedOrder.parameters;\n\n        // OrderType 2-3 requires zone to call or approve via authorizeOrder.\n        if (\n            _isRestrictedAndCallerNotZone(parameters.orderType, parameters.zone)\n        ) {\n            // Encode the `authorizeOrder` call in memory.\n            (MemoryPointer callData, uint256 size) = _encodeAuthorizeOrder(\n                orderHash,\n                parameters,\n                advancedOrder.extraData,\n                orderHashes,\n                orderIndex\n            );\n\n            // Write the error selector to memory at the zero slot where it can\n            // be used to revert with a specific error message.\n            ZeroSlotPtr.write(InvalidRestrictedOrder_error_selector);\n\n            // Perform call and ensure a corresponding magic value was returned.\n            _callAndCheckStatus(parameters.zone, orderHash, callData, size);\n\n            // Restore the zero slot.\n            ZeroSlotPtr.write(0);\n        }\n    }\n\n    /**\n     * @dev Internal function to determine the post-execution validity of\n     *      restricted and contract orders. Restricted orders where the caller\n     *      is not the zone must successfully call `validateOrder` with the\n     *      correct magic value returned. Contract orders must successfully call\n     *      `ratifyOrder` with the correct magic value returned.\n     *\n     * @param advancedOrder The advanced order in question.\n     * @param orderHashes   The order hashes of each order included as part of\n     *                      the current fulfillment.\n     * @param orderHash     The hash of the order.\n     */\n    function _assertRestrictedAdvancedOrderValidity(\n        AdvancedOrder memory advancedOrder,\n        bytes32[] memory orderHashes,\n        bytes32 orderHash\n    ) internal {\n        // Declare variables that will be assigned based on the order type.\n        address target;\n        uint256 errorSelector;\n        MemoryPointer callData;\n        uint256 size;\n\n        // Retrieve the parameters of the order in question.\n        OrderParameters memory parameters = advancedOrder.parameters;\n\n        // OrderType 2-3 require zone to be caller or approve via validateOrder.\n        if (\n            _isRestrictedAndCallerNotZone(parameters.orderType, parameters.zone)\n        ) {\n            // Encode the `validateOrder` call in memory.\n            (callData, size) = _encodeValidateOrder(\n                parameters\n                    .toMemoryPointer()\n                    .offset(OrderParameters_salt_offset)\n                    .readUint256(),\n                orderHashes\n            );\n\n            // Set the target to the zone.\n            target = (\n                parameters\n                    .toMemoryPointer()\n                    .offset(OrderParameters_zone_offset)\n                    .readAddress()\n            );\n\n            // Set the restricted-order-specific error selector.\n            errorSelector = InvalidRestrictedOrder_error_selector;\n        } else if (parameters.orderType == OrderType.CONTRACT) {\n            // Set the target to the offerer (note the offerer has no offset).\n            target = parameters.toMemoryPointer().readAddress();\n\n            // Shift the target 96 bits to the left.\n            uint256 shiftedOfferer;\n            assembly {\n                shiftedOfferer := shl(\n                    ContractOrder_orderHash_offerer_shift,\n                    target\n                )\n            }\n\n            // Encode the `ratifyOrder` call in memory.\n            (callData, size) = _encodeRatifyOrder(\n                orderHash,\n                parameters,\n                advancedOrder.extraData,\n                orderHashes,\n                shiftedOfferer\n            );\n\n            // Set the contract-order-specific error selector.\n            errorSelector = InvalidContractOrder_error_selector;\n        } else {\n            return;\n        }\n\n        // Write the error selector to memory at the zero slot where it can be\n        // used to revert with a specific error message.\n        ZeroSlotPtr.write(errorSelector);\n\n        // Perform call and ensure a corresponding magic value was returned.\n        _callAndCheckStatus(target, orderHash, callData, size);\n\n        // Restore the zero slot.\n        ZeroSlotPtr.write(0);\n    }\n\n    /**\n     * @dev Determines whether the specified order type is restricted and the\n     *      caller is not the specified zone.\n     *\n     * @param orderType     The type of the order to check.\n     * @param zone          The address of the zone to check against.\n     *\n     * @return mustValidate True if the order type is restricted and the caller\n     *                      is not the specified zone, false otherwise.\n     */\n    function _isRestrictedAndCallerNotZone(\n        OrderType orderType,\n        address zone\n    ) internal view returns (bool mustValidate) {\n        // Utilize assembly to efficiently perform the check.\n        assembly {\n            mustValidate := and(\n                // Note that this check requires that there are no order\n                // types beyond the current set (0-4).  It will need to be\n                // modified if more order types are added.\n                and(lt(orderType, 4), gt(orderType, 1)),\n                iszero(eq(caller(), zone))\n            )\n        }\n    }\n\n    /**\n     * @dev Calls the specified target with the given data and checks the status\n     *      of the call. Revert reasons will be ""bubbled up"" if one is returned,\n     *      otherwise reverting calls will throw a generic error based on the\n     *      supplied error handler. Note that the custom error selector must\n     *      already be in memory at the zero slot when this function is called.\n     *\n     * @param target        The address of the contract to call.\n     * @param orderHash     The hash of the order associated with the call.\n     * @param callData      The data to pass to the contract call.\n     * @param size          The size of calldata.\n     */\n    function _callAndCheckStatus(\n        address target,\n        bytes32 orderHash,\n        MemoryPointer callData,\n        uint256 size\n    ) internal {\n        bool success;\n        bool magicMatch;\n        assembly {\n            // Get magic value from the selector at start of provided calldata.\n            let magic := and(mload(callData), MaskOverFirstFourBytes)\n\n            // Clear the start of scratch space.\n            mstore(0, 0)\n\n            // Perform call, placing result in the first word of scratch space.\n            success := call(gas(), target, 0, callData, size, 0, OneWord)\n\n            // Determine if returned magic value matches the calldata selector.\n            magicMatch := eq(magic, mload(0))\n        }\n\n        // Revert if the call was not successful.\n        if (!success) {\n            // Revert and pass reason along if one was returned.\n            _revertWithReasonIfOneIsReturned();\n\n            // If no reason was returned, revert with supplied error selector.\n            assembly {\n                // The error selector is already in memory at the zero slot.\n                mstore(0x80, orderHash)\n                // revert(abi.encodeWithSelector(\n                //     ""InvalidRestrictedOrder(bytes32)"",\n                //     orderHash\n                // ))\n                revert(0x7c, InvalidRestrictedOrder_error_length)\n            }\n        }\n\n        // Revert if the correct magic value was not returned.\n        if (!magicMatch) {\n            // Revert with a generic error message.\n            assembly {\n                // The error selector is already in memory at the zero slot.\n                mstore(0x80, orderHash)\n                // revert(abi.encodeWithSelector(\n                //     ""InvalidRestrictedOrder(bytes32)"",\n                //     orderHash\n                // ))\n                revert(0x7c, InvalidRestrictedOrder_error_length)\n            }\n        }\n    }\n\n    /**\n     * @dev Calls the specified target with the given data and checks the status\n     *      of the call. Revert reasons will be ""bubbled up"" if one is returned,\n     *      otherwise reverting calls will throw a generic error based on the\n     *      supplied error handler.\n     *\n     * @param target          The address of the contract to call.\n     * @param orderHash       The hash of the order associated with the call.\n     * @param callData        The data to pass to the contract call.\n     * @param size            The size of calldata.\n     * @param errorSelector   The error handling function to call if the call\n     *                        fails or the magic value does not match.\n     * @param revertOnInvalid Whether to revert if the call is invalid. Must\n     *                        still revert if the call returns invalid data.\n     */\n    function _callAndCheckStatusWithSkip(\n        address target,\n        bytes32 orderHash,\n        MemoryPointer callData,\n        uint256 size,\n        uint256 errorSelector,\n        bool revertOnInvalid\n    ) internal returns (bool) {\n        bool success;\n        bool magicMatch;\n        assembly {\n            // Get magic value from the selector at start of provided calldata.\n            let magic := and(mload(callData), MaskOverFirstFourBytes)\n\n            // Clear the start of scratch space.\n            mstore(0, 0)\n\n            // Perform call, placing result in the first word of scratch space.\n            success := call(gas(), target, 0, callData, size, 0, OneWord)\n\n            // Determine if returned magic value matches the calldata selector.\n            magicMatch := eq(magic, mload(0))\n        }\n\n        // Revert or return false if the call was not successful.\n        if (!success) {\n            if (!revertOnInvalid) {\n                return false;\n            }\n\n            // Revert and pass reason along if one was returned.\n            _revertWithReasonIfOneIsReturned();\n\n            // If no reason was returned, revert with supplied error selector.\n            assembly {\n                mstore(0, errorSelector)\n                mstore(InvalidRestrictedOrder_error_orderHash_ptr, orderHash)\n                // revert(abi.encodeWithSelector(\n                //     ""InvalidRestrictedOrder(bytes32)"",\n                //     orderHash\n                // ))\n                revert(\n                    Error_selector_offset,\n                    InvalidRestrictedOrder_error_length\n                )\n            }\n        }\n\n        // Revert if the correct magic value was not returned.\n        if (!magicMatch) {\n            // Revert with a generic error message.\n            assembly {\n                mstore(0, errorSelector)\n                mstore(InvalidRestrictedOrder_error_orderHash_ptr, orderHash)\n\n                // revert(abi.encodeWithSelector(\n                //     ""InvalidRestrictedOrder(bytes32)"",\n                //     orderHash\n                // ))\n                revert(\n                    Error_selector_offset,\n                    InvalidRestrictedOrder_error_length\n                )\n            }\n        }\n\n        return true;\n    }\n}\n'}, 'lib/seaport-types/src/interfaces/ConduitInterface.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {\n    ConduitBatch1155Transfer,\n    ConduitTransfer\n} from ""../conduit/lib/ConduitStructs.sol"";\n\n/**\n * @title ConduitInterface\n * @author 0age\n * @notice ConduitInterface contains all external function interfaces, events,\n *         and errors for conduit contracts.\n */\ninterface ConduitInterface {\n    /**\n     * @dev Revert with an error when attempting to execute transfers using a\n     *      caller that does not have an open channel.\n     */\n    error ChannelClosed(address channel);\n\n    /**\n     * @dev Revert with an error when attempting to update a channel to the\n     *      current status of that channel.\n     */\n    error ChannelStatusAlreadySet(address channel, bool isOpen);\n\n    /**\n     * @dev Revert with an error when attempting to execute a transfer for an\n     *      item that does not have an ERC20/721/1155 item type.\n     */\n    error InvalidItemType();\n\n    /**\n     * @dev Revert with an error when attempting to update the status of a\n     *      channel from a caller that is not the conduit controller.\n     */\n    error InvalidController();\n\n    /**\n     * @dev Emit an event whenever a channel is opened or closed.\n     *\n     * @param channel The channel that has been updated.\n     * @param open    A boolean indicating whether the conduit is open or not.\n     */\n    event ChannelUpdated(address indexed channel, bool open);\n\n    /**\n     * @notice Execute a sequence of ERC20/721/1155 transfers. Only a caller\n     *         with an open channel can call this function.\n     *\n     * @param transfers The ERC20/721/1155 transfers to perform.\n     *\n     * @return magicValue A magic value indicating that the transfers were\n     *                    performed successfully.\n     */\n    function execute(\n        ConduitTransfer[] calldata transfers\n    ) external returns (bytes4 magicValue);\n\n    /**\n     * @notice Execute a sequence of batch 1155 transfers. Only a caller with an\n     *         open channel can call this function.\n     *\n     * @param batch1155Transfers The 1155 batch transfers to perform.\n     *\n     * @return magicValue A magic value indicating that the transfers were\n     *                    performed successfully.\n     */\n    function executeBatch1155(\n        ConduitBatch1155Transfer[] calldata batch1155Transfers\n    ) external returns (bytes4 magicValue);\n\n    /**\n     * @notice Execute a sequence of transfers, both single and batch 1155. Only\n     *         a caller with an open channel can call this function.\n     *\n     * @param standardTransfers  The ERC20/721/1155 transfers to perform.\n     * @param batch1155Transfers The 1155 batch transfers to perform.\n     *\n     * @return magicValue A magic value indicating that the transfers were\n     *                    performed successfully.\n     */\n    function executeWithBatch1155(\n        ConduitTransfer[] calldata standardTransfers,\n        ConduitBatch1155Transfer[] calldata batch1155Transfers\n    ) external returns (bytes4 magicValue);\n\n    /**\n     * @notice Open or close a given channel. Only callable by the controller.\n     *\n     * @param channel The channel to open or close.\n     * @param isOpen  The status of the channel (either open or closed).\n     */\n    function updateChannel(address channel, bool isOpen) external;\n}\n'}, 'lib/seaport-types/src/conduit/lib/ConduitEnums.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nenum ConduitItemType {\n    NATIVE, // unused\n    ERC20,\n    ERC721,\n    ERC1155\n}\n'}, 'src/lib/Verifiers.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { OrderStatus } from ""seaport-types/src/lib/ConsiderationStructs.sol"";\n\nimport { Assertions } from ""./Assertions.sol"";\n\nimport { SignatureVerification } from ""./SignatureVerification.sol"";\n\nimport {\n    _revertInvalidTime,\n    _revertOrderAlreadyFilled,\n    _revertOrderIsCancelled,\n    _revertOrderPartiallyFilled\n} from ""seaport-types/src/lib/ConsiderationErrors.sol"";\n\nimport {\n    BulkOrderProof_keyShift,\n    BulkOrderProof_keySize,\n    BulkOrderProof_lengthAdjustmentBeforeMask,\n    BulkOrderProof_lengthRangeAfterMask,\n    BulkOrderProof_minSize,\n    BulkOrderProof_rangeSize,\n    ECDSA_MaxLength,\n    OneWord,\n    OneWordShift,\n    ThirtyOneBytes,\n    TwoWords\n} from ""seaport-types/src/lib/ConsiderationConstants.sol"";\n\n/**\n * @title Verifiers\n * @author 0age\n * @notice Verifiers contains functions for performing verifications.\n */\ncontract Verifiers is Assertions, SignatureVerification {\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) Assertions(conduitController) {}\n\n    /**\n     * @dev Internal view function to ensure that the current time falls within\n     *      an order\'s valid timespan.\n     *\n     * @param startTime       The time at which the order becomes active.\n     * @param endTime         The time at which the order becomes inactive.\n     * @param revertOnInvalid A boolean indicating whether to revert if the\n     *                        order is not active.\n     *\n     * @return valid A boolean indicating whether the order is active.\n     */\n    function _verifyTime(\n        uint256 startTime,\n        uint256 endTime,\n        bool revertOnInvalid\n    ) internal view returns (bool valid) {\n        // Mark as valid if order has started and has not already ended.\n        assembly {\n            valid := and(\n                iszero(gt(startTime, timestamp())),\n                gt(endTime, timestamp())\n            )\n        }\n\n        // Only revert on invalid if revertOnInvalid has been supplied as true.\n        if (revertOnInvalid && !valid) {\n            _revertInvalidTime(startTime, endTime);\n        }\n    }\n\n    /**\n     * @dev Internal view function to verify the signature of an order. An\n     *      ERC-1271 fallback will be attempted if either the signature length\n     *      is not 64 or 65 bytes or if the recovered signer does not match the\n     *      supplied offerer. Note that in cases where a 64 or 65 byte signature\n     *      is supplied, only standard ECDSA signatures that recover to a\n     *      non-zero address are supported.\n     *\n     * @param offerer   The offerer for the order.\n     * @param orderHash The order hash.\n     * @param signature A signature from the offerer indicating that the order\n     *                  has been approved.\n     */\n    function _verifySignature(\n        address offerer,\n        bytes32 orderHash,\n        bytes memory signature\n    ) internal view {\n        // Determine whether the offerer is the caller.\n        bool offererIsCaller;\n        assembly {\n            offererIsCaller := eq(offerer, caller())\n        }\n\n        // Skip signature verification if the offerer is the caller.\n        if (offererIsCaller) {\n            return;\n        }\n\n        // Derive the EIP-712 domain separator.\n        bytes32 domainSeparator = _domainSeparator();\n\n        // Derive original EIP-712 digest using domain separator and order hash.\n        bytes32 originalDigest = _deriveEIP712Digest(\n            domainSeparator,\n            orderHash\n        );\n\n        // Read the length of the signature from memory and place on the stack.\n        uint256 originalSignatureLength = signature.length;\n\n        // Determine effective digest if signature has a valid bulk order size.\n        bytes32 digest;\n        if (_isValidBulkOrderSize(originalSignatureLength)) {\n            // Rederive order hash and digest using bulk order proof.\n            (orderHash) = _computeBulkOrderProof(signature, orderHash);\n            digest = _deriveEIP712Digest(domainSeparator, orderHash);\n        } else {\n            // Supply the original digest as the effective digest.\n            digest = originalDigest;\n        }\n\n        // Ensure that the signature for the digest is valid for the offerer.\n        _assertValidSignature(\n            offerer,\n            digest,\n            originalDigest,\n            originalSignatureLength,\n            signature\n        );\n    }\n\n    /**\n     * @dev Determines whether the specified bulk order size is valid.\n     *\n     * @param signatureLength The signature length of the bulk order to check.\n     *\n     * @return validLength True if bulk order size is valid, false otherwise.\n     */\n    function _isValidBulkOrderSize(\n        uint256 signatureLength\n    ) internal pure returns (bool validLength) {\n        // Utilize assembly to validate the length; the equivalent logic is\n        // (64 + x) + 3 + 32y where (0 <= x <= 1) and (1 <= y <= 24).\n        assembly {\n            validLength := and(\n                lt(\n                    sub(signatureLength, BulkOrderProof_minSize),\n                    BulkOrderProof_rangeSize\n                ),\n                lt(\n                    and(\n                        add(\n                            signatureLength,\n                            BulkOrderProof_lengthAdjustmentBeforeMask\n                        ),\n                        ThirtyOneBytes\n                    ),\n                    BulkOrderProof_lengthRangeAfterMask\n                )\n            )\n        }\n    }\n\n    /**\n     * @dev Computes the bulk order hash for the specified proof and leaf. Note\n     *      that if an index that exceeds the number of orders in the bulk order\n     *      payload will instead ""wrap around"" and refer to an earlier index.\n     *\n     * @param proofAndSignature The proof and signature of the bulk order.\n     * @param leaf              The leaf of the bulk order tree.\n     *\n     * @return bulkOrderHash The bulk order hash.\n     */\n    function _computeBulkOrderProof(\n        bytes memory proofAndSignature,\n        bytes32 leaf\n    ) internal pure returns (bytes32 bulkOrderHash) {\n        // Declare arguments for the root hash and the height of the proof.\n        bytes32 root;\n        uint256 height;\n\n        // Utilize assembly to efficiently derive the root hash using the proof.\n        assembly {\n            // Retrieve the length of the proof, key, and signature combined.\n            let fullLength := mload(proofAndSignature)\n\n            // If proofAndSignature has odd length, it is a compact signature\n            // with 64 bytes.\n            let signatureLength := sub(ECDSA_MaxLength, and(fullLength, 1))\n\n            // Derive height (or depth of tree) with signature and proof length.\n            height := shr(OneWordShift, sub(fullLength, signatureLength))\n\n            // Update the length in memory to only include the signature.\n            mstore(proofAndSignature, signatureLength)\n\n            // Derive the pointer for the key using the signature length.\n            let keyPtr := add(proofAndSignature, add(OneWord, signatureLength))\n\n            // Retrieve the three-byte key using the derived pointer.\n            let key := shr(BulkOrderProof_keyShift, mload(keyPtr))\n\n            /// Retrieve pointer to first proof element by applying a constant\n            // for the key size to the derived key pointer.\n            let proof := add(keyPtr, BulkOrderProof_keySize)\n\n            // Compute level 1.\n            let scratchPtr1 := shl(OneWordShift, and(key, 1))\n            mstore(scratchPtr1, leaf)\n            mstore(xor(scratchPtr1, OneWord), mload(proof))\n\n            // Compute remaining proofs.\n            for {\n                let i := 1\n            } lt(i, height) {\n                i := add(i, 1)\n            } {\n                proof := add(proof, OneWord)\n                let scratchPtr := shl(OneWordShift, and(shr(i, key), 1))\n                mstore(scratchPtr, keccak256(0, TwoWords))\n                mstore(xor(scratchPtr, OneWord), mload(proof))\n            }\n\n            // Compute root hash.\n            root := keccak256(0, TwoWords)\n        }\n\n        // Retrieve appropriate typehash constant based on height.\n        bytes32 rootTypeHash = _lookupBulkOrderTypehash(height);\n\n        // Use the typehash and the root hash to derive final bulk order hash.\n        assembly {\n            mstore(0, rootTypeHash)\n            mstore(OneWord, root)\n            bulkOrderHash := keccak256(0, TwoWords)\n        }\n    }\n\n    /**\n     * @dev Internal view function to validate that a given order is fillable\n     *      and not cancelled based on the order status.\n     *\n     * @param orderHash       The order hash.\n     * @param orderStatus     The status of the order, including whether it has\n     *                        been cancelled and the fraction filled.\n     * @param onlyAllowUnused A boolean flag indicating whether partial fills\n     *                        are supported by the calling function.\n     * @param revertOnInvalid A boolean indicating whether to revert if the\n     *                        order has been cancelled or filled beyond the\n     *                        allowable amount.\n     *\n     * @return valid A boolean indicating whether the order is valid.\n     */\n    function _verifyOrderStatus(\n        bytes32 orderHash,\n        OrderStatus storage orderStatus,\n        bool onlyAllowUnused,\n        bool revertOnInvalid\n    ) internal view returns (bool valid) {\n        // Ensure that the order has not been cancelled.\n        if (orderStatus.isCancelled) {\n            // Only revert if revertOnInvalid has been supplied as true.\n            if (revertOnInvalid) {\n                _revertOrderIsCancelled(orderHash);\n            }\n\n            // Return false as the order status is invalid.\n            return false;\n        }\n\n        // Read order status numerator from storage and place on stack.\n        uint256 orderStatusNumerator = orderStatus.numerator;\n\n        // If the order is not entirely unused...\n        if (orderStatusNumerator != 0) {\n            // ensure the order has not been partially filled when not allowed.\n            if (onlyAllowUnused) {\n                // Always revert on partial fills when onlyAllowUnused is true.\n                _revertOrderPartiallyFilled(orderHash);\n            }\n            // Otherwise, ensure that order has not been entirely filled.\n            else if (orderStatusNumerator >= orderStatus.denominator) {\n                // Only revert if revertOnInvalid has been supplied as true.\n                if (revertOnInvalid) {\n                    _revertOrderAlreadyFilled(orderHash);\n                }\n\n                // Return false as the order status is invalid.\n                return false;\n            }\n        }\n\n        // Return true as the order status is valid.\n        valid = true;\n    }\n}\n'}, 'src/lib/TokenTransferrer.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.14;\n\nimport {\n    BadReturnValueFromERC20OnTransfer_error_amount_ptr,\n    BadReturnValueFromERC20OnTransfer_error_from_ptr,\n    BadReturnValueFromERC20OnTransfer_error_length,\n    BadReturnValueFromERC20OnTransfer_error_selector,\n    BadReturnValueFromERC20OnTransfer_error_to_ptr,\n    BadReturnValueFromERC20OnTransfer_error_token_ptr,\n    BatchTransfer1155Params_amounts_head_ptr,\n    BatchTransfer1155Params_calldata_baseSize,\n    BatchTransfer1155Params_data_head_ptr,\n    BatchTransfer1155Params_data_length_basePtr,\n    BatchTransfer1155Params_ids_head_ptr,\n    BatchTransfer1155Params_ids_length_offset,\n    BatchTransfer1155Params_ids_length_ptr,\n    BatchTransfer1155Params_ptr,\n    ConduitBatch1155Transfer_amounts_length_baseOffset,\n    ConduitBatch1155Transfer_from_offset,\n    ConduitBatch1155Transfer_ids_head_offset,\n    ConduitBatch1155Transfer_ids_length_offset,\n    ConduitBatch1155Transfer_usable_head_size,\n    ConduitBatchTransfer_amounts_head_offset,\n    CostPerWord,\n    DefaultFreeMemoryPointer,\n    ERC1155_safeBatchTransferFrom_signature,\n    ERC1155_safeTransferFrom_amount_ptr,\n    ERC1155_safeTransferFrom_data_length_offset,\n    ERC1155_safeTransferFrom_data_length_ptr,\n    ERC1155_safeTransferFrom_data_offset_ptr,\n    ERC1155_safeTransferFrom_from_ptr,\n    ERC1155_safeTransferFrom_id_ptr,\n    ERC1155_safeTransferFrom_length,\n    ERC1155_safeTransferFrom_sig_ptr,\n    ERC1155_safeTransferFrom_signature,\n    ERC1155_safeTransferFrom_to_ptr,\n    ERC1155BatchTransferGenericFailure_error_signature,\n    ERC1155BatchTransferGenericFailure_ids_offset,\n    ERC1155BatchTransferGenericFailure_token_ptr,\n    ERC20_transferFrom_amount_ptr,\n    ERC20_transferFrom_from_ptr,\n    ERC20_transferFrom_length,\n    ERC20_transferFrom_sig_ptr,\n    ERC20_transferFrom_signature,\n    ERC20_transferFrom_to_ptr,\n    ERC721_transferFrom_from_ptr,\n    ERC721_transferFrom_id_ptr,\n    ERC721_transferFrom_length,\n    ERC721_transferFrom_sig_ptr,\n    ERC721_transferFrom_signature,\n    ERC721_transferFrom_to_ptr,\n    ExtraGasBuffer,\n    FreeMemoryPointerSlot,\n    Generic_error_selector_offset,\n    Invalid1155BatchTransferEncoding_length,\n    Invalid1155BatchTransferEncoding_ptr,\n    Invalid1155BatchTransferEncoding_selector,\n    MemoryExpansionCoefficientShift,\n    NoContract_error_account_ptr,\n    NoContract_error_length,\n    NoContract_error_selector,\n    OneWord,\n    OneWordShift,\n    Slot0x80,\n    Slot0xA0,\n    Slot0xC0,\n    ThirtyOneBytes,\n    TokenTransferGenericFailure_err_identifier_ptr,\n    TokenTransferGenericFailure_error_amount_ptr,\n    TokenTransferGenericFailure_error_from_ptr,\n    TokenTransferGenericFailure_error_identifier_ptr,\n    TokenTransferGenericFailure_error_length,\n    TokenTransferGenericFailure_error_selector,\n    TokenTransferGenericFailure_error_to_ptr,\n    TokenTransferGenericFailure_error_token_ptr,\n    TwoWords,\n    TwoWordsShift,\n    ZeroSlot\n} from ""seaport-types/src/lib/TokenTransferrerConstants.sol"";\n\nimport {\n    TokenTransferrerErrors\n} from ""seaport-types/src/interfaces/TokenTransferrerErrors.sol"";\n\nimport {\n    ConduitBatch1155Transfer\n} from ""seaport-types/src/conduit/lib/ConduitStructs.sol"";\n\n/**\n * @title TokenTransferrer\n * @author 0age\n * @custom:coauthor d1ll0n\n * @custom:coauthor transmissions11\n * @notice TokenTransferrer is a library for performing optimized ERC20, ERC721,\n *         ERC1155, and batch ERC1155 transfers, used by both Seaport as well as\n *         by conduits deployed by the ConduitController. Use great caution when\n *         considering these functions for use in other codebases, as there are\n *         significant side effects and edge cases that need to be thoroughly\n *         understood and carefully addressed.\n */\ncontract TokenTransferrer is TokenTransferrerErrors {\n    /**\n     * @dev Internal function to transfer ERC20 tokens from a given originator\n     *      to a given recipient. Sufficient approvals must be set on the\n     *      contract performing the transfer.\n     *\n     * @param token      The ERC20 token to transfer.\n     * @param from       The originator of the transfer.\n     * @param to         The recipient of the transfer.\n     * @param amount     The amount to transfer.\n     */\n    function _performERC20Transfer(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        // Utilize assembly to perform an optimized ERC20 token transfer.\n        assembly {\n            // The free memory pointer memory slot will be used when populating\n            // call data for the transfer; read the value and restore it later.\n            let memPointer := mload(FreeMemoryPointerSlot)\n\n            // Write call data into memory, starting with function selector.\n            mstore(ERC20_transferFrom_sig_ptr, ERC20_transferFrom_signature)\n            mstore(ERC20_transferFrom_from_ptr, from)\n            mstore(ERC20_transferFrom_to_ptr, to)\n            mstore(ERC20_transferFrom_amount_ptr, amount)\n\n            // Make call & copy up to 32 bytes of return data to scratch space.\n            // Scratch space does not need to be cleared ahead of time, as the\n            // subsequent check will ensure that either at least a full word of\n            // return data is received (in which case it will be overwritten) or\n            // that no data is received (in which case scratch space will be\n            // ignored) on a successful call to the given token.\n            let callStatus := call(\n                gas(),\n                token,\n                0,\n                ERC20_transferFrom_sig_ptr,\n                ERC20_transferFrom_length,\n                0,\n                OneWord\n            )\n\n            // Determine whether transfer was successful using status & result.\n            let success := and(\n                // Set success to whether the call reverted, if not check it\n                // either returned exactly 1 (can\'t just be non-zero data),\n                // or had no return data.\n                or(\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\n                    iszero(returndatasize())\n                ),\n                callStatus\n            )\n\n            // Handle cases where either the transfer failed or no data was\n            // returned. Group these, as most transfers will succeed with data.\n            // Equivalent to `or(iszero(success), iszero(returndatasize()))`\n            // but after it\'s inverted for JUMPI this expression is cheaper.\n            if iszero(and(success, iszero(iszero(returndatasize())))) {\n                // If the token has no code or the transfer failed: Equivalent\n                // to `or(iszero(success), iszero(extcodesize(token)))` but\n                // after it\'s inverted for JUMPI this expression is cheaper.\n                if iszero(and(iszero(iszero(extcodesize(token))), success)) {\n                    // If the transfer failed:\n                    if iszero(success) {\n                        // If it was due to a revert:\n                        if iszero(callStatus) {\n                            // If it returned a message, bubble it up as long as\n                            // sufficient gas remains to do so:\n                            if returndatasize() {\n                                // Ensure that sufficient gas is available to\n                                // copy returndata while expanding memory where\n                                // necessary. Start by computing the word size\n                                // of returndata and allocated memory. Round up\n                                // to the nearest full word.\n                                let returnDataWords := shr(\n                                    OneWordShift,\n                                    add(returndatasize(), ThirtyOneBytes)\n                                )\n\n                                // Note: use the free memory pointer in place of\n                                // msize() to work around a Yul warning that\n                                // prevents accessing msize directly when the IR\n                                // pipeline is activated.\n                                let msizeWords := shr(OneWordShift, memPointer)\n\n                                // Next, compute the cost of the returndatacopy.\n                                let cost := mul(CostPerWord, returnDataWords)\n\n                                // Then, compute cost of new memory allocation.\n                                if gt(returnDataWords, msizeWords) {\n                                    cost := add(\n                                        cost,\n                                        add(\n                                            mul(\n                                                sub(\n                                                    returnDataWords,\n                                                    msizeWords\n                                                ),\n                                                CostPerWord\n                                            ),\n                                            shr(\n                                                MemoryExpansionCoefficientShift,\n                                                sub(\n                                                    mul(\n                                                        returnDataWords,\n                                                        returnDataWords\n                                                    ),\n                                                    mul(msizeWords, msizeWords)\n                                                )\n                                            )\n                                        )\n                                    )\n                                }\n\n                                // Finally, add a small constant and compare to\n                                // gas remaining; bubble up the revert data if\n                                // enough gas is still available.\n                                if lt(add(cost, ExtraGasBuffer), gas()) {\n                                    // Copy returndata to memory; overwrite\n                                    // existing memory.\n                                    returndatacopy(0, 0, returndatasize())\n\n                                    // Revert, specifying memory region with\n                                    // copied returndata.\n                                    revert(0, returndatasize())\n                                }\n                            }\n\n                            // Store left-padded selector with push4, mem[28:32]\n                            mstore(\n                                0,\n                                TokenTransferGenericFailure_error_selector\n                            )\n                            mstore(\n                                TokenTransferGenericFailure_error_token_ptr,\n                                token\n                            )\n                            mstore(\n                                TokenTransferGenericFailure_error_from_ptr,\n                                from\n                            )\n                            mstore(TokenTransferGenericFailure_error_to_ptr, to)\n                            mstore(\n                                TokenTransferGenericFailure_err_identifier_ptr,\n                                0\n                            )\n                            mstore(\n                                TokenTransferGenericFailure_error_amount_ptr,\n                                amount\n                            )\n\n                            // revert(abi.encodeWithSignature(\n                            //     ""TokenTransferGenericFailure(\n                            //         address,address,address,uint256,uint256\n                            //     )"", token, from, to, identifier, amount\n                            // ))\n                            revert(\n                                Generic_error_selector_offset,\n                                TokenTransferGenericFailure_error_length\n                            )\n                        }\n\n                        // Otherwise revert with a message about the token\n                        // returning false or non-compliant return values.\n\n                        // Store left-padded selector with push4, mem[28:32]\n                        mstore(\n                            0,\n                            BadReturnValueFromERC20OnTransfer_error_selector\n                        )\n                        mstore(\n                            BadReturnValueFromERC20OnTransfer_error_token_ptr,\n                            token\n                        )\n                        mstore(\n                            BadReturnValueFromERC20OnTransfer_error_from_ptr,\n                            from\n                        )\n                        mstore(\n                            BadReturnValueFromERC20OnTransfer_error_to_ptr,\n                            to\n                        )\n                        mstore(\n                            BadReturnValueFromERC20OnTransfer_error_amount_ptr,\n                            amount\n                        )\n\n                        // revert(abi.encodeWithSignature(\n                        //     ""BadReturnValueFromERC20OnTransfer(\n                        //         address,address,address,uint256\n                        //     )"", token, from, to, amount\n                        // ))\n                        revert(\n                            Generic_error_selector_offset,\n                            BadReturnValueFromERC20OnTransfer_error_length\n                        )\n                    }\n\n                    // Otherwise, revert with error about token not having code:\n                    // Store left-padded selector with push4, mem[28:32]\n                    mstore(0, NoContract_error_selector)\n                    mstore(NoContract_error_account_ptr, token)\n\n                    // revert(abi.encodeWithSignature(\n                    //      ""NoContract(address)"", account\n                    // ))\n                    revert(\n                        Generic_error_selector_offset,\n                        NoContract_error_length\n                    )\n                }\n\n                // Otherwise, the token just returned no data despite the call\n                // having succeeded; no need to optimize for this as it\'s not\n                // technically ERC20 compliant.\n            }\n\n            // Restore the original free memory pointer.\n            mstore(FreeMemoryPointerSlot, memPointer)\n\n            // Restore the zero slot to zero.\n            mstore(ZeroSlot, 0)\n        }\n    }\n\n    /**\n     * @dev Internal function to transfer an ERC721 token from a given\n     *      originator to a given recipient. Sufficient approvals must be set on\n     *      the contract performing the transfer. Note that this function does\n     *      not check whether the receiver can accept the ERC721 token (i.e. it\n     *      does not use `safeTransferFrom`).\n     *\n     * @param token      The ERC721 token to transfer.\n     * @param from       The originator of the transfer.\n     * @param to         The recipient of the transfer.\n     * @param identifier The tokenId to transfer.\n     */\n    function _performERC721Transfer(\n        address token,\n        address from,\n        address to,\n        uint256 identifier\n    ) internal {\n        // Utilize assembly to perform an optimized ERC721 token transfer.\n        assembly {\n            // If the token has no code, revert.\n            if iszero(extcodesize(token)) {\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, NoContract_error_selector)\n                mstore(NoContract_error_account_ptr, token)\n\n                // revert(abi.encodeWithSignature(\n                //     ""NoContract(address)"", account\n                // ))\n                revert(Generic_error_selector_offset, NoContract_error_length)\n            }\n\n            // The free memory pointer memory slot will be used when populating\n            // call data for the transfer; read the value and restore it later.\n            let memPointer := mload(FreeMemoryPointerSlot)\n\n            // Write call data to memory starting with function selector.\n            mstore(ERC721_transferFrom_sig_ptr, ERC721_transferFrom_signature)\n            mstore(ERC721_transferFrom_from_ptr, from)\n            mstore(ERC721_transferFrom_to_ptr, to)\n            mstore(ERC721_transferFrom_id_ptr, identifier)\n\n            // Perform the call, ignoring return data.\n            let success := call(\n                gas(),\n                token,\n                0,\n                ERC721_transferFrom_sig_ptr,\n                ERC721_transferFrom_length,\n                0,\n                0\n            )\n\n            // If the transfer reverted:\n            if iszero(success) {\n                // If it returned a message, bubble it up as long as sufficient\n                // gas remains to do so:\n                if returndatasize() {\n                    // Ensure that sufficient gas is available to copy\n                    // returndata while expanding memory where necessary. Start\n                    // by computing word size of returndata & allocated memory.\n                    // Round up to the nearest full word.\n                    let returnDataWords := shr(\n                        OneWordShift,\n                        add(returndatasize(), ThirtyOneBytes)\n                    )\n\n                    // Note: use the free memory pointer in place of msize() to\n                    // work around a Yul warning that prevents accessing msize\n                    // directly when the IR pipeline is activated.\n                    let msizeWords := shr(OneWordShift, memPointer)\n\n                    // Next, compute the cost of the returndatacopy.\n                    let cost := mul(CostPerWord, returnDataWords)\n\n                    // Then, compute cost of new memory allocation.\n                    if gt(returnDataWords, msizeWords) {\n                        cost := add(\n                            cost,\n                            add(\n                                mul(\n                                    sub(returnDataWords, msizeWords),\n                                    CostPerWord\n                                ),\n                                shr(\n                                    MemoryExpansionCoefficientShift,\n                                    sub(\n                                        mul(returnDataWords, returnDataWords),\n                                        mul(msizeWords, msizeWords)\n                                    )\n                                )\n                            )\n                        )\n                    }\n\n                    // Finally, add a small constant and compare to gas\n                    // remaining; bubble up the revert data if enough gas is\n                    // still available.\n                    if lt(add(cost, ExtraGasBuffer), gas()) {\n                        // Copy returndata to memory; overwrite existing memory.\n                        returndatacopy(0, 0, returndatasize())\n\n                        // Revert, giving memory region with copied returndata.\n                        revert(0, returndatasize())\n                    }\n                }\n\n                // Otherwise revert with a generic error message.\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, TokenTransferGenericFailure_error_selector)\n                mstore(TokenTransferGenericFailure_error_token_ptr, token)\n                mstore(TokenTransferGenericFailure_error_from_ptr, from)\n                mstore(TokenTransferGenericFailure_error_to_ptr, to)\n                mstore(\n                    TokenTransferGenericFailure_error_identifier_ptr,\n                    identifier\n                )\n                mstore(TokenTransferGenericFailure_error_amount_ptr, 1)\n\n                // revert(abi.encodeWithSignature(\n                //     ""TokenTransferGenericFailure(\n                //         address,address,address,uint256,uint256\n                //     )"", token, from, to, identifier, amount\n                // ))\n                revert(\n                    Generic_error_selector_offset,\n                    TokenTransferGenericFailure_error_length\n                )\n            }\n\n            // Restore the original free memory pointer.\n            mstore(FreeMemoryPointerSlot, memPointer)\n\n            // Restore the zero slot to zero.\n            mstore(ZeroSlot, 0)\n        }\n    }\n\n    /**\n     * @dev Internal function to transfer ERC1155 tokens from a given\n     *      originator to a given recipient. Sufficient approvals must be set on\n     *      the contract performing the transfer and contract recipients must\n     *      implement the ERC1155TokenReceiver interface to indicate that they\n     *      are willing to accept the transfer.\n     *\n     * @param token      The ERC1155 token to transfer.\n     * @param from       The originator of the transfer.\n     * @param to         The recipient of the transfer.\n     * @param identifier The id to transfer.\n     * @param amount     The amount to transfer.\n     */\n    function _performERC1155Transfer(\n        address token,\n        address from,\n        address to,\n        uint256 identifier,\n        uint256 amount\n    ) internal {\n        // Utilize assembly to perform an optimized ERC1155 token transfer.\n        assembly {\n            // If the token has no code, revert.\n            if iszero(extcodesize(token)) {\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, NoContract_error_selector)\n                mstore(NoContract_error_account_ptr, token)\n\n                // revert(abi.encodeWithSignature(\n                //     ""NoContract(address)"", account\n                // ))\n                revert(Generic_error_selector_offset, NoContract_error_length)\n            }\n\n            // The following memory slots will be used when populating call data\n            // for the transfer; read the values and restore them later.\n            let memPointer := mload(FreeMemoryPointerSlot)\n            let slot0x80 := mload(Slot0x80)\n            let slot0xA0 := mload(Slot0xA0)\n            let slot0xC0 := mload(Slot0xC0)\n\n            // Write call data into memory, beginning with function selector.\n            mstore(\n                ERC1155_safeTransferFrom_sig_ptr,\n                ERC1155_safeTransferFrom_signature\n            )\n            mstore(ERC1155_safeTransferFrom_from_ptr, from)\n            mstore(ERC1155_safeTransferFrom_to_ptr, to)\n            mstore(ERC1155_safeTransferFrom_id_ptr, identifier)\n            mstore(ERC1155_safeTransferFrom_amount_ptr, amount)\n            mstore(\n                ERC1155_safeTransferFrom_data_offset_ptr,\n                ERC1155_safeTransferFrom_data_length_offset\n            )\n            mstore(ERC1155_safeTransferFrom_data_length_ptr, 0)\n\n            // Perform the call, ignoring return data.\n            let success := call(\n                gas(),\n                token,\n                0,\n                ERC1155_safeTransferFrom_sig_ptr,\n                ERC1155_safeTransferFrom_length,\n                0,\n                0\n            )\n\n            // If the transfer reverted:\n            if iszero(success) {\n                // If it returned a message, bubble it up as long as sufficient\n                // gas remains to do so:\n                if returndatasize() {\n                    // Ensure that sufficient gas is available to copy\n                    // returndata while expanding memory where necessary. Start\n                    // by computing word size of returndata & allocated memory.\n                    // Round up to the nearest full word.\n                    let returnDataWords := shr(\n                        OneWordShift,\n                        add(returndatasize(), ThirtyOneBytes)\n                    )\n\n                    // Note: use the free memory pointer in place of msize() to\n                    // work around a Yul warning that prevents accessing msize\n                    // directly when the IR pipeline is activated.\n                    let msizeWords := shr(OneWordShift, memPointer)\n\n                    // Next, compute the cost of the returndatacopy.\n                    let cost := mul(CostPerWord, returnDataWords)\n\n                    // Then, compute cost of new memory allocation.\n                    if gt(returnDataWords, msizeWords) {\n                        cost := add(\n                            cost,\n                            add(\n                                mul(\n                                    sub(returnDataWords, msizeWords),\n                                    CostPerWord\n                                ),\n                                shr(\n                                    MemoryExpansionCoefficientShift,\n                                    sub(\n                                        mul(returnDataWords, returnDataWords),\n                                        mul(msizeWords, msizeWords)\n                                    )\n                                )\n                            )\n                        )\n                    }\n\n                    // Finally, add a small constant and compare to gas\n                    // remaining; bubble up the revert data if enough gas is\n                    // still available.\n                    if lt(add(cost, ExtraGasBuffer), gas()) {\n                        // Copy returndata to memory; overwrite existing memory.\n                        returndatacopy(0, 0, returndatasize())\n\n                        // Revert, giving memory region with copied returndata.\n                        revert(0, returndatasize())\n                    }\n                }\n\n                // Otherwise revert with a generic error message.\n\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, TokenTransferGenericFailure_error_selector)\n                mstore(TokenTransferGenericFailure_error_token_ptr, token)\n                mstore(TokenTransferGenericFailure_error_from_ptr, from)\n                mstore(TokenTransferGenericFailure_error_to_ptr, to)\n                mstore(\n                    TokenTransferGenericFailure_error_identifier_ptr,\n                    identifier\n                )\n                mstore(TokenTransferGenericFailure_error_amount_ptr, amount)\n\n                // revert(abi.encodeWithSignature(\n                //     ""TokenTransferGenericFailure(\n                //         address,address,address,uint256,uint256\n                //     )"", token, from, to, identifier, amount\n                // ))\n                revert(\n                    Generic_error_selector_offset,\n                    TokenTransferGenericFailure_error_length\n                )\n            }\n\n            mstore(Slot0x80, slot0x80) // Restore slot 0x80.\n            mstore(Slot0xA0, slot0xA0) // Restore slot 0xA0.\n            mstore(Slot0xC0, slot0xC0) // Restore slot 0xC0.\n\n            // Restore the original free memory pointer.\n            mstore(FreeMemoryPointerSlot, memPointer)\n\n            // Restore the zero slot to zero.\n            mstore(ZeroSlot, 0)\n        }\n    }\n\n    /**\n     * @dev Internal function to transfer ERC1155 tokens from a given\n     *      originator to a given recipient. Sufficient approvals must be set on\n     *      the contract performing the transfer and contract recipients must\n     *      implement the ERC1155TokenReceiver interface to indicate that they\n     *      are willing to accept the transfer. NOTE: this function is not\n     *      memory-safe; it will overwrite existing memory, restore the free\n     *      memory pointer to the default value, and overwrite the zero slot.\n     *      This function should only be called once memory is no longer\n     *      required and when uninitialized arrays are not utilized, and memory\n     *      should be considered fully corrupted (aside from the existence of a\n     *      default-value free memory pointer) after calling this function.\n     *\n     * @param batchTransfers The group of 1155 batch transfers to perform.\n     */\n    function _performERC1155BatchTransfers(\n        ConduitBatch1155Transfer[] calldata batchTransfers\n    ) internal {\n        // Utilize assembly to perform optimized batch 1155 transfers.\n        assembly {\n            let len := batchTransfers.length\n            // Pointer to first head in the array, which is offset to the struct\n            // at each index. This gets incremented after each loop to avoid\n            // multiplying by 32 to get the offset for each element.\n            let nextElementHeadPtr := batchTransfers.offset\n\n            // Pointer to beginning of the head of the array. This is the\n            // reference position each offset references. It\'s held static to\n            // let each loop calculate the data position for an element.\n            let arrayHeadPtr := nextElementHeadPtr\n\n            // Write the function selector, which will be reused for each call:\n            // safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\n            mstore(\n                ConduitBatch1155Transfer_from_offset,\n                ERC1155_safeBatchTransferFrom_signature\n            )\n\n            // Iterate over each batch transfer.\n            for {\n                let i := 0\n            } lt(i, len) {\n                i := add(i, 1)\n            } {\n                // Read the offset to the beginning of the element and add\n                // it to pointer to the beginning of the array head to get\n                // the absolute position of the element in calldata.\n                let elementPtr := add(\n                    arrayHeadPtr,\n                    calldataload(nextElementHeadPtr)\n                )\n\n                // Retrieve the token from calldata.\n                let token := calldataload(elementPtr)\n\n                // If the token has no code, revert.\n                if iszero(extcodesize(token)) {\n                    // Store left-padded selector with push4, mem[28:32]\n                    mstore(0, NoContract_error_selector)\n                    mstore(NoContract_error_account_ptr, token)\n\n                    // revert(abi.encodeWithSignature(\n                    //     ""NoContract(address)"", account\n                    // ))\n                    revert(\n                        Generic_error_selector_offset,\n                        NoContract_error_length\n                    )\n                }\n\n                // Get the total number of supplied ids.\n                let idsLength := calldataload(\n                    add(elementPtr, ConduitBatch1155Transfer_ids_length_offset)\n                )\n\n                // Determine the expected offset for the amounts array.\n                let expectedAmountsOffset := add(\n                    ConduitBatch1155Transfer_amounts_length_baseOffset,\n                    shl(OneWordShift, idsLength)\n                )\n\n                // Validate struct encoding.\n                let invalidEncoding := iszero(\n                    and(\n                        // ids.length == amounts.length\n                        eq(\n                            idsLength,\n                            calldataload(add(elementPtr, expectedAmountsOffset))\n                        ),\n                        and(\n                            // ids_offset == 0xa0\n                            eq(\n                                calldataload(\n                                    add(\n                                        elementPtr,\n                                        ConduitBatch1155Transfer_ids_head_offset\n                                    )\n                                ),\n                                ConduitBatch1155Transfer_ids_length_offset\n                            ),\n                            // amounts_offset == 0xc0 + ids.length*32\n                            eq(\n                                calldataload(\n                                    add(\n                                        elementPtr,\n                                        ConduitBatchTransfer_amounts_head_offset\n                                    )\n                                ),\n                                expectedAmountsOffset\n                            )\n                        )\n                    )\n                )\n\n                // Revert with an error if the encoding is not valid.\n                if invalidEncoding {\n                    // Store left-padded selector with push4, mem[28:32]\n                    mstore(\n                        Invalid1155BatchTransferEncoding_ptr,\n                        Invalid1155BatchTransferEncoding_selector\n                    )\n\n                    // revert(abi.encodeWithSignature(\n                    //     ""Invalid1155BatchTransferEncoding()""\n                    // ))\n                    revert(\n                        Invalid1155BatchTransferEncoding_ptr,\n                        Invalid1155BatchTransferEncoding_length\n                    )\n                }\n\n                // Update the offset position for the next loop\n                nextElementHeadPtr := add(nextElementHeadPtr, OneWord)\n\n                // Copy the first section of calldata (before dynamic values).\n                calldatacopy(\n                    BatchTransfer1155Params_ptr,\n                    add(elementPtr, ConduitBatch1155Transfer_from_offset),\n                    ConduitBatch1155Transfer_usable_head_size\n                )\n\n                // Determine size of calldata required for ids and amounts. Note\n                // that the size includes both lengths as well as the data.\n                let idsAndAmountsSize := add(\n                    TwoWords,\n                    shl(TwoWordsShift, idsLength)\n                )\n\n                // Update the offset for the data array in memory.\n                mstore(\n                    BatchTransfer1155Params_data_head_ptr,\n                    add(\n                        BatchTransfer1155Params_ids_length_offset,\n                        idsAndAmountsSize\n                    )\n                )\n\n                // Set the length of the data array in memory to zero.\n                mstore(\n                    add(\n                        BatchTransfer1155Params_data_length_basePtr,\n                        idsAndAmountsSize\n                    ),\n                    0\n                )\n\n                // Determine the total calldata size for the call to transfer.\n                let transferDataSize := add(\n                    BatchTransfer1155Params_calldata_baseSize,\n                    idsAndAmountsSize\n                )\n\n                // Copy second section of calldata (including dynamic values).\n                calldatacopy(\n                    BatchTransfer1155Params_ids_length_ptr,\n                    add(elementPtr, ConduitBatch1155Transfer_ids_length_offset),\n                    idsAndAmountsSize\n                )\n\n                // Perform the call to transfer 1155 tokens.\n                let success := call(\n                    gas(),\n                    token,\n                    0,\n                    ConduitBatch1155Transfer_from_offset, // Data start.\n                    transferDataSize, // Location of the length of callData.\n                    0,\n                    0\n                )\n\n                // If the transfer reverted:\n                if iszero(success) {\n                    // If it returned a message, bubble it up as long as\n                    // sufficient gas remains to do so:\n                    if returndatasize() {\n                        // Ensure that sufficient gas is available to copy\n                        // returndata while expanding memory where necessary.\n                        // Start by computing word size of returndata and\n                        // allocated memory. Round up to the nearest full word.\n                        let returnDataWords := shr(\n                            OneWordShift,\n                            add(returndatasize(), ThirtyOneBytes)\n                        )\n\n                        // Note: use transferDataSize in place of msize() to\n                        // work around a Yul warning that prevents accessing\n                        // msize directly when the IR pipeline is activated.\n                        // The free memory pointer is not used here because\n                        // this function does almost all memory management\n                        // manually and does not update it, and transferDataSize\n                        // should be the largest memory value used (unless a\n                        // previous batch was larger).\n                        let msizeWords := shr(OneWordShift, transferDataSize)\n\n                        // Next, compute the cost of the returndatacopy.\n                        let cost := mul(CostPerWord, returnDataWords)\n\n                        // Then, compute cost of new memory allocation.\n                        if gt(returnDataWords, msizeWords) {\n                            cost := add(\n                                cost,\n                                add(\n                                    mul(\n                                        sub(returnDataWords, msizeWords),\n                                        CostPerWord\n                                    ),\n                                    shr(\n                                        MemoryExpansionCoefficientShift,\n                                        sub(\n                                            mul(\n                                                returnDataWords,\n                                                returnDataWords\n                                            ),\n                                            mul(msizeWords, msizeWords)\n                                        )\n                                    )\n                                )\n                            )\n                        }\n\n                        // Finally, add a small constant and compare to gas\n                        // remaining; bubble up the revert data if enough gas is\n                        // still available.\n                        if lt(add(cost, ExtraGasBuffer), gas()) {\n                            // Copy returndata to memory; overwrite existing.\n                            returndatacopy(0, 0, returndatasize())\n\n                            // Revert with memory region containing returndata.\n                            revert(0, returndatasize())\n                        }\n                    }\n\n                    // Set the error signature.\n                    mstore(\n                        0,\n                        ERC1155BatchTransferGenericFailure_error_signature\n                    )\n\n                    // Write the token.\n                    mstore(ERC1155BatchTransferGenericFailure_token_ptr, token)\n\n                    // Increase the offset to ids by 32.\n                    mstore(\n                        BatchTransfer1155Params_ids_head_ptr,\n                        ERC1155BatchTransferGenericFailure_ids_offset\n                    )\n\n                    // Increase the offset to amounts by 32.\n                    mstore(\n                        BatchTransfer1155Params_amounts_head_ptr,\n                        add(\n                            OneWord,\n                            mload(BatchTransfer1155Params_amounts_head_ptr)\n                        )\n                    )\n\n                    // Return modified region. The total size stays the same as\n                    // `token` uses the same number of bytes as `data.length`.\n                    revert(0, transferDataSize)\n                }\n            }\n\n            // Reset the free memory pointer to the default value; memory must\n            // be assumed to be dirtied and not reused from this point forward.\n            // Also note that the zero slot is not reset to zero, meaning empty\n            // arrays cannot be safely created or utilized until it is restored.\n            mstore(FreeMemoryPointerSlot, DefaultFreeMemoryPointer)\n        }\n    }\n}\n'}, 'lib/seaport-types/src/interfaces/ZoneInteractionErrors.sol': {'content': ""// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n * @title ZoneInteractionErrors\n * @author 0age\n * @notice ZoneInteractionErrors contains errors related to zone interaction.\n */\ninterface ZoneInteractionErrors {\n    /**\n     * @dev Revert with an error when attempting to fill an order that specifies\n     *      a restricted submitter as its order type when not submitted by\n     *      either the offerer or the order's zone or approved as valid by the\n     *      zone in question via a call to `isValidOrder`.\n     *\n     * @param orderHash The order hash for the invalid restricted order.\n     */\n    error InvalidRestrictedOrder(bytes32 orderHash);\n\n    /**\n     * @dev Revert with an error when attempting to fill a contract order that\n     *      fails to generate an order successfully, that does not adhere to the\n     *      requirements for minimum spent or maximum received supplied by the\n     *      fulfiller, or that fails the post-execution `ratifyOrder` check..\n     *\n     * @param orderHash The order hash for the invalid contract order.\n     */\n    error InvalidContractOrder(bytes32 orderHash);\n}\n""}, 'src/lib/LowLevelHelpers.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {\n    CostPerWord,\n    ExtraGasBuffer,\n    FreeMemoryPointerSlot,\n    MemoryExpansionCoefficientShift,\n    OneWord,\n    OneWordShift,\n    ThirtyOneBytes\n} from ""seaport-types/src/lib/ConsiderationConstants.sol"";\n\nimport {\n    MemoryPointer,\n    MemoryPointerLib\n} from ""seaport-types/src/helpers/PointerLibraries.sol"";\n\nimport {\n    AdvancedOrder,\n    Execution\n} from ""seaport-types/src/lib/ConsiderationStructs.sol"";\n\n/**\n * @title LowLevelHelpers\n * @author 0age\n * @notice LowLevelHelpers contains logic for performing various low-level\n *         operations.\n */\ncontract LowLevelHelpers {\n    /**\n     * @dev Internal view function to revert and pass along the revert reason if\n     *      data was returned by the last call and that the size of that data\n     *      does not exceed the currently allocated memory size.\n     */\n    function _revertWithReasonIfOneIsReturned() internal view {\n        assembly {\n            // If it returned a message, bubble it up as long as sufficient gas\n            // remains to do so:\n            if returndatasize() {\n                // Ensure that sufficient gas is available to copy returndata\n                // while expanding memory where necessary. Start by computing\n                // the word size of returndata and allocated memory.\n                let returnDataWords := shr(\n                    OneWordShift,\n                    add(returndatasize(), ThirtyOneBytes)\n                )\n\n                // Note: use the free memory pointer in place of msize() to work\n                // around a Yul warning that prevents accessing msize directly\n                // when the IR pipeline is activated.\n                let msizeWords := shr(\n                    OneWordShift,\n                    mload(FreeMemoryPointerSlot)\n                )\n\n                // Next, compute the cost of the returndatacopy.\n                let cost := mul(CostPerWord, returnDataWords)\n\n                // Then, compute cost of new memory allocation.\n                if gt(returnDataWords, msizeWords) {\n                    cost := add(\n                        cost,\n                        add(\n                            mul(sub(returnDataWords, msizeWords), CostPerWord),\n                            shr(\n                                MemoryExpansionCoefficientShift,\n                                sub(\n                                    mul(returnDataWords, returnDataWords),\n                                    mul(msizeWords, msizeWords)\n                                )\n                            )\n                        )\n                    )\n                }\n\n                // Finally, add a small constant and compare to gas remaining;\n                // bubble up the revert data if enough gas is still available.\n                if lt(add(cost, ExtraGasBuffer), gas()) {\n                    // Copy returndata to memory; overwrite existing memory.\n                    returndatacopy(0, 0, returndatasize())\n\n                    // Revert, specifying memory region with copied returndata.\n                    revert(0, returndatasize())\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Internal view function to branchlessly select either the caller (if\n     *      a supplied recipient is equal to zero) or the supplied recipient (if\n     *      that recipient is a nonzero value).\n     *\n     * @param recipient The supplied recipient.\n     *\n     * @return updatedRecipient The updated recipient.\n     */\n    function _substituteCallerForEmptyRecipient(\n        address recipient\n    ) internal view returns (address updatedRecipient) {\n        // Utilize assembly to perform a branchless operation on the recipient.\n        assembly {\n            // Add caller to recipient if recipient equals 0; otherwise add 0.\n            updatedRecipient := add(recipient, mul(iszero(recipient), caller()))\n        }\n    }\n\n    /**\n     * @dev Internal pure function to cast a `bool` value to a `uint256` value.\n     *\n     * @param b The `bool` value to cast.\n     *\n     * @return u The `uint256` value.\n     */\n    function _cast(bool b) internal pure returns (uint256 u) {\n        assembly {\n            u := b\n        }\n    }\n\n    /**\n     * @dev Internal pure function to cast the `pptrOffset` function from\n     *      `MemoryPointerLib` to a function that takes a memory array of\n     *      `AdvancedOrder` and an offset in memory and returns the\n     *      `AdvancedOrder` whose pointer is stored at that offset from the\n     *      array length.\n     */\n    function _getReadAdvancedOrderByOffset()\n        internal\n        pure\n        returns (\n            function(AdvancedOrder[] memory, uint256)\n                internal\n                pure\n                returns (AdvancedOrder memory) fn2\n        )\n    {\n        function(MemoryPointer, uint256)\n            internal\n            pure\n            returns (MemoryPointer) fn1 = MemoryPointerLib.pptrOffset;\n\n        assembly {\n            fn2 := fn1\n        }\n    }\n\n    /**\n     * @dev Internal pure function to cast the `pptrOffset` function from\n     *      `MemoryPointerLib` to a function that takes a memory array of\n     *      `Execution` and an offset in memory and returns the\n     *      `Execution` whose pointer is stored at that offset from the\n     *      array length.\n     */\n    function _getReadExecutionByOffset()\n        internal\n        pure\n        returns (\n            function(Execution[] memory, uint256)\n                internal\n                pure\n                returns (Execution memory) fn2\n        )\n    {\n        function(MemoryPointer, uint256)\n            internal\n            pure\n            returns (MemoryPointer) fn1 = MemoryPointerLib.pptrOffset;\n\n        assembly {\n            fn2 := fn1\n        }\n    }\n\n    /**\n     * @dev Internal pure function to return a `true` value that solc\n     *      will not recognize as a compile time constant.\n     *\n     *      This function is used to bypass function specialization for\n     *      functions which take a constant boolean as an input parameter.\n     *\n     *      This should only be used in cases where specialization has a\n     *      negligible impact on the gas cost of the function.\n     *\n     *      Note: assumes the calldatasize is non-zero.\n     */\n    function _runTimeConstantTrue() internal pure returns (bool) {\n        return msg.data.length > 0;\n    }\n\n    /**\n     * @dev Internal pure function to return a `false` value that solc\n     *      will not recognize as a compile time constant.\n     *\n     *      This function is used to bypass function specialization for\n     *      functions which take a constant boolean as an input parameter.\n     *\n     *      This should only be used in cases where specialization has a\n     *      negligible impact on the gas cost of the function.\n     *\n     *      Note: assumes the calldatasize is non-zero.\n     */\n    function _runTimeConstantFalse() internal pure returns (bool) {\n        return msg.data.length == 0;\n    }\n}\n'}, 'src/lib/ConsiderationEncoder.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {\n    authorizeOrder_calldata_baseOffset,\n    authorizeOrder_head_offset,\n    authorizeOrder_selector_offset,\n    authorizeOrder_selector,\n    authorizeOrder_zoneParameters_offset,\n    BasicOrder_addlRecipients_length_cdPtr,\n    BasicOrder_common_params_size,\n    BasicOrder_consideration_offset_from_offer,\n    BasicOrder_offerer_cdPtr,\n    BasicOrder_startTime_cdPtr,\n    BasicOrder_startTimeThroughZoneHash_size,\n    BasicOrder_totalOriginalAdditionalRecipients_cdPtr,\n    Common_amount_offset,\n    Common_identifier_offset,\n    Common_token_offset,\n    generateOrder_base_tail_offset,\n    generateOrder_context_head_offset,\n    generateOrder_head_offset,\n    generateOrder_maximumSpent_head_offset,\n    generateOrder_minimumReceived_head_offset,\n    generateOrder_selector_offset,\n    generateOrder_selector,\n    OneWord,\n    OneWordShift,\n    OnlyFullWordMask,\n    OrderFulfilled_baseDataSize,\n    OrderFulfilled_offer_length_baseOffset,\n    OrderParameters_consideration_head_offset,\n    OrderParameters_endTime_offset,\n    OrderParameters_offer_head_offset,\n    OrderParameters_startTime_offset,\n    OrderParameters_zoneHash_offset,\n    ratifyOrder_base_tail_offset,\n    ratifyOrder_consideration_head_offset,\n    ratifyOrder_context_head_offset,\n    ratifyOrder_contractNonce_offset,\n    ratifyOrder_head_offset,\n    ratifyOrder_orderHashes_head_offset,\n    ratifyOrder_selector_offset,\n    ratifyOrder_selector,\n    ReceivedItem_size,\n    Selector_length,\n    SixtyThreeBytes,\n    SpentItem_size_shift,\n    SpentItem_size,\n    validateOrder_selector,\n    validateOrder_selector_offset,\n    ZoneParameters_base_tail_offset,\n    ZoneParameters_basicOrderFixedElements_length,\n    ZoneParameters_consideration_head_offset,\n    ZoneParameters_endTime_offset,\n    ZoneParameters_extraData_head_offset,\n    ZoneParameters_fulfiller_offset,\n    ZoneParameters_offer_head_offset,\n    ZoneParameters_offerer_offset,\n    ZoneParameters_orderHashes_head_offset,\n    ZoneParameters_selectorAndPointer_length,\n    ZoneParameters_startTime_offset,\n    ZoneParameters_zoneHash_offset\n} from ""seaport-types/src/lib/ConsiderationConstants.sol"";\n\nimport {\n    BasicOrderParameters,\n    OrderParameters\n} from ""seaport-types/src/lib/ConsiderationStructs.sol"";\n\nimport {\n    CalldataPointer,\n    getFreeMemoryPointer,\n    setFreeMemoryPointer,\n    MemoryPointer,\n    OffsetOrLengthMask\n} from ""seaport-types/src/helpers/PointerLibraries.sol"";\n\ncontract ConsiderationEncoder {\n    /**\n     * @dev Takes a bytes array and casts it to a memory pointer.\n     *\n     * @param obj A bytes array in memory.\n     *\n     * @return ptr A memory pointer to the start of the bytes array in memory.\n     */\n    function toMemoryPointer(\n        bytes memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Takes an array of bytes32 types and casts it to a memory pointer.\n     *\n     * @param obj An array of bytes32 types in memory.\n     *\n     * @return ptr A memory pointer to the start of the array of bytes32 types\n     *             in memory.\n     */\n    function toMemoryPointer(\n        bytes32[] memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Takes a bytes array in memory and copies it to a new location in\n     *      memory.\n     *\n     * @param src A memory pointer referencing the bytes array to be copied (and\n     *            pointing to the length of the bytes array).\n     * @param src A memory pointer referencing the location in memory to copy\n     *            the bytes array to (and pointing to the length of the copied\n     *            bytes array).\n     *\n     * @return size The size of the bytes array.\n     */\n    function _encodeBytes(\n        MemoryPointer src,\n        MemoryPointer dst\n    ) internal view returns (uint256 size) {\n        unchecked {\n            // Mask the length of the bytes array to protect against overflow\n            // and round up to the nearest word.\n            // Note: `size` also includes the 1 word that stores the length.\n            size = (src.readUint256() + SixtyThreeBytes) & OnlyFullWordMask;\n\n            // Copy the bytes array to the new memory location.\n            src.copy(dst, size);\n        }\n    }\n\n    /**\n     * @dev Takes an OrderParameters struct and a context bytes array in memory\n     *      and encodes it as `generateOrder` calldata.\n     *\n     * @param orderParameters The OrderParameters struct used to construct the\n     *                        encoded `generateOrder` calldata.\n     * @param context         The context bytes array used to construct the\n     *                        encoded `generateOrder` calldata.\n     *\n     * @return dst  A memory pointer referencing the encoded `generateOrder`\n     *              calldata.\n     * @return size The size of the bytes array.\n     */\n    function _encodeGenerateOrder(\n        OrderParameters memory orderParameters,\n        bytes memory context\n    ) internal view returns (MemoryPointer dst, uint256 size) {\n        // Get the memory pointer for the OrderParameters struct.\n        MemoryPointer src = orderParameters.toMemoryPointer();\n\n        // Get free memory pointer to write calldata to.\n        dst = getFreeMemoryPointer();\n\n        // Write generateOrder selector and get pointer to start of calldata.\n        dst.write(generateOrder_selector);\n        dst = dst.offset(generateOrder_selector_offset);\n\n        // Get pointer to the beginning of the encoded data.\n        MemoryPointer dstHead = dst.offset(generateOrder_head_offset);\n\n        // Write `fulfiller` to calldata.\n        dstHead.write(msg.sender);\n\n        // Initialize tail offset, used to populate the minimumReceived array.\n        uint256 tailOffset = generateOrder_base_tail_offset;\n\n        // Write offset to minimumReceived.\n        dstHead.offset(generateOrder_minimumReceived_head_offset).write(\n            tailOffset\n        );\n\n        // Get memory pointer to `orderParameters.offer.length`.\n        MemoryPointer srcOfferPointer = src\n            .offset(OrderParameters_offer_head_offset)\n            .readMemoryPointer();\n\n        // Encode the offer array as a `SpentItem[]`.\n        uint256 minimumReceivedSize = _encodeSpentItems(\n            srcOfferPointer,\n            dstHead.offset(tailOffset)\n        );\n\n        unchecked {\n            // Increment tail offset, now used to populate maximumSpent array.\n            tailOffset += minimumReceivedSize;\n        }\n\n        // Write offset to maximumSpent.\n        dstHead.offset(generateOrder_maximumSpent_head_offset).write(\n            tailOffset\n        );\n\n        // Get memory pointer to `orderParameters.consideration.length`.\n        MemoryPointer srcConsiderationPointer = src\n            .offset(OrderParameters_consideration_head_offset)\n            .readMemoryPointer();\n\n        // Encode the consideration array as a `SpentItem[]`.\n        uint256 maximumSpentSize = _encodeSpentItems(\n            srcConsiderationPointer,\n            dstHead.offset(tailOffset)\n        );\n\n        unchecked {\n            // Increment tail offset, now used to populate context array.\n            tailOffset += maximumSpentSize;\n        }\n\n        // Write offset to context.\n        dstHead.offset(generateOrder_context_head_offset).write(tailOffset);\n\n        // Get memory pointer to context.\n        MemoryPointer srcContext = toMemoryPointer(context);\n\n        // Encode context as a bytes array.\n        uint256 contextSize = _encodeBytes(\n            srcContext,\n            dstHead.offset(tailOffset)\n        );\n\n        unchecked {\n            // Increment the tail offset, now used to determine final size.\n            tailOffset += contextSize;\n\n            // Derive the final size by including the selector.\n            size = Selector_length + tailOffset;\n        }\n    }\n\n    /**\n     * @dev Takes an order hash (e.g. offerer shifted 96 bits to the left XOR\'d\n     *      with the contract nonce in the case of contract orders), an\n     *      OrderParameters struct, context bytes array, and an array of order\n     *      hashes for each order included as part of the current fulfillment\n     *      and encodes it as `ratifyOrder` calldata.\n     *\n     * @param orderHash       The order hash (e.g. shl(0x60, offerer) ^ nonce).\n     * @param orderParameters The OrderParameters struct used to construct the\n     *                        encoded `ratifyOrder` calldata.\n     * @param context         The context bytes array used to construct the\n     *                        encoded `ratifyOrder` calldata.\n     * @param orderHashes     An array of bytes32 values representing the order\n     *                        hashes of all orders included as part of the\n     *                        current fulfillment.\n     * @param shiftedOfferer  The offerer for the order, shifted 96 bits to the\n     *                        left.\n     *\n     * @return dst  A memory pointer referencing the encoded `ratifyOrder`\n     *              calldata.\n     * @return size The size of the bytes array.\n     */\n    function _encodeRatifyOrder(\n        bytes32 orderHash, // e.g. shl(0x60, offerer) ^ contract nonce\n        OrderParameters memory orderParameters,\n        bytes memory context, // encoded based on the schemaID\n        bytes32[] memory orderHashes,\n        uint256 shiftedOfferer\n    ) internal view returns (MemoryPointer dst, uint256 size) {\n        // Get free memory pointer to write calldata to. This isn\'t allocated as\n        // it is only used for a single function call.\n        dst = getFreeMemoryPointer();\n\n        // Write ratifyOrder selector and get pointer to start of calldata.\n        dst.write(ratifyOrder_selector);\n        dst = dst.offset(ratifyOrder_selector_offset);\n\n        // Get pointer to the beginning of the encoded data.\n        MemoryPointer dstHead = dst.offset(ratifyOrder_head_offset);\n\n        // Write contractNonce to calldata via xor(orderHash, shiftedOfferer).\n        dstHead.offset(ratifyOrder_contractNonce_offset).write(\n            uint256(orderHash) ^ shiftedOfferer\n        );\n\n        // Initialize tail offset, used to populate the offer array.\n        uint256 tailOffset = ratifyOrder_base_tail_offset;\n        MemoryPointer src = orderParameters.toMemoryPointer();\n\n        // Write offset to `offer`.\n        dstHead.write(tailOffset);\n\n        // Get memory pointer to `orderParameters.offer.length`.\n        MemoryPointer srcOfferPointer = src\n            .offset(OrderParameters_offer_head_offset)\n            .readMemoryPointer();\n\n        // Encode the offer array as a `SpentItem[]`.\n        uint256 offerSize = _encodeSpentItems(\n            srcOfferPointer,\n            dstHead.offset(tailOffset)\n        );\n\n        unchecked {\n            // Increment tail offset, now used to populate consideration array.\n            tailOffset += offerSize;\n        }\n\n        // Write offset to consideration.\n        dstHead.offset(ratifyOrder_consideration_head_offset).write(tailOffset);\n\n        // Get pointer to `orderParameters.consideration.length`.\n        MemoryPointer srcConsiderationPointer = src\n            .offset(OrderParameters_consideration_head_offset)\n            .readMemoryPointer();\n\n        // Encode the consideration array as a `ReceivedItem[]`.\n        uint256 considerationSize = _encodeConsiderationAsReceivedItems(\n            srcConsiderationPointer,\n            dstHead.offset(tailOffset)\n        );\n\n        unchecked {\n            // Increment tail offset, now used to populate context array.\n            tailOffset += considerationSize;\n        }\n\n        // Write offset to context.\n        dstHead.offset(ratifyOrder_context_head_offset).write(tailOffset);\n\n        // Encode context.\n        uint256 contextSize = _encodeBytes(\n            toMemoryPointer(context),\n            dstHead.offset(tailOffset)\n        );\n\n        unchecked {\n            // Increment tail offset, now used to populate orderHashes array.\n            tailOffset += contextSize;\n        }\n\n        // Write offset to orderHashes.\n        dstHead.offset(ratifyOrder_orderHashes_head_offset).write(tailOffset);\n\n        // Encode orderHashes.\n        uint256 orderHashesSize = _encodeOrderHashes(\n            toMemoryPointer(orderHashes),\n            dstHead.offset(tailOffset)\n        );\n\n        unchecked {\n            // Increment the tail offset, now used to determine final size.\n            tailOffset += orderHashesSize;\n\n            // Derive the final size by including the selector.\n            size = Selector_length + tailOffset;\n        }\n    }\n\n    /**\n     * @dev Takes an order hash, OrderParameters struct, extraData bytes array,\n     *      and array of order hashes for each order included as part of the\n     *      current fulfillment and encodes it as `authorizeOrder` calldata.\n     *      Note that future, new versions of this contract may end up writing\n     *      to a memory region that might have been potentially dirtied by the\n     *      accumulator. Since the book-keeping for the accumulator does not\n     *      update the free memory pointer, it will be necessary to ensure that\n     *      all bytes in the memory in the range [dst, dst+size) are fully\n     *      updated/written to in this function.\n     *\n     * @param orderHash       The order hash.\n     * @param orderParameters The OrderParameters struct used to construct the\n     *                        encoded `authorizeOrder` calldata.\n     * @param extraData       The extraData bytes array used to construct the\n     *                        encoded `authorizeOrder` calldata.\n     * @param orderHashes     An array of bytes32 values representing the order\n     *                        hashes of all available orders validated thus far\n     *                        as part of current fulfillment.\n     *                        Note that this differs from the orderHashes array\n     *                        passed to `validateOrder` in that the latter\n     *                        includes *all* available and validated orders\n     *                        in the final fulfillment, as it is only a subset\n     *                        of the final fulfilled orderHashes.\n     *\n     * @return dst  A memory pointer referencing the encoded `authorizeOrder`\n     *              calldata.\n     * @return size The size of the bytes array.\n     */\n    function _encodeAuthorizeOrder(\n        bytes32 orderHash,\n        OrderParameters memory orderParameters,\n        bytes memory extraData,\n        bytes32[] memory orderHashes,\n        uint256 orderIndex\n    ) internal view returns (MemoryPointer dst, uint256 size) {\n        // Get free memory pointer to write calldata to.\n        MemoryPointer ptr = getFreeMemoryPointer();\n\n        dst = ptr;\n\n        // Write authorizeOrder selector and get pointer to start of calldata.\n        dst.write(authorizeOrder_selector);\n        dst = dst.offset(authorizeOrder_selector_offset);\n\n        // Get pointer to the beginning of the encoded data.\n        MemoryPointer dstHead = dst.offset(authorizeOrder_head_offset);\n\n        // Write offset to zoneParameters to start of calldata.\n        dstHead.write(authorizeOrder_zoneParameters_offset);\n\n        // Reuse `dstHead` as pointer to zoneParameters.\n        dstHead = dstHead.offset(authorizeOrder_zoneParameters_offset);\n\n        // Write orderHash and fulfiller to zoneParameters.\n        dstHead.writeBytes32(orderHash);\n        dstHead.offset(ZoneParameters_fulfiller_offset).write(msg.sender);\n\n        // Get the memory pointer to the order parameters struct.\n        MemoryPointer src = orderParameters.toMemoryPointer();\n\n        // Copy offerer, startTime, endTime and zoneHash to zoneParameters.\n        dstHead.offset(ZoneParameters_offerer_offset).write(src.readUint256());\n        dstHead.offset(ZoneParameters_startTime_offset).write(\n            src.offset(OrderParameters_startTime_offset).readUint256()\n        );\n        dstHead.offset(ZoneParameters_endTime_offset).write(\n            src.offset(OrderParameters_endTime_offset).readUint256()\n        );\n        dstHead.offset(ZoneParameters_zoneHash_offset).write(\n            src.offset(OrderParameters_zoneHash_offset).readUint256()\n        );\n\n        // Initialize tail offset, used to populate the offer array.\n        uint256 tailOffset = ZoneParameters_base_tail_offset;\n\n        // Write offset to `offer`.\n        dstHead.offset(ZoneParameters_offer_head_offset).write(tailOffset);\n\n        // Get pointer to `orderParameters.offer.length`.\n        MemoryPointer srcOfferPointer = src\n            .offset(OrderParameters_offer_head_offset)\n            .readMemoryPointer();\n\n        // Encode the offer array as a `SpentItem[]`.\n        uint256 offerSize = _encodeSpentItems(\n            srcOfferPointer,\n            dstHead.offset(tailOffset)\n        );\n\n        unchecked {\n            // Increment tail offset, now used to populate consideration array.\n            tailOffset += offerSize;\n        }\n\n        // Write offset to consideration.\n        dstHead.offset(ZoneParameters_consideration_head_offset).write(\n            tailOffset\n        );\n\n        // Get pointer to `orderParameters.consideration.length`.\n        MemoryPointer srcConsiderationPointer = src\n            .offset(OrderParameters_consideration_head_offset)\n            .readMemoryPointer();\n\n        // Encode the consideration array as a `ReceivedItem[]`.\n        uint256 considerationSize = _encodeConsiderationAsReceivedItems(\n            srcConsiderationPointer,\n            dstHead.offset(tailOffset)\n        );\n\n        unchecked {\n            // Increment tail offset, now used to populate extraData array.\n            tailOffset += considerationSize;\n        }\n\n        // Write offset to extraData.\n        dstHead.offset(ZoneParameters_extraData_head_offset).write(tailOffset);\n\n        unchecked {\n            // Copy extraData.\n            uint256 extraDataSize = _encodeBytes(\n                toMemoryPointer(extraData),\n                dstHead.offset(tailOffset)\n            );\n\n            // Increment tail offset, now used to populate orderHashes array.\n            tailOffset += extraDataSize;\n        }\n\n        // Write offset to orderHashes.\n        dstHead.offset(ZoneParameters_orderHashes_head_offset).write(\n            tailOffset\n        );\n\n        // Encode the order hashes array.\n        MemoryPointer orderHashesLengthLocation = dstHead.offset(tailOffset);\n\n        unchecked {\n            uint256 orderHashesSize = _encodeOrderHashes(\n                toMemoryPointer(orderHashes),\n                orderHashesLengthLocation\n            );\n\n            // Increment the tail offset, now used to determine final size.\n            tailOffset += orderHashesSize;\n\n            // Derive final size including selector and ZoneParameters pointer.\n            size = ZoneParameters_selectorAndPointer_length + tailOffset;\n        }\n\n        // Update the free memory pointer.\n        setFreeMemoryPointer(dst.offset(size));\n\n        // Track the pointer, size (when performing validateOrder) and pointer\n        // to orderHashes length by overriding the salt value on the order.\n        orderParameters.salt = ((MemoryPointer.unwrap(ptr) << 128) |\n            (size << 64) |\n            MemoryPointer.unwrap(orderHashesLengthLocation));\n\n        // Write the shortened orderHashes array length.\n        orderHashesLengthLocation.write(orderIndex);\n\n        // Modify encoding size to account for the shorter orderHashes array.\n        size -= (orderHashes.length - orderIndex) << OneWordShift;\n    }\n\n    /**\n     * @dev Takes an order hash, OrderParameters struct, extraData bytes array,\n     *      and array of order hashes for each order included as part of the\n     *      current fulfillment and encodes it as `validateOrder` calldata.\n     *      Note that future, new versions of this contract may end up writing\n     *      to a memory region that might have been potentially dirtied by the\n     *      accumulator. Since the book-keeping for the accumulator does not\n     *      update the free memory pointer, it will be necessary to ensure that\n     *      all bytes in the memory in the range [dst, dst+size) are fully\n     *      updated/written to in this function.\n     *\n     * @param salt            The salt on the order, which has been repurposed\n     *                        to contain relevant pointers and encoding size.\n     * @param orderHashes     An array of bytes32 values representing the order\n     *                        hashes of all orders included as part of the\n     *                        current fulfillment.\n     *\n     * @return dst  A memory pointer referencing the encoded `validateOrder`\n     *              calldata.\n     * @return size The size of the bytes array.\n     */\n    function _encodeValidateOrder(\n        uint256 salt,\n        bytes32[] memory orderHashes\n    ) internal view returns (MemoryPointer dst, uint256 size) {\n        dst = MemoryPointer.wrap(salt >> 128);\n        size = (salt >> 64) & OffsetOrLengthMask;\n        MemoryPointer orderHashesLengthLocation = MemoryPointer.wrap(\n            salt & OffsetOrLengthMask\n        );\n\n        // Write validateOrder selector.\n        dst.write(validateOrder_selector);\n\n        dst = dst.offset(validateOrder_selector_offset);\n\n        // Encode the order hashes array. Note that this currently modifies\n        // order hashes that are known to be properly encoded already and could\n        // therefore be skipped.\n        _encodeOrderHashes(\n            toMemoryPointer(orderHashes),\n            orderHashesLengthLocation\n        );\n    }\n\n    /**\n     * @dev Takes an order hash and BasicOrderParameters struct (from calldata)\n     *      and encodes it as `authorizeOrder` calldata. Note that memory data\n     *      is reused from `OrderFulfilled` event data, and the rest of the\n     *      calldata is prefixed and postfixed to this memory region. Note that\n     *      the memory region before the spent and received items on the\n     *      `OrderFulfilled` event are overwritten, which implies that this\n     *      function will need to be modified should the layout of that event\n     *      data change in the future.\n     *\n     * @param orderHash  The order hash.\n     *\n     * @return ptr  A memory pointer referencing the encoded `authorizeOrder`\n     *              calldata with extra padding at the start to word align.\n     * @return size The size of the bytes array.\n     */\n    function _encodeAuthorizeBasicOrder(\n        bytes32 orderHash\n    )\n        internal\n        view\n        returns (\n            MemoryPointer ptr,\n            uint256 size,\n            uint256 memoryLocationForOrderHashes\n        )\n    {\n        unchecked {\n            // Derive offset to pre `OrderFulfilled`\'s spent item event data\n            // using base offset & total original recipients.\n            ptr = MemoryPointer.wrap(\n                authorizeOrder_calldata_baseOffset +\n                    (CalldataPointer\n                        .wrap(\n                            BasicOrder_totalOriginalAdditionalRecipients_cdPtr\n                        )\n                        .readUint256() << OneWordShift)\n            );\n        }\n\n        MemoryPointer dst = ptr;\n\n        // Write authorizeOrder selector and get pointer to start of calldata.\n        dst.write(authorizeOrder_selector);\n        dst = dst.offset(authorizeOrder_selector_offset);\n\n        // Get pointer to the beginning of the encoded data.\n        MemoryPointer dstHead = dst.offset(authorizeOrder_head_offset);\n\n        // Write offset to zoneParameters to start of calldata.\n        dstHead.write(authorizeOrder_zoneParameters_offset);\n\n        // Reuse `dstHead` as pointer to zoneParameters.\n        dstHead = dstHead.offset(authorizeOrder_zoneParameters_offset);\n\n        // Write offerer, orderHash and fulfiller to zoneParameters.\n        dstHead.writeBytes32(orderHash);\n        dstHead.offset(ZoneParameters_fulfiller_offset).write(msg.sender);\n        dstHead.offset(ZoneParameters_offerer_offset).write(\n            CalldataPointer.wrap(BasicOrder_offerer_cdPtr).readAddress()\n        );\n\n        // Copy startTime, endTime and zoneHash to zoneParameters.\n        CalldataPointer.wrap(BasicOrder_startTime_cdPtr).copy(\n            dstHead.offset(ZoneParameters_startTime_offset),\n            BasicOrder_startTimeThroughZoneHash_size\n        );\n\n        // Initialize tail offset, used for the offer + consideration arrays.\n        uint256 tailOffset = ZoneParameters_base_tail_offset;\n\n        // Write offset to offer from event data into target calldata.\n        dstHead.offset(ZoneParameters_offer_head_offset).write(tailOffset);\n\n        unchecked {\n            // Write consideration offset next (located 5 words after offer).\n            dstHead.offset(ZoneParameters_consideration_head_offset).write(\n                tailOffset + BasicOrder_consideration_offset_from_offer\n            );\n\n            // Retrieve the length of additional recipients.\n            uint256 additionalRecipientsLength = CalldataPointer\n                .wrap(BasicOrder_addlRecipients_length_cdPtr)\n                .readUint256();\n\n            // Derive size of offer and consideration data.\n            // 2 words (lengths) + 4 (offer data) + 5 (consideration 1) + 5 * ar\n            uint256 offerAndConsiderationSize = OrderFulfilled_baseDataSize +\n                (additionalRecipientsLength * ReceivedItem_size);\n\n            // Increment tail offset, now used to populate extraData array.\n            tailOffset += offerAndConsiderationSize;\n        }\n\n        // Write empty bytes for extraData.\n        dstHead.offset(ZoneParameters_extraData_head_offset).write(tailOffset);\n        dstHead.offset(tailOffset).write(0);\n\n        unchecked {\n            // Increment tail offset, now used to populate orderHashes array.\n            tailOffset += OneWord;\n        }\n\n        // Write offset to orderHashes.\n        dstHead.offset(ZoneParameters_orderHashes_head_offset).write(\n            tailOffset\n        );\n\n        memoryLocationForOrderHashes = MemoryPointer.unwrap(\n            dstHead.offset(tailOffset)\n        );\n\n        // Write length = 0 to the orderHashes array.\n        dstHead.offset(tailOffset).write(0);\n\n        unchecked {\n            // Write the single order hash to the orderHashes array.\n            dstHead.offset(tailOffset + OneWord).writeBytes32(orderHash);\n\n            // Final size: selector, ZoneParameters pointer, orderHashes & tail.\n            size = ZoneParameters_basicOrderFixedElements_length + tailOffset;\n        }\n    }\n\n    /**\n     * @dev Takes pointers to already-encoded data and modifies it so that\n     *      it is properly formatted for a `validateOrder` call.\n     *\n     * @param dst                          A memory pointer referencing the\n     *                                     encoded `validateOrder` calldata.\n     * @param memoryLocationForOrderHashes A memory pointer referencing where\n     *                                     to encode orderHashes length of 1.\n     */\n    function _encodeValidateBasicOrder(\n        MemoryPointer dst,\n        uint256 memoryLocationForOrderHashes\n    ) internal pure {\n        // Write validateOrder selector and get pointer to start of calldata.\n        dst.write(validateOrder_selector);\n\n        // Write length = 1 to the orderHashes array. Note that size should now\n        // be one word larger than the provided size.\n        MemoryPointer.wrap(memoryLocationForOrderHashes).write(1);\n    }\n\n    /**\n     * @dev Takes a memory pointer to an array of bytes32 values representing\n     *      the order hashes included as part of the fulfillment and a memory\n     *      pointer to a location to copy it to, and copies the source data to\n     *      the destination in memory.\n     *\n     * @param srcLength A memory pointer referencing the order hashes array to\n     *                  be copied (and pointing to the length of the array).\n     * @param dstLength A memory pointer referencing the location in memory to\n     *                  copy the orderHashes array to (and pointing to the\n     *                  length of the copied array).\n     *\n     * @return size The size of the order hashes array (including the length).\n     */\n    function _encodeOrderHashes(\n        MemoryPointer srcLength,\n        MemoryPointer dstLength\n    ) internal view returns (uint256 size) {\n        // Read length of the array from source and write to destination.\n        uint256 length = srcLength.readUint256();\n        dstLength.write(length);\n\n        unchecked {\n            // Determine head & tail size as one word per element in the array.\n            uint256 headAndTailSize = length << OneWordShift;\n\n            // Copy the tail starting from the next element of the source to the\n            // next element of the destination.\n            srcLength.next().copy(dstLength.next(), headAndTailSize);\n\n            // Set size to the length of the tail plus one word for length.\n            size = headAndTailSize + OneWord;\n        }\n    }\n\n    /**\n     * @dev Takes a memory pointer to an offer or consideration array and a\n     *      memory pointer to a location to copy it to, and copies the source\n     *      data to the destination in memory as a SpentItem array.\n     *\n     * @param srcLength A memory pointer referencing the offer or consideration\n     *                  array to be copied as a SpentItem array (and pointing to\n     *                  the length of the original array).\n     * @param dstLength A memory pointer referencing the location in memory to\n     *                  copy the offer array to (and pointing to the length of\n     *                  the copied array).\n     *\n     * @return size The size of the SpentItem array (including the length).\n     */\n    function _encodeSpentItems(\n        MemoryPointer srcLength,\n        MemoryPointer dstLength\n    ) internal pure returns (uint256 size) {\n        assembly {\n            // Read length of the array from source and write to destination.\n            let length := mload(srcLength)\n            mstore(dstLength, length)\n\n            // Get pointer to first item\'s head position in the array,\n            // containing the item\'s pointer in memory. The head pointer will be\n            // incremented until it reaches the tail position (start of the\n            // array data).\n            let mPtrHead := add(srcLength, OneWord)\n\n            // Position in memory to write next item for calldata. Since\n            // SpentItem has a fixed length, the array elements do not contain\n            // head elements in calldata, they are concatenated together after\n            // the array length.\n            let cdPtrData := add(dstLength, OneWord)\n\n            // Pointer to end of array head in memory.\n            let mPtrHeadEnd := add(mPtrHead, shl(OneWordShift, length))\n\n            for {\n\n            } lt(mPtrHead, mPtrHeadEnd) {\n\n            } {\n                // Read pointer to data for array element from head position.\n                let mPtrTail := mload(mPtrHead)\n\n                // Copy itemType, token, identifier, amount to calldata.\n                mstore(cdPtrData, mload(mPtrTail))\n                mstore(\n                    add(cdPtrData, Common_token_offset),\n                    mload(add(mPtrTail, Common_token_offset))\n                )\n                mstore(\n                    add(cdPtrData, Common_identifier_offset),\n                    mload(add(mPtrTail, Common_identifier_offset))\n                )\n                mstore(\n                    add(cdPtrData, Common_amount_offset),\n                    mload(add(mPtrTail, Common_amount_offset))\n                )\n\n                mPtrHead := add(mPtrHead, OneWord)\n                cdPtrData := add(cdPtrData, SpentItem_size)\n            }\n\n            size := add(OneWord, shl(SpentItem_size_shift, length))\n        }\n    }\n\n    /**\n     * @dev Takes a memory pointer to an consideration array and a memory\n     *      pointer to a location to copy it to, and copies the source data to\n     *      the destination in memory as a ReceivedItem array.\n     *\n     * @param srcLength A memory pointer referencing the consideration array to\n     *                  be copied as a ReceivedItem array (and pointing to the\n     *                  length of the original array).\n     * @param dstLength A memory pointer referencing the location in memory to\n     *                  copy the consideration array to as a ReceivedItem array\n     *                  (and pointing to the length of the new array).\n     *\n     * @return size The size of the ReceivedItem array (including the length).\n     */\n    function _encodeConsiderationAsReceivedItems(\n        MemoryPointer srcLength,\n        MemoryPointer dstLength\n    ) internal view returns (uint256 size) {\n        unchecked {\n            // Read length of the array from source and write to destination.\n            uint256 length = srcLength.readUint256();\n            dstLength.write(length);\n\n            // Get pointer to first item\'s head position in the array,\n            // containing the item\'s pointer in memory. The head pointer will be\n            // incremented until it reaches the tail position (start of the\n            // array data).\n            MemoryPointer srcHead = srcLength.next();\n            MemoryPointer srcHeadEnd = srcHead.offset(length << OneWordShift);\n\n            // Position in memory to write next item for calldata. Since\n            // ReceivedItem has a fixed length, the array elements do not\n            // contain offsets in calldata, they are concatenated together after\n            // the array length.\n            MemoryPointer dstHead = dstLength.next();\n            while (srcHead.lt(srcHeadEnd)) {\n                MemoryPointer srcTail = srcHead.pptr();\n                srcTail.copy(dstHead, ReceivedItem_size);\n                srcHead = srcHead.next();\n                dstHead = dstHead.offset(ReceivedItem_size);\n            }\n\n            size = OneWord + (length * ReceivedItem_size);\n        }\n    }\n}\n'}, 'lib/seaport-types/src/conduit/lib/ConduitStructs.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport { ConduitItemType } from ""./ConduitEnums.sol"";\n\n/**\n * @dev A ConduitTransfer is a struct that contains the information needed for a\n *      conduit to transfer an item from one address to another.\n */\nstruct ConduitTransfer {\n    ConduitItemType itemType;\n    address token;\n    address from;\n    address to;\n    uint256 identifier;\n    uint256 amount;\n}\n\n/**\n * @dev A ConduitBatch1155Transfer is a struct that contains the information\n *      needed for a conduit to transfer a batch of ERC-1155 tokens from one\n *      address to another.\n */\nstruct ConduitBatch1155Transfer {\n    address token;\n    address from;\n    address to;\n    uint256[] ids;\n    uint256[] amounts;\n}\n'}, 'src/lib/Assertions.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {\n    OrderParameters\n} from ""seaport-types/src/lib/ConsiderationStructs.sol"";\n\nimport { GettersAndDerivers } from ""./GettersAndDerivers.sol"";\n\nimport {\n    TokenTransferrerErrors\n} from ""seaport-types/src/interfaces/TokenTransferrerErrors.sol"";\n\nimport { CounterManager } from ""./CounterManager.sol"";\n\nimport {\n    AdditionalRecipient_size_shift,\n    AddressDirtyUpperBitThreshold,\n    BasicOrder_additionalRecipients_head_cdPtr,\n    BasicOrder_additionalRecipients_head_ptr,\n    BasicOrder_addlRecipients_length_cdPtr,\n    BasicOrder_basicOrderType_cdPtr,\n    BasicOrder_basicOrderType_range,\n    BasicOrder_considerationToken_cdPtr,\n    BasicOrder_offerer_cdPtr,\n    BasicOrder_offerToken_cdPtr,\n    BasicOrder_parameters_cdPtr,\n    BasicOrder_parameters_ptr,\n    BasicOrder_signature_cdPtr,\n    BasicOrder_signature_ptr,\n    BasicOrder_zone_cdPtr\n} from ""seaport-types/src/lib/ConsiderationConstants.sol"";\n\nimport {\n    Error_selector_offset,\n    MissingItemAmount_error_length,\n    MissingItemAmount_error_selector\n} from ""seaport-types/src/lib/ConsiderationErrorConstants.sol"";\n\nimport {\n    _revertInvalidBasicOrderParameterEncoding,\n    _revertMissingOriginalConsiderationItems\n} from ""seaport-types/src/lib/ConsiderationErrors.sol"";\n\n/**\n * @title Assertions\n * @author 0age\n * @notice Assertions contains logic for making various assertions that do not\n *         fit neatly within a dedicated semantic scope.\n */\ncontract Assertions is\n    GettersAndDerivers,\n    CounterManager,\n    TokenTransferrerErrors\n{\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(\n        address conduitController\n    ) GettersAndDerivers(conduitController) {}\n\n    /**\n     * @dev Internal view function to ensure that the supplied consideration\n     *      array length on a given set of order parameters is not less than the\n     *      original consideration array length for that order and to retrieve\n     *      the current counter for a given order\'s offerer and zone and use it\n     *      to derive the order hash.\n     *\n     * @param orderParameters The parameters of the order to hash.\n     *\n     * @return The hash.\n     */\n    function _assertConsiderationLengthAndGetOrderHash(\n        OrderParameters memory orderParameters\n    ) internal view returns (bytes32) {\n        // Ensure supplied consideration array length is not less than original.\n        _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(\n            orderParameters.consideration.length,\n            orderParameters.totalOriginalConsiderationItems\n        );\n\n        // Derive and return order hash using current counter for the offerer.\n        return\n            _deriveOrderHash(\n                orderParameters,\n                _getCounter(orderParameters.offerer)\n            );\n    }\n\n    /**\n     * @dev Internal pure function to ensure that the supplied consideration\n     *      array length for an order to be fulfilled is not less than the\n     *      original consideration array length for that order.\n     *\n     * @param suppliedConsiderationItemTotal The number of consideration items\n     *                                       supplied when fulfilling the order.\n     * @param originalConsiderationItemTotal The number of consideration items\n     *                                       supplied on initial order creation.\n     */\n    function _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(\n        uint256 suppliedConsiderationItemTotal,\n        uint256 originalConsiderationItemTotal\n    ) internal pure {\n        // Ensure supplied consideration array length is not less than original.\n        if (suppliedConsiderationItemTotal < originalConsiderationItemTotal) {\n            _revertMissingOriginalConsiderationItems();\n        }\n    }\n\n    /**\n     * @dev Internal pure function to ensure that a given item amount is not\n     *      zero.\n     *\n     * @param amount The amount to check.\n     */\n    function _assertNonZeroAmount(uint256 amount) internal pure {\n        assembly {\n            if iszero(amount) {\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, MissingItemAmount_error_selector)\n\n                // revert(abi.encodeWithSignature(""MissingItemAmount()""))\n                revert(Error_selector_offset, MissingItemAmount_error_length)\n            }\n        }\n    }\n\n    /**\n     * @dev Internal pure function to validate calldata offsets for dynamic\n     *      types in BasicOrderParameters and other parameters. This ensures\n     *      that functions using the calldata object normally will be using the\n     *      same data as the assembly functions and that values that are bound\n     *      to a given range are within that range. Note that no parameters are\n     *      supplied as all basic order functions use the same calldata\n     *      encoding.\n     */\n    function _assertValidBasicOrderParameters() internal pure {\n        // Declare a boolean designating basic order parameter offset validity.\n        bool validOffsets;\n\n        // Utilize assembly in order to read offset data directly from calldata.\n        assembly {\n            /*\n             * Checks:\n             * 1. Order parameters struct offset == 0x20\n             * 2. Additional recipients arr offset == 0x240\n             * 3. Signature offset == 0x260 + (recipients.length * 0x40)\n             * 4. BasicOrderType between 0 and 23 (i.e. < 24)\n             * 5. Offerer, zone, offer token, and consideration token have no\n             *    upper dirty bits — each argument is type(uint160).max or less\n             */\n            validOffsets := and(\n                and(\n                    and(\n                        // Order parameters at cd 0x04 offset = 0x20.\n                        eq(\n                            calldataload(BasicOrder_parameters_cdPtr),\n                            BasicOrder_parameters_ptr\n                        ),\n                        // Additional recipients at cd 0x224 offset = 0x240.\n                        eq(\n                            calldataload(\n                                BasicOrder_additionalRecipients_head_cdPtr\n                            ),\n                            BasicOrder_additionalRecipients_head_ptr\n                        )\n                    ),\n                    // Signature offset = 0x260 + recipients.length * 0x40.\n                    eq(\n                        // Load signature offset from calldata 0x244.\n                        calldataload(BasicOrder_signature_cdPtr),\n                        // Expected offset = start of recipients + len * 64.\n                        add(\n                            BasicOrder_signature_ptr,\n                            shl(\n                                // Each additional recipient length = 0x40.\n                                AdditionalRecipient_size_shift,\n                                // Additional recipients length at cd 0x264.\n                                calldataload(\n                                    BasicOrder_addlRecipients_length_cdPtr\n                                )\n                            )\n                        )\n                    )\n                ),\n                and(\n                    // Ensure BasicOrderType parameter is less than 0x18.\n                    lt(\n                        // BasicOrderType parameter = calldata offset 0x124.\n                        calldataload(BasicOrder_basicOrderType_cdPtr),\n                        // Value should be less than 24.\n                        BasicOrder_basicOrderType_range\n                    ),\n                    // Ensure no dirty upper bits are present on offerer,\n                    // zone, offer token, or consideration token.\n                    lt(\n                        or(\n                            or(\n                                // Offerer parameter = calldata offset 0x84.\n                                calldataload(BasicOrder_offerer_cdPtr),\n                                // Zone parameter = calldata offset 0xa4.\n                                calldataload(BasicOrder_zone_cdPtr)\n                            ),\n                            or(\n                                // Offer token parameter = cd offset 0xc4.\n                                calldataload(BasicOrder_offerToken_cdPtr),\n                                // Consideration parameter = offset 0x24.\n                                calldataload(\n                                    BasicOrder_considerationToken_cdPtr\n                                )\n                            )\n                        ),\n                        AddressDirtyUpperBitThreshold\n                    )\n                )\n            )\n        }\n\n        // Revert with an error if basic order parameter offsets are invalid.\n        if (!validOffsets) {\n            _revertInvalidBasicOrderParameterEncoding();\n        }\n    }\n}\n'}, 'src/lib/SignatureVerification.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {\n    SignatureVerificationErrors\n} from ""seaport-types/src/interfaces/SignatureVerificationErrors.sol"";\n\nimport { LowLevelHelpers } from ""./LowLevelHelpers.sol"";\n\nimport {\n    ECDSA_MaxLength,\n    ECDSA_signature_s_offset,\n    ECDSA_signature_v_offset,\n    ECDSA_twentySeventhAndTwentyEighthBytesSet,\n    Ecrecover_args_size,\n    Ecrecover_precompile,\n    EIP1271_isValidSignature_calldata_baseLength,\n    EIP1271_isValidSignature_digest_negativeOffset,\n    EIP1271_isValidSignature_selector_negativeOffset,\n    EIP1271_isValidSignature_selector,\n    EIP1271_isValidSignature_signature_head_offset,\n    EIP2098_allButHighestBitMask,\n    MaxUint8,\n    OneWord,\n    Signature_lower_v\n} from ""seaport-types/src/lib/ConsiderationConstants.sol"";\n\nimport {\n    BadContractSignature_error_length,\n    BadContractSignature_error_selector,\n    BadSignatureV_error_length,\n    BadSignatureV_error_selector,\n    BadSignatureV_error_v_ptr,\n    Error_selector_offset,\n    InvalidSignature_error_length,\n    InvalidSignature_error_selector,\n    InvalidSigner_error_length,\n    InvalidSigner_error_selector\n} from ""seaport-types/src/lib/ConsiderationErrorConstants.sol"";\n\n/**\n * @title SignatureVerification\n * @author 0age\n * @notice SignatureVerification contains logic for verifying signatures.\n */\ncontract SignatureVerification is SignatureVerificationErrors, LowLevelHelpers {\n    /**\n     * @dev Internal view function to verify the signature of an order. An\n     *      ERC-1271 fallback will be attempted if either the signature length\n     *      is not 64 or 65 bytes or if the recovered signer does not match the\n     *      supplied signer.\n     *\n     * @param signer                  The signer for the order.\n     * @param digest                  The digest to verify signature against.\n     * @param originalDigest          The original digest to verify signature\n     *                                against.\n     * @param originalSignatureLength The original signature length.\n     * @param signature               A signature from the signer indicating\n     *                                that the order has been approved.\n     */\n    function _assertValidSignature(\n        address signer,\n        bytes32 digest,\n        bytes32 originalDigest,\n        uint256 originalSignatureLength,\n        bytes memory signature\n    ) internal view {\n        // Declare value for ecrecover equality or 1271 call success status.\n        bool success;\n\n        // Utilize assembly to perform optimized signature verification check.\n        assembly {\n            // Ensure that first word of scratch space is empty.\n            mstore(0, 0)\n\n            // Get the length of the signature.\n            let signatureLength := mload(signature)\n\n            // Get the pointer to the value preceding the signature length.\n            // This will be used for temporary memory overrides - either the\n            // signature head for isValidSignature or the digest for ecrecover.\n            let wordBeforeSignaturePtr := sub(signature, OneWord)\n\n            // Cache the current value behind the signature to restore it later.\n            let cachedWordBeforeSignature := mload(wordBeforeSignaturePtr)\n\n            // Declare lenDiff + recoveredSigner scope to manage stack pressure.\n            {\n                // Take the difference between the max ECDSA signature length\n                // and the actual signature length. Overflow desired for any\n                // values > 65. If the diff is not 0 or 1, it is not a valid\n                // ECDSA signature - move on to EIP1271 check.\n                let lenDiff := sub(ECDSA_MaxLength, signatureLength)\n\n                // Declare variable for recovered signer.\n                let recoveredSigner\n\n                // If diff is 0 or 1, it may be an ECDSA signature.\n                // Try to recover signer.\n                if iszero(gt(lenDiff, 1)) {\n                    // Read the signature `s` value.\n                    let originalSignatureS := mload(\n                        add(signature, ECDSA_signature_s_offset)\n                    )\n\n                    // Read the first byte of the word after `s`. If the\n                    // signature is 65 bytes, this will be the real `v` value.\n                    // If not, it will need to be modified - doing it this way\n                    // saves an extra condition.\n                    let v := byte(\n                        0,\n                        mload(add(signature, ECDSA_signature_v_offset))\n                    )\n\n                    // If lenDiff is 1, parse 64-byte signature as ECDSA.\n                    if lenDiff {\n                        // Extract yParity from highest bit of vs and add 27 to\n                        // get v.\n                        v := add(\n                            shr(MaxUint8, originalSignatureS),\n                            Signature_lower_v\n                        )\n\n                        // Extract canonical s from vs, all but the highest bit.\n                        // Temporarily overwrite the original `s` value in the\n                        // signature.\n                        mstore(\n                            add(signature, ECDSA_signature_s_offset),\n                            and(\n                                originalSignatureS,\n                                EIP2098_allButHighestBitMask\n                            )\n                        )\n                    }\n                    // Temporarily overwrite the signature length with `v` to\n                    // conform to the expected input for ecrecover.\n                    mstore(signature, v)\n\n                    // Temporarily overwrite the word before the length with\n                    // `digest` to conform to the expected input for ecrecover.\n                    mstore(wordBeforeSignaturePtr, digest)\n\n                    // Attempt to recover the signer for the given signature. Do\n                    // not check the call status as ecrecover will return a null\n                    // address if the signature is invalid.\n                    pop(\n                        staticcall(\n                            gas(),\n                            Ecrecover_precompile, // Call ecrecover precompile.\n                            wordBeforeSignaturePtr, // Use data memory location.\n                            Ecrecover_args_size, // Size of digest, v, r, and s.\n                            0, // Write result to scratch space.\n                            OneWord // Provide size of returned result.\n                        )\n                    )\n\n                    // Restore cached word before signature.\n                    mstore(wordBeforeSignaturePtr, cachedWordBeforeSignature)\n\n                    // Restore cached signature length.\n                    mstore(signature, signatureLength)\n\n                    // Restore cached signature `s` value.\n                    mstore(\n                        add(signature, ECDSA_signature_s_offset),\n                        originalSignatureS\n                    )\n\n                    // Read the recovered signer from the buffer given as return\n                    // space for ecrecover.\n                    recoveredSigner := mload(0)\n                }\n\n                // Set success to true if the signature provided was a valid\n                // ECDSA signature and the signer is not the null address. Use\n                // gt instead of direct as success is used outside of assembly.\n                success := and(eq(signer, recoveredSigner), gt(signer, 0))\n            }\n\n            // If the signature was not verified with ecrecover, try EIP1271.\n            if iszero(success) {\n                // Reset the original signature length.\n                mstore(signature, originalSignatureLength)\n\n                // Temporarily overwrite the word before the signature length\n                // and use it as the head of the signature input to\n                // `isValidSignature`, which has a value of 64.\n                mstore(\n                    wordBeforeSignaturePtr,\n                    EIP1271_isValidSignature_signature_head_offset\n                )\n\n                // Get pointer to use for the selector of `isValidSignature`.\n                let selectorPtr := sub(\n                    signature,\n                    EIP1271_isValidSignature_selector_negativeOffset\n                )\n\n                // Cache the value currently stored at the selector pointer.\n                let cachedWordOverwrittenBySelector := mload(selectorPtr)\n\n                // Cache the value currently stored at the digest pointer.\n                let cachedWordOverwrittenByDigest := mload(\n                    sub(\n                        signature,\n                        EIP1271_isValidSignature_digest_negativeOffset\n                    )\n                )\n\n                // Write the selector first, since it overlaps the digest.\n                mstore(selectorPtr, EIP1271_isValidSignature_selector)\n\n                // Next, write the original digest.\n                mstore(\n                    sub(\n                        signature,\n                        EIP1271_isValidSignature_digest_negativeOffset\n                    ),\n                    originalDigest\n                )\n\n                // Call signer with `isValidSignature` to validate signature.\n                success := staticcall(\n                    gas(),\n                    signer,\n                    selectorPtr,\n                    add(\n                        originalSignatureLength,\n                        EIP1271_isValidSignature_calldata_baseLength\n                    ),\n                    0,\n                    OneWord\n                )\n\n                // Determine if the signature is valid on successful calls.\n                if success {\n                    // If first word of scratch space does not contain EIP-1271\n                    // signature selector, revert.\n                    if iszero(eq(mload(0), EIP1271_isValidSignature_selector)) {\n                        // Revert with bad 1271 signature if signer has code.\n                        if extcodesize(signer) {\n                            // Bad contract signature.\n                            // Store left-padded selector with push4, mem[28:32]\n                            mstore(0, BadContractSignature_error_selector)\n\n                            // revert(abi.encodeWithSignature(\n                            //     ""BadContractSignature()""\n                            // ))\n                            revert(\n                                Error_selector_offset,\n                                BadContractSignature_error_length\n                            )\n                        }\n\n                        // Check if signature length was invalid.\n                        if gt(sub(ECDSA_MaxLength, signatureLength), 1) {\n                            // Revert with generic invalid signature error.\n                            // Store left-padded selector with push4, mem[28:32]\n                            mstore(0, InvalidSignature_error_selector)\n\n                            // revert(abi.encodeWithSignature(\n                            //     ""InvalidSignature()""\n                            // ))\n                            revert(\n                                Error_selector_offset,\n                                InvalidSignature_error_length\n                            )\n                        }\n\n                        // Check if v was invalid.\n                        if and(\n                            eq(signatureLength, ECDSA_MaxLength),\n                            iszero(\n                                byte(\n                                    byte(\n                                        0,\n                                        mload(\n                                            add(\n                                                signature,\n                                                ECDSA_signature_v_offset\n                                            )\n                                        )\n                                    ),\n                                    ECDSA_twentySeventhAndTwentyEighthBytesSet\n                                )\n                            )\n                        ) {\n                            // Revert with invalid v value.\n                            // Store left-padded selector with push4, mem[28:32]\n                            mstore(0, BadSignatureV_error_selector)\n                            mstore(\n                                BadSignatureV_error_v_ptr,\n                                byte(\n                                    0,\n                                    mload(\n                                        add(signature, ECDSA_signature_v_offset)\n                                    )\n                                )\n                            )\n\n                            // revert(abi.encodeWithSignature(\n                            //     ""BadSignatureV(uint8)"", v\n                            // ))\n                            revert(\n                                Error_selector_offset,\n                                BadSignatureV_error_length\n                            )\n                        }\n\n                        // Revert with generic invalid signer error message.\n                        // Store left-padded selector with push4, mem[28:32]\n                        mstore(0, InvalidSigner_error_selector)\n\n                        // revert(abi.encodeWithSignature(""InvalidSigner()""))\n                        revert(\n                            Error_selector_offset,\n                            InvalidSigner_error_length\n                        )\n                    }\n                }\n\n                // Restore the cached values overwritten by selector, digest and\n                // signature head.\n                mstore(wordBeforeSignaturePtr, cachedWordBeforeSignature)\n                mstore(selectorPtr, cachedWordOverwrittenBySelector)\n                mstore(\n                    sub(\n                        signature,\n                        EIP1271_isValidSignature_digest_negativeOffset\n                    ),\n                    cachedWordOverwrittenByDigest\n                )\n            }\n        }\n\n        // If the call failed...\n        if (!success) {\n            // Revert and pass reason along if one was returned.\n            _revertWithReasonIfOneIsReturned();\n\n            // Otherwise, revert with error indicating bad contract signature.\n            assembly {\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, BadContractSignature_error_selector)\n                // revert(abi.encodeWithSignature(""BadContractSignature()""))\n                revert(Error_selector_offset, BadContractSignature_error_length)\n            }\n        }\n    }\n}\n'}, 'lib/seaport-types/src/lib/TokenTransferrerConstants.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/*\n * -------------------------- Disambiguation & Other Notes ---------------------\n *    - The term ""head"" is used as it is in the documentation for ABI encoding,\n *      but only in reference to dynamic types, i.e. it always refers to the\n *      offset or pointer to the body of a dynamic type. In calldata, the head\n *      is always an offset (relative to the parent object), while in memory,\n *      the head is always the pointer to the body. More information found here:\n *      https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#argument-encoding\n *        - Note that the length of an array is separate from and precedes the\n *          head of the array.\n *\n *    - The term ""body"" is used in place of the term ""head"" used in the ABI\n *      documentation. It refers to the start of the data for a dynamic type,\n *      e.g. the first word of a struct or the first word of the first element\n *      in an array.\n *\n *    - The term ""pointer"" is used to describe the absolute position of a value\n *      and never an offset relative to another value.\n *        - The suffix ""_ptr"" refers to a memory pointer.\n *        - The suffix ""_cdPtr"" refers to a calldata pointer.\n *\n *    - The term ""offset"" is used to describe the position of a value relative\n *      to some parent value. For example, OrderParameters_conduit_offset is the\n *      offset to the ""conduit"" value in the OrderParameters struct relative to\n *      the start of the body.\n *        - Note: Offsets are used to derive pointers.\n *\n *    - Some structs have pointers defined for all of their fields in this file.\n *      Lines which are commented out are fields that are not used in the\n *      codebase but have been left in for readability.\n */\n\nuint256 constant ThirtyOneBytes = 0x1f;\nuint256 constant OneWord = 0x20;\nuint256 constant TwoWords = 0x40;\nuint256 constant ThreeWords = 0x60;\n\nuint256 constant OneWordShift = 0x5;\nuint256 constant TwoWordsShift = 0x6;\n\nuint256 constant FreeMemoryPointerSlot = 0x40;\nuint256 constant ZeroSlot = 0x60;\nuint256 constant DefaultFreeMemoryPointer = 0x80;\n\nuint256 constant Slot0x80 = 0x80;\nuint256 constant Slot0xA0 = 0xa0;\nuint256 constant Slot0xC0 = 0xc0;\n\nuint256 constant Generic_error_selector_offset = 0x1c;\n\n// abi.encodeWithSignature(""transferFrom(address,address,uint256)"")\nuint256 constant ERC20_transferFrom_signature = (\n    0x23b872dd00000000000000000000000000000000000000000000000000000000\n);\nuint256 constant ERC20_transferFrom_sig_ptr = 0x0;\nuint256 constant ERC20_transferFrom_from_ptr = 0x04;\nuint256 constant ERC20_transferFrom_to_ptr = 0x24;\nuint256 constant ERC20_transferFrom_amount_ptr = 0x44;\nuint256 constant ERC20_transferFrom_length = 0x64; // 4 + 32 * 3 == 100\n\n// abi.encodeWithSignature(\n//     ""safeTransferFrom(address,address,uint256,uint256,bytes)""\n// )\nuint256 constant ERC1155_safeTransferFrom_signature = (\n    0xf242432a00000000000000000000000000000000000000000000000000000000\n);\nuint256 constant ERC1155_safeTransferFrom_sig_ptr = 0x0;\nuint256 constant ERC1155_safeTransferFrom_from_ptr = 0x04;\nuint256 constant ERC1155_safeTransferFrom_to_ptr = 0x24;\nuint256 constant ERC1155_safeTransferFrom_id_ptr = 0x44;\nuint256 constant ERC1155_safeTransferFrom_amount_ptr = 0x64;\nuint256 constant ERC1155_safeTransferFrom_data_offset_ptr = 0x84;\nuint256 constant ERC1155_safeTransferFrom_data_length_ptr = 0xa4;\nuint256 constant ERC1155_safeTransferFrom_length = 0xc4; // 4 + 32 * 6 == 196\nuint256 constant ERC1155_safeTransferFrom_data_length_offset = 0xa0;\n\n// abi.encodeWithSignature(\n//     ""safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)""\n// )\nuint256 constant ERC1155_safeBatchTransferFrom_signature = (\n    0x2eb2c2d600000000000000000000000000000000000000000000000000000000\n);\n\n// bytes4 constant ERC1155_safeBatchTransferFrom_selector = bytes4(\n//     bytes32(ERC1155_safeBatchTransferFrom_signature)\n// );\n\nuint256 constant ERC721_transferFrom_signature = (\n    0x23b872dd00000000000000000000000000000000000000000000000000000000\n);\nuint256 constant ERC721_transferFrom_sig_ptr = 0x0;\nuint256 constant ERC721_transferFrom_from_ptr = 0x04;\nuint256 constant ERC721_transferFrom_to_ptr = 0x24;\nuint256 constant ERC721_transferFrom_id_ptr = 0x44;\nuint256 constant ERC721_transferFrom_length = 0x64; // 4 + 32 * 3 == 100\n\n/*\n *  error NoContract(address account)\n *    - Defined in TokenTransferrerErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x00: account\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant NoContract_error_selector = 0x5f15d672;\nuint256 constant NoContract_error_account_ptr = 0x20;\nuint256 constant NoContract_error_length = 0x24;\n\n/*\n *  error TokenTransferGenericFailure(\n *      address token,\n *      address from,\n *      address to,\n *      uint256 identifier,\n *      uint256 amount\n *  )\n *    - Defined in TokenTransferrerErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: token\n *    - 0x40: from\n *    - 0x60: to\n *    - 0x80: identifier\n *    - 0xa0: amount\n * Revert buffer is memory[0x1c:0xc0]\n */\nuint256 constant TokenTransferGenericFailure_error_selector = 0xf486bc87;\nuint256 constant TokenTransferGenericFailure_error_token_ptr = 0x20;\nuint256 constant TokenTransferGenericFailure_error_from_ptr = 0x40;\nuint256 constant TokenTransferGenericFailure_error_to_ptr = 0x60;\nuint256 constant TokenTransferGenericFailure_error_identifier_ptr = 0x80;\nuint256 constant TokenTransferGenericFailure_err_identifier_ptr = 0x80;\nuint256 constant TokenTransferGenericFailure_error_amount_ptr = 0xa0;\nuint256 constant TokenTransferGenericFailure_error_length = 0xa4;\n\nuint256 constant ExtraGasBuffer = 0x20;\nuint256 constant CostPerWord = 0x3;\nuint256 constant MemoryExpansionCoefficientShift = 0x9;\n\n// Values are offset by 32 bytes in order to write the token to the beginning\n// in the event of a revert\nuint256 constant BatchTransfer1155Params_ptr = 0x24;\nuint256 constant BatchTransfer1155Params_ids_head_ptr = 0x64;\nuint256 constant BatchTransfer1155Params_amounts_head_ptr = 0x84;\nuint256 constant BatchTransfer1155Params_data_head_ptr = 0xa4;\nuint256 constant BatchTransfer1155Params_data_length_basePtr = 0xc4;\nuint256 constant BatchTransfer1155Params_calldata_baseSize = 0xc4;\n\nuint256 constant BatchTransfer1155Params_ids_length_ptr = 0xc4;\n\nuint256 constant BatchTransfer1155Params_ids_length_offset = 0xa0;\n// uint256 constant BatchTransfer1155Params_amounts_length_baseOffset = 0xc0;\n// uint256 constant BatchTransfer1155Params_data_length_baseOffset = 0xe0;\n\nuint256 constant ConduitBatch1155Transfer_usable_head_size = 0x80;\n\nuint256 constant ConduitBatch1155Transfer_from_offset = 0x20;\nuint256 constant ConduitBatch1155Transfer_ids_head_offset = 0x60;\n// uint256 constant ConduitBatch1155Transfer_amounts_head_offset = 0x80;\nuint256 constant ConduitBatch1155Transfer_ids_length_offset = 0xa0;\nuint256 constant ConduitBatch1155Transfer_amounts_length_baseOffset = 0xc0;\n// uint256 constant ConduitBatch1155Transfer_calldata_baseSize = 0xc0;\n\n// Note: abbreviated version of above constant to adhere to line length limit.\nuint256 constant ConduitBatchTransfer_amounts_head_offset = 0x80;\n\nuint256 constant Invalid1155BatchTransferEncoding_ptr = 0x00;\nuint256 constant Invalid1155BatchTransferEncoding_length = 0x04;\nuint256 constant Invalid1155BatchTransferEncoding_selector = (\n    0xeba2084c00000000000000000000000000000000000000000000000000000000\n);\n\nuint256 constant ERC1155BatchTransferGenericFailure_error_signature = (\n    0xafc445e200000000000000000000000000000000000000000000000000000000\n);\nuint256 constant ERC1155BatchTransferGenericFailure_token_ptr = 0x04;\nuint256 constant ERC1155BatchTransferGenericFailure_ids_offset = 0xc0;\n\n/*\n *  error BadReturnValueFromERC20OnTransfer(\n *      address token, address from, address to, uint256 amount\n *  )\n *    - Defined in TokenTransferrerErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x00: token\n *    - 0x20: from\n *    - 0x40: to\n *    - 0x60: amount\n * Revert buffer is memory[0x1c:0xa0]\n */\nuint256 constant BadReturnValueFromERC20OnTransfer_error_selector = 0x98891923;\nuint256 constant BadReturnValueFromERC20OnTransfer_error_token_ptr = 0x20;\nuint256 constant BadReturnValueFromERC20OnTransfer_error_from_ptr = 0x40;\nuint256 constant BadReturnValueFromERC20OnTransfer_error_to_ptr = 0x60;\nuint256 constant BadReturnValueFromERC20OnTransfer_error_amount_ptr = 0x80;\nuint256 constant BadReturnValueFromERC20OnTransfer_error_length = 0x84;\n'}, 'lib/seaport-types/src/interfaces/TokenTransferrerErrors.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n * @title TokenTransferrerErrors\n */\ninterface TokenTransferrerErrors {\n    /**\n     * @dev Revert with an error when an ERC721 transfer with amount other than\n     *      one is attempted.\n     *\n     * @param amount The amount of the ERC721 tokens to transfer.\n     */\n    error InvalidERC721TransferAmount(uint256 amount);\n\n    /**\n     * @dev Revert with an error when attempting to fulfill an order where an\n     *      item has an amount of zero.\n     */\n    error MissingItemAmount();\n\n    /**\n     * @dev Revert with an error when attempting to fulfill an order where an\n     *      item has unused parameters. This includes both the token and the\n     *      identifier parameters for native transfers as well as the identifier\n     *      parameter for ERC20 transfers. Note that the conduit does not\n     *      perform this check, leaving it up to the calling channel to enforce\n     *      when desired.\n     */\n    error UnusedItemParameters();\n\n    /**\n     * @dev Revert with an error when an ERC20, ERC721, or ERC1155 token\n     *      transfer reverts.\n     *\n     * @param token      The token for which the transfer was attempted.\n     * @param from       The source of the attempted transfer.\n     * @param to         The recipient of the attempted transfer.\n     * @param identifier The identifier for the attempted transfer.\n     * @param amount     The amount for the attempted transfer.\n     */\n    error TokenTransferGenericFailure(\n        address token,\n        address from,\n        address to,\n        uint256 identifier,\n        uint256 amount\n    );\n\n    /**\n     * @dev Revert with an error when a batch ERC1155 token transfer reverts.\n     *\n     * @param token       The token for which the transfer was attempted.\n     * @param from        The source of the attempted transfer.\n     * @param to          The recipient of the attempted transfer.\n     * @param identifiers The identifiers for the attempted transfer.\n     * @param amounts     The amounts for the attempted transfer.\n     */\n    error ERC1155BatchTransferGenericFailure(\n        address token,\n        address from,\n        address to,\n        uint256[] identifiers,\n        uint256[] amounts\n    );\n\n    /**\n     * @dev Revert with an error when an ERC20 token transfer returns a falsey\n     *      value.\n     *\n     * @param token      The token for which the ERC20 transfer was attempted.\n     * @param from       The source of the attempted ERC20 transfer.\n     * @param to         The recipient of the attempted ERC20 transfer.\n     * @param amount     The amount for the attempted ERC20 transfer.\n     */\n    error BadReturnValueFromERC20OnTransfer(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    );\n\n    /**\n     * @dev Revert with an error when an account being called as an assumed\n     *      contract does not have code and returns no data.\n     *\n     * @param account The account that should contain code.\n     */\n    error NoContract(address account);\n\n    /**\n     * @dev Revert with an error when attempting to execute an 1155 batch\n     *      transfer using calldata not produced by default ABI encoding or with\n     *      different lengths for ids and amounts arrays.\n     */\n    error Invalid1155BatchTransferEncoding();\n}\n'}, 'src/lib/GettersAndDerivers.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {\n    OrderParameters\n} from ""seaport-types/src/lib/ConsiderationStructs.sol"";\n\nimport { ConsiderationBase } from ""./ConsiderationBase.sol"";\n\nimport {\n    Create2AddressDerivation_length,\n    Create2AddressDerivation_ptr,\n    EIP_712_PREFIX,\n    EIP712_ConsiderationItem_size,\n    EIP712_DigestPayload_size,\n    EIP712_DomainSeparator_offset,\n    EIP712_OfferItem_size,\n    EIP712_Order_size,\n    EIP712_OrderHash_offset,\n    FreeMemoryPointerSlot,\n    information_conduitController_offset,\n    information_domainSeparator_offset,\n    information_length,\n    information_version_cd_offset,\n    information_version_offset,\n    information_versionLengthPtr,\n    information_versionWithLength,\n    MaskOverByteTwelve,\n    MaskOverLastTwentyBytes,\n    OneWord,\n    OneWordShift,\n    OrderParameters_consideration_head_offset,\n    OrderParameters_counter_offset,\n    OrderParameters_offer_head_offset,\n    TwoWords\n} from ""seaport-types/src/lib/ConsiderationConstants.sol"";\n\n/**\n * @title GettersAndDerivers\n * @author 0age\n * @notice ConsiderationInternal contains pure and internal view functions\n *         related to getting or deriving various values.\n */\ncontract GettersAndDerivers is ConsiderationBase {\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(\n        address conduitController\n    ) ConsiderationBase(conduitController) {}\n\n    /**\n     * @dev Internal view function to derive the order hash for a given order.\n     *      Note that only the original consideration items are included in the\n     *      order hash, as additional consideration items may be supplied by the\n     *      caller.\n     *\n     * @param orderParameters The parameters of the order to hash.\n     * @param counter         The counter of the order to hash.\n     *\n     * @return orderHash The hash.\n     */\n    function _deriveOrderHash(\n        OrderParameters memory orderParameters,\n        uint256 counter\n    ) internal view returns (bytes32 orderHash) {\n        // Get length of original consideration array and place it on the stack.\n        uint256 originalConsiderationLength = (\n            orderParameters.totalOriginalConsiderationItems\n        );\n\n        /*\n         * Memory layout for an array of structs (dynamic or not) is similar\n         * to ABI encoding of dynamic types, with a head segment followed by\n         * a data segment. The main difference is that the head of an element\n         * is a memory pointer rather than an offset.\n         */\n\n        // Declare a variable for the derived hash of the offer array.\n        bytes32 offerHash;\n\n        // Read offer item EIP-712 typehash from runtime code & place on stack.\n        bytes32 typeHash = _OFFER_ITEM_TYPEHASH;\n\n        // Utilize assembly so that memory regions can be reused across hashes.\n        assembly {\n            // Retrieve the free memory pointer and place on the stack.\n            let hashArrPtr := mload(FreeMemoryPointerSlot)\n\n            // Get the pointer to the offers array.\n            let offerArrPtr := mload(\n                add(orderParameters, OrderParameters_offer_head_offset)\n            )\n\n            // Load the length.\n            let offerLength := mload(offerArrPtr)\n\n            // Set the pointer to the first offer\'s head.\n            offerArrPtr := add(offerArrPtr, OneWord)\n\n            // Iterate over the offer items.\n            for {\n                let i := 0\n            } lt(i, offerLength) {\n                i := add(i, 1)\n            } {\n                // Read the pointer to the offer data and subtract one word\n                // to get typeHash pointer.\n                let ptr := sub(mload(offerArrPtr), OneWord)\n\n                // Read the current value before the offer data.\n                let value := mload(ptr)\n\n                // Write the type hash to the previous word.\n                mstore(ptr, typeHash)\n\n                // Take the EIP712 hash and store it in the hash array.\n                mstore(hashArrPtr, keccak256(ptr, EIP712_OfferItem_size))\n\n                // Restore the previous word.\n                mstore(ptr, value)\n\n                // Increment the array pointers by one word.\n                offerArrPtr := add(offerArrPtr, OneWord)\n                hashArrPtr := add(hashArrPtr, OneWord)\n            }\n\n            // Derive the offer hash using the hashes of each item.\n            offerHash := keccak256(\n                mload(FreeMemoryPointerSlot),\n                shl(OneWordShift, offerLength)\n            )\n        }\n\n        // Declare a variable for the derived hash of the consideration array.\n        bytes32 considerationHash;\n\n        // Read consideration item typehash from runtime code & place on stack.\n        typeHash = _CONSIDERATION_ITEM_TYPEHASH;\n\n        // Utilize assembly so that memory regions can be reused across hashes.\n        assembly {\n            // Retrieve the free memory pointer and place on the stack.\n            let hashArrPtr := mload(FreeMemoryPointerSlot)\n\n            // Get the pointer to the consideration array.\n            let considerationArrPtr := add(\n                mload(\n                    add(\n                        orderParameters,\n                        OrderParameters_consideration_head_offset\n                    )\n                ),\n                OneWord\n            )\n\n            // Iterate over the consideration items (not including tips).\n            for {\n                let i := 0\n            } lt(i, originalConsiderationLength) {\n                i := add(i, 1)\n            } {\n                // Read the pointer to the consideration data and subtract one\n                // word to get typeHash pointer.\n                let ptr := sub(mload(considerationArrPtr), OneWord)\n\n                // Read the current value before the consideration data.\n                let value := mload(ptr)\n\n                // Write the type hash to the previous word.\n                mstore(ptr, typeHash)\n\n                // Take the EIP712 hash and store it in the hash array.\n                mstore(\n                    hashArrPtr,\n                    keccak256(ptr, EIP712_ConsiderationItem_size)\n                )\n\n                // Restore the previous word.\n                mstore(ptr, value)\n\n                // Increment the array pointers by one word.\n                considerationArrPtr := add(considerationArrPtr, OneWord)\n                hashArrPtr := add(hashArrPtr, OneWord)\n            }\n\n            // Derive the consideration hash using the hashes of each item.\n            considerationHash := keccak256(\n                mload(FreeMemoryPointerSlot),\n                shl(OneWordShift, originalConsiderationLength)\n            )\n        }\n\n        // Read order item EIP-712 typehash from runtime code & place on stack.\n        typeHash = _ORDER_TYPEHASH;\n\n        // Utilize assembly to access derived hashes & other arguments directly.\n        assembly {\n            // Retrieve pointer to the region located just behind parameters.\n            let typeHashPtr := sub(orderParameters, OneWord)\n\n            // Store the value at that pointer location to restore later.\n            let previousValue := mload(typeHashPtr)\n\n            // Store the order item EIP-712 typehash at the typehash location.\n            mstore(typeHashPtr, typeHash)\n\n            // Retrieve the pointer for the offer array head.\n            let offerHeadPtr := add(\n                orderParameters,\n                OrderParameters_offer_head_offset\n            )\n\n            // Retrieve the data pointer referenced by the offer head.\n            let offerDataPtr := mload(offerHeadPtr)\n\n            // Store the offer hash at the retrieved memory location.\n            mstore(offerHeadPtr, offerHash)\n\n            // Retrieve the pointer for the consideration array head.\n            let considerationHeadPtr := add(\n                orderParameters,\n                OrderParameters_consideration_head_offset\n            )\n\n            // Retrieve the data pointer referenced by the consideration head.\n            let considerationDataPtr := mload(considerationHeadPtr)\n\n            // Store the consideration hash at the retrieved memory location.\n            mstore(considerationHeadPtr, considerationHash)\n\n            // Retrieve the pointer for the counter.\n            let counterPtr := add(\n                orderParameters,\n                OrderParameters_counter_offset\n            )\n\n            // Store the counter at the retrieved memory location.\n            mstore(counterPtr, counter)\n\n            // Derive the order hash using the full range of order parameters.\n            orderHash := keccak256(typeHashPtr, EIP712_Order_size)\n\n            // Restore the value previously held at typehash pointer location.\n            mstore(typeHashPtr, previousValue)\n\n            // Restore offer data pointer at the offer head pointer location.\n            mstore(offerHeadPtr, offerDataPtr)\n\n            // Restore consideration data pointer at the consideration head ptr.\n            mstore(considerationHeadPtr, considerationDataPtr)\n\n            // Restore consideration item length at the counter pointer.\n            mstore(counterPtr, originalConsiderationLength)\n        }\n    }\n\n    /**\n     * @dev Internal view function to derive the address of a given conduit\n     *      using a corresponding conduit key.\n     *\n     * @param conduitKey A bytes32 value indicating what corresponding conduit,\n     *                   if any, to source token approvals from. This value is\n     *                   the ""salt"" parameter supplied by the deployer (i.e. the\n     *                   conduit controller) when deploying the given conduit.\n     *\n     * @return conduit The address of the conduit associated with the given\n     *                 conduit key.\n     */\n    function _deriveConduit(\n        bytes32 conduitKey\n    ) internal view returns (address conduit) {\n        // Read conduit controller address from runtime and place on the stack.\n        address conduitController = address(_CONDUIT_CONTROLLER);\n\n        // Read conduit creation code hash from runtime and place on the stack.\n        bytes32 conduitCreationCodeHash = _CONDUIT_CREATION_CODE_HASH;\n\n        // Leverage scratch space to perform an efficient hash.\n        assembly {\n            // Retrieve the free memory pointer; it will be replaced afterwards.\n            let freeMemoryPointer := mload(FreeMemoryPointerSlot)\n\n            // Place the control character and the conduit controller in scratch\n            // space; note that eleven bytes at the beginning are left unused.\n            mstore(0, or(MaskOverByteTwelve, conduitController))\n\n            // Place the conduit key in the next region of scratch space.\n            mstore(OneWord, conduitKey)\n\n            // Place conduit creation code hash in free memory pointer location.\n            mstore(TwoWords, conduitCreationCodeHash)\n\n            // Derive conduit by hashing and applying a mask over last 20 bytes.\n            conduit := and(\n                // Hash the relevant region.\n                keccak256(\n                    // The region starts at memory pointer 11.\n                    Create2AddressDerivation_ptr,\n                    // The region is 85 bytes long (1 + 20 + 32 + 32).\n                    Create2AddressDerivation_length\n                ),\n                // The address equals the last twenty bytes of the hash.\n                MaskOverLastTwentyBytes\n            )\n\n            // Restore the free memory pointer.\n            mstore(FreeMemoryPointerSlot, freeMemoryPointer)\n        }\n    }\n\n    /**\n     * @dev Internal view function to get the EIP-712 domain separator. If the\n     *      chainId matches the chainId set on deployment, the cached domain\n     *      separator will be returned; otherwise, it will be derived from\n     *      scratch.\n     *\n     * @return The domain separator.\n     */\n    function _domainSeparator() internal view returns (bytes32) {\n        return\n            block.chainid == _CHAIN_ID\n                ? _DOMAIN_SEPARATOR\n                : _deriveDomainSeparator();\n    }\n\n    /**\n     * @dev Internal view function to retrieve configuration information for\n     *      this contract.\n     *\n     * @return The contract version.\n     * @return The domain separator for this contract.\n     * @return The conduit Controller set for this contract.\n     */\n    function _information()\n        internal\n        view\n        returns (\n            string memory /* version */,\n            bytes32 /* domainSeparator */,\n            address /* conduitController */\n        )\n    {\n        // Derive the domain separator.\n        bytes32 domainSeparator = _domainSeparator();\n\n        // Declare variable as immutables cannot be accessed within assembly.\n        address conduitController = address(_CONDUIT_CONTROLLER);\n\n        // Return the version, domain separator, and conduit controller.\n        assembly {\n            mstore(information_version_offset, information_version_cd_offset)\n            mstore(information_domainSeparator_offset, domainSeparator)\n            mstore(information_conduitController_offset, conduitController)\n            mstore(information_versionLengthPtr, information_versionWithLength)\n            return(information_version_offset, information_length)\n        }\n    }\n\n    /**\n     * @dev Internal pure function to efficiently derive an digest to sign for\n     *      an order in accordance with EIP-712.\n     *\n     * @param domainSeparator The domain separator.\n     * @param orderHash       The order hash.\n     *\n     * @return value The hash.\n     */\n    function _deriveEIP712Digest(\n        bytes32 domainSeparator,\n        bytes32 orderHash\n    ) internal pure returns (bytes32 value) {\n        // Leverage scratch space to perform an efficient hash.\n        assembly {\n            // Place the EIP-712 prefix at the start of scratch space.\n            mstore(0, EIP_712_PREFIX)\n\n            // Place the domain separator in the next region of scratch space.\n            mstore(EIP712_DomainSeparator_offset, domainSeparator)\n\n            // Place the order hash in scratch space, spilling into the first\n            // two bytes of the free memory pointer — this should never be set\n            // as memory cannot be expanded to that size, and will be zeroed out\n            // after the hash is performed.\n            mstore(EIP712_OrderHash_offset, orderHash)\n\n            // Hash the relevant region (65 bytes).\n            value := keccak256(0, EIP712_DigestPayload_size)\n\n            // Clear out the dirtied bits in the memory pointer.\n            mstore(EIP712_OrderHash_offset, 0)\n        }\n    }\n}\n'}, 'src/lib/CounterManager.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {\n    ConsiderationEventsAndErrors\n} from ""seaport-types/src/interfaces/ConsiderationEventsAndErrors.sol"";\n\nimport { ReentrancyGuard } from ""./ReentrancyGuard.sol"";\n\nimport {\n    Counter_blockhash_shift,\n    OneWord,\n    TwoWords\n} from ""seaport-types/src/lib/ConsiderationConstants.sol"";\n\n/**\n * @title CounterManager\n * @author 0age\n * @notice CounterManager contains a storage mapping and related functionality\n *         for retrieving and incrementing a per-offerer counter.\n */\ncontract CounterManager is ConsiderationEventsAndErrors, ReentrancyGuard {\n    // Only orders signed using an offerer\'s current counter are fulfillable.\n    mapping(address => uint256) private _counters;\n\n    /**\n     * @dev Internal function to cancel all orders from a given offerer in bulk\n     *      by incrementing a counter by a large, quasi-random interval. Note\n     *      that only the offerer may increment the counter. Note that the\n     *      counter is incremented by a large, quasi-random interval, which\n     *      makes it infeasible to ""activate"" signed orders by incrementing the\n     *      counter.  This activation functionality can be achieved instead with\n     *      restricted orders or contract orders.\n     *\n     * @return newCounter The new counter.\n     */\n    function _incrementCounter() internal returns (uint256 newCounter) {\n        // Ensure that the reentrancy guard is not currently set.\n        _assertNonReentrant();\n\n        // Utilize assembly to access counters storage mapping directly. Skip\n        // overflow check as counter cannot be incremented that far.\n        assembly {\n            // Use second half of previous block hash as a quasi-random number.\n            let quasiRandomNumber := shr(\n                Counter_blockhash_shift,\n                blockhash(sub(number(), 1))\n            )\n\n            // Write the caller to scratch space.\n            mstore(0, caller())\n\n            // Write the storage slot for _counters to scratch space.\n            mstore(OneWord, _counters.slot)\n\n            // Derive the storage pointer for the counter value.\n            let storagePointer := keccak256(0, TwoWords)\n\n            // Derive new counter value using random number and original value.\n            newCounter := add(quasiRandomNumber, sload(storagePointer))\n\n            // Store the updated counter value.\n            sstore(storagePointer, newCounter)\n        }\n\n        // Emit an event containing the new counter.\n        emit CounterIncremented(newCounter, msg.sender);\n    }\n\n    /**\n     * @dev Internal view function to retrieve the current counter for a given\n     *      offerer.\n     *\n     * @param offerer The offerer in question.\n     *\n     * @return currentCounter The current counter.\n     */\n    function _getCounter(\n        address offerer\n    ) internal view returns (uint256 currentCounter) {\n        // Return the counter for the supplied offerer.\n        currentCounter = _counters[offerer];\n    }\n}\n'}, 'lib/seaport-types/src/interfaces/SignatureVerificationErrors.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n * @title SignatureVerificationErrors\n * @author 0age\n * @notice SignatureVerificationErrors contains all errors related to signature\n *         verification.\n */\ninterface SignatureVerificationErrors {\n    /**\n     * @dev Revert with an error when a signature that does not contain a v\n     *      value of 27 or 28 has been supplied.\n     *\n     * @param v The invalid v value.\n     */\n    error BadSignatureV(uint8 v);\n\n    /**\n     * @dev Revert with an error when the signer recovered by the supplied\n     *      signature does not match the offerer or an allowed EIP-1271 signer\n     *      as specified by the offerer in the event they are a contract.\n     */\n    error InvalidSigner();\n\n    /**\n     * @dev Revert with an error when a signer cannot be recovered from the\n     *      supplied signature.\n     */\n    error InvalidSignature();\n\n    /**\n     * @dev Revert with an error when an EIP-1271 call to an account fails.\n     */\n    error BadContractSignature();\n}\n'}, 'src/lib/ConsiderationBase.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {\n    ConduitControllerInterface\n} from ""seaport-types/src/interfaces/ConduitControllerInterface.sol"";\n\nimport {\n    ConsiderationEventsAndErrors\n} from ""seaport-types/src/interfaces/ConsiderationEventsAndErrors.sol"";\n\nimport {\n    BulkOrder_Typehash_Height_One,\n    BulkOrder_Typehash_Height_Two,\n    BulkOrder_Typehash_Height_Three,\n    BulkOrder_Typehash_Height_Four,\n    BulkOrder_Typehash_Height_Five,\n    BulkOrder_Typehash_Height_Six,\n    BulkOrder_Typehash_Height_Seven,\n    BulkOrder_Typehash_Height_Eight,\n    BulkOrder_Typehash_Height_Nine,\n    BulkOrder_Typehash_Height_Ten,\n    BulkOrder_Typehash_Height_Eleven,\n    BulkOrder_Typehash_Height_Twelve,\n    BulkOrder_Typehash_Height_Thirteen,\n    BulkOrder_Typehash_Height_Fourteen,\n    BulkOrder_Typehash_Height_Fifteen,\n    BulkOrder_Typehash_Height_Sixteen,\n    BulkOrder_Typehash_Height_Seventeen,\n    BulkOrder_Typehash_Height_Eighteen,\n    BulkOrder_Typehash_Height_Nineteen,\n    BulkOrder_Typehash_Height_Twenty,\n    BulkOrder_Typehash_Height_TwentyOne,\n    BulkOrder_Typehash_Height_TwentyTwo,\n    BulkOrder_Typehash_Height_TwentyThree,\n    BulkOrder_Typehash_Height_TwentyFour,\n    EIP712_domainData_chainId_offset,\n    EIP712_domainData_nameHash_offset,\n    EIP712_domainData_size,\n    EIP712_domainData_verifyingContract_offset,\n    EIP712_domainData_versionHash_offset,\n    FreeMemoryPointerSlot,\n    NameLengthPtr,\n    NameWithLength,\n    OneWord,\n    Slot0x80,\n    ThreeWords,\n    ZeroSlot\n} from ""seaport-types/src/lib/ConsiderationConstants.sol"";\n\nimport { ConsiderationDecoder } from ""./ConsiderationDecoder.sol"";\n\nimport { ConsiderationEncoder } from ""./ConsiderationEncoder.sol"";\n\n/**\n * @title ConsiderationBase\n * @author 0age\n * @notice ConsiderationBase contains immutable constants and constructor logic.\n */\ncontract ConsiderationBase is\n    ConsiderationDecoder,\n    ConsiderationEncoder,\n    ConsiderationEventsAndErrors\n{\n    // Precompute hashes, original chainId, and domain separator on deployment.\n    bytes32 internal immutable _NAME_HASH;\n    bytes32 internal immutable _VERSION_HASH;\n    bytes32 internal immutable _EIP_712_DOMAIN_TYPEHASH;\n    bytes32 internal immutable _OFFER_ITEM_TYPEHASH;\n    bytes32 internal immutable _CONSIDERATION_ITEM_TYPEHASH;\n    bytes32 internal immutable _ORDER_TYPEHASH;\n    uint256 internal immutable _CHAIN_ID;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n\n    // Allow for interaction with the conduit controller.\n    ConduitControllerInterface internal immutable _CONDUIT_CONTROLLER;\n\n    // Cache the conduit creation code hash used by the conduit controller.\n    bytes32 internal immutable _CONDUIT_CREATION_CODE_HASH;\n\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) {\n        // Derive name and version hashes alongside required EIP-712 typehashes.\n        (\n            _NAME_HASH,\n            _VERSION_HASH,\n            _EIP_712_DOMAIN_TYPEHASH,\n            _OFFER_ITEM_TYPEHASH,\n            _CONSIDERATION_ITEM_TYPEHASH,\n            _ORDER_TYPEHASH\n        ) = _deriveTypehashes();\n\n        // Store the current chainId and derive the current domain separator.\n        _CHAIN_ID = block.chainid;\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n\n        // Set the supplied conduit controller.\n        _CONDUIT_CONTROLLER = ConduitControllerInterface(conduitController);\n\n        // Retrieve the conduit creation code hash from the supplied controller.\n        (_CONDUIT_CREATION_CODE_HASH, ) = (\n            _CONDUIT_CONTROLLER.getConduitCodeHashes()\n        );\n    }\n\n    /**\n     * @dev Internal view function to derive the EIP-712 domain separator.\n     *\n     * @return domainSeparator The derived domain separator.\n     */\n    function _deriveDomainSeparator()\n        internal\n        view\n        returns (bytes32 domainSeparator)\n    {\n        bytes32 typehash = _EIP_712_DOMAIN_TYPEHASH;\n        bytes32 nameHash = _NAME_HASH;\n        bytes32 versionHash = _VERSION_HASH;\n\n        // Leverage scratch space and other memory to perform an efficient hash.\n        assembly {\n            // Retrieve the free memory pointer; it will be replaced afterwards.\n            let freeMemoryPointer := mload(FreeMemoryPointerSlot)\n\n            // Retrieve value at 0x80; it will also be replaced afterwards.\n            let slot0x80 := mload(Slot0x80)\n\n            // Place typehash, name hash, and version hash at start of memory.\n            mstore(0, typehash)\n            mstore(EIP712_domainData_nameHash_offset, nameHash)\n            mstore(EIP712_domainData_versionHash_offset, versionHash)\n\n            // Place chainId in the next memory location.\n            mstore(EIP712_domainData_chainId_offset, chainid())\n\n            // Place the address of this contract in the next memory location.\n            mstore(EIP712_domainData_verifyingContract_offset, address())\n\n            // Hash relevant region of memory to derive the domain separator.\n            domainSeparator := keccak256(0, EIP712_domainData_size)\n\n            // Restore the free memory pointer.\n            mstore(FreeMemoryPointerSlot, freeMemoryPointer)\n\n            // Restore the zero slot to zero.\n            mstore(ZeroSlot, 0)\n\n            // Restore the value at 0x80.\n            mstore(Slot0x80, slot0x80)\n        }\n    }\n\n    /**\n     * @dev Internal pure function to retrieve the default name of this\n     *      contract and return.\n     *\n     * @return The name of this contract.\n     */\n    function _name() internal pure virtual returns (string memory) {\n        // Return the name of the contract.\n        assembly {\n            // First element is the offset for the returned string. Offset the\n            // value in memory by one word so that the free memory pointer will\n            // be overwritten by the next write.\n            mstore(OneWord, OneWord)\n\n            // Name is right padded, so it touches the length which is left\n            // padded. This enables writing both values at once. The free memory\n            // pointer will be overwritten in the process.\n            mstore(NameLengthPtr, NameWithLength)\n\n            // Standard ABI encoding pads returned data to the nearest word. Use\n            // the already empty zero slot memory region for this purpose and\n            // return the final name string, offset by the original single word.\n            return(OneWord, ThreeWords)\n        }\n    }\n\n    /**\n     * @dev Internal pure function to retrieve the default name of this contract\n     *      as a string that can be used internally.\n     *\n     * @return The name of this contract.\n     */\n    function _nameString() internal pure virtual returns (string memory) {\n        // Return the name of the contract.\n        return ""Consideration"";\n    }\n\n    /**\n     * @dev Internal pure function to derive required EIP-712 typehashes and\n     *      other hashes during contract creation.\n     *\n     * @return nameHash                  The hash of the name of the contract.\n     * @return versionHash               The hash of the version string of the\n     *                                   contract.\n     * @return eip712DomainTypehash      The primary EIP-712 domain typehash.\n     * @return offerItemTypehash         The EIP-712 typehash for OfferItem\n     *                                   types.\n     * @return considerationItemTypehash The EIP-712 typehash for\n     *                                   ConsiderationItem types.\n     * @return orderTypehash             The EIP-712 typehash for Order types.\n     */\n    function _deriveTypehashes()\n        internal\n        pure\n        returns (\n            bytes32 nameHash,\n            bytes32 versionHash,\n            bytes32 eip712DomainTypehash,\n            bytes32 offerItemTypehash,\n            bytes32 considerationItemTypehash,\n            bytes32 orderTypehash\n        )\n    {\n        // Derive hash of the name of the contract.\n        nameHash = keccak256(bytes(_nameString()));\n\n        // Derive hash of the version string of the contract.\n        versionHash = keccak256(bytes(""1.6""));\n\n        // Construct the OfferItem type string.\n        bytes memory offerItemTypeString = bytes(\n            ""OfferItem(""\n            ""uint8 itemType,""\n            ""address token,""\n            ""uint256 identifierOrCriteria,""\n            ""uint256 startAmount,""\n            ""uint256 endAmount""\n            "")""\n        );\n\n        // Construct the ConsiderationItem type string.\n        bytes memory considerationItemTypeString = bytes(\n            ""ConsiderationItem(""\n            ""uint8 itemType,""\n            ""address token,""\n            ""uint256 identifierOrCriteria,""\n            ""uint256 startAmount,""\n            ""uint256 endAmount,""\n            ""address recipient""\n            "")""\n        );\n\n        // Construct the OrderComponents type string, not including the above.\n        bytes memory orderComponentsPartialTypeString = bytes(\n            ""OrderComponents(""\n            ""address offerer,""\n            ""address zone,""\n            ""OfferItem[] offer,""\n            ""ConsiderationItem[] consideration,""\n            ""uint8 orderType,""\n            ""uint256 startTime,""\n            ""uint256 endTime,""\n            ""bytes32 zoneHash,""\n            ""uint256 salt,""\n            ""bytes32 conduitKey,""\n            ""uint256 counter""\n            "")""\n        );\n\n        // Construct the primary EIP-712 domain type string.\n        eip712DomainTypehash = keccak256(\n            bytes(\n                ""EIP712Domain(""\n                ""string name,""\n                ""string version,""\n                ""uint256 chainId,""\n                ""address verifyingContract""\n                "")""\n            )\n        );\n\n        // Derive the OfferItem type hash using the corresponding type string.\n        offerItemTypehash = keccak256(offerItemTypeString);\n\n        // Derive ConsiderationItem type hash using corresponding type string.\n        considerationItemTypehash = keccak256(considerationItemTypeString);\n\n        bytes memory orderTypeString = bytes.concat(\n            orderComponentsPartialTypeString,\n            considerationItemTypeString,\n            offerItemTypeString\n        );\n\n        // Derive OrderItem type hash via combination of relevant type strings.\n        orderTypehash = keccak256(orderTypeString);\n    }\n\n    /**\n     * @dev Internal pure function to look up one of twenty-four potential bulk\n     *      order typehash constants based on the height of the bulk order tree.\n     *      Note that values between one and twenty-four are supported, which is\n     *      enforced by _isValidBulkOrderSize.\n     *\n     * @param _treeHeight The height of the bulk order tree. The value must be\n     *                    between one and twenty-four.\n     *\n     * @return _typeHash The EIP-712 typehash for the bulk order type with the\n     *                   given height.\n     */\n    function _lookupBulkOrderTypehash(\n        uint256 _treeHeight\n    ) internal pure returns (bytes32 _typeHash) {\n        // Utilize assembly to efficiently retrieve correct bulk order typehash.\n        assembly {\n            // Use a Yul function to enable use of the `leave` keyword\n            // to stop searching once the appropriate type hash is found.\n            function lookupTypeHash(treeHeight) -> typeHash {\n                // Handle tree heights one through eight.\n                if lt(treeHeight, 9) {\n                    // Handle tree heights one through four.\n                    if lt(treeHeight, 5) {\n                        // Handle tree heights one and two.\n                        if lt(treeHeight, 3) {\n                            // Utilize branchless logic to determine typehash.\n                            typeHash := ternary(\n                                eq(treeHeight, 1),\n                                BulkOrder_Typehash_Height_One,\n                                BulkOrder_Typehash_Height_Two\n                            )\n\n                            // Exit the function once typehash has been located.\n                            leave\n                        }\n\n                        // Handle height three and four via branchless logic.\n                        typeHash := ternary(\n                            eq(treeHeight, 3),\n                            BulkOrder_Typehash_Height_Three,\n                            BulkOrder_Typehash_Height_Four\n                        )\n\n                        // Exit the function once typehash has been located.\n                        leave\n                    }\n\n                    // Handle tree height five and six.\n                    if lt(treeHeight, 7) {\n                        // Utilize branchless logic to determine typehash.\n                        typeHash := ternary(\n                            eq(treeHeight, 5),\n                            BulkOrder_Typehash_Height_Five,\n                            BulkOrder_Typehash_Height_Six\n                        )\n\n                        // Exit the function once typehash has been located.\n                        leave\n                    }\n\n                    // Handle height seven and eight via branchless logic.\n                    typeHash := ternary(\n                        eq(treeHeight, 7),\n                        BulkOrder_Typehash_Height_Seven,\n                        BulkOrder_Typehash_Height_Eight\n                    )\n\n                    // Exit the function once typehash has been located.\n                    leave\n                }\n\n                // Handle tree height nine through sixteen.\n                if lt(treeHeight, 17) {\n                    // Handle tree height nine through twelve.\n                    if lt(treeHeight, 13) {\n                        // Handle tree height nine and ten.\n                        if lt(treeHeight, 11) {\n                            // Utilize branchless logic to determine typehash.\n                            typeHash := ternary(\n                                eq(treeHeight, 9),\n                                BulkOrder_Typehash_Height_Nine,\n                                BulkOrder_Typehash_Height_Ten\n                            )\n\n                            // Exit the function once typehash has been located.\n                            leave\n                        }\n\n                        // Handle height eleven and twelve via branchless logic.\n                        typeHash := ternary(\n                            eq(treeHeight, 11),\n                            BulkOrder_Typehash_Height_Eleven,\n                            BulkOrder_Typehash_Height_Twelve\n                        )\n\n                        // Exit the function once typehash has been located.\n                        leave\n                    }\n\n                    // Handle tree height thirteen and fourteen.\n                    if lt(treeHeight, 15) {\n                        // Utilize branchless logic to determine typehash.\n                        typeHash := ternary(\n                            eq(treeHeight, 13),\n                            BulkOrder_Typehash_Height_Thirteen,\n                            BulkOrder_Typehash_Height_Fourteen\n                        )\n\n                        // Exit the function once typehash has been located.\n                        leave\n                    }\n                    // Handle height fifteen and sixteen via branchless logic.\n                    typeHash := ternary(\n                        eq(treeHeight, 15),\n                        BulkOrder_Typehash_Height_Fifteen,\n                        BulkOrder_Typehash_Height_Sixteen\n                    )\n\n                    // Exit the function once typehash has been located.\n                    leave\n                }\n\n                // Handle tree height seventeen through twenty.\n                if lt(treeHeight, 21) {\n                    // Handle tree height seventeen and eighteen.\n                    if lt(treeHeight, 19) {\n                        // Utilize branchless logic to determine typehash.\n                        typeHash := ternary(\n                            eq(treeHeight, 17),\n                            BulkOrder_Typehash_Height_Seventeen,\n                            BulkOrder_Typehash_Height_Eighteen\n                        )\n\n                        // Exit the function once typehash has been located.\n                        leave\n                    }\n\n                    // Handle height nineteen and twenty via branchless logic.\n                    typeHash := ternary(\n                        eq(treeHeight, 19),\n                        BulkOrder_Typehash_Height_Nineteen,\n                        BulkOrder_Typehash_Height_Twenty\n                    )\n\n                    // Exit the function once typehash has been located.\n                    leave\n                }\n\n                // Handle tree height twenty-one and twenty-two.\n                if lt(treeHeight, 23) {\n                    // Utilize branchless logic to determine typehash.\n                    typeHash := ternary(\n                        eq(treeHeight, 21),\n                        BulkOrder_Typehash_Height_TwentyOne,\n                        BulkOrder_Typehash_Height_TwentyTwo\n                    )\n\n                    // Exit the function once typehash has been located.\n                    leave\n                }\n\n                // Handle height twenty-three & twenty-four w/ branchless logic.\n                typeHash := ternary(\n                    eq(treeHeight, 23),\n                    BulkOrder_Typehash_Height_TwentyThree,\n                    BulkOrder_Typehash_Height_TwentyFour\n                )\n\n                // Exit the function once typehash has been located.\n                leave\n            }\n\n            // Implement ternary conditional using branchless logic.\n            function ternary(cond, ifTrue, ifFalse) -> c {\n                c := xor(ifFalse, mul(cond, xor(ifFalse, ifTrue)))\n            }\n\n            // Look up the typehash using the supplied tree height.\n            _typeHash := lookupTypeHash(_treeHeight)\n        }\n    }\n}\n'}, 'lib/seaport-types/src/interfaces/ConsiderationEventsAndErrors.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {\n    OrderParameters,\n    ReceivedItem,\n    SpentItem\n} from ""../lib/ConsiderationStructs.sol"";\n\n/**\n * @title ConsiderationEventsAndErrors\n * @author 0age\n * @notice ConsiderationEventsAndErrors contains all events and errors.\n */\ninterface ConsiderationEventsAndErrors {\n    /**\n     * @dev Emit an event whenever an order is successfully fulfilled.\n     *\n     * @param orderHash     The hash of the fulfilled order.\n     * @param offerer       The offerer of the fulfilled order.\n     * @param zone          The zone of the fulfilled order.\n     * @param recipient     The recipient of each spent item on the fulfilled\n     *                      order, or the null address if there is no specific\n     *                      fulfiller (i.e. the order is part of a group of\n     *                      orders). Defaults to the caller unless explicitly\n     *                      specified otherwise by the fulfiller.\n     * @param offer         The offer items spent as part of the order.\n     * @param consideration The consideration items received as part of the\n     *                      order along with the recipients of each item.\n     */\n    event OrderFulfilled(\n        bytes32 orderHash,\n        address indexed offerer,\n        address indexed zone,\n        address recipient,\n        SpentItem[] offer,\n        ReceivedItem[] consideration\n    );\n\n    /**\n     * @dev Emit an event whenever an order is successfully cancelled.\n     *\n     * @param orderHash The hash of the cancelled order.\n     * @param offerer   The offerer of the cancelled order.\n     * @param zone      The zone of the cancelled order.\n     */\n    event OrderCancelled(\n        bytes32 orderHash,\n        address indexed offerer,\n        address indexed zone\n    );\n\n    /**\n     * @dev Emit an event whenever an order is explicitly validated. Note that\n     *      this event will not be emitted on partial fills even though they do\n     *      validate the order as part of partial fulfillment.\n     *\n     * @param orderHash        The hash of the validated order.\n     * @param orderParameters  The parameters of the validated order.\n     */\n    event OrderValidated(bytes32 orderHash, OrderParameters orderParameters);\n\n    /**\n     * @dev Emit an event whenever one or more orders are matched using either\n     *      matchOrders or matchAdvancedOrders.\n     *\n     * @param orderHashes The order hashes of the matched orders.\n     */\n    event OrdersMatched(bytes32[] orderHashes);\n\n    /**\n     * @dev Emit an event whenever a counter for a given offerer is incremented.\n     *\n     * @param newCounter The new counter for the offerer.\n     * @param offerer    The offerer in question.\n     */\n    event CounterIncremented(uint256 newCounter, address indexed offerer);\n\n    /**\n     * @dev Revert with an error when attempting to fill an order that has\n     *      already been fully filled.\n     *\n     * @param orderHash The order hash on which a fill was attempted.\n     */\n    error OrderAlreadyFilled(bytes32 orderHash);\n\n    /**\n     * @dev Revert with an error when attempting to fill an order outside the\n     *      specified start time and end time.\n     *\n     * @param startTime The time at which the order becomes active.\n     * @param endTime   The time at which the order becomes inactive.\n     */\n    error InvalidTime(uint256 startTime, uint256 endTime);\n\n    /**\n     * @dev Revert with an error when attempting to fill an order referencing an\n     *      invalid conduit (i.e. one that has not been deployed).\n     */\n    error InvalidConduit(bytes32 conduitKey, address conduit);\n\n    /**\n     * @dev Revert with an error when an order is supplied for fulfillment with\n     *      a consideration array that is shorter than the original array.\n     */\n    error MissingOriginalConsiderationItems();\n\n    /**\n     * @dev Revert with an error when an order is validated and the length of\n     *      the consideration array is not equal to the supplied total original\n     *      consideration items value. This error is also thrown when contract\n     *      orders supply a total original consideration items value that does\n     *      not match the supplied consideration array length.\n     */\n    error ConsiderationLengthNotEqualToTotalOriginal();\n\n    /**\n     * @dev Revert with an error when a call to a conduit fails with revert data\n     *      that is too expensive to return.\n     */\n    error InvalidCallToConduit(address conduit);\n\n    /**\n     * @dev Revert with an error if a consideration amount has not been fully\n     *      zeroed out after applying all fulfillments.\n     *\n     * @param orderIndex         The index of the order with the consideration\n     *                           item with a shortfall.\n     * @param considerationIndex The index of the consideration item on the\n     *                           order.\n     * @param shortfallAmount    The unfulfilled consideration amount.\n     */\n    error ConsiderationNotMet(\n        uint256 orderIndex,\n        uint256 considerationIndex,\n        uint256 shortfallAmount\n    );\n\n    /**\n     * @dev Revert with an error when insufficient native tokens are supplied as\n     *      part of msg.value when fulfilling orders.\n     */\n    error InsufficientNativeTokensSupplied();\n\n    /**\n     * @dev Revert with an error when a native token transfer reverts.\n     */\n    error NativeTokenTransferGenericFailure(address account, uint256 amount);\n\n    /**\n     * @dev Revert with an error when a partial fill is attempted on an order\n     *      that does not specify partial fill support in its order type.\n     */\n    error PartialFillsNotEnabledForOrder();\n\n    /**\n     * @dev Revert with an error when attempting to fill an order that has been\n     *      cancelled.\n     *\n     * @param orderHash The hash of the cancelled order.\n     */\n    error OrderIsCancelled(bytes32 orderHash);\n\n    /**\n     * @dev Revert with an error when attempting to fill a basic order that has\n     *      been partially filled.\n     *\n     * @param orderHash The hash of the partially used order.\n     */\n    error OrderPartiallyFilled(bytes32 orderHash);\n\n    /**\n     * @dev Revert with an error when attempting to cancel an order as a caller\n     *      other than the indicated offerer or zone or when attempting to\n     *      cancel a contract order.\n     */\n    error CannotCancelOrder();\n\n    /**\n     * @dev Revert with an error when supplying a fraction with a value of zero\n     *      for the numerator or denominator, or one where the numerator exceeds\n     *      the denominator.\n     */\n    error BadFraction();\n\n    /**\n     * @dev Revert with an error when a caller attempts to supply callvalue to a\n     *      non-payable basic order route or does not supply any callvalue to a\n     *      payable basic order route.\n     */\n    error InvalidMsgValue(uint256 value);\n\n    /**\n     * @dev Revert with an error when attempting to fill a basic order using\n     *      calldata not produced by default ABI encoding.\n     */\n    error InvalidBasicOrderParameterEncoding();\n\n    /**\n     * @dev Revert with an error when attempting to fulfill any number of\n     *      available orders when none are fulfillable.\n     */\n    error NoSpecifiedOrdersAvailable();\n\n    /**\n     * @dev Revert with an error when attempting to fulfill an order with an\n     *      offer for a native token outside of matching orders.\n     */\n    error InvalidNativeOfferItem();\n}\n'}, 'src/lib/ReentrancyGuard.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {\n    ReentrancyErrors\n} from ""seaport-types/src/interfaces/ReentrancyErrors.sol"";\n\nimport { LowLevelHelpers } from ""./LowLevelHelpers.sol"";\n\nimport {\n    _revertInvalidMsgValue,\n    _revertNoReentrantCalls\n} from ""seaport-types/src/lib/ConsiderationErrors.sol"";\n\nimport {\n    _ENTERED_AND_ACCEPTING_NATIVE_TOKENS_SSTORE,\n    _ENTERED_SSTORE,\n    _NOT_ENTERED_SSTORE,\n    _ENTERED_AND_ACCEPTING_NATIVE_TOKENS_TSTORE,\n    _ENTERED_TSTORE,\n    _NOT_ENTERED_TSTORE,\n    _TSTORE_ENABLED_SSTORE,\n    _REENTRANCY_GUARD_SLOT,\n    _TLOAD_TEST_PAYLOAD,\n    _TLOAD_TEST_PAYLOAD_OFFSET,\n    _TLOAD_TEST_PAYLOAD_LENGTH\n} from ""seaport-types/src/lib/ConsiderationConstants.sol"";\n\nimport {\n    InvalidMsgValue_error_selector,\n    InvalidMsgValue_error_length,\n    InvalidMsgValue_error_value_ptr,\n    NoReentrantCalls_error_selector,\n    NoReentrantCalls_error_length,\n    Error_selector_offset\n} from ""seaport-types/src/lib/ConsiderationErrorConstants.sol"";\n\n/**\n * @title ReentrancyGuard\n * @author 0age\n * @notice ReentrancyGuard contains a storage variable (or a transient storage\n *         variable in EVM environments that support it once activated) and\n *         related functionality for protecting against reentrancy.\n */\ncontract ReentrancyGuard is ReentrancyErrors, LowLevelHelpers {\n    // Declare an immutable variable to store the initial TSTORE support status.\n    bool private immutable _tstoreInitialSupport;\n\n    // Declare an immutable variable to store the tstore test contract address.\n    address private immutable _tloadTestContract;\n\n    /**\n     * @dev Initialize the reentrancy guard during deployment. This involves\n     *      attempting to deploy a contract that utilizes TLOAD as part of the\n     *      contract construction bytecode, and configuring initial support for\n     *      using TSTORE in place of SSTORE for the reentrancy lock based on the\n     *      result.\n     */\n    constructor() {\n        // Deploy the contract testing TLOAD support and store the address.\n        address tloadTestContract = _prepareTloadTest();\n\n        // Ensure the deployment was successful.\n        if (tloadTestContract == address(0)) {\n            revert TloadTestContractDeploymentFailed();\n        }\n\n        // Determine if TSTORE is supported.\n        bool tstoreInitialSupport = _testTload(tloadTestContract);\n\n        // Store the result as an immutable.\n        _tstoreInitialSupport = tstoreInitialSupport;\n\n        // Set the address of the deployed TLOAD test contract as an immutable.\n        _tloadTestContract = tloadTestContract;\n\n        // If not using TSTORE (where _NOT_ENTERED_TSTORE = 0), set initial\n        // sentinel value (where _NOT_ENTERED_SSTORE = 1).\n        if (!tstoreInitialSupport) {\n            // Initialize storage for the reentrancy guard in a cleared state.\n            assembly {\n                sstore(_REENTRANCY_GUARD_SLOT, _NOT_ENTERED_SSTORE)\n            }\n        }\n    }\n\n    /**\n     * @dev External function to activate TSTORE usage for the reentrancy guard.\n     *      Does not need to be called if TSTORE is supported from deployment,\n     *      and only needs to be called once. Reverts if TSTORE has already been\n     *      activated, if the opcode is not available, or if the reentrancy\n     *      guard is currently set.\n     */\n    function __activateTstore() external {\n        // Determine if TSTORE can potentially be activated. If it has already\n        // been activated, or if the reentrancy guard is currently set, then\n        // it cannot be activated.\n        bool tstoreActivatable;\n        assembly {\n            tstoreActivatable := eq(\n                sload(_REENTRANCY_GUARD_SLOT),\n                _NOT_ENTERED_SSTORE\n            )\n        }\n\n        // Revert if TSTORE is already activated or not activatable.\n        if (_tstoreInitialSupport || !tstoreActivatable) {\n            revert TStoreAlreadyActivated();\n        }\n\n        // Determine if TSTORE can be activated and revert if not.\n        if (!_testTload(_tloadTestContract)) {\n            revert TStoreNotSupported();\n        }\n\n        // Mark TSTORE as activated.\n        assembly {\n            sstore(_REENTRANCY_GUARD_SLOT, _TSTORE_ENABLED_SSTORE)\n        }\n    }\n\n    /**\n     * @dev Internal function to ensure that a sentinel value for the reentrancy\n     *      guard is not currently set and, if not, to set a sentinel value for\n     *      the reentrancy guard based on whether or not native tokens may be\n     *      received during execution or not.\n     *\n     * @param acceptNativeTokens A boolean indicating whether native tokens may\n     *                           be received during execution or not.\n     */\n    function _setReentrancyGuard(bool acceptNativeTokens) internal {\n        // Place immutable variable on the stack access within inline assembly.\n        bool tstoreInitialSupport = _tstoreInitialSupport;\n\n        // Utilize assembly to set the reentrancy guard based on tstore support.\n        assembly {\n            // ""Loop"" over three possible cases for setting the reentrancy guard\n            // based on tstore support and state, exiting once the respective\n            // state has been identified and a corresponding guard has been set.\n            for {} 1 {} {\n                // 1: handle case where tstore is supported from the start.\n                if tstoreInitialSupport {\n                    // Ensure that the reentrancy guard is not already set.\n                    if tload(_REENTRANCY_GUARD_SLOT) {\n                        // Store left-padded selector with push4,\n                        // mem[28:32] = selector\n                        mstore(0, NoReentrantCalls_error_selector)\n\n                        // revert(abi.encodeWithSignature(""NoReentrantCalls()""))\n                        revert(\n                            Error_selector_offset,\n                            NoReentrantCalls_error_length\n                        )\n                    }\n\n                    // Set the reentrancy guard. A value of 1 indicates that\n                    // native tokens may not be accepted during execution,\n                    // whereas a value of 2 indicates that they will be accepted\n                    // (returning any remaining native tokens to the caller).\n                    tstore(\n                        _REENTRANCY_GUARD_SLOT,\n                        add(_ENTERED_TSTORE, acceptNativeTokens)\n                    )\n\n                    // Exit the loop.\n                    break\n                }\n\n                // Retrieve the reentrancy guard sentinel value.\n                let reentrancyGuard := sload(_REENTRANCY_GUARD_SLOT)\n\n                // 2: handle tstore support that was activated post-deployment.\n                if iszero(reentrancyGuard) {\n                    // Ensure that the reentrancy guard is not already set.\n                    if tload(_REENTRANCY_GUARD_SLOT) {\n                        // Store left-padded selector with push4,\n                        // mem[28:32] = selector\n                        mstore(0, NoReentrantCalls_error_selector)\n\n                        // revert(abi.encodeWithSignature(""NoReentrantCalls()""))\n                        revert(\n                            Error_selector_offset,\n                            NoReentrantCalls_error_length\n                        )\n                    }\n\n                    // Set the reentrancy guard. A value of 1 indicates that\n                    // native tokens may not be accepted during execution,\n                    // whereas a value of 2 indicates that they will be accepted\n                    // (returning any remaining native tokens to the caller).\n                    tstore(\n                        _REENTRANCY_GUARD_SLOT,\n                        add(_ENTERED_TSTORE, acceptNativeTokens)\n                    )\n\n                    // Exit the loop.\n                    break\n                }\n\n                // 3: handle case where tstore support has not been activated.\n                // Ensure that the reentrancy guard is not already set.\n                if iszero(eq(reentrancyGuard, _NOT_ENTERED_SSTORE)) {\n                    // Store left-padded selector with push4 (reduces bytecode),\n                    // mem[28:32] = selector\n                    mstore(0, NoReentrantCalls_error_selector)\n\n                    // revert(abi.encodeWithSignature(""NoReentrantCalls()""))\n                    revert(Error_selector_offset, NoReentrantCalls_error_length)\n                }\n\n                // Set the reentrancy guard. A value of 2 indicates that native\n                // tokens may not be accepted during execution, whereas a value\n                // of 3 indicates that they will be accepted (with any remaining\n                // native tokens returned to the caller).\n                sstore(\n                    _REENTRANCY_GUARD_SLOT,\n                    add(_ENTERED_SSTORE, acceptNativeTokens)\n                )\n\n                // Exit the loop.\n                break\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function to unset the reentrancy guard sentinel value.\n     */\n    function _clearReentrancyGuard() internal {\n        // Place immutable variable on the stack access within inline assembly.\n        bool tstoreInitialSupport = _tstoreInitialSupport;\n\n        // Utilize assembly to clear reentrancy guard based on tstore support.\n        assembly {\n            // ""Loop"" over three possible cases for clearing reentrancy guard\n            // based on tstore support and state, exiting once the respective\n            // state has been identified and corresponding guard cleared.\n            for {} 1 {} {\n                // 1: handle case where tstore is supported from the start.\n                if tstoreInitialSupport {\n                    // Clear the reentrancy guard.\n                    tstore(_REENTRANCY_GUARD_SLOT, _NOT_ENTERED_TSTORE)\n\n                    // Exit the loop.\n                    break\n                }\n\n                // Retrieve the reentrancy guard sentinel value.\n                let reentrancyGuard := sload(_REENTRANCY_GUARD_SLOT)\n\n                // 2: handle tstore support that was activated post-deployment.\n                if iszero(reentrancyGuard) {\n                    // Clear the reentrancy guard.\n                    tstore(_REENTRANCY_GUARD_SLOT, _NOT_ENTERED_TSTORE)\n\n                    // Exit the loop.\n                    break\n                }\n\n                // 3: handle case where tstore support has not been activated.\n                // Clear the reentrancy guard.\n                sstore(_REENTRANCY_GUARD_SLOT, _NOT_ENTERED_SSTORE)\n\n                // Exit the loop.\n                break\n            }\n        }\n    }\n\n    /**\n     * @dev Internal view function to ensure that a sentinel value for the\n     *      reentrancy guard is not currently set.\n     */\n    function _assertNonReentrant() internal view {\n        // Place immutable variable on the stack access within inline assembly.\n        bool tstoreInitialSupport = _tstoreInitialSupport;\n\n        // Utilize assembly to check reentrancy guard based on tstore support.\n        assembly {\n            // 1: handle case where tstore is supported from the start.\n            if tstoreInitialSupport {\n                // Ensure that the reentrancy guard is not currently set.\n                if tload(_REENTRANCY_GUARD_SLOT) {\n                    // Store left-padded selector with push4,\n                    // mem[28:32] = selector\n                    mstore(0, NoReentrantCalls_error_selector)\n\n                    // revert(abi.encodeWithSignature(""NoReentrantCalls()""))\n                    revert(Error_selector_offset, NoReentrantCalls_error_length)\n                }\n            }\n\n            // Handle cases where tstore is not initially supported.\n            if iszero(tstoreInitialSupport) {\n                // Retrieve the reentrancy guard sentinel value.\n                let reentrancyGuard := sload(_REENTRANCY_GUARD_SLOT)\n\n                // 2: handle tstore support that was activated post-deployment.\n                if iszero(reentrancyGuard) {\n                    // Ensure that the reentrancy guard is not currently set.\n                    if tload(_REENTRANCY_GUARD_SLOT) {\n                        // Store left-padded selector with push4,\n                        // mem[28:32] = selector\n                        mstore(0, NoReentrantCalls_error_selector)\n\n                        // revert(abi.encodeWithSignature(""NoReentrantCalls()""))\n                        revert(\n                            Error_selector_offset,\n                            NoReentrantCalls_error_length\n                        )\n                    }\n                }\n\n                // 3: handle case where tstore support has not been activated.\n                // Ensure that the reentrancy guard is not currently set.\n                if gt(reentrancyGuard, _NOT_ENTERED_SSTORE) {\n                    // Store left-padded selector with push4 (reduces bytecode),\n                    // mem[28:32] = selector\n                    mstore(0, NoReentrantCalls_error_selector)\n\n                    // revert(abi.encodeWithSignature(""NoReentrantCalls()""))\n                    revert(Error_selector_offset, NoReentrantCalls_error_length)\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Internal view function to ensure that the sentinel value indicating\n     *      native tokens may be received during execution is currently set.\n     */\n    function _assertAcceptingNativeTokens() internal view {\n        // Place immutable variable on the stack access within inline assembly.\n        bool tstoreInitialSupport = _tstoreInitialSupport;\n\n        // Utilize assembly to check reentrancy guard based on tstore support.\n        assembly {\n            // 1: handle case where tstore is supported from the start.\n            if tstoreInitialSupport {\n                // Ensure reentrancy guard is set to accept native tokens.\n                if iszero(\n                    eq(\n                        tload(_REENTRANCY_GUARD_SLOT),\n                        _ENTERED_AND_ACCEPTING_NATIVE_TOKENS_TSTORE\n                    )\n                ) {\n                    // Store left-padded selector with push4,\n                    // mem[28:32] = selector\n                    mstore(0, InvalidMsgValue_error_selector)\n\n                    // Store argument.\n                    mstore(InvalidMsgValue_error_value_ptr, callvalue())\n\n                    // revert(abi.encodeWithSignature(\n                    //   ""InvalidMsgValue(uint256)"", value)\n                    // )\n                    revert(Error_selector_offset, InvalidMsgValue_error_length)\n                }\n            }\n\n            // Handle cases where tstore is not initially supported.\n            if iszero(tstoreInitialSupport) {\n                // Retrieve the reentrancy guard sentinel value.\n                let reentrancyGuard := sload(_REENTRANCY_GUARD_SLOT)\n\n                // 2: handle tstore support that was activated post-deployment.\n                if iszero(reentrancyGuard) {\n                    // Ensure reentrancy guard is set to accept native tokens.\n                    if iszero(\n                        eq(\n                            tload(_REENTRANCY_GUARD_SLOT),\n                            _ENTERED_AND_ACCEPTING_NATIVE_TOKENS_TSTORE\n                        )\n                    ) {\n                        // Store left-padded selector with push4,\n                        // mem[28:32] = selector\n                        mstore(0, InvalidMsgValue_error_selector)\n\n                        // Store argument.\n                        mstore(InvalidMsgValue_error_value_ptr, callvalue())\n\n                        // revert(abi.encodeWithSignature(\n                        //   ""InvalidMsgValue(uint256)"", value)\n                        // )\n                        revert(\n                            Error_selector_offset,\n                            InvalidMsgValue_error_length\n                        )\n                    }\n                }\n\n                // 3: handle case where tstore support has not been activated.\n                // Ensure reentrancy guard is set to accepting native tokens.\n                if and(\n                    iszero(iszero(reentrancyGuard)),\n                    iszero(\n                        eq(\n                            reentrancyGuard,\n                            _ENTERED_AND_ACCEPTING_NATIVE_TOKENS_SSTORE\n                        )\n                    )\n                ) {\n                    // Store left-padded selector with push4 (reduces bytecode),\n                    // mem[28:32] = selector\n                    mstore(0, InvalidMsgValue_error_selector)\n\n                    // Store argument.\n                    mstore(InvalidMsgValue_error_value_ptr, callvalue())\n\n                    // revert(abi.encodeWithSignature(\n                    //   ""InvalidMsgValue(uint256)"", value)\n                    // )\n                    revert(Error_selector_offset, InvalidMsgValue_error_length)\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Private function to deploy a test contract that utilizes TLOAD as\n     *      part of its fallback logic.\n     */\n    function _prepareTloadTest() private returns (address contractAddress) {\n        // Utilize assembly to deploy a contract testing TLOAD support.\n        assembly {\n            // Write the contract deployment code payload to scratch space.\n            mstore(0, _TLOAD_TEST_PAYLOAD)\n\n            // Deploy the contract.\n            contractAddress := create(\n                0,\n                _TLOAD_TEST_PAYLOAD_OFFSET,\n                _TLOAD_TEST_PAYLOAD_LENGTH\n            )\n        }\n    }\n\n    /**\n     * @dev Private view function to determine if TSTORE/TLOAD are supported by\n     *      the current EVM implementation by attempting to call the test\n     *      contract, which utilizes TLOAD as part of its fallback logic.\n     */\n    function _testTload(\n        address tloadTestContract\n    ) private view returns (bool ok) {\n        // Call the test contract, which will perform a TLOAD test. If the call\n        // does not revert, then TLOAD/TSTORE is supported. Do not forward all\n        // available gas, as all forwarded gas will be consumed on revert.\n        (ok, ) = tloadTestContract.staticcall{ gas: gasleft() / 10 }("""");\n    }\n}\n'}, 'lib/seaport-types/src/interfaces/ConduitControllerInterface.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n * @title ConduitControllerInterface\n * @author 0age\n * @notice ConduitControllerInterface contains all external function interfaces,\n *         structs, events, and errors for the conduit controller.\n */\ninterface ConduitControllerInterface {\n    /**\n     * @dev Track the conduit key, current owner, new potential owner, and open\n     *      channels for each deployed conduit.\n     */\n    struct ConduitProperties {\n        bytes32 key;\n        address owner;\n        address potentialOwner;\n        address[] channels;\n        mapping(address => uint256) channelIndexesPlusOne;\n    }\n\n    /**\n     * @dev Emit an event whenever a new conduit is created.\n     *\n     * @param conduit    The newly created conduit.\n     * @param conduitKey The conduit key used to create the new conduit.\n     */\n    event NewConduit(address conduit, bytes32 conduitKey);\n\n    /**\n     * @dev Emit an event whenever conduit ownership is transferred.\n     *\n     * @param conduit       The conduit for which ownership has been\n     *                      transferred.\n     * @param previousOwner The previous owner of the conduit.\n     * @param newOwner      The new owner of the conduit.\n     */\n    event OwnershipTransferred(\n        address indexed conduit,\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Emit an event whenever a conduit owner registers a new potential\n     *      owner for that conduit.\n     *\n     * @param newPotentialOwner The new potential owner of the conduit.\n     */\n    event PotentialOwnerUpdated(address indexed newPotentialOwner);\n\n    /**\n     * @dev Revert with an error when attempting to create a new conduit using a\n     *      conduit key where the first twenty bytes of the key do not match the\n     *      address of the caller.\n     */\n    error InvalidCreator();\n\n    /**\n     * @dev Revert with an error when attempting to create a new conduit when no\n     *      initial owner address is supplied.\n     */\n    error InvalidInitialOwner();\n\n    /**\n     * @dev Revert with an error when attempting to set a new potential owner\n     *      that is already set.\n     */\n    error NewPotentialOwnerAlreadySet(\n        address conduit,\n        address newPotentialOwner\n    );\n\n    /**\n     * @dev Revert with an error when attempting to cancel ownership transfer\n     *      when no new potential owner is currently set.\n     */\n    error NoPotentialOwnerCurrentlySet(address conduit);\n\n    /**\n     * @dev Revert with an error when attempting to interact with a conduit that\n     *      does not yet exist.\n     */\n    error NoConduit();\n\n    /**\n     * @dev Revert with an error when attempting to create a conduit that\n     *      already exists.\n     */\n    error ConduitAlreadyExists(address conduit);\n\n    /**\n     * @dev Revert with an error when attempting to update channels or transfer\n     *      ownership of a conduit when the caller is not the owner of the\n     *      conduit in question.\n     */\n    error CallerIsNotOwner(address conduit);\n\n    /**\n     * @dev Revert with an error when attempting to register a new potential\n     *      owner and supplying the null address.\n     */\n    error NewPotentialOwnerIsZeroAddress(address conduit);\n\n    /**\n     * @dev Revert with an error when attempting to claim ownership of a conduit\n     *      with a caller that is not the current potential owner for the\n     *      conduit in question.\n     */\n    error CallerIsNotNewPotentialOwner(address conduit);\n\n    /**\n     * @dev Revert with an error when attempting to retrieve a channel using an\n     *      index that is out of range.\n     */\n    error ChannelOutOfRange(address conduit);\n\n    /**\n     * @notice Deploy a new conduit using a supplied conduit key and assigning\n     *         an initial owner for the deployed conduit. Note that the first\n     *         twenty bytes of the supplied conduit key must match the caller\n     *         and that a new conduit cannot be created if one has already been\n     *         deployed using the same conduit key.\n     *\n     * @param conduitKey   The conduit key used to deploy the conduit. Note that\n     *                     the first twenty bytes of the conduit key must match\n     *                     the caller of this contract.\n     * @param initialOwner The initial owner to set for the new conduit.\n     *\n     * @return conduit The address of the newly deployed conduit.\n     */\n    function createConduit(\n        bytes32 conduitKey,\n        address initialOwner\n    ) external returns (address conduit);\n\n    /**\n     * @notice Open or close a channel on a given conduit, thereby allowing the\n     *         specified account to execute transfers against that conduit.\n     *         Extreme care must be taken when updating channels, as malicious\n     *         or vulnerable channels can transfer any ERC20, ERC721 and ERC1155\n     *         tokens where the token holder has granted the conduit approval.\n     *         Only the owner of the conduit in question may call this function.\n     *\n     * @param conduit The conduit for which to open or close the channel.\n     * @param channel The channel to open or close on the conduit.\n     * @param isOpen  A boolean indicating whether to open or close the channel.\n     */\n    function updateChannel(\n        address conduit,\n        address channel,\n        bool isOpen\n    ) external;\n\n    /**\n     * @notice Initiate conduit ownership transfer by assigning a new potential\n     *         owner for the given conduit. Once set, the new potential owner\n     *         may call `acceptOwnership` to claim ownership of the conduit.\n     *         Only the owner of the conduit in question may call this function.\n     *\n     * @param conduit The conduit for which to initiate ownership transfer.\n     * @param newPotentialOwner The new potential owner of the conduit.\n     */\n    function transferOwnership(\n        address conduit,\n        address newPotentialOwner\n    ) external;\n\n    /**\n     * @notice Clear the currently set potential owner, if any, from a conduit.\n     *         Only the owner of the conduit in question may call this function.\n     *\n     * @param conduit The conduit for which to cancel ownership transfer.\n     */\n    function cancelOwnershipTransfer(address conduit) external;\n\n    /**\n     * @notice Accept ownership of a supplied conduit. Only accounts that the\n     *         current owner has set as the new potential owner may call this\n     *         function.\n     *\n     * @param conduit The conduit for which to accept ownership.\n     */\n    function acceptOwnership(address conduit) external;\n\n    /**\n     * @notice Retrieve the current owner of a deployed conduit.\n     *\n     * @param conduit The conduit for which to retrieve the associated owner.\n     *\n     * @return owner The owner of the supplied conduit.\n     */\n    function ownerOf(address conduit) external view returns (address owner);\n\n    /**\n     * @notice Retrieve the conduit key for a deployed conduit via reverse\n     *         lookup.\n     *\n     * @param conduit The conduit for which to retrieve the associated conduit\n     *                key.\n     *\n     * @return conduitKey The conduit key used to deploy the supplied conduit.\n     */\n    function getKey(address conduit) external view returns (bytes32 conduitKey);\n\n    /**\n     * @notice Derive the conduit associated with a given conduit key and\n     *         determine whether that conduit exists (i.e. whether it has been\n     *         deployed).\n     *\n     * @param conduitKey The conduit key used to derive the conduit.\n     *\n     * @return conduit The derived address of the conduit.\n     * @return exists  A boolean indicating whether the derived conduit has been\n     *                 deployed or not.\n     */\n    function getConduit(\n        bytes32 conduitKey\n    ) external view returns (address conduit, bool exists);\n\n    /**\n     * @notice Retrieve the potential owner, if any, for a given conduit. The\n     *         current owner may set a new potential owner via\n     *         `transferOwnership` and that owner may then accept ownership of\n     *         the conduit in question via `acceptOwnership`.\n     *\n     * @param conduit The conduit for which to retrieve the potential owner.\n     *\n     * @return potentialOwner The potential owner, if any, for the conduit.\n     */\n    function getPotentialOwner(\n        address conduit\n    ) external view returns (address potentialOwner);\n\n    /**\n     * @notice Retrieve the status (either open or closed) of a given channel on\n     *         a conduit.\n     *\n     * @param conduit The conduit for which to retrieve the channel status.\n     * @param channel The channel for which to retrieve the status.\n     *\n     * @return isOpen The status of the channel on the given conduit.\n     */\n    function getChannelStatus(\n        address conduit,\n        address channel\n    ) external view returns (bool isOpen);\n\n    /**\n     * @notice Retrieve the total number of open channels for a given conduit.\n     *\n     * @param conduit The conduit for which to retrieve the total channel count.\n     *\n     * @return totalChannels The total number of open channels for the conduit.\n     */\n    function getTotalChannels(\n        address conduit\n    ) external view returns (uint256 totalChannels);\n\n    /**\n     * @notice Retrieve an open channel at a specific index for a given conduit.\n     *         Note that the index of a channel can change as a result of other\n     *         channels being closed on the conduit.\n     *\n     * @param conduit      The conduit for which to retrieve the open channel.\n     * @param channelIndex The index of the channel in question.\n     *\n     * @return channel The open channel, if any, at the specified channel index.\n     */\n    function getChannel(\n        address conduit,\n        uint256 channelIndex\n    ) external view returns (address channel);\n\n    /**\n     * @notice Retrieve all open channels for a given conduit. Note that calling\n     *         this function for a conduit with many channels will revert with\n     *         an out-of-gas error.\n     *\n     * @param conduit The conduit for which to retrieve open channels.\n     *\n     * @return channels An array of open channels on the given conduit.\n     */\n    function getChannels(\n        address conduit\n    ) external view returns (address[] memory channels);\n\n    /**\n     * @dev Retrieve the conduit creation code and runtime code hashes.\n     */\n    function getConduitCodeHashes()\n        external\n        view\n        returns (bytes32 creationCodeHash, bytes32 runtimeCodeHash);\n}\n'}, 'src/lib/ConsiderationDecoder.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {\n    AdvancedOrder,\n    ConsiderationItem,\n    CriteriaResolver,\n    Fulfillment,\n    FulfillmentComponent,\n    OfferItem,\n    Order,\n    OrderParameters,\n    ReceivedItem\n} from ""seaport-types/src/lib/ConsiderationStructs.sol"";\n\nimport {\n    AdvancedOrder_denominator_offset,\n    AdvancedOrder_extraData_offset,\n    AdvancedOrder_fixed_segment_0,\n    AdvancedOrder_head_size,\n    AdvancedOrder_numerator_offset,\n    AdvancedOrder_signature_offset,\n    AdvancedOrderPlusOrderParameters_head_size,\n    Common_amount_offset,\n    Common_endAmount_offset,\n    Common_identifier_offset,\n    Common_token_offset,\n    ConsiderationItem_recipient_offset,\n    ConsiderationItem_size_with_head_pointer,\n    ConsiderationItem_size,\n    CriteriaResolver_criteriaProof_offset,\n    CriteriaResolver_fixed_segment_0,\n    CriteriaResolver_head_size,\n    ThreeWords,\n    FreeMemoryPointerSlot,\n    Fulfillment_considerationComponents_offset,\n    Fulfillment_head_size,\n    FulfillmentComponent_mem_tail_size_shift,\n    FulfillmentComponent_mem_tail_size,\n    generateOrder_maximum_returned_array_length,\n    OfferItem_size_with_head_pointer,\n    OfferItem_size,\n    OneWord,\n    OneWordShift,\n    OnlyFullWordMask,\n    Order_head_size,\n    Order_signature_offset,\n    OrderComponents_OrderParameters_common_head_size,\n    OrderParameters_consideration_head_offset,\n    OrderParameters_head_size,\n    OrderParameters_offer_head_offset,\n    OrderParameters_totalOriginalConsiderationItems_offset,\n    ReceivedItem_recipient_offset,\n    ReceivedItem_size,\n    ReceivedItem_size_excluding_recipient,\n    SpentItem_size_shift,\n    SpentItem_size,\n    ThirtyOneBytes,\n    TwoWords\n} from ""seaport-types/src/lib/ConsiderationConstants.sol"";\n\nimport {\n    CalldataPointer,\n    malloc,\n    MemoryPointer,\n    OffsetOrLengthMask\n} from ""seaport-types/src/helpers/PointerLibraries.sol"";\n\ncontract ConsiderationDecoder {\n    /**\n     * @dev Takes a bytes array from calldata and copies it into memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the bytes array in\n     *                    calldata which contains the length of the array.\n     *\n     * @return mPtrLength A memory pointer to the start of the bytes array in\n     *                    memory which contains the length of the array.\n     */\n    function _decodeBytes(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        assembly {\n            // Get the current free memory pointer.\n            mPtrLength := mload(FreeMemoryPointerSlot)\n\n            // Derive the size of the bytes array, rounding up to nearest word\n            // and adding a word for the length field. Note: masking\n            // `calldataload(cdPtrLength)` is redundant here.\n            let size := add(\n                and(\n                    add(calldataload(cdPtrLength), ThirtyOneBytes),\n                    OnlyFullWordMask\n                ),\n                OneWord\n            )\n\n            // Copy bytes from calldata into memory based on pointers and size.\n            calldatacopy(mPtrLength, cdPtrLength, size)\n\n            // Store the masked value in memory. Note: the value of `size` is at\n            // least 32, meaning the calldatacopy above will at least write to\n            // `[mPtrLength, mPtrLength + 32)`.\n            mstore(\n                mPtrLength,\n                and(calldataload(cdPtrLength), OffsetOrLengthMask)\n            )\n\n            // Update free memory pointer based on the size of the bytes array.\n            mstore(FreeMemoryPointerSlot, add(mPtrLength, size))\n        }\n    }\n\n    /**\n     * @dev Takes an offer array from calldata and copies it into memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the offer array\n     *                    in calldata which contains the length of the array.\n     *\n     * @return mPtrLength A memory pointer to the start of the offer array in\n     *                    memory which contains the length of the array.\n     */\n    function _decodeOffer(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        assembly {\n            // Retrieve length of array, masking to prevent potential overflow.\n            let arrLength := and(calldataload(cdPtrLength), OffsetOrLengthMask)\n\n            // Get the current free memory pointer.\n            mPtrLength := mload(FreeMemoryPointerSlot)\n\n            // Write the array length to memory.\n            mstore(mPtrLength, arrLength)\n\n            // Derive the head by adding one word to the length pointer.\n            let mPtrHead := add(mPtrLength, OneWord)\n\n            // Derive the tail by adding one word per element (note that structs\n            // are written to memory with an offset per struct element).\n            let mPtrTail := add(mPtrHead, shl(OneWordShift, arrLength))\n\n            // Track the next tail, beginning with the initial tail value.\n            let mPtrTailNext := mPtrTail\n\n            // Copy all offer array data into memory at the tail pointer.\n            calldatacopy(\n                mPtrTail,\n                add(cdPtrLength, OneWord),\n                mul(arrLength, OfferItem_size)\n            )\n\n            // Track the next head pointer, starting with initial head value.\n            let mPtrHeadNext := mPtrHead\n\n            // Iterate over each head pointer until it reaches the tail.\n            for {\n\n            } lt(mPtrHeadNext, mPtrTail) {\n\n            } {\n                // Write the next tail pointer to next head pointer in memory.\n                mstore(mPtrHeadNext, mPtrTailNext)\n\n                // Increment the next head pointer by one word.\n                mPtrHeadNext := add(mPtrHeadNext, OneWord)\n\n                // Increment the next tail pointer by the size of an offer item.\n                mPtrTailNext := add(mPtrTailNext, OfferItem_size)\n            }\n\n            // Update free memory pointer to allocate memory up to end of tail.\n            mstore(FreeMemoryPointerSlot, mPtrTailNext)\n        }\n    }\n\n    /**\n     * @dev Takes a consideration array from calldata and copies it into memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the consideration\n     *                    array in calldata which contains the length of the\n     *                    array.\n     *\n     * @return mPtrLength A memory pointer to the start of the consideration\n     *                    array in memory which contains the length of the\n     *                    array.\n     */\n    function _decodeConsideration(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        assembly {\n            // Retrieve length of array, masking to prevent potential overflow.\n            let arrLength := and(calldataload(cdPtrLength), OffsetOrLengthMask)\n\n            // Get the current free memory pointer.\n            mPtrLength := mload(FreeMemoryPointerSlot)\n\n            // Write the array length to memory.\n            mstore(mPtrLength, arrLength)\n\n            // Derive the head by adding one word to the length pointer.\n            let mPtrHead := add(mPtrLength, OneWord)\n\n            // Derive the tail by adding one word per element (note that structs\n            // are written to memory with an offset per struct element).\n            let mPtrTail := add(mPtrHead, shl(OneWordShift, arrLength))\n\n            // Track the next tail, beginning with the initial tail value.\n            let mPtrTailNext := mPtrTail\n\n            // Copy all consideration array data into memory at tail pointer.\n            calldatacopy(\n                mPtrTail,\n                add(cdPtrLength, OneWord),\n                mul(arrLength, ConsiderationItem_size)\n            )\n\n            // Track the next head pointer, starting with initial head value.\n            let mPtrHeadNext := mPtrHead\n\n            // Iterate over each head pointer until it reaches the tail.\n            for {\n\n            } lt(mPtrHeadNext, mPtrTail) {\n\n            } {\n                // Write the next tail pointer to next head pointer in memory.\n                mstore(mPtrHeadNext, mPtrTailNext)\n\n                // Increment the next head pointer by one word.\n                mPtrHeadNext := add(mPtrHeadNext, OneWord)\n\n                // Increment next tail pointer by size of a consideration item.\n                mPtrTailNext := add(mPtrTailNext, ConsiderationItem_size)\n            }\n\n            // Update free memory pointer to allocate memory up to end of tail.\n            mstore(FreeMemoryPointerSlot, mPtrTailNext)\n        }\n    }\n\n    /**\n     * @dev Takes a calldata pointer and memory pointer and copies a referenced\n     *      OrderParameters struct and associated offer and consideration data\n     *      to memory.\n     *\n     * @param cdPtr A calldata pointer for the OrderParameters struct.\n     * @param mPtr A memory pointer to the OrderParameters struct head.\n     */\n    function _decodeOrderParametersTo(\n        CalldataPointer cdPtr,\n        MemoryPointer mPtr\n    ) internal pure {\n        // Copy the full OrderParameters head from calldata to memory.\n        cdPtr.copy(mPtr, OrderParameters_head_size);\n\n        // Resolve the offer calldata offset, use that to decode and copy offer\n        // from calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(OrderParameters_offer_head_offset).write(\n            _decodeOffer(cdPtr.pptrOffset(OrderParameters_offer_head_offset))\n        );\n\n        // Resolve consideration calldata offset, use that to copy consideration\n        // from calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(OrderParameters_consideration_head_offset).write(\n            _decodeConsideration(\n                cdPtr.pptrOffset(OrderParameters_consideration_head_offset)\n            )\n        );\n    }\n\n    /**\n     * @dev Takes a calldata pointer to an OrderParameters struct and copies the\n     *      decoded struct to memory.\n     *\n     * @param cdPtr A calldata pointer for the OrderParameters struct.\n     *\n     * @return mPtr A memory pointer to the OrderParameters struct head.\n     */\n    function _decodeOrderParameters(\n        CalldataPointer cdPtr\n    ) internal pure returns (MemoryPointer mPtr) {\n        // Allocate required memory for the OrderParameters head (offer and\n        // consideration are allocated independently).\n        mPtr = malloc(OrderParameters_head_size);\n\n        // Decode and copy the order parameters to the newly allocated memory.\n        _decodeOrderParametersTo(cdPtr, mPtr);\n    }\n\n    /**\n     * @dev Takes a calldata pointer to an Order struct and copies the decoded\n     *      struct to memory.\n     *\n     * @param cdPtr A calldata pointer for the Order struct.\n     *\n     * @return mPtr A memory pointer to the Order struct head.\n     */\n    function _decodeOrder(\n        CalldataPointer cdPtr\n    ) internal pure returns (MemoryPointer mPtr) {\n        // Allocate required memory for the Order head (OrderParameters and\n        // signature are allocated independently).\n        mPtr = malloc(Order_head_size);\n\n        // Resolve OrderParameters calldata offset, use it to decode and copy\n        // from calldata, and write resultant memory offset to head in memory.\n        mPtr.write(_decodeOrderParameters(cdPtr.pptr()));\n\n        // Resolve signature calldata offset, use that to decode and copy from\n        // calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(Order_signature_offset).write(\n            _decodeBytes(cdPtr.pptrOffset(Order_signature_offset))\n        );\n    }\n\n    /**\n     * @dev Takes a calldata pointer to an AdvancedOrder struct and copies the\n     *      decoded struct to memory.\n     *\n     * @param cdPtr A calldata pointer for the AdvancedOrder struct.\n     *\n     * @return mPtr A memory pointer to the AdvancedOrder struct head.\n     */\n    function _decodeAdvancedOrder(\n        CalldataPointer cdPtr\n    ) internal pure returns (MemoryPointer mPtr) {\n        // Allocate memory for AdvancedOrder head and OrderParameters head.\n        mPtr = malloc(AdvancedOrderPlusOrderParameters_head_size);\n\n        // Use numerator + denominator calldata offset to decode and copy\n        // from calldata and write resultant memory offset to head in memory.\n        cdPtr.offset(AdvancedOrder_numerator_offset).copy(\n            mPtr.offset(AdvancedOrder_numerator_offset),\n            AdvancedOrder_fixed_segment_0\n        );\n\n        // Get pointer to memory immediately after advanced order.\n        MemoryPointer mPtrParameters = mPtr.offset(AdvancedOrder_head_size);\n\n        // Write pptr for advanced order parameters to memory.\n        mPtr.write(mPtrParameters);\n\n        // Resolve OrderParameters calldata pointer & write to allocated region.\n        _decodeOrderParametersTo(cdPtr.pptr(), mPtrParameters);\n\n        // Resolve signature calldata offset, use that to decode and copy from\n        // calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(AdvancedOrder_signature_offset).write(\n            _decodeBytes(cdPtr.pptrOffset(AdvancedOrder_signature_offset))\n        );\n\n        // Resolve extraData calldata offset, use that to decode and copy from\n        // calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(AdvancedOrder_extraData_offset).write(\n            _decodeBytes(cdPtr.pptrOffset(AdvancedOrder_extraData_offset))\n        );\n    }\n\n    /**\n     * @dev Allocates a single word of empty bytes in memory and returns the\n     *      pointer to that memory region.\n     *\n     * @return mPtr The memory pointer to the new empty word in memory.\n     */\n    function _getEmptyBytesOrArray()\n        internal\n        pure\n        returns (MemoryPointer mPtr)\n    {\n        mPtr = malloc(OneWord);\n        mPtr.write(0);\n    }\n\n    /**\n     * @dev Takes a calldata pointer to an Order struct and copies the decoded\n     *      struct to memory as an AdvancedOrder.\n     *\n     * @param cdPtr A calldata pointer for the Order struct.\n     *\n     * @return mPtr A memory pointer to the AdvancedOrder struct head.\n     */\n    function _decodeOrderAsAdvancedOrder(\n        CalldataPointer cdPtr\n    ) internal pure returns (MemoryPointer mPtr) {\n        // Allocate memory for AdvancedOrder head and OrderParameters head.\n        mPtr = malloc(AdvancedOrderPlusOrderParameters_head_size);\n\n        // Get pointer to memory immediately after advanced order.\n        MemoryPointer mPtrParameters = mPtr.offset(AdvancedOrder_head_size);\n\n        // Write pptr for advanced order parameters.\n        mPtr.write(mPtrParameters);\n\n        // Resolve OrderParameters calldata pointer & write to allocated region.\n        _decodeOrderParametersTo(cdPtr.pptr(), mPtrParameters);\n\n        // Write default Order numerator and denominator values (i.e. 1/1).\n        mPtr.offset(AdvancedOrder_numerator_offset).write(1);\n        mPtr.offset(AdvancedOrder_denominator_offset).write(1);\n\n        // Resolve signature calldata offset, use that to decode and copy from\n        // calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(AdvancedOrder_signature_offset).write(\n            _decodeBytes(cdPtr.pptrOffset(Order_signature_offset))\n        );\n\n        // Resolve extraData calldata offset, use that to decode and copy from\n        // calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(AdvancedOrder_extraData_offset).write(\n            _getEmptyBytesOrArray()\n        );\n    }\n\n    /**\n     * @dev Takes a calldata pointer to an array of Order structs and copies the\n     *      decoded array to memory as an array of AdvancedOrder structs.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the orders array in\n     *                    calldata which contains the length of the array.\n     *\n     * @return mPtrLength A memory pointer to the start of the array of advanced\n     *                    orders in memory which contains length of the array.\n     */\n    function _decodeOrdersAsAdvancedOrders(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        // Retrieve length of array, masking to prevent potential overflow.\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\n\n        unchecked {\n            // Derive offset to the tail based on one word per array element.\n            uint256 tailOffset = arrLength << OneWordShift;\n\n            // Add one additional word for the length and allocate memory.\n            mPtrLength = malloc(tailOffset + OneWord);\n\n            // Write the length of the array to memory.\n            mPtrLength.write(arrLength);\n\n            // Advance to first memory & calldata pointers (e.g. after length).\n            MemoryPointer mPtrHead = mPtrLength.next();\n            CalldataPointer cdPtrHead = cdPtrLength.next();\n\n            // Iterate over each pointer, word by word, until tail is reached.\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\n                // Resolve Order calldata offset, use it to decode and copy from\n                // calldata, and write resultant AdvancedOrder offset to memory.\n                mPtrHead.offset(offset).write(\n                    _decodeOrderAsAdvancedOrder(cdPtrHead.pptrOffset(offset))\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Takes a calldata pointer to a criteria proof, or an array bytes32\n     *      types, and copies the decoded proof to memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the criteria proof\n     *                    in calldata which contains the length of the array.\n     *\n     * @return mPtrLength A memory pointer to the start of the criteria proof\n     *                    in memory which contains length of the array.\n     */\n    function _decodeCriteriaProof(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        // Retrieve length of array, masking to prevent potential overflow.\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\n\n        unchecked {\n            // Derive array size based on one word per array element and length.\n            uint256 arrSize = (arrLength + 1) << OneWordShift;\n\n            // Allocate memory equal to the array size.\n            mPtrLength = malloc(arrSize);\n\n            // Copy the array from calldata into memory.\n            cdPtrLength.copy(mPtrLength, arrSize);\n        }\n    }\n\n    /**\n     * @dev Takes a calldata pointer to a CriteriaResolver struct and copies the\n     *      decoded struct to memory.\n     *\n     * @param cdPtr A calldata pointer for the CriteriaResolver struct.\n     *\n     * @return mPtr A memory pointer to the CriteriaResolver struct head.\n     */\n    function _decodeCriteriaResolver(\n        CalldataPointer cdPtr\n    ) internal pure returns (MemoryPointer mPtr) {\n        // Allocate required memory for the CriteriaResolver head (the criteria\n        // proof bytes32 array is allocated independently).\n        mPtr = malloc(CriteriaResolver_head_size);\n\n        // Decode and copy order index, side, index, and identifier from\n        // calldata and write resultant memory offset to head in memory.\n        cdPtr.copy(mPtr, CriteriaResolver_fixed_segment_0);\n\n        // Resolve criteria proof calldata offset, use it to decode and copy\n        // from calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(CriteriaResolver_criteriaProof_offset).write(\n            _decodeCriteriaProof(\n                cdPtr.pptrOffset(CriteriaResolver_criteriaProof_offset)\n            )\n        );\n    }\n\n    /**\n     * @dev Takes an array of criteria resolvers from calldata and copies it\n     *      into memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the criteria\n     *                    resolver array in calldata which contains the length\n     *                    of the array.\n     *\n     * @return mPtrLength A memory pointer to the start of the criteria resolver\n     *                    array in memory which contains the length of the\n     *                    array.\n     */\n    function _decodeCriteriaResolvers(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        // Retrieve length of array, masking to prevent potential overflow.\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\n\n        unchecked {\n            // Derive offset to the tail based on one word per array element.\n            uint256 tailOffset = arrLength << OneWordShift;\n\n            // Add one additional word for the length and allocate memory.\n            mPtrLength = malloc(tailOffset + OneWord);\n\n            // Write the length of the array to memory.\n            mPtrLength.write(arrLength);\n\n            // Advance to first memory & calldata pointers (e.g. after length).\n            MemoryPointer mPtrHead = mPtrLength.next();\n            CalldataPointer cdPtrHead = cdPtrLength.next();\n\n            // Iterate over each pointer, word by word, until tail is reached.\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\n                // Resolve CriteriaResolver calldata offset, use it to decode\n                // and copy from calldata, and write resultant memory offset.\n                mPtrHead.offset(offset).write(\n                    _decodeCriteriaResolver(cdPtrHead.pptrOffset(offset))\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Takes an array of orders from calldata and copies it into memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the orders array in\n     *                    calldata which contains the length of the array.\n     *\n     * @return mPtrLength A memory pointer to the start of the orders array\n     *                    in memory which contains the length of the array.\n     */\n    function _decodeOrders(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        // Retrieve length of array, masking to prevent potential overflow.\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\n\n        unchecked {\n            // Derive offset to the tail based on one word per array element.\n            uint256 tailOffset = arrLength << OneWordShift;\n\n            // Add one additional word for the length and allocate memory.\n            mPtrLength = malloc(tailOffset + OneWord);\n\n            // Write the length of the array to memory.\n            mPtrLength.write(arrLength);\n\n            // Advance to first memory & calldata pointers (e.g. after length).\n            MemoryPointer mPtrHead = mPtrLength.next();\n            CalldataPointer cdPtrHead = cdPtrLength.next();\n\n            // Iterate over each pointer, word by word, until tail is reached.\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\n                // Resolve Order calldata offset, use it to decode and copy\n                // from calldata, and write resultant memory offset.\n                mPtrHead.offset(offset).write(\n                    _decodeOrder(cdPtrHead.pptrOffset(offset))\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Takes an array of fulfillment components from calldata and copies it\n     *      into memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the fulfillment\n     *                    components array in calldata which contains the length\n     *                    of the array.\n     *\n     * @return mPtrLength A memory pointer to the start of the fulfillment\n     *                    components array in memory which contains the length\n     *                    of the array.\n     */\n    function _decodeFulfillmentComponents(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        assembly {\n            let arrLength := and(calldataload(cdPtrLength), OffsetOrLengthMask)\n\n            // Get the current free memory pointer.\n            mPtrLength := mload(FreeMemoryPointerSlot)\n\n            mstore(mPtrLength, arrLength)\n            let mPtrHead := add(mPtrLength, OneWord)\n            let mPtrTail := add(mPtrHead, shl(OneWordShift, arrLength))\n            let mPtrTailNext := mPtrTail\n            calldatacopy(\n                mPtrTail,\n                add(cdPtrLength, OneWord),\n                shl(FulfillmentComponent_mem_tail_size_shift, arrLength)\n            )\n            let mPtrHeadNext := mPtrHead\n            for {\n\n            } lt(mPtrHeadNext, mPtrTail) {\n\n            } {\n                mstore(mPtrHeadNext, mPtrTailNext)\n                mPtrHeadNext := add(mPtrHeadNext, OneWord)\n                mPtrTailNext := add(\n                    mPtrTailNext,\n                    FulfillmentComponent_mem_tail_size\n                )\n            }\n\n            // Update the free memory pointer.\n            mstore(FreeMemoryPointerSlot, mPtrTailNext)\n        }\n    }\n\n    /**\n     * @dev Takes a nested array of fulfillment components from calldata and\n     *      copies it into memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the nested\n     *                    fulfillment components array in calldata which\n     *                    contains the length of the array.\n     *\n     * @return mPtrLength A memory pointer to the start of the nested\n     *                    fulfillment components array in memory which\n     *                    contains the length of the array.\n     */\n    function _decodeNestedFulfillmentComponents(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        // Retrieve length of array, masking to prevent potential overflow.\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\n\n        unchecked {\n            // Derive offset to the tail based on one word per array element.\n            uint256 tailOffset = arrLength << OneWordShift;\n\n            // Add one additional word for the length and allocate memory.\n            mPtrLength = malloc(tailOffset + OneWord);\n\n            // Write the length of the array to memory.\n            mPtrLength.write(arrLength);\n\n            // Advance to first memory & calldata pointers (e.g. after length).\n            MemoryPointer mPtrHead = mPtrLength.next();\n            CalldataPointer cdPtrHead = cdPtrLength.next();\n\n            // Iterate over each pointer, word by word, until tail is reached.\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\n                // Resolve FulfillmentComponents array calldata offset, use it\n                // to decode and copy from calldata, and write memory offset.\n                mPtrHead.offset(offset).write(\n                    _decodeFulfillmentComponents(cdPtrHead.pptrOffset(offset))\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Takes an array of advanced orders from calldata and copies it into\n     *      memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the advanced orders\n     *                    array in calldata which contains the length of the\n     *                    array.\n     *\n     * @return mPtrLength A memory pointer to the start of the advanced orders\n     *                    array in memory which contains the length of the\n     *                    array.\n     */\n    function _decodeAdvancedOrders(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        // Retrieve length of array, masking to prevent potential overflow.\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\n\n        unchecked {\n            // Derive offset to the tail based on one word per array element.\n            uint256 tailOffset = arrLength << OneWordShift;\n\n            // Add one additional word for the length and allocate memory.\n            mPtrLength = malloc(tailOffset + OneWord);\n\n            // Write the length of the array to memory.\n            mPtrLength.write(arrLength);\n\n            // Advance to first memory & calldata pointers (e.g. after length).\n            MemoryPointer mPtrHead = mPtrLength.next();\n            CalldataPointer cdPtrHead = cdPtrLength.next();\n\n            // Iterate over each pointer, word by word, until tail is reached.\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\n                // Resolve AdvancedOrder calldata offset, use it to decode and\n                // copy from calldata, and write resultant memory offset.\n                mPtrHead.offset(offset).write(\n                    _decodeAdvancedOrder(cdPtrHead.pptrOffset(offset))\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Takes a calldata pointer to a Fulfillment struct and copies the\n     *      decoded struct to memory.\n     *\n     * @param cdPtr A calldata pointer for the Fulfillment struct.\n     *\n     * @return mPtr A memory pointer to the Fulfillment struct head.\n     */\n    function _decodeFulfillment(\n        CalldataPointer cdPtr\n    ) internal pure returns (MemoryPointer mPtr) {\n        // Allocate required memory for the Fulfillment head (the fulfillment\n        // components arrays are allocated independently).\n        mPtr = malloc(Fulfillment_head_size);\n\n        // Resolve offerComponents calldata offset, use it to decode and copy\n        // from calldata, and write resultant memory offset to head in memory.\n        mPtr.write(_decodeFulfillmentComponents(cdPtr.pptr()));\n\n        // Resolve considerationComponents calldata offset, use it to decode and\n        // copy from calldata, and write resultant memory offset to memory head.\n        mPtr.offset(Fulfillment_considerationComponents_offset).write(\n            _decodeFulfillmentComponents(\n                cdPtr.pptrOffset(Fulfillment_considerationComponents_offset)\n            )\n        );\n    }\n\n    /**\n     * @dev Takes an array of fulfillments from calldata and copies it into\n     *      memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the fulfillments\n     *                    array in calldata which contains the length of the\n     *                    array.\n     *\n     * @return mPtrLength A memory pointer to the start of the fulfillments\n     *                    array in memory which contains the length of the\n     *                    array.\n     */\n    function _decodeFulfillments(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        // Retrieve length of array, masking to prevent potential overflow.\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\n\n        unchecked {\n            // Derive offset to the tail based on one word per array element.\n            uint256 tailOffset = arrLength << OneWordShift;\n\n            // Add one additional word for the length and allocate memory.\n            mPtrLength = malloc(tailOffset + OneWord);\n\n            // Write the length of the array to memory.\n            mPtrLength.write(arrLength);\n\n            // Advance to first memory & calldata pointers (e.g. after length).\n            MemoryPointer mPtrHead = mPtrLength.next();\n            CalldataPointer cdPtrHead = cdPtrLength.next();\n\n            // Iterate over each pointer, word by word, until tail is reached.\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\n                // Resolve Fulfillment calldata offset, use it to decode and\n                // copy from calldata, and write resultant memory offset.\n                mPtrHead.offset(offset).write(\n                    _decodeFulfillment(cdPtrHead.pptrOffset(offset))\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Takes a calldata pointer to an OrderComponents struct and copies the\n     *      decoded struct to memory as an OrderParameters struct (with the\n     *      totalOriginalConsiderationItems value set equal to the length of the\n     *      supplied consideration array).\n     *\n     * @param cdPtr A calldata pointer for the OrderComponents struct.\n     *\n     * @return mPtr A memory pointer to the OrderParameters struct head.\n     */\n    function _decodeOrderComponentsAsOrderParameters(\n        CalldataPointer cdPtr\n    ) internal pure returns (MemoryPointer mPtr) {\n        // Allocate memory for the OrderParameters head.\n        mPtr = malloc(OrderParameters_head_size);\n\n        // Copy the full OrderComponents head from calldata to memory.\n        cdPtr.copy(mPtr, OrderComponents_OrderParameters_common_head_size);\n\n        // Resolve the offer calldata offset, use that to decode and copy offer\n        // from calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(OrderParameters_offer_head_offset).write(\n            _decodeOffer(cdPtr.pptrOffset(OrderParameters_offer_head_offset))\n        );\n\n        // Resolve consideration calldata offset, use that to copy consideration\n        // from calldata, and write resultant memory offset to head in memory.\n        MemoryPointer consideration = _decodeConsideration(\n            cdPtr.pptrOffset(OrderParameters_consideration_head_offset)\n        );\n        mPtr.offset(OrderParameters_consideration_head_offset).write(\n            consideration\n        );\n\n        // Write masked consideration length to totalOriginalConsiderationItems.\n        mPtr\n            .offset(OrderParameters_totalOriginalConsiderationItems_offset)\n            .write(consideration.readUint256());\n    }\n\n    /**\n     * @dev Decodes the returndata from a call to generateOrder, or returns\n     *      empty arrays and a boolean signifying that the returndata does not\n     *      adhere to a valid encoding scheme if it cannot be decoded. Note\n     *      that this function expects that original offer and consideration\n     *      item arrays have been modified and repurposed to resemble spent\n     *      and received item arrays; specifically, the recipient should be\n     *      in the endAmount location on consideration items and the derived\n     *      amount should be in the startAmount location for both item types.\n     *\n     * @return invalidEncoding A boolean signifying whether the returndata has\n     *                         an invalid encoding.\n     * @return offer           The decoded offer array.\n     * @return consideration   The decoded consideration array.\n     */\n    function _decodeGenerateOrderReturndata(\n        MemoryPointer originalOffer,\n        MemoryPointer originalConsideration\n    )\n        internal\n        pure\n        returns (\n            uint256 invalidEncoding,\n            MemoryPointer offer,\n            MemoryPointer consideration\n        )\n    {\n        assembly {\n            // Check that returndatasize is at least three words:\n            // 1. offerOffset\n            // 2. considerationOffset\n            // 3. offerLength & considerationLength might occupy just one word\n            //    if offerOffset & considerationOffset would point to the same\n            //    offset and the arrays have length 0.\n            invalidEncoding := lt(returndatasize(), ThreeWords)\n\n            let offsetOffer\n            let offsetConsideration\n            let offerLength\n            let considerationLength\n\n            // Proceed if enough returndata is present to continue evaluation.\n            if iszero(invalidEncoding) {\n                // Copy first two words of returndata (the offsets to offer and\n                // consideration array lengths) to scratch space.\n                returndatacopy(0, 0, TwoWords)\n                offsetOffer := mload(0)\n                offsetConsideration := mload(OneWord)\n\n                // If valid length, check that offsets word boundaries are\n                // within returndata.\n                let invalidOfferOffset := gt(\n                    add(offsetOffer, OneWord),\n                    returndatasize()\n                )\n                let invalidConsiderationOffset := gt(\n                    add(offsetConsideration, OneWord),\n                    returndatasize()\n                )\n\n                // Only proceed if length (and thus encoding) is valid so far.\n                invalidEncoding := or(\n                    invalidOfferOffset,\n                    invalidConsiderationOffset\n                )\n                if iszero(invalidEncoding) {\n                    // Copy length of offer array to scratch space.\n                    returndatacopy(0, offsetOffer, OneWord)\n                    offerLength := mload(0)\n\n                    // Copy length of consideration array to scratch space.\n                    returndatacopy(OneWord, offsetConsideration, OneWord)\n                    considerationLength := mload(OneWord)\n\n                    {\n                        // Derive end offsets for offer & consideration arrays.\n                        let offerEndOffset := add(\n                            add(offsetOffer, OneWord),\n                            shl(SpentItem_size_shift, offerLength)\n                        )\n                        let considerationEndOffset := add(\n                            add(offsetConsideration, OneWord),\n                            mul(ReceivedItem_size, considerationLength)\n                        )\n\n                        // Don\'t continue if either offer or consideration\n                        // length exceeds 65535 or if returndatasize is less\n                        // than the end offsets.\n                        invalidEncoding := or(\n                            gt(\n                                or(offerLength, considerationLength),\n                                generateOrder_maximum_returned_array_length\n                            ),\n                            or(\n                                lt(returndatasize(), offerEndOffset),\n                                lt(returndatasize(), considerationEndOffset)\n                            )\n                        )\n\n                        // Set first word of scratch space to 0 so length of\n                        // offer/consideration are set to 0 on invalid encoding.\n                        mstore(0, 0)\n                    }\n                }\n            }\n\n            if iszero(invalidEncoding) {\n                let invalidSpentItems, invalidReceivedItems\n                offer, invalidSpentItems := copySpentItemsAsOfferItems(\n                    originalOffer,\n                    add(offsetOffer, OneWord),\n                    offerLength\n                )\n\n                consideration, invalidReceivedItems :=\n                    copyReceivedItemsAsConsiderationItems(\n                        originalConsideration,\n                        add(offsetConsideration, OneWord),\n                        considerationLength\n                    )\n\n                invalidEncoding := or(invalidSpentItems, invalidReceivedItems)\n            }\n\n            function copySpentItemsAsOfferItems(\n                mPtrLengthOriginal,\n                rdPtrHeadSpentItems,\n                length\n            ) -> mPtrLength, invalidSpentItems {\n                // Retrieve the current free memory pointer.\n                mPtrLength := mload(FreeMemoryPointerSlot)\n\n                // Cache the original offer array length\n                let originalOfferLength := mload(mPtrLengthOriginal)\n\n                // Allocate memory for the new array.\n                mstore(\n                    FreeMemoryPointerSlot,\n                    add(\n                        mPtrLength,\n                        add(\n                            OneWord,\n                            mul(length, OfferItem_size_with_head_pointer)\n                        )\n                    )\n                )\n\n                // Write the length of the array to the start of free memory.\n                mstore(mPtrLength, length)\n\n                // Use offset from length to minimize stack depth.\n                let headOffsetFromLength := OneWord\n                let headSizeWithLength := shl(OneWordShift, add(1, length))\n                let mPtrTailNext := add(mPtrLength, headSizeWithLength)\n                let mPtrTailOriginalNext := add(\n                    mPtrLengthOriginal,\n                    shl(OneWordShift, add(1, originalOfferLength))\n                )\n\n                let headSizeToCompareWithLength := shl(\n                    OneWordShift,\n                    add(1, min(length, originalOfferLength))\n                )\n\n                // Iterate over each new element with a corresponding original\n                // item. For each original offer item, check that:\n                // - There is a corresponding new spent item.\n                // - The original and new items match with compareItems.\n                // - The new offer item amount >= original amount.\n                invalidSpentItems := gt(originalOfferLength, length)\n                for {\n\n                } lt(headOffsetFromLength, headSizeToCompareWithLength) {\n\n                } {\n                    // Write the memory pointer to the accompanying head offset.\n                    mstore(add(mPtrLength, headOffsetFromLength), mPtrTailNext)\n\n                    // Copy itemType, token, identifier and amount.\n                    returndatacopy(\n                        mPtrTailNext,\n                        rdPtrHeadSpentItems,\n                        SpentItem_size\n                    )\n\n                    let newAmount := mload(\n                        add(mPtrTailNext, Common_amount_offset)\n                    )\n\n                    // Copy amount to endAmount.\n                    mstore(\n                        add(mPtrTailNext, Common_endAmount_offset),\n                        newAmount\n                    )\n\n                    let originalAmount := mload(\n                        add(mPtrTailOriginalNext, Common_amount_offset)\n                    )\n                    invalidSpentItems := or(\n                        invalidSpentItems,\n                        or(\n                            compareItems(mPtrTailOriginalNext, mPtrTailNext),\n                            gt(originalAmount, newAmount)\n                        )\n                    )\n\n                    // Update read pointer, next tail pointer for new and\n                    // original, and head offset.\n                    rdPtrHeadSpentItems := add(\n                        rdPtrHeadSpentItems,\n                        SpentItem_size\n                    )\n                    mPtrTailNext := add(mPtrTailNext, OfferItem_size)\n                    mPtrTailOriginalNext := add(\n                        mPtrTailOriginalNext,\n                        OfferItem_size\n                    )\n                    headOffsetFromLength := add(headOffsetFromLength, OneWord)\n                }\n\n                // Iterate over each element without corresponding original item\n                for {\n\n                } lt(headOffsetFromLength, headSizeWithLength) {\n\n                } {\n                    // Write the memory pointer to the accompanying head offset.\n                    mstore(add(mPtrLength, headOffsetFromLength), mPtrTailNext)\n\n                    // Copy itemType, token, identifier and amount.\n                    returndatacopy(\n                        mPtrTailNext,\n                        rdPtrHeadSpentItems,\n                        SpentItem_size\n                    )\n\n                    // Copy amount to endAmount.\n                    mstore(\n                        add(mPtrTailNext, Common_endAmount_offset),\n                        mload(add(mPtrTailNext, Common_amount_offset))\n                    )\n\n                    // Update read pointer, next tail pointer, and head offset.\n                    rdPtrHeadSpentItems := add(\n                        rdPtrHeadSpentItems,\n                        SpentItem_size\n                    )\n                    mPtrTailNext := add(mPtrTailNext, OfferItem_size)\n                    headOffsetFromLength := add(headOffsetFromLength, OneWord)\n                }\n            }\n\n            function copyReceivedItemsAsConsiderationItems(\n                mPtrLengthOriginal,\n                rdPtrHeadReceivedItems,\n                length\n            ) -> mPtrLength, invalidReceivedItems {\n                // Retrieve the current free memory pointer.\n                mPtrLength := mload(FreeMemoryPointerSlot)\n                // Cache the original consideration array length\n                let originalConsiderationLength := mload(mPtrLengthOriginal)\n\n                // Ensure returned array length does not exceed original length.\n                invalidReceivedItems := gt(length, originalConsiderationLength)\n\n                // Derive the length of the new array in memory, capped by the\n                // original consideration array length.\n                let newLength := min(length, originalConsiderationLength)\n\n                // Allocate memory for the array. Note that memory does not need\n                // to be allocated for new elements without a corresponding\n                // original item as the new array will be invalid if its length\n                // exceeds the original array length.\n                mstore(\n                    FreeMemoryPointerSlot,\n                    add(\n                        mPtrLength,\n                        add(\n                            OneWord,\n                            mul(\n                                newLength,\n                                ConsiderationItem_size_with_head_pointer\n                            )\n                        )\n                    )\n                )\n\n                // Write the length of the array to the start of free memory.\n                mstore(mPtrLength, newLength)\n\n                // Use offset from length to minimize stack depth.\n                let headOffsetFromLength := OneWord\n                let mPtrTailNext := add(\n                    mPtrLength,\n                    shl(OneWordShift, add(1, newLength))\n                )\n                let mPtrTailOriginalNext := add(\n                    mPtrLengthOriginal,\n                    shl(OneWordShift, add(1, originalConsiderationLength))\n                )\n\n                let headSizeToCompareWithLength := shl(\n                    OneWordShift,\n                    add(1, newLength)\n                )\n\n                // Iterate over each new element with a corresponding original\n                // item. For each new received item, check that:\n                // - The new & original items match according to compareItems.\n                // - The new consideration item amount <= the original amount.\n                // - The items have the same recipient if original != null.\n                for {\n\n                } lt(headOffsetFromLength, headSizeToCompareWithLength) {\n\n                } {\n                    // Write the memory pointer to the accompanying head offset.\n                    mstore(add(mPtrLength, headOffsetFromLength), mPtrTailNext)\n\n                    // Copy itemType, token, identifier, amount and recipient.\n                    returndatacopy(\n                        mPtrTailNext,\n                        rdPtrHeadReceivedItems,\n                        ReceivedItem_size\n                    )\n\n                    // Copy amount to consideration item\'s recipient offset.\n                    returndatacopy(\n                        add(mPtrTailNext, ConsiderationItem_recipient_offset),\n                        add(rdPtrHeadReceivedItems, Common_amount_offset),\n                        OneWord\n                    )\n\n                    // Retrieve both the new and original item amounts.\n                    let newAmount := mload(\n                        add(mPtrTailNext, Common_amount_offset)\n                    )\n                    let originalAmount := mload(\n                        add(mPtrTailOriginalNext, Common_amount_offset)\n                    )\n\n                    // Compare items\' item type, token, and identifier, ensure\n                    // they have the same recipient and that the new amount is\n                    // less than or equal to the original amount. The original\n                    // recipient must already be present at the ReceivedItem\n                    // recipient offset rather than at the initial\n                    // ConsiderationItem recipient offset.\n                    invalidReceivedItems := or(\n                        invalidReceivedItems,\n                        or(\n                            compareItems(mPtrTailOriginalNext, mPtrTailNext),\n                            or(\n                                gt(newAmount, originalAmount),\n                                checkRecipients(\n                                    mload(\n                                        add(\n                                            mPtrTailOriginalNext,\n                                            ReceivedItem_recipient_offset\n                                        )\n                                    ),\n                                    mload(\n                                        add(\n                                            mPtrTailNext,\n                                            ReceivedItem_recipient_offset\n                                        )\n                                    )\n                                )\n                            )\n                        )\n                    )\n\n                    // Update read pointer, next tail pointer, and head offset.\n                    rdPtrHeadReceivedItems := add(\n                        rdPtrHeadReceivedItems,\n                        ReceivedItem_size\n                    )\n                    mPtrTailNext := add(mPtrTailNext, ConsiderationItem_size)\n                    mPtrTailOriginalNext := add(\n                        mPtrTailOriginalNext,\n                        ConsiderationItem_size\n                    )\n                    headOffsetFromLength := add(headOffsetFromLength, OneWord)\n                }\n\n                // Note: skip copying new elements without a corresponding\n                // original item as the new array will be invalid if its length\n                // exceeds the original array length.\n            }\n\n            /**\n             * @dev Yul function to check the compatibility of two offer or\n             *      consideration items for contract orders.  Note that the\n             *      itemType and identifier are reset in cases where criteria is\n             *      equal to 0 (collection-wide or ""wildcard"" items), which\n             *      means that a contract offerer has full latitude to choose\n             *      any identifier it wants mid-flight, in contrast to the usual\n             *      behavior, where the fulfiller can pick which identifier to\n             *      receive by providing a CriteriaResolver.\n             *\n             * @param originalItem The original offer or consideration item.\n             * @param newItem      The new offer or consideration item.\n             *\n             * @return isInvalid Error buffer indicating whether or not the\n             *                   items are incompatible.\n             */\n            function compareItems(originalItem, newItem) -> isInvalid {\n                let itemType := mload(originalItem)\n                let identifier := mload(\n                    add(originalItem, Common_identifier_offset)\n                )\n\n                // Use returned identifier for criteria-based items with a\n                // criteria value of 0 (collection-wide or ""wildcard"" items).\n                if and(gt(itemType, 3), iszero(identifier)) {\n                    // Replace item type with non-criteria equivalent.\n                    itemType := sub(itemType, 2)\n\n                    // Replace identifier with the returned identifier.\n                    identifier := mload(add(newItem, Common_identifier_offset))\n                }\n\n                isInvalid := iszero(\n                    and(\n                        // originalItem.token == newItem.token &&\n                        // originalItem.itemType == newItem.itemType\n                        and(\n                            eq(\n                                mload(add(originalItem, Common_token_offset)),\n                                mload(add(newItem, Common_token_offset))\n                            ),\n                            eq(itemType, mload(newItem))\n                        ),\n                        // originalItem.identifier == newItem.identifier\n                        eq(\n                            identifier,\n                            mload(add(newItem, Common_identifier_offset))\n                        )\n                    )\n                )\n            }\n\n            /**\n             * @dev Internal pure function to check the compatibility of two\n             *      recipients on consideration items for contract orders. This\n             *      check is skipped if no recipient is originally supplied.\n             *\n             * @param originalRecipient The original consideration item\n             *                          recipient.\n             * @param newRecipient      The new consideration item recipient.\n             *\n             * @return isInvalid Error buffer indicating whether or not the\n             *                   two recipients are incompatible.\n             */\n            function checkRecipients(originalRecipient, newRecipient)\n                -> isInvalid\n            {\n                isInvalid := iszero(\n                    or(\n                        iszero(originalRecipient),\n                        eq(newRecipient, originalRecipient)\n                    )\n                )\n            }\n\n            function min(a, b) -> c {\n                c := add(b, mul(lt(a, b), sub(a, b)))\n            }\n        }\n    }\n\n    /**\n     * @dev Converts a function returning _decodeGenerateOrderReturndata types\n     *      into a function returning offer and consideration types.\n     *\n     * @param inFn The input function, taking no arguments and returning an\n     *             error buffer, spent item array, and received item array.\n     *\n     * @return outFn The output function, taking no arguments and returning an\n     *               error buffer, offer array, and consideration array.\n     */\n    function _convertGetGeneratedOrderResult(\n        function(MemoryPointer, MemoryPointer)\n            internal\n            pure\n            returns (uint256, MemoryPointer, MemoryPointer) inFn\n    )\n        internal\n        pure\n        returns (\n            function(OfferItem[] memory, ConsiderationItem[] memory)\n                internal\n                pure\n                returns (\n                    uint256,\n                    OfferItem[] memory,\n                    ConsiderationItem[] memory\n                ) outFn\n        )\n    {\n        assembly {\n            outFn := inFn\n        }\n    }\n\n    /**\n     * @dev Converts a function taking ReceivedItem, address, bytes32, and bytes\n     *      types (e.g. the _transfer function) into a function taking\n     *      OfferItem, address, bytes32, and bytes types.\n     *\n     * @param inFn The input function, taking ReceivedItem, address, bytes32,\n     *             and bytes types (e.g. the _transfer function).\n     *\n     * @return outFn The output function, taking OfferItem, address, bytes32,\n     *               and bytes types.\n     */\n    function _toOfferItemInput(\n        function(ReceivedItem memory, address, bytes32, bytes memory)\n            internal inFn\n    )\n        internal\n        pure\n        returns (\n            function(OfferItem memory, address, bytes32, bytes memory)\n                internal outFn\n        )\n    {\n        assembly {\n            outFn := inFn\n        }\n    }\n\n    /**\n     * @dev Converts a function taking ReceivedItem, address, bytes32, and bytes\n     *      types (e.g. the _transfer function) into a function taking\n     *      ConsiderationItem, address, bytes32, and bytes types.\n     *\n     * @param inFn The input function, taking ReceivedItem, address, bytes32,\n     *             and bytes types (e.g. the _transfer function).\n     *\n     * @return outFn The output function, taking ConsiderationItem, address,\n     *               bytes32, and bytes types.\n     */\n    function _toConsiderationItemInput(\n        function(ReceivedItem memory, address, bytes32, bytes memory)\n            internal inFn\n    )\n        internal\n        pure\n        returns (\n            function(ConsiderationItem memory, address, bytes32, bytes memory)\n                internal outFn\n        )\n    {\n        assembly {\n            outFn := inFn\n        }\n    }\n\n    /**\n     * @dev Converts a function taking a calldata pointer and returning a memory\n     *      pointer into a function taking that calldata pointer and returning\n     *      a bytes type.\n     *\n     * @param inFn The input function, taking an arbitrary calldata pointer and\n     *             returning an arbitrary memory pointer.\n     *\n     * @return outFn The output function, taking an arbitrary calldata pointer\n     *               and returning a bytes type.\n     */\n    function _toBytesReturnType(\n        function(CalldataPointer) internal pure returns (MemoryPointer) inFn\n    )\n        internal\n        pure\n        returns (\n            function(CalldataPointer) internal pure returns (bytes memory) outFn\n        )\n    {\n        assembly {\n            outFn := inFn\n        }\n    }\n\n    /**\n     * @dev Converts a function taking a calldata pointer and returning a memory\n     *      pointer into a function taking that calldata pointer and returning\n     *      an OrderParameters type.\n     *\n     * @param inFn The input function, taking an arbitrary calldata pointer and\n     *             returning an arbitrary memory pointer.\n     *\n     * @return outFn The output function, taking an arbitrary calldata pointer\n     *               and returning an OrderParameters type.\n     */\n    function _toOrderParametersReturnType(\n        function(CalldataPointer) internal pure returns (MemoryPointer) inFn\n    )\n        internal\n        pure\n        returns (\n            function(CalldataPointer)\n                internal\n                pure\n                returns (OrderParameters memory) outFn\n        )\n    {\n        assembly {\n            outFn := inFn\n        }\n    }\n\n    /**\n     * @dev Converts a function taking a calldata pointer and returning a memory\n     *      pointer into a function taking that calldata pointer and returning\n     *      an AdvancedOrder type.\n     *\n     * @param inFn The input function, taking an arbitrary calldata pointer and\n     *             returning an arbitrary memory pointer.\n     *\n     * @return outFn The output function, taking an arbitrary calldata pointer\n     *               and returning an AdvancedOrder type.\n     */\n    function _toAdvancedOrderReturnType(\n        function(CalldataPointer) internal pure returns (MemoryPointer) inFn\n    )\n        internal\n        pure\n        returns (\n            function(CalldataPointer)\n                internal\n                pure\n                returns (AdvancedOrder memory) outFn\n        )\n    {\n        assembly {\n            outFn := inFn\n        }\n    }\n\n    /**\n     * @dev Converts a function taking a calldata pointer and returning a memory\n     *      pointer into a function taking that calldata pointer and returning\n     *      a dynamic array of CriteriaResolver types.\n     *\n     * @param inFn The input function, taking an arbitrary calldata pointer and\n     *             returning an arbitrary memory pointer.\n     *\n     * @return outFn The output function, taking an arbitrary calldata pointer\n     *               and returning a dynamic array of CriteriaResolver types.\n     */\n    function _toCriteriaResolversReturnType(\n        function(CalldataPointer) internal pure returns (MemoryPointer) inFn\n    )\n        internal\n        pure\n        returns (\n            function(CalldataPointer)\n                internal\n                pure\n                returns (CriteriaResolver[] memory) outFn\n        )\n    {\n        assembly {\n            outFn := inFn\n        }\n    }\n\n    /**\n     * @dev Converts a function taking a calldata pointer and returning a memory\n     *      pointer into a function taking that calldata pointer and returning\n     *      a dynamic array of Order types.\n     *\n     * @param inFn The input function, taking an arbitrary calldata pointer and\n     *             returning an arbitrary memory pointer.\n     *\n     * @return outFn The output function, taking an arbitrary calldata pointer\n     *               and returning a dynamic array of Order types.\n     */\n    function _toOrdersReturnType(\n        function(CalldataPointer) internal pure returns (MemoryPointer) inFn\n    )\n        internal\n        pure\n        returns (\n            function(CalldataPointer)\n                internal\n                pure\n                returns (Order[] memory) outFn\n        )\n    {\n        assembly {\n            outFn := inFn\n        }\n    }\n\n    /**\n     * @dev Converts a function taking a calldata pointer and returning a memory\n     *      pointer into a function taking that calldata pointer and returning\n     *      a nested dynamic array of dynamic arrays of FulfillmentComponent\n     *      types.\n     *\n     * @param inFn The input function, taking an arbitrary calldata pointer and\n     *             returning an arbitrary memory pointer.\n     *\n     * @return outFn The output function, taking an arbitrary calldata pointer\n     *               and returning a nested dynamic array of dynamic arrays of\n     *               FulfillmentComponent types.\n     */\n    function _toNestedFulfillmentComponentsReturnType(\n        function(CalldataPointer) internal pure returns (MemoryPointer) inFn\n    )\n        internal\n        pure\n        returns (\n            function(CalldataPointer)\n                internal\n                pure\n                returns (FulfillmentComponent[][] memory) outFn\n        )\n    {\n        assembly {\n            outFn := inFn\n        }\n    }\n\n    /**\n     * @dev Converts a function taking a calldata pointer and returning a memory\n     *      pointer into a function taking that calldata pointer and returning\n     *      a dynamic array of AdvancedOrder types.\n     *\n     * @param inFn The input function, taking an arbitrary calldata pointer and\n     *             returning an arbitrary memory pointer.\n     *\n     * @return outFn The output function, taking an arbitrary calldata pointer\n     *               and returning a dynamic array of AdvancedOrder types.\n     */\n    function _toAdvancedOrdersReturnType(\n        function(CalldataPointer) internal pure returns (MemoryPointer) inFn\n    )\n        internal\n        pure\n        returns (\n            function(CalldataPointer)\n                internal\n                pure\n                returns (AdvancedOrder[] memory) outFn\n        )\n    {\n        assembly {\n            outFn := inFn\n        }\n    }\n\n    /**\n     * @dev Converts a function taking a calldata pointer and returning a memory\n     *      pointer into a function taking that calldata pointer and returning\n     *      a dynamic array of Fulfillment types.\n     *\n     * @param inFn The input function, taking an arbitrary calldata pointer and\n     *             returning an arbitrary memory pointer.\n     *\n     * @return outFn The output function, taking an arbitrary calldata pointer\n     *               and returning a dynamic array of Fulfillment types.\n     */\n    function _toFulfillmentsReturnType(\n        function(CalldataPointer) internal pure returns (MemoryPointer) inFn\n    )\n        internal\n        pure\n        returns (\n            function(CalldataPointer)\n                internal\n                pure\n                returns (Fulfillment[] memory) outFn\n        )\n    {\n        assembly {\n            outFn := inFn\n        }\n    }\n\n    /**\n     * @dev Caches the endAmount in an offer item and replaces it with\n     * a given recipient so that its memory may be reused as a temporary\n     * ReceivedItem.\n     *\n     * @param offerItem The offer item.\n     * @param recipient The recipient.\n     *\n     * @return originalEndAmount The original end amount.\n     */\n    function _replaceEndAmountWithRecipient(\n        OfferItem memory offerItem,\n        address recipient\n    ) internal pure returns (uint256 originalEndAmount) {\n        assembly {\n            // Derive the pointer to the end amount on the offer item.\n            let endAmountPtr := add(offerItem, ReceivedItem_recipient_offset)\n\n            // Retrieve the value of the end amount on the offer item.\n            originalEndAmount := mload(endAmountPtr)\n\n            // Write recipient to received item at the offer end amount pointer.\n            mstore(endAmountPtr, recipient)\n        }\n    }\n}\n'}, 'lib/seaport-types/src/interfaces/ReentrancyErrors.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n * @title ReentrancyErrors\n * @author 0age\n * @notice ReentrancyErrors contains errors related to reentrancy.\n */\ninterface ReentrancyErrors {\n    /**\n     * @dev Revert with an error when a caller attempts to reenter a protected\n     *      function.\n     */\n    error NoReentrantCalls();\n\n    /**\n     * @dev Revert with an error when attempting to activate the TSTORE opcode\n     *      when it is already active.\n     */\n    error TStoreAlreadyActivated();\n\n    /**\n     * @dev Revert with an error when attempting to activate the TSTORE opcode\n     *      in an EVM environment that does not support it.\n     */\n    error TStoreNotSupported();\n\n    /**\n     * @dev Revert with an error when deployment of the contract for testing\n     *      TSTORE support fails.\n     */\n    error TloadTestContractDeploymentFailed();\n}\n'}}

// File: settings
{'remappings': ['seaport-types/=lib/seaport-types/'], 'optimizer': {'enabled': True, 'runs': 9999999}, 'metadata': {'useLiteralContent': False, 'bytecodeHash': 'none', 'appendCBOR': True}, 'outputSelection': {'*': {'*': ['evm.bytecode', 'evm.deployedBytecode', 'abi']}}, 'evmVersion': 'cancun', 'viaIR': True, 'libraries': {}}",True
0x38a1899fb0bb01d4bcb0e7a3b3f2819e4ad391c1,"// SPDX-License-Identifier: LGPL-3.0-or-later
// Taken from: https://github.com/gnosis/safe-contracts/blob/development/contracts/proxies/GnosisSafeProxy.sol
pragma solidity ^0.7.0;

/// @title IProxy - Helper interface to access masterCopy of the Proxy on-chain
/// @author Richard Meissner - <richard@gnosis.io>
interface IProxy {
    function masterCopy() external view returns (address);
}

/// @title WalletProxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.
/// @author Stefan George - <stefan@gnosis.io>
/// @author Richard Meissner - <richard@gnosis.io>
contract WalletProxy {

    // masterCopy always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.
    // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`
    address internal masterCopy;

    /// @dev Constructor function sets address of master copy contract.
    /// @param _masterCopy Master copy address.
    constructor(address _masterCopy)
    {
        require(_masterCopy != address(0), ""Invalid master copy address provided"");
        masterCopy = _masterCopy;
    }

    /// @dev Fallback function forwards all transactions and returns all received return data.
    fallback()
    payable
    external
    {
        // solium-disable-next-line security/no-inline-assembly
        assembly {
            let _masterCopy := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)
        // 0xa619486e == keccak(""masterCopy()""). The value is right padded to 32-bytes with 0s
            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {
                mstore(0, _masterCopy)
                return(0, 0x20)
            }
            calldatacopy(0, 0, calldatasize())
            let success := delegatecall(gas(), _masterCopy, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())
            if eq(success, 0) { revert(0, returndatasize()) }
            return(0, returndatasize())
        }
    }
}",True
0x5cc0103c10b74d2865f778da3321e629e44b9f6d,"//SPDX-License-Identifier: MIT Licensed
pragma solidity ^0.8.17;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == _msgSender(), ""Ownable: caller is not the owner"");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(
            newOwner != address(0),
            ""Ownable: new owner is the zero address""
        );
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

interface IERC20 {
    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );

    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function transfer(address to, uint256 amount) external returns (bool);

    function allowance(address owner, address spender)
        external
        view
        returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);

    function decimals() external view returns (uint8);
}

interface AggregatorV3Interface {
    function decimals() external view returns (uint8);

    function description() external view returns (string memory);

    function version() external view returns (uint256);

    function getRoundData(uint80 _roundId)
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        );

    function latestRoundData()
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        );
}

contract Presale is Ownable {
    IERC20 public mainToken;
    IERC20 public USDT = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);
    IERC20 public USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);

    uint256 public tokensToSell;
    uint256[] public tokenPerUsdPrice;
    uint256 public totalStages;
    uint8 public tokenDecimals;


    AggregatorV3Interface public priceFeed;

    struct Phase {
        uint256 tokenPerUsdPrice;
    }

    uint256 public currentStage;
    uint256 public cardboughtAmount;
    uint256 public totalUsers;
    uint256 public soldToken;
    uint256 public amountRaised;
    uint256 public amountRaisedUSDT;
    uint256 public amountRaisedUSDC;
    uint256 public totalRaised;
    uint256 public uniqueBuyers;
    address payable public fundReceiver;

    bool public presaleStatus;
    bool public isPresaleEnded;

    address[] public UsersAddresses;
    struct User {
        uint256 native_balance;
        uint256 usdt_balance;
        uint256 usdc_balance;
        uint256 claimedAmount;
        uint256 claimAbleAmount;
        uint256 purchasedToken;
    }
    mapping(address => User) public users;
    mapping(uint256 => Phase) public phases;
    mapping(address => bool) public isExist;

    event BuyToken(address indexed _user, uint256 indexed _amount);
    event ClaimToken(address _user, uint256 indexed _amount);
    event UpdatePrice(uint256 _oldPrice, uint256 _newPrice);

    constructor(IERC20 _token, address _fundReceiver) {
        mainToken = _token;
        fundReceiver = payable(_fundReceiver);
        priceFeed = AggregatorV3Interface(
            0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419
        );
        tokenDecimals = mainToken.decimals();
        tokensToSell = 6_800_000_000 * 10**tokenDecimals;
        tokenPerUsdPrice = [
            68027 * 10**(tokenDecimals-2),
            61728 * 10**(tokenDecimals - 2),
            56818 * 10**(tokenDecimals - 2),
            52356 * 10**(tokenDecimals - 2),
            48544 * 10**(tokenDecimals - 2),
            45249 * 10**(tokenDecimals - 2),
            42553 * 10**(tokenDecimals - 2),
            400 * 10**(tokenDecimals),
            37736 * 10**(tokenDecimals - 2),
            22676 * 10**(tokenDecimals - 2)
        ];
        for (uint256 i = 0; i < tokenPerUsdPrice.length; i++) {
            phases[i].tokenPerUsdPrice = tokenPerUsdPrice[i];
        }
        totalStages = tokenPerUsdPrice.length;
    }

    // update a presale
    function updatePresale(uint256 _phaseId, uint256 _tokenPerUsdPrice)
        public
        onlyOwner
    {
        phases[_phaseId].tokenPerUsdPrice = _tokenPerUsdPrice;
    }

    // to get real time price of BNB
    function getLatestPrice() public view returns (uint256) {
        (, int256 price, , , ) = priceFeed.latestRoundData();
        price = (price * (10**10));
        return uint256(price);
    }

    // to buy token during preSale time with BNB => for web3 use

    function buyToken() public payable {
        require(!isPresaleEnded, ""Presale ended!"");
        require(presaleStatus, "" Presale is Paused, check back later"");
        if (!isExist[msg.sender]) {
            isExist[msg.sender] = true;
            uniqueBuyers++;
            UsersAddresses.push(msg.sender);
        }
        fundReceiver.transfer(msg.value);

        uint256 usdAmount = (msg.value * (getLatestPrice()) * (1e6)) / (1e18 * 1e18);
        uint256 numberOfTokens;
        numberOfTokens = nativeToToken(msg.value, currentStage);
        require(
            soldToken + numberOfTokens <= tokensToSell,
            ""Phase Limit Reached""
        );
        soldToken = soldToken + (numberOfTokens);
        amountRaised = amountRaised + msg.value;
        totalRaised += usdAmount;

        users[msg.sender].native_balance = users[msg.sender].native_balance + (msg.value);
        users[msg.sender].claimAbleAmount = users[msg.sender].claimAbleAmount +numberOfTokens;
        users[msg.sender].purchasedToken += numberOfTokens;
    }

    // to buy token during preSale time with USDT => for web3 use
    function buyTokenUSDT(
        uint256 amount
    ) public {
        require(!isPresaleEnded, ""Presale ended!"");
        require(presaleStatus, "" Presale is Paused, check back later"");
        if (!isExist[msg.sender]) {
            isExist[msg.sender] = true;
            uniqueBuyers++;
            UsersAddresses.push(msg.sender);
        }
        USDT.transferFrom(msg.sender, fundReceiver, amount);

        uint256 numberOfTokens;
        numberOfTokens = usdtToToken(amount, currentStage);
        require(
            soldToken + numberOfTokens <= tokensToSell,
            ""Phase Limit Reached""
        );
        soldToken = soldToken + numberOfTokens;
        amountRaisedUSDT = amountRaisedUSDT + amount;
        totalRaised += amount;

        users[msg.sender].usdt_balance += amount;
        users[msg.sender].claimAbleAmount = users[msg.sender].claimAbleAmount +numberOfTokens;
    
        users[msg.sender].purchasedToken += numberOfTokens;
    }

    // to buy token during preSale time with USDC => for web3 use
    function buyTokenUSDC(
        uint256 amount
    ) public {
        require(!isPresaleEnded, ""Presale ended!"");
        require(presaleStatus, "" Presale is Paused, check back later"");
        if (!isExist[msg.sender]) {
            isExist[msg.sender] = true;
            uniqueBuyers++;
            UsersAddresses.push(msg.sender);
        }
        USDC.transferFrom(msg.sender, fundReceiver, amount);

        uint256 numberOfTokens;
        numberOfTokens = usdtToToken(amount, currentStage);
        require(
            soldToken + numberOfTokens <= tokensToSell,
            ""Phase Limit Reached""
        );

        soldToken = soldToken + numberOfTokens;
        amountRaisedUSDC = amountRaisedUSDC + amount;
        totalRaised += amount;

        users[msg.sender].usdc_balance += amount;

        users[msg.sender].claimAbleAmount = users[msg.sender].claimAbleAmount +numberOfTokens;

        users[msg.sender].purchasedToken += numberOfTokens;
    }

    function buyTokenCard(
        address _user,
        uint256 _tokenAmount
    ) public payable {
        require(!isPresaleEnded, ""Presale ended!"");
        require(presaleStatus, "" Presale is Paused, check back later"");
        if (!isExist[_user]) {
            isExist[_user] = true;
            uniqueBuyers++;
            UsersAddresses.push(_user);
        }
        fundReceiver.transfer(msg.value);
        uint256 usdAmount = (msg.value * (getLatestPrice())* 1e6) / (1e18 * 1e18);

        uint256 numberOfTokens;
        numberOfTokens = nativeToToken(msg.value, currentStage);
        require(
            soldToken + numberOfTokens <= tokensToSell,
            ""Phase Limit Reached""
        );

        soldToken = soldToken + (numberOfTokens);
        amountRaised = amountRaised + msg.value;
        totalRaised += usdAmount;

        users[_user].native_balance = users[_user].native_balance + (msg.value);
        users[_user].claimAbleAmount =
            users[_user].claimAbleAmount +
            numberOfTokens;
        cardboughtAmount += _tokenAmount;
        users[_user].purchasedToken += numberOfTokens;
    }

    function claimTokens() external {
        require(isPresaleEnded, ""Presale has not ended yet"");
        require(isExist[msg.sender], ""User don't exist"");
        User storage user = users[msg.sender];
        uint256 claimAmount = user.claimAbleAmount;
        require(claimAmount > 0, ""No tokens to claim"");
        user.claimedAmount += claimAmount;
        mainToken.transfer(msg.sender, claimAmount);
        user.claimAbleAmount = 0;
        emit ClaimToken(msg.sender, claimAmount);
    }

    function getPhaseDetail(uint256 phaseInd)
        external
        view
        returns (uint256 priceUsd)
    {
        Phase memory phase = phases[phaseInd];
        return (phase.tokenPerUsdPrice);
    }

    function setPresaleStatus(bool _status) external onlyOwner {
        presaleStatus = _status;
    }

    function endPresale() external onlyOwner {
        require(!isPresaleEnded, ""Already ended"");
        isPresaleEnded = true;
    }

    // to check number of token for given BNB
    function nativeToToken(uint256 _amount, uint256 phaseId)
        public
        view
        returns (uint256)
    {
        uint256 bnbToUsd = (_amount * (getLatestPrice()) *(1e6)) / ((1e18) * (1e18));
        uint256 numberOfTokens = (bnbToUsd * phases[phaseId].tokenPerUsdPrice) /
            (1e6);
        return numberOfTokens;
    }

    //  function ethToTokens(uint256 _id, uint256 amount)
    //     public
    //     view
    //     returns (uint256 _tokens)
    // {
    //     uint256 usdAmount = amount * getLatestPrice() * USDT_MULTIPLIER / (ETH_MULTIPLIER * ETH_MULTIPLIER);
    //     _tokens = usdtToTokens(_id, usdAmount);
    // }

    // to check number of token for given usdt
    function usdtToToken(uint256 _amount, uint256 phaseId)
        public
        view
        returns (uint256)
    {
        uint256 numberOfTokens = (_amount * phases[phaseId].tokenPerUsdPrice) /
            (1e6);
        return numberOfTokens;
    }

    function updateInfos(
        uint256 _sold,
        uint256 _raised,
        uint256 _raisedInUsdt
    ) external onlyOwner {
        soldToken = _sold;
        amountRaised = _raised;
        amountRaisedUSDT = _raisedInUsdt;
    }

    // change tokens
    function updateToken(address _token) external onlyOwner {
        mainToken = IERC20(_token);
    }

    function whitelistAddresses(
        address[] memory _addresses,
        uint256[] memory _tokenAmount
    ) external onlyOwner {
        require(
            _addresses.length == _tokenAmount.length,
            ""Addresses and amounts must be equal""
        );

        for (uint256 i = 0; i < _addresses.length; i++) {
            users[_addresses[i]].claimAbleAmount += _tokenAmount[i];
        }
    }

    //change tokens for buy
    function updateStableTokens(IERC20 _USDT, IERC20 _USDC) external onlyOwner {
        USDT = IERC20(_USDT);
        USDC = IERC20(_USDC);
    }

    // to withdraw funds for liquidity
    function initiateTransfer(uint256 _value) external onlyOwner {
        fundReceiver.transfer(_value);
    }

    function totalUsersCount() external view returns (uint256) {
        return UsersAddresses.length;
    }

    // to withdraw funds for liquidity
    function changeFundReciever(address _addr) external onlyOwner {
        fundReceiver = payable(_addr);
    }

    // to withdraw funds for liquidity
    function updatePriceFeed(AggregatorV3Interface _priceFeed)
        external
        onlyOwner
    {
        priceFeed = _priceFeed;
    }

    // funtion is used to change the stage of presale
    function setCurrentStage(uint256 _stageNum) public onlyOwner {
        currentStage = _stageNum;
    }

    // to withdraw out tokens
    function transferTokens(IERC20 token, uint256 _value) external onlyOwner {
        token.transfer(fundReceiver, _value);
    }
}",True
0xdac17f958d2ee523a2206206994597c13d831ec7,"pragma solidity ^0.4.17;

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of ""user permissions"".
 */
contract Ownable {
    address public owner;

    /**
      * @dev The Ownable constructor sets the original `owner` of the contract to the sender
      * account.
      */
    function Ownable() public {
        owner = msg.sender;
    }

    /**
      * @dev Throws if called by any account other than the owner.
      */
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    /**
    * @dev Allows the current owner to transfer control of the contract to a newOwner.
    * @param newOwner The address to transfer ownership to.
    */
    function transferOwnership(address newOwner) public onlyOwner {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

}

/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20Basic {
    uint public _totalSupply;
    function totalSupply() public constant returns (uint);
    function balanceOf(address who) public constant returns (uint);
    function transfer(address to, uint value) public;
    event Transfer(address indexed from, address indexed to, uint value);
}

/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 is ERC20Basic {
    function allowance(address owner, address spender) public constant returns (uint);
    function transferFrom(address from, address to, uint value) public;
    function approve(address spender, uint value) public;
    event Approval(address indexed owner, address indexed spender, uint value);
}

/**
 * @title Basic token
 * @dev Basic version of StandardToken, with no allowances.
 */
contract BasicToken is Ownable, ERC20Basic {
    using SafeMath for uint;

    mapping(address => uint) public balances;

    // additional variables for use if transaction fees ever became necessary
    uint public basisPointsRate = 0;
    uint public maximumFee = 0;

    /**
    * @dev Fix for the ERC20 short address attack.
    */
    modifier onlyPayloadSize(uint size) {
        require(!(msg.data.length < size + 4));
        _;
    }

    /**
    * @dev transfer token for a specified address
    * @param _to The address to transfer to.
    * @param _value The amount to be transferred.
    */
    function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) {
        uint fee = (_value.mul(basisPointsRate)).div(10000);
        if (fee > maximumFee) {
            fee = maximumFee;
        }
        uint sendAmount = _value.sub(fee);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(sendAmount);
        if (fee > 0) {
            balances[owner] = balances[owner].add(fee);
            Transfer(msg.sender, owner, fee);
        }
        Transfer(msg.sender, _to, sendAmount);
    }

    /**
    * @dev Gets the balance of the specified address.
    * @param _owner The address to query the the balance of.
    * @return An uint representing the amount owned by the passed address.
    */
    function balanceOf(address _owner) public constant returns (uint balance) {
        return balances[_owner];
    }

}

/**
 * @title Standard ERC20 token
 *
 * @dev Implementation of the basic standard token.
 * @dev https://github.com/ethereum/EIPs/issues/20
 * @dev Based oncode by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
 */
contract StandardToken is BasicToken, ERC20 {

    mapping (address => mapping (address => uint)) public allowed;

    uint public constant MAX_UINT = 2**256 - 1;

    /**
    * @dev Transfer tokens from one address to another
    * @param _from address The address which you want to send tokens from
    * @param _to address The address which you want to transfer to
    * @param _value uint the amount of tokens to be transferred
    */
    function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3 * 32) {
        var _allowance = allowed[_from][msg.sender];

        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
        // if (_value > _allowance) throw;

        uint fee = (_value.mul(basisPointsRate)).div(10000);
        if (fee > maximumFee) {
            fee = maximumFee;
        }
        if (_allowance < MAX_UINT) {
            allowed[_from][msg.sender] = _allowance.sub(_value);
        }
        uint sendAmount = _value.sub(fee);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(sendAmount);
        if (fee > 0) {
            balances[owner] = balances[owner].add(fee);
            Transfer(_from, owner, fee);
        }
        Transfer(_from, _to, sendAmount);
    }

    /**
    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
    * @param _spender The address which will spend the funds.
    * @param _value The amount of tokens to be spent.
    */
    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {

        // To change the approve amount you first have to reduce the addresses`
        //  allowance to zero by calling `approve(_spender, 0)` if it is not
        //  already 0 to mitigate the race condition described here:
        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
        require(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));

        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
    }

    /**
    * @dev Function to check the amount of tokens than an owner allowed to a spender.
    * @param _owner address The address which owns the funds.
    * @param _spender address The address which will spend the funds.
    * @return A uint specifying the amount of tokens still available for the spender.
    */
    function allowance(address _owner, address _spender) public constant returns (uint remaining) {
        return allowed[_owner][_spender];
    }

}


/**
 * @title Pausable
 * @dev Base contract which allows children to implement an emergency stop mechanism.
 */
contract Pausable is Ownable {
  event Pause();
  event Unpause();

  bool public paused = false;


  /**
   * @dev Modifier to make a function callable only when the contract is not paused.
   */
  modifier whenNotPaused() {
    require(!paused);
    _;
  }

  /**
   * @dev Modifier to make a function callable only when the contract is paused.
   */
  modifier whenPaused() {
    require(paused);
    _;
  }

  /**
   * @dev called by the owner to pause, triggers stopped state
   */
  function pause() onlyOwner whenNotPaused public {
    paused = true;
    Pause();
  }

  /**
   * @dev called by the owner to unpause, returns to normal state
   */
  function unpause() onlyOwner whenPaused public {
    paused = false;
    Unpause();
  }
}

contract BlackList is Ownable, BasicToken {

    /////// Getters to allow the same blacklist to be used also by other contracts (including upgraded Tether) ///////
    function getBlackListStatus(address _maker) external constant returns (bool) {
        return isBlackListed[_maker];
    }

    function getOwner() external constant returns (address) {
        return owner;
    }

    mapping (address => bool) public isBlackListed;
    
    function addBlackList (address _evilUser) public onlyOwner {
        isBlackListed[_evilUser] = true;
        AddedBlackList(_evilUser);
    }

    function removeBlackList (address _clearedUser) public onlyOwner {
        isBlackListed[_clearedUser] = false;
        RemovedBlackList(_clearedUser);
    }

    function destroyBlackFunds (address _blackListedUser) public onlyOwner {
        require(isBlackListed[_blackListedUser]);
        uint dirtyFunds = balanceOf(_blackListedUser);
        balances[_blackListedUser] = 0;
        _totalSupply -= dirtyFunds;
        DestroyedBlackFunds(_blackListedUser, dirtyFunds);
    }

    event DestroyedBlackFunds(address _blackListedUser, uint _balance);

    event AddedBlackList(address _user);

    event RemovedBlackList(address _user);

}

contract UpgradedStandardToken is StandardToken{
    // those methods are called by the legacy contract
    // and they must ensure msg.sender to be the contract address
    function transferByLegacy(address from, address to, uint value) public;
    function transferFromByLegacy(address sender, address from, address spender, uint value) public;
    function approveByLegacy(address from, address spender, uint value) public;
}

contract TetherToken is Pausable, StandardToken, BlackList {

    string public name;
    string public symbol;
    uint public decimals;
    address public upgradedAddress;
    bool public deprecated;

    //  The contract can be initialized with a number of tokens
    //  All the tokens are deposited to the owner address
    //
    // @param _balance Initial supply of the contract
    // @param _name Token Name
    // @param _symbol Token symbol
    // @param _decimals Token decimals
    function TetherToken(uint _initialSupply, string _name, string _symbol, uint _decimals) public {
        _totalSupply = _initialSupply;
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        balances[owner] = _initialSupply;
        deprecated = false;
    }

    // Forward ERC20 methods to upgraded contract if this one is deprecated
    function transfer(address _to, uint _value) public whenNotPaused {
        require(!isBlackListed[msg.sender]);
        if (deprecated) {
            return UpgradedStandardToken(upgradedAddress).transferByLegacy(msg.sender, _to, _value);
        } else {
            return super.transfer(_to, _value);
        }
    }

    // Forward ERC20 methods to upgraded contract if this one is deprecated
    function transferFrom(address _from, address _to, uint _value) public whenNotPaused {
        require(!isBlackListed[_from]);
        if (deprecated) {
            return UpgradedStandardToken(upgradedAddress).transferFromByLegacy(msg.sender, _from, _to, _value);
        } else {
            return super.transferFrom(_from, _to, _value);
        }
    }

    // Forward ERC20 methods to upgraded contract if this one is deprecated
    function balanceOf(address who) public constant returns (uint) {
        if (deprecated) {
            return UpgradedStandardToken(upgradedAddress).balanceOf(who);
        } else {
            return super.balanceOf(who);
        }
    }

    // Forward ERC20 methods to upgraded contract if this one is deprecated
    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {
        if (deprecated) {
            return UpgradedStandardToken(upgradedAddress).approveByLegacy(msg.sender, _spender, _value);
        } else {
            return super.approve(_spender, _value);
        }
    }

    // Forward ERC20 methods to upgraded contract if this one is deprecated
    function allowance(address _owner, address _spender) public constant returns (uint remaining) {
        if (deprecated) {
            return StandardToken(upgradedAddress).allowance(_owner, _spender);
        } else {
            return super.allowance(_owner, _spender);
        }
    }

    // deprecate current contract in favour of a new one
    function deprecate(address _upgradedAddress) public onlyOwner {
        deprecated = true;
        upgradedAddress = _upgradedAddress;
        Deprecate(_upgradedAddress);
    }

    // deprecate current contract if favour of a new one
    function totalSupply() public constant returns (uint) {
        if (deprecated) {
            return StandardToken(upgradedAddress).totalSupply();
        } else {
            return _totalSupply;
        }
    }

    // Issue a new amount of tokens
    // these tokens are deposited into the owner address
    //
    // @param _amount Number of tokens to be issued
    function issue(uint amount) public onlyOwner {
        require(_totalSupply + amount > _totalSupply);
        require(balances[owner] + amount > balances[owner]);

        balances[owner] += amount;
        _totalSupply += amount;
        Issue(amount);
    }

    // Redeem tokens.
    // These tokens are withdrawn from the owner address
    // if the balance must be enough to cover the redeem
    // or the call will fail.
    // @param _amount Number of tokens to be issued
    function redeem(uint amount) public onlyOwner {
        require(_totalSupply >= amount);
        require(balances[owner] >= amount);

        _totalSupply -= amount;
        balances[owner] -= amount;
        Redeem(amount);
    }

    function setParams(uint newBasisPoints, uint newMaxFee) public onlyOwner {
        // Ensure transparency by hardcoding limit beyond which fees can never be added
        require(newBasisPoints < 20);
        require(newMaxFee < 50);

        basisPointsRate = newBasisPoints;
        maximumFee = newMaxFee.mul(10**decimals);

        Params(basisPointsRate, maximumFee);
    }

    // Called when new token are issued
    event Issue(uint amount);

    // Called when tokens are redeemed
    event Redeem(uint amount);

    // Called when contract is deprecated
    event Deprecate(address newAddress);

    // Called if contract ever adds fees
    event Params(uint feeBasisPoints, uint maxFee);
}",True
0x35c8941c294e9d60e0742cb9f3d58c0d1ba2dec4,"// File: language
Solidity

// File: sources
{'src/EthCoin.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport ""openzeppelin-contracts/contracts/access/Ownable.sol"";\nimport ""openzeppelin-contracts/contracts/token/ERC20/ERC20.sol"";\n\ncontract Ethcoin is ERC20, Ownable {\n    /// @notice Maximum supply of the token\n    uint256 public constant MAX_SUPPLY = 21000000e18; // 21 million\n\n    /// @notice Block interval for mining\n    uint256 public constant BLOCK_INTERVAL = 1 minutes;\n\n    /// @notice The cost to mine\n    uint256 public constant MINE_COST = 0.0001 ether;\n\n    /// @notice The mining reward\n    uint256 public miningReward = 200e18; // 200 ETHC\n\n    /// @notice The current block number\n    uint256 public blockNumber;\n\n    /// @notice The last block time\n    uint256 public lastBlockTime;\n\n    /// @notice The halving interval\n    uint256 public halvingInterval = 10080; // 10080 Ethcoin blocks, ~1 week\n\n    /// @notice The last halving block\n    uint256 public lastHalvingBlock;\n\n    /// @notice The fee collector address\n    address public feeCollector;\n\n    struct Block {\n        address[] miners;\n        address selectedMiner;\n    }\n\n    /// @notice The blocks data\n    mapping(uint256 => Block) public blocks;\n\n    event Mine(uint256 indexed blockNumber, address indexed miner, uint256 mineCounts);\n    event NewBlock(uint256 indexed blockNumber, address indexed miner);\n    event FeeCollectorSet(address feeCollector);\n\n    constructor() ERC20(""Ethcoin"", ""ETHC"") Ownable(msg.sender) {\n        blocks[0].miners.push(msg.sender);\n        lastBlockTime = block.timestamp;\n\n        emit Mine(0, msg.sender, 1);\n    }\n\n    /**\n     * @notice Get the miners for a specific block.\n     * @param _blockNumber The block number\n     * @return The miners\n     */\n    function minersOfBlock(uint256 _blockNumber) public view returns (address[] memory) {\n        return blocks[_blockNumber].miners;\n    }\n\n    /**\n     * @notice Get the miners for a specific block with a range.\n     * @dev This function is not recommended to use for on-chain purposes.\n     * @param _blockNumber The block number\n     * @param _from The start index\n     * @param _to The end index\n     * @return The miners\n     */\n    function minersOfBlockWithRange(uint256 _blockNumber, uint256 _from, uint256 _to)\n        public\n        view\n        returns (address[] memory)\n    {\n        uint256 count = _to - _from;\n        address[] memory miners = new address[](count);\n        for (uint256 i = 0; i < count; i++) {\n            miners[i] = blocks[_blockNumber].miners[_from + i];\n        }\n        return miners;\n    }\n\n    /**\n     * @notice Get the number of miners for a specific block.\n     * @param _blockNumber The block number\n     * @return The number of miners\n     */\n    function minersOfBlockCount(uint256 _blockNumber) public view returns (uint256) {\n        return blocks[_blockNumber].miners.length;\n    }\n\n    /**\n     * @notice Get the selected miner for a specific block.\n     * @param _blockNumber The block number\n     * @return The selected miner\n     */\n    function selectedMinerOfBlock(uint256 _blockNumber) public view returns (address) {\n        return blocks[_blockNumber].selectedMiner;\n    }\n\n    /**\n     * @notice Get the next halving block.\n     * @return The next halving block\n     */\n    function nextHalvingBlock() public view returns (uint256) {\n        return lastHalvingBlock + halvingInterval;\n    }\n\n    /**\n     * @notice Mines the reward multiple times in the current block.\n     * @param mineCounts The number of times to mine\n     */\n    function mineBatch(uint256 mineCounts) public payable {\n        require(msg.value == MINE_COST * mineCounts, ""insufficient mine cost"");\n\n        uint256 targetBlock = blockNumber + 1;\n        for (uint256 i = 0; i < mineCounts;) {\n            _mine(msg.sender, targetBlock);\n\n            unchecked {\n                i++;\n            }\n        }\n\n        emit Mine(targetBlock, msg.sender, mineCounts);\n    }\n\n    /**\n     * @notice Mines the reward in the current block.\n     */\n    function mine() public payable {\n        require(msg.value == MINE_COST, ""insufficient mine cost"");\n\n        uint256 targetBlock = blockNumber + 1;\n        _mine(msg.sender, targetBlock);\n\n        emit Mine(targetBlock, msg.sender, 1);\n    }\n\n    /**\n     * @notice Mines the reward multiple times in the future block.\n     * @param mineCounts The number of times to mine per block\n     * @param blockCounts The number of future blocks to mine\n     */\n    function futureMine(uint256 mineCounts, uint256 blockCounts) public payable {\n        require(msg.value == MINE_COST * mineCounts * blockCounts, ""insufficient mine cost"");\n\n        // The future mine starts with blockNumber + 2.\n        uint256 targetBlock = blockNumber + 2;\n        for (uint256 i = 0; i < blockCounts;) {\n            for (uint256 j = 0; j < mineCounts;) {\n                _mine(msg.sender, targetBlock + i);\n\n                unchecked {\n                    j++;\n                }\n            }\n\n            emit Mine(targetBlock + i, msg.sender, mineCounts);\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /**\n     * @notice Sets the fee collector address.\n     * @param _feeCollector The fee collector address\n     */\n    function setFeeCollector(address _feeCollector) public onlyOwner {\n        feeCollector = _feeCollector;\n\n        emit FeeCollectorSet(_feeCollector);\n    }\n\n    /**\n     * @notice Collects the Ether.\n     * @param amount The amount of Ether to collect\n     */\n    function collect(uint256 amount) public {\n        require(msg.sender == feeCollector, ""only feeCollector can collect"");\n\n        (bool sent,) = feeCollector.call{value: amount}("""");\n        require(sent, ""failed to send Ether"");\n    }\n\n    /**\n     * @dev Mines the reward.\n     * @param user The user address\n     * @param targetBlock The target block number to mine\n     */\n    function _mine(address user, uint256 targetBlock) private {\n        blocks[targetBlock].miners.push(user);\n\n        if (block.timestamp >= lastBlockTime + BLOCK_INTERVAL) {\n            // Randomly select a miner to receive the reward.\n            address selectedMiner = _selectRandomMiner();\n\n            // Proceed halving check & reward only if the whole supply was not minted yet.\n            if (totalSupply() + miningReward <= MAX_SUPPLY) {\n                // Mint the reward to the selected miner.\n                _mint(selectedMiner, miningReward);\n            }\n\n            // Record the selected miner.\n            blocks[blockNumber].selectedMiner = selectedMiner;\n            emit NewBlock(blockNumber, selectedMiner);\n\n            // Proceed to the next block.\n            blockNumber++;\n            lastBlockTime = block.timestamp;\n\n            // Check if it\'s time for halving.\n            if (blockNumber >= nextHalvingBlock()) {\n                miningReward = miningReward / 2;\n                halvingInterval = halvingInterval * 2;\n\n                lastHalvingBlock = blockNumber;\n            }\n        }\n    }\n\n    /**\n     * @dev Selects a random miner from the miners of the previous block.\n     * @return The selected miner\n     */\n    function _selectRandomMiner() private view returns (address) {\n        uint256 minerCount = minersOfBlockCount(blockNumber);\n        uint256 randomIndex = uint256(\n            keccak256(\n                abi.encodePacked(\n                    block.prevrandao, block.timestamp, minerCount, blocks[blockNumber].miners[minerCount - 1]\n                )\n            )\n        ) % minerCount;\n        return blocks[blockNumber].miners[randomIndex];\n    }\n}\n'}, 'lib/openzeppelin-contracts/contracts/access/Ownable.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from ""../utils/Context.sol"";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n'}, 'lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from ""./IERC20.sol"";\nimport {IERC20Metadata} from ""./extensions/IERC20Metadata.sol"";\nimport {Context} from ""../../utils/Context.sol"";\nimport {IERC20Errors} from ""../../interfaces/draft-IERC6093.sol"";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn\'t required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it\'s overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``\'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n'}, 'lib/openzeppelin-contracts/contracts/utils/Context.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n'}, 'lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol': {'content': ""// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n""}, 'lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from ""../IERC20.sol"";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n'}, 'lib/openzeppelin-contracts/contracts/interfaces/draft-IERC6093.sol': {'content': ""// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n""}}

// File: settings
{'remappings': ['@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/', 'ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/', 'erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/', 'forge-std/=lib/forge-std/src/', 'openzeppelin-contracts/=lib/openzeppelin-contracts/'], 'optimizer': {'enabled': True, 'runs': 200}, 'metadata': {'useLiteralContent': False, 'bytecodeHash': 'ipfs', 'appendCBOR': True}, 'outputSelection': {'*': {'*': ['evm.bytecode', 'evm.deployedBytecode', 'devdoc', 'userdoc', 'metadata', 'abi']}}, 'evmVersion': 'paris', 'viaIR': False, 'libraries': {}}",True
0x1111111254eeb25477b68fb85ed929f73a960582,"/*
                                                           ,▄▓▓██▌   ,╓▄▄▓▓▓▓▓▓▓▓▄▄▄,,
                                                        ,▓██▓███▓▄▓███▓╬╬╬╬╬╬╬╬╬╬╬╬╬▓███▓▄,
                                                  ▄█   ▓██╬╣███████╬▓▀╬╬▓▓▓████████████▓█████▄,
                                                 ▓██▌ ▓██╬╣██████╬▓▌  ██████████████████████▌╙╙▀ⁿ
                                                ▐████████╬▓████▓▓█╨ ▄ ╟█████████▓▓╬╬╬╬╬▓▓█████▓▄
                                  └▀▓▓▄╓        ╟█▓╣█████▓██████▀ ╓█▌ ███████▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬▓██▓▄
                                     └▀████▓▄╥  ▐██╬╬██████████╙ Æ▀─ ▓███▀╚╠╬╩▀▀███████▓▓╬╬╬╬╬╬╬╬╬██▄
                                        └▀██▓▀▀█████▓╬▓██████▀     ▄█████▒╠""      └╙▓██████▓╬╬╬╬╬╬╬╬██▄
                                           └▀██▄,└╙▀▀████▌└╙    ^""▀╙╙╙""╙██      @▄    ╙▀███████╬╬╬╬╬╬╬██µ
                                              └▀██▓▄, ██▌       ╒       ╙█▓     ]▓█▓╔    ▀███████▓╬╬╬╬╬▓█▌
                                                  ▀█████       ▓         ╟█▌    ]╠██▓░▒╓   ▀████████╬╬╬╬╣█▌
                                                  ▐████      ╓█▀█▌      ,██▌    ╚Å███▓▒▒╠╓  ╙█████████╬╬╬╣█▌
                                                  └████     ▓█░░▓█      ▀▀▀    φ▒╫████▒▒▒▒╠╓  █████████▓╬╬▓█µ
                                                   ╘███µ ▌▄█▓▄▓▀`     ,▀    ,╔╠░▓██████▌╠▒▒▒φ  ██████████╬╬██
                                                   ▐████µ╙▓▀`     ,▀╙,╔╔φφφ╠░▄▓███████▌░▓╙▒▒▒╠ └██╬███████╬▓█⌐
                                                   ╫██ ▓▌         ▌φ▒▒░▓██████████████▌▒░▓╚▒▒▒╠ ▓██╬▓██████╣█▌
                                                   ██▌           ▌╔▒▒▄████████████████▒▒▒░▌╠▒▒▒≥▐██▓╬╬███████▌
                                                   ██▌      ,╓φ╠▓«▒▒▓████▀  ▀█████████▌▒▒▒╟░▒▒▒▒▐███╬╬╣████▓█▌
                                                  ▐██      ╠▒▄▓▓███▓████└     ▀████████▌▒▒░▌╚▒▒▒▐███▓╬╬████ ╙▌
                                                  ███  )  ╠▒░░░▒░╬████▀        └████████░▒▒░╬∩▒▒▓████╬╬╣███
                                                 ▓██    ╠╠▒▒▐█▀▀▌`░╫██           ███████▒▒▒▒░▒▒½█████╬╬╣███
                                                ███ ,█▄ ╠▒▒▒╫▌,▄▀,▒╫██           ╟██████▒▒▒░╣⌠▒▓█████╬╬╣██▌
                                               ╘██µ ██` ╠▒▒░██╬φ╠▄▓██`            ██████░░▌φ╠░▓█████▓╬╬▓██
                                                ╟██  .φ╠▒░▄█▀░░▄██▀└              █████▌▒╣φ▒░▓██████╬╬╣██
                                                 ▀██▄▄▄╓▄███████▀                ▐█████░▓φ▒▄███████▓╬╣██
                                                   ╙▀▀▀██▀└                      ████▓▄▀φ▄▓████████╬▓█▀
                                                                                ▓███╬╩╔╣██████████▓██└
                                                                              ╓████▀▄▓████████▀████▀
                                                                            ,▓███████████████─]██╙
                                                                         ,▄▓██████████████▀└  ╙
                                                                    ,╓▄▓███████████████▀╙
                                                             `""▀▀▀████████▀▀▀▀`▄███▀▀└
                                                                              └└



                    11\   11\                     11\             11\   11\            11\                                       11\
                  1111 |  \__|                    11 |            111\  11 |           11 |                                      11 |
                  \_11 |  11\ 1111111\   1111111\ 1111111\        1111\ 11 | 111111\ 111111\   11\  11\  11\  111111\   111111\  11 |  11\
                    11 |  11 |11  __11\ 11  _____|11  __11\       11 11\11 |11  __11\\_11  _|  11 | 11 | 11 |11  __11\ 11  __11\ 11 | 11  |
                    11 |  11 |11 |  11 |11 /      11 |  11 |      11 \1111 |11111111 | 11 |    11 | 11 | 11 |11 /  11 |11 |  \__|111111  /
                    11 |  11 |11 |  11 |11 |      11 |  11 |      11 |\111 |11   ____| 11 |11\ 11 | 11 | 11 |11 |  11 |11 |      11  _11<
                  111111\ 11 |11 |  11 |\1111111\ 11 |  11 |      11 | \11 |\1111111\  \1111  |\11111\1111  |\111111  |11 |      11 | \11\
                  \______|\__|\__|  \__| \_______|\__|  \__|      \__|  \__| \_______|  \____/  \_____\____/  \______/ \__|      \__|  \__|



                               111111\                                                               11\     11\
                              11  __11\                                                              11 |    \__|
                              11 /  11 | 111111\   111111\   111111\   111111\   111111\   111111\ 111111\   11\  111111\  1111111\
                              11111111 |11  __11\ 11  __11\ 11  __11\ 11  __11\ 11  __11\  \____11\\_11  _|  11 |11  __11\ 11  __11\
                              11  __11 |11 /  11 |11 /  11 |11 |  \__|11111111 |11 /  11 | 1111111 | 11 |    11 |11 /  11 |11 |  11 |
                              11 |  11 |11 |  11 |11 |  11 |11 |      11   ____|11 |  11 |11  __11 | 11 |11\ 11 |11 |  11 |11 |  11 |
                              11 |  11 |\1111111 |\1111111 |11 |      \1111111\ \1111111 |\1111111 | \1111  |11 |\111111  |11 |  11 |
                              \__|  \__| \____11 | \____11 |\__|       \_______| \____11 | \_______|  \____/ \__| \______/ \__|  \__|
                                        11\   11 |11\   11 |                    11\   11 |
                                        \111111  |\111111  |                    \111111  |
                                         \______/  \______/                      \______/
                                                1111111\                        11\
                                                11  __11\                       11 |
                                                11 |  11 | 111111\  11\   11\ 111111\    111111\   111111\
                                                1111111  |11  __11\ 11 |  11 |\_11  _|  11  __11\ 11  __11\
                                                11  __11< 11 /  11 |11 |  11 |  11 |    11111111 |11 |  \__|
                                                11 |  11 |11 |  11 |11 |  11 |  11 |11\ 11   ____|11 |
                                                11 |  11 |\111111  |\111111  |  \1111  |\1111111\ 11 |
                                                \__|  \__| \______/  \______/    \____/  \_______|\__|
*/

// SPDX-License-Identifier: MIT

// File contracts/interfaces/IClipperExchangeInterface.sol


pragma solidity 0.8.17;

/// @title Clipper interface subset used in swaps
interface IClipperExchangeInterface {
    struct Signature {
        uint8 v;
        bytes32 r;
        bytes32 s;
    }

    function sellEthForToken(address outputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, Signature calldata theSignature, bytes calldata auxiliaryData) external payable;
    function sellTokenForEth(address inputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, Signature calldata theSignature, bytes calldata auxiliaryData) external;
    function swap(address inputToken, address outputToken, uint256 inputAmount, uint256 outputAmount, uint256 goodUntil, address destinationAddress, Signature calldata theSignature, bytes calldata auxiliaryData) external;
}


// File contracts/helpers/RouterErrors.sol


pragma solidity 0.8.17;

library RouterErrors {
    error ReturnAmountIsNotEnough();
    error InvalidMsgValue();
    error ERC20TransferFailed();
}


// File @1inch/solidity-utils/contracts/EthReceiver.sol@v2.1.1


pragma solidity ^0.8.0;

abstract contract EthReceiver {
    error EthDepositRejected();

    receive() external payable {
        _receive();
    }

    function _receive() internal virtual {
        // solhint-disable-next-line avoid-tx-origin
        if (msg.sender == tx.origin) revert EthDepositRejected();
    }
}


// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.7.3

// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}


// File @1inch/solidity-utils/contracts/interfaces/IDaiLikePermit.sol@v2.1.1


pragma solidity ^0.8.0;


interface IDaiLikePermit {
    function permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) external;
}


// File @1inch/solidity-utils/contracts/libraries/RevertReasonForwarder.sol@v2.1.1


pragma solidity ^0.8.0;

library RevertReasonForwarder {
    function reRevert() internal pure {
        // bubble up revert reason from latest external call
        /// @solidity memory-safe-assembly
        assembly { // solhint-disable-line no-inline-assembly
            let ptr := mload(0x40)
            returndatacopy(ptr, 0, returndatasize())
            revert(ptr, returndatasize())
        }
    }
}


// File @openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol@v4.7.3

// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
 * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
 *
 * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 * need to send a transaction, and thus is not required to hold Ether at all.
 */
interface IERC20Permit {
    /**
     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
     * given ``owner``'s signed approval.
     *
     * IMPORTANT: The same issues {IERC20-approve} has related to transaction
     * ordering also apply here.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `deadline` must be a timestamp in the future.
     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
     * over the EIP712-formatted function arguments.
     * - the signature must use ``owner``'s current nonce (see {nonces}).
     *
     * For more information on the signature format, see the
     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
     * section].
     */
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    /**
     * @dev Returns the current nonce for `owner`. This value must be
     * included whenever a signature is generated for {permit}.
     *
     * Every successful call to {permit} increases ``owner``'s nonce by one. This
     * prevents a signature from being used multiple times.
     */
    function nonces(address owner) external view returns (uint256);

    /**
     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
     */
    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32);
}


// File @1inch/solidity-utils/contracts/libraries/SafeERC20.sol@v2.1.1


pragma solidity ^0.8.0;




library SafeERC20 {
    error SafeTransferFailed();
    error SafeTransferFromFailed();
    error ForceApproveFailed();
    error SafeIncreaseAllowanceFailed();
    error SafeDecreaseAllowanceFailed();
    error SafePermitBadLength();

    // Ensures method do not revert or return boolean `true`, admits call to non-smart-contract
    function safeTransferFrom(IERC20 token, address from, address to, uint256 amount) internal {
        bytes4 selector = token.transferFrom.selector;
        bool success;
        /// @solidity memory-safe-assembly
        assembly { // solhint-disable-line no-inline-assembly
            let data := mload(0x40)

            mstore(data, selector)
            mstore(add(data, 0x04), from)
            mstore(add(data, 0x24), to)
            mstore(add(data, 0x44), amount)
            success := call(gas(), token, 0, data, 100, 0x0, 0x20)
            if success {
                switch returndatasize()
                case 0 { success := gt(extcodesize(token), 0) }
                default { success := and(gt(returndatasize(), 31), eq(mload(0), 1)) }
            }
        }
        if (!success) revert SafeTransferFromFailed();
    }

    // Ensures method do not revert or return boolean `true`, admits call to non-smart-contract
    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        if (!_makeCall(token, token.transfer.selector, to, value)) {
            revert SafeTransferFailed();
        }
    }

    // If `approve(from, to, amount)` fails, try to `approve(from, to, 0)` before retry
    function forceApprove(IERC20 token, address spender, uint256 value) internal {
        if (!_makeCall(token, token.approve.selector, spender, value)) {
            if (!_makeCall(token, token.approve.selector, spender, 0) ||
                !_makeCall(token, token.approve.selector, spender, value))
            {
                revert ForceApproveFailed();
            }
        }
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 allowance = token.allowance(address(this), spender);
        if (value > type(uint256).max - allowance) revert SafeIncreaseAllowanceFailed();
        forceApprove(token, spender, allowance + value);
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 allowance = token.allowance(address(this), spender);
        if (value > allowance) revert SafeDecreaseAllowanceFailed();
        forceApprove(token, spender, allowance - value);
    }

    function safePermit(IERC20 token, bytes calldata permit) internal {
        bool success;
        if (permit.length == 32 * 7) {
            success = _makeCalldataCall(token, IERC20Permit.permit.selector, permit);
        } else if (permit.length == 32 * 8) {
            success = _makeCalldataCall(token, IDaiLikePermit.permit.selector, permit);
        } else {
            revert SafePermitBadLength();
        }
        if (!success) RevertReasonForwarder.reRevert();
    }

    function _makeCall(IERC20 token, bytes4 selector, address to, uint256 amount) private returns(bool success) {
        /// @solidity memory-safe-assembly
        assembly { // solhint-disable-line no-inline-assembly
            let data := mload(0x40)

            mstore(data, selector)
            mstore(add(data, 0x04), to)
            mstore(add(data, 0x24), amount)
            success := call(gas(), token, 0, data, 0x44, 0x0, 0x20)
            if success {
                switch returndatasize()
                case 0 { success := gt(extcodesize(token), 0) }
                default { success := and(gt(returndatasize(), 31), eq(mload(0), 1)) }
            }
        }
    }

    function _makeCalldataCall(IERC20 token, bytes4 selector, bytes calldata args) private returns(bool success) {
        /// @solidity memory-safe-assembly
        assembly { // solhint-disable-line no-inline-assembly
            let len := add(4, args.length)
            let data := mload(0x40)

            mstore(data, selector)
            calldatacopy(add(data, 0x04), args.offset, args.length)
            success := call(gas(), token, 0, data, len, 0x0, 0x20)
            if success {
                switch returndatasize()
                case 0 { success := gt(extcodesize(token), 0) }
                default { success := and(gt(returndatasize(), 31), eq(mload(0), 1)) }
            }
        }
    }
}


// File @1inch/solidity-utils/contracts/interfaces/IWETH.sol@v2.1.1


pragma solidity ^0.8.0;

interface IWETH is IERC20 {
    function deposit() external payable;
    function withdraw(uint256 amount) external;
}


// File contracts/routers/ClipperRouter.sol


pragma solidity 0.8.17;






/// @title Clipper router that allows to use `ClipperExchangeInterface` for swaps
contract ClipperRouter is EthReceiver {
    using SafeERC20 for IERC20;

    uint256 private constant _SIGNATURE_S_MASK = 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;
    uint256 private constant _SIGNATURE_V_SHIFT = 255;
    bytes6 private constant _INCH_TAG_WITH_LENGTH_PREFIX = ""\x051INCH"";
    IERC20 private constant _ETH = IERC20(address(0));
    IWETH private immutable _WETH;  // solhint-disable-line var-name-mixedcase

    constructor(IWETH weth) {
        _WETH = weth;
    }

    /// @notice Same as `clipperSwapTo` but calls permit first,
    /// allowing to approve token spending and make a swap in one transaction.
    /// @dev See tests for examples
    /// @param recipient Address that will receive swap funds
    /// @param srcToken Source token
    /// @param dstToken Destination token
    /// @param inputAmount Amount of source tokens to swap
    /// @param outputAmount Amount of destination tokens to receive
    /// @param goodUntil Timestamp until the swap will be valid
    /// @param r Clipper order signature (r part)
    /// @param vs Clipper order signature (vs part)
    /// @param permit Should contain valid permit that can be used in `IERC20Permit.permit` calls.
    /// @return returnAmount Amount of destination tokens received
    function clipperSwapToWithPermit(
        IClipperExchangeInterface clipperExchange,
        address payable recipient,
        IERC20 srcToken,
        IERC20 dstToken,
        uint256 inputAmount,
        uint256 outputAmount,
        uint256 goodUntil,
        bytes32 r,
        bytes32 vs,
        bytes calldata permit
    ) external returns(uint256 returnAmount) {
        srcToken.safePermit(permit);
        return clipperSwapTo(clipperExchange, recipient, srcToken, dstToken, inputAmount, outputAmount, goodUntil, r, vs);
    }

    /// @notice Same as `clipperSwapTo` but uses `msg.sender` as recipient
    /// @param srcToken Source token
    /// @param dstToken Destination token
    /// @param inputAmount Amount of source tokens to swap
    /// @param outputAmount Amount of destination tokens to receive
    /// @param goodUntil Timestamp until the swap will be valid
    /// @param r Clipper order signature (r part)
    /// @param vs Clipper order signature (vs part)
    /// @return returnAmount Amount of destination tokens received
    function clipperSwap(
        IClipperExchangeInterface clipperExchange,
        IERC20 srcToken,
        IERC20 dstToken,
        uint256 inputAmount,
        uint256 outputAmount,
        uint256 goodUntil,
        bytes32 r,
        bytes32 vs
    ) external payable returns(uint256 returnAmount) {
        return clipperSwapTo(clipperExchange, payable(msg.sender), srcToken, dstToken, inputAmount, outputAmount, goodUntil, r, vs);
    }

    /// @notice Performs swap using Clipper exchange. Wraps and unwraps ETH if required.
    /// Sending non-zero `msg.value` for anything but ETH swaps is prohibited
    /// @param recipient Address that will receive swap funds
    /// @param srcToken Source token
    /// @param dstToken Destination token
    /// @param inputAmount Amount of source tokens to swap
    /// @param outputAmount Amount of destination tokens to receive
    /// @param goodUntil Timestamp until the swap will be valid
    /// @param r Clipper order signature (r part)
    /// @param vs Clipper order signature (vs part)
    /// @return returnAmount Amount of destination tokens received
    function clipperSwapTo(
        IClipperExchangeInterface clipperExchange,
        address payable recipient,
        IERC20 srcToken,
        IERC20 dstToken,
        uint256 inputAmount,
        uint256 outputAmount,
        uint256 goodUntil,
        bytes32 r,
        bytes32 vs
    ) public payable returns(uint256 returnAmount) {
        bool srcETH = srcToken == _ETH;
        if (srcETH) {
            if (msg.value != inputAmount) revert RouterErrors.InvalidMsgValue();
        } else if (srcToken == _WETH) {
            srcETH = true;
            if (msg.value != 0) revert RouterErrors.InvalidMsgValue();
            // _WETH.transferFrom(msg.sender, address(this), inputAmount);
            // _WETH.withdraw(inputAmount);
            address weth = address(_WETH);
            bytes4 transferFromSelector = _WETH.transferFrom.selector;
            bytes4 withdrawSelector = _WETH.withdraw.selector;
            /// @solidity memory-safe-assembly
            assembly { // solhint-disable-line no-inline-assembly
                let ptr := mload(0x40)

                mstore(ptr, transferFromSelector)
                mstore(add(ptr, 0x04), caller())
                mstore(add(ptr, 0x24), address())
                mstore(add(ptr, 0x44), inputAmount)
                if iszero(call(gas(), weth, 0, ptr, 0x64, 0, 0)) {
                    returndatacopy(ptr, 0, returndatasize())
                    revert(ptr, returndatasize())
                }

                mstore(ptr, withdrawSelector)
                mstore(add(ptr, 0x04), inputAmount)
                if iszero(call(gas(), weth, 0, ptr, 0x24, 0, 0)) {
                    returndatacopy(ptr, 0, returndatasize())
                    revert(ptr, returndatasize())
                }
            }
        } else {
            if (msg.value != 0) revert RouterErrors.InvalidMsgValue();
            srcToken.safeTransferFrom(msg.sender, address(clipperExchange), inputAmount);
        }

        if (srcETH) {
            // clipperExchange.sellEthForToken{value: inputAmount}(address(dstToken), inputAmount, outputAmount, goodUntil, recipient, signature, _INCH_TAG);
            address clipper = address(clipperExchange);
            bytes4 selector = clipperExchange.sellEthForToken.selector;
            /// @solidity memory-safe-assembly
            assembly { // solhint-disable-line no-inline-assembly
                let ptr := mload(0x40)

                mstore(ptr, selector)
                mstore(add(ptr, 0x04), dstToken)
                mstore(add(ptr, 0x24), inputAmount)
                mstore(add(ptr, 0x44), outputAmount)
                mstore(add(ptr, 0x64), goodUntil)
                mstore(add(ptr, 0x84), recipient)
                mstore(add(ptr, 0xa4), add(27, shr(_SIGNATURE_V_SHIFT, vs)))
                mstore(add(ptr, 0xc4), r)
                mstore(add(ptr, 0xe4), and(vs, _SIGNATURE_S_MASK))
                mstore(add(ptr, 0x104), 0x120)
                mstore(add(ptr, 0x143), _INCH_TAG_WITH_LENGTH_PREFIX)
                if iszero(call(gas(), clipper, inputAmount, ptr, 0x149, 0, 0)) {
                    returndatacopy(ptr, 0, returndatasize())
                    revert(ptr, returndatasize())
                }
            }
        } else if (dstToken == _ETH || dstToken == _WETH) {
            // clipperExchange.sellTokenForEth(address(srcToken), inputAmount, outputAmount, goodUntil, recipient, signature, _INCH_TAG);
            address clipper = address(clipperExchange);
            bytes4 selector = clipperExchange.sellTokenForEth.selector;
            /// @solidity memory-safe-assembly
            assembly { // solhint-disable-line no-inline-assembly
                let ptr := mload(0x40)

                mstore(ptr, selector)
                mstore(add(ptr, 0x04), srcToken)
                mstore(add(ptr, 0x24), inputAmount)
                mstore(add(ptr, 0x44), outputAmount)
                mstore(add(ptr, 0x64), goodUntil)
                switch iszero(dstToken)
                case 1 {
                    mstore(add(ptr, 0x84), recipient)
                }
                default {
                    mstore(add(ptr, 0x84), address())
                }
                mstore(add(ptr, 0xa4), add(27, shr(_SIGNATURE_V_SHIFT, vs)))
                mstore(add(ptr, 0xc4), r)
                mstore(add(ptr, 0xe4), and(vs, _SIGNATURE_S_MASK))
                mstore(add(ptr, 0x104), 0x120)
                mstore(add(ptr, 0x143), _INCH_TAG_WITH_LENGTH_PREFIX)
                if iszero(call(gas(), clipper, 0, ptr, 0x149, 0, 0)) {
                    returndatacopy(ptr, 0, returndatasize())
                    revert(ptr, returndatasize())
                }
            }

            if (dstToken == _WETH) {
                // _WETH.deposit{value: outputAmount}();
                // _WETH.transfer(recipient, outputAmount);
                address weth = address(_WETH);
                bytes4 depositSelector = _WETH.deposit.selector;
                bytes4 transferSelector = _WETH.transfer.selector;
                /// @solidity memory-safe-assembly
                assembly { // solhint-disable-line no-inline-assembly
                    let ptr := mload(0x40)

                    mstore(ptr, depositSelector)
                    if iszero(call(gas(), weth, outputAmount, ptr, 0x04, 0, 0)) {
                        returndatacopy(ptr, 0, returndatasize())
                        revert(ptr, returndatasize())
                    }

                    mstore(ptr, transferSelector)
                    mstore(add(ptr, 0x04), recipient)
                    mstore(add(ptr, 0x24), outputAmount)
                    if iszero(call(gas(), weth, 0, ptr, 0x44, 0, 0)) {
                        returndatacopy(ptr, 0, returndatasize())
                        revert(ptr, returndatasize())
                    }
                }
            }
        } else {
            // clipperExchange.swap(address(srcToken), address(dstToken), inputAmount, outputAmount, goodUntil, recipient, signature, _INCH_TAG);
            address clipper = address(clipperExchange);
            bytes4 selector = clipperExchange.swap.selector;
            /// @solidity memory-safe-assembly
            assembly { // solhint-disable-line no-inline-assembly
                let ptr := mload(0x40)

                mstore(ptr, selector)
                mstore(add(ptr, 0x04), srcToken)
                mstore(add(ptr, 0x24), dstToken)
                mstore(add(ptr, 0x44), inputAmount)
                mstore(add(ptr, 0x64), outputAmount)
                mstore(add(ptr, 0x84), goodUntil)
                mstore(add(ptr, 0xa4), recipient)
                mstore(add(ptr, 0xc4), add(27, shr(_SIGNATURE_V_SHIFT, vs)))
                mstore(add(ptr, 0xe4), r)
                mstore(add(ptr, 0x104), and(vs, _SIGNATURE_S_MASK))
                mstore(add(ptr, 0x124), 0x140)
                mstore(add(ptr, 0x163), _INCH_TAG_WITH_LENGTH_PREFIX)
                if iszero(call(gas(), clipper, 0, ptr, 0x169, 0, 0)) {
                    returndatacopy(ptr, 0, returndatasize())
                    revert(ptr, returndatasize())
                }
            }
        }

        return outputAmount;
    }
}


// File contracts/interfaces/IAggregationExecutor.sol


pragma solidity 0.8.17;

/// @title Interface for making arbitrary calls during swap
interface IAggregationExecutor {
    /// @notice propagates information about original msg.sender and executes arbitrary data
    function execute(address msgSender) external payable;  // 0x4b64e492
}


// File @1inch/solidity-utils/contracts/interfaces/IERC20MetadataUppercase.sol@v2.1.1


pragma solidity ^0.8.0;


interface IERC20MetadataUppercase {
    function NAME() external view returns (string memory);  // solhint-disable-line func-name-mixedcase
    function SYMBOL() external view returns (string memory);  // solhint-disable-line func-name-mixedcase
}


// File @1inch/solidity-utils/contracts/libraries/StringUtil.sol@v2.1.1


pragma solidity ^0.8.0;

/// @title Library with gas-efficient string operations
library StringUtil {
    function toHex(uint256 value) internal pure returns (string memory) {
        return toHex(abi.encodePacked(value));
    }

    function toHex(address value) internal pure returns (string memory) {
        return toHex(abi.encodePacked(value));
    }

    function toHex(bytes memory data) internal pure returns (string memory result) {
        /// @solidity memory-safe-assembly
        assembly { // solhint-disable-line no-inline-assembly
            function _toHex16(input) -> output {
                output := or(
                    and(input, 0xFFFFFFFFFFFFFFFF000000000000000000000000000000000000000000000000),
                    shr(64, and(input, 0x0000000000000000FFFFFFFFFFFFFFFF00000000000000000000000000000000))
                )
                output := or(
                    and(output, 0xFFFFFFFF000000000000000000000000FFFFFFFF000000000000000000000000),
                    shr(32, and(output, 0x00000000FFFFFFFF000000000000000000000000FFFFFFFF0000000000000000))
                )
                output := or(
                    and(output, 0xFFFF000000000000FFFF000000000000FFFF000000000000FFFF000000000000),
                    shr(16, and(output, 0x0000FFFF000000000000FFFF000000000000FFFF000000000000FFFF00000000))
                )
                output := or(
                    and(output, 0xFF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000),
                    shr(8, and(output, 0x00FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF0000))
                )
                output := or(
                    shr(4, and(output, 0xF000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000)),
                    shr(8, and(output, 0x0F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F00))
                )
                output := add(
                    add(0x3030303030303030303030303030303030303030303030303030303030303030, output),
                    mul(
                        and(
                            shr(4, add(output, 0x0606060606060606060606060606060606060606060606060606060606060606)),
                            0x0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F
                        ),
                        7   // Change 7 to 39 for lower case output
                    )
                )
            }

            result := mload(0x40)
            let length := mload(data)
            let resultLength := shl(1, length)
            let toPtr := add(result, 0x22)          // 32 bytes for length + 2 bytes for '0x'
            mstore(0x40, add(toPtr, resultLength))  // move free memory pointer
            mstore(add(result, 2), 0x3078)          // 0x3078 is right aligned so we write to `result + 2`
                                                    // to store the last 2 bytes in the beginning of the string
            mstore(result, add(resultLength, 2))    // extra 2 bytes for '0x'

            for {
                let fromPtr := add(data, 0x20)
                let endPtr := add(fromPtr, length)
            } lt(fromPtr, endPtr) {
                fromPtr := add(fromPtr, 0x20)
            } {
                let rawData := mload(fromPtr)
                let hexData := _toHex16(rawData)
                mstore(toPtr, hexData)
                toPtr := add(toPtr, 0x20)
                hexData := _toHex16(shl(128, rawData))
                mstore(toPtr, hexData)
                toPtr := add(toPtr, 0x20)
            }
        }
    }
}


// File @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol@v4.7.3

// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface for the optional metadata functions from the ERC20 standard.
 *
 * _Available since v4.1._
 */
interface IERC20Metadata is IERC20 {
    /**
     * @dev Returns the name of the token.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the symbol of the token.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the decimals places of the token.
     */
    function decimals() external view returns (uint8);
}


// File @1inch/solidity-utils/contracts/libraries/UniERC20.sol@v2.1.1


pragma solidity ^0.8.0;





library UniERC20 {
    using SafeERC20 for IERC20;

    error InsufficientBalance();
    error ApproveCalledOnETH();
    error NotEnoughValue();
    error FromIsNotSender();
    error ToIsNotThis();
    error ETHTransferFailed();

    uint256 private constant _RAW_CALL_GAS_LIMIT = 5000;
    IERC20 private constant _ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);
    IERC20 private constant _ZERO_ADDRESS = IERC20(address(0));

    function isETH(IERC20 token) internal pure returns (bool) {
        return (token == _ZERO_ADDRESS || token == _ETH_ADDRESS);
    }

    function uniBalanceOf(IERC20 token, address account) internal view returns (uint256) {
        if (isETH(token)) {
            return account.balance;
        } else {
            return token.balanceOf(account);
        }
    }

    /// @dev note that this function does nothing in case of zero amount
    function uniTransfer(IERC20 token, address payable to, uint256 amount) internal {
        if (amount > 0) {
            if (isETH(token)) {
                if (address(this).balance < amount) revert InsufficientBalance();
                // solhint-disable-next-line avoid-low-level-calls
                (bool success, ) = to.call{value: amount, gas: _RAW_CALL_GAS_LIMIT}("""");
                if (!success) revert ETHTransferFailed();
            } else {
                token.safeTransfer(to, amount);
            }
        }
    }

    /// @dev note that this function does nothing in case of zero amount
    function uniTransferFrom(IERC20 token, address payable from, address to, uint256 amount) internal {
        if (amount > 0) {
            if (isETH(token)) {
                if (msg.value < amount) revert NotEnoughValue();
                if (from != msg.sender) revert FromIsNotSender();
                if (to != address(this)) revert ToIsNotThis();
                if (msg.value > amount) {
                    // Return remainder if exist
                    unchecked {
                        // solhint-disable-next-line avoid-low-level-calls
                        (bool success, ) = from.call{value: msg.value - amount, gas: _RAW_CALL_GAS_LIMIT}("""");
                        if (!success) revert ETHTransferFailed();
                    }
                }
            } else {
                token.safeTransferFrom(from, to, amount);
            }
        }
    }

    function uniSymbol(IERC20 token) internal view returns(string memory) {
        return _uniDecode(token, IERC20Metadata.symbol.selector, IERC20MetadataUppercase.SYMBOL.selector);
    }

    function uniName(IERC20 token) internal view returns(string memory) {
        return _uniDecode(token, IERC20Metadata.name.selector, IERC20MetadataUppercase.NAME.selector);
    }

    function uniApprove(IERC20 token, address to, uint256 amount) internal {
        if (isETH(token)) revert ApproveCalledOnETH();

        token.forceApprove(to, amount);
    }

    /// 20K gas is provided to account for possible implementations of name/symbol
    /// (token implementation might be behind proxy or store the value in storage)
    function _uniDecode(IERC20 token, bytes4 lowerCaseSelector, bytes4 upperCaseSelector) private view returns(string memory result) {
        if (isETH(token)) {
            return ""ETH"";
        }

        (bool success, bytes memory data) = address(token).staticcall{ gas: 20000 }(
            abi.encodeWithSelector(lowerCaseSelector)
        );
        if (!success) {
            (success, data) = address(token).staticcall{ gas: 20000 }(
                abi.encodeWithSelector(upperCaseSelector)
            );
        }

        if (success && data.length >= 0x40) {
            (uint256 offset, uint256 len) = abi.decode(data, (uint256, uint256));
            if (offset == 0x20 && len > 0 && data.length == 0x40 + len) {
                /// @solidity memory-safe-assembly
                assembly { // solhint-disable-line no-inline-assembly
                    result := add(data, 0x20)
                }
                return result;
            }
        }

        if (success && data.length == 32) {
            uint256 len = 0;
            while (len < data.length && data[len] >= 0x20 && data[len] <= 0x7E) {
                unchecked {
                    len++;
                }
            }

            if (len > 0) {
                /// @solidity memory-safe-assembly
                assembly { // solhint-disable-line no-inline-assembly
                    mstore(data, len)
                }
                return string(data);
            }
        }

        return StringUtil.toHex(address(token));
    }
}


// File contracts/routers/GenericRouter.sol


pragma solidity 0.8.17;





contract GenericRouter is EthReceiver {
    using UniERC20 for IERC20;
    using SafeERC20 for IERC20;

    error ZeroMinReturn();
    error ZeroReturnAmount();

    uint256 private constant _PARTIAL_FILL = 1 << 0;
    uint256 private constant _REQUIRES_EXTRA_ETH = 1 << 1;

    struct SwapDescription {
        IERC20 srcToken;
        IERC20 dstToken;
        address payable srcReceiver;
        address payable dstReceiver;
        uint256 amount;
        uint256 minReturnAmount;
        uint256 flags;
    }

    /// @notice Performs a swap, delegating all calls encoded in `data` to `executor`. See tests for usage examples
    /// @dev router keeps 1 wei of every token on the contract balance for gas optimisations reasons. This affects first swap of every token by leaving 1 wei on the contract.
    /// @param executor Aggregation executor that executes calls described in `data`
    /// @param desc Swap description
    /// @param permit Should contain valid permit that can be used in `IERC20Permit.permit` calls.
    /// @param data Encoded calls that `caller` should execute in between of swaps
    /// @return returnAmount Resulting token amount
    /// @return spentAmount Source token amount
    function swap(
        IAggregationExecutor executor,
        SwapDescription calldata desc,
        bytes calldata permit,
        bytes calldata data
    )
        external
        payable
        returns (
            uint256 returnAmount,
            uint256 spentAmount
        )
    {
        if (desc.minReturnAmount == 0) revert ZeroMinReturn();

        IERC20 srcToken = desc.srcToken;
        IERC20 dstToken = desc.dstToken;

        bool srcETH = srcToken.isETH();
        if (desc.flags & _REQUIRES_EXTRA_ETH != 0) {
            if (msg.value <= (srcETH ? desc.amount : 0)) revert RouterErrors.InvalidMsgValue();
        } else {
            if (msg.value != (srcETH ? desc.amount : 0)) revert RouterErrors.InvalidMsgValue();
        }

        if (!srcETH) {
            if (permit.length > 0) {
                srcToken.safePermit(permit);
            }
            srcToken.safeTransferFrom(msg.sender, desc.srcReceiver, desc.amount);
        }

        _execute(executor, msg.sender, desc.amount, data);

        spentAmount = desc.amount;
        // we leave 1 wei on the router for gas optimisations reasons
        returnAmount = dstToken.uniBalanceOf(address(this));
        if (returnAmount == 0) revert ZeroReturnAmount();
        unchecked { returnAmount--; }

        if (desc.flags & _PARTIAL_FILL != 0) {
            uint256 unspentAmount = srcToken.uniBalanceOf(address(this));
            if (unspentAmount > 1) {
                // we leave 1 wei on the router for gas optimisations reasons
                unchecked { unspentAmount--; }
                spentAmount -= unspentAmount;
                srcToken.uniTransfer(payable(msg.sender), unspentAmount);
            }
            if (returnAmount * desc.amount < desc.minReturnAmount * spentAmount) revert RouterErrors.ReturnAmountIsNotEnough();
        } else {
            if (returnAmount < desc.minReturnAmount) revert RouterErrors.ReturnAmountIsNotEnough();
        }

        address payable dstReceiver = (desc.dstReceiver == address(0)) ? payable(msg.sender) : desc.dstReceiver;
        dstToken.uniTransfer(dstReceiver, returnAmount);
    }

    function _execute(
        IAggregationExecutor executor,
        address srcTokenOwner,
        uint256 inputAmount,
        bytes calldata data
    ) private {
        bytes4 executeSelector = executor.execute.selector;
        /// @solidity memory-safe-assembly
        assembly {  // solhint-disable-line no-inline-assembly
            let ptr := mload(0x40)

            mstore(ptr, executeSelector)
            mstore(add(ptr, 0x04), srcTokenOwner)
            calldatacopy(add(ptr, 0x24), data.offset, data.length)
            mstore(add(add(ptr, 0x24), data.length), inputAmount)

            if iszero(call(gas(), executor, callvalue(), ptr, add(0x44, data.length), 0, 0)) {
                returndatacopy(ptr, 0, returndatasize())
                revert(ptr, returndatasize())
            }
        }
    }
}


// File contracts/routers/UnoswapRouter.sol


pragma solidity 0.8.17;




contract UnoswapRouter is EthReceiver {
    using SafeERC20 for IERC20;

    error ReservesCallFailed();
    error SwapAmountTooLarge();

    bytes4 private constant _TRANSFER_FROM_CALL_SELECTOR = 0x23b872dd;
    bytes4 private constant _WETH_DEPOSIT_CALL_SELECTOR = 0xd0e30db0;
    bytes4 private constant _WETH_WITHDRAW_CALL_SELECTOR = 0x2e1a7d4d;
    bytes4 private constant _ERC20_TRANSFER_CALL_SELECTOR = 0xa9059cbb;
    uint256 private constant _ADDRESS_MASK =   0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff;
    uint256 private constant _REVERSE_MASK =   0x8000000000000000000000000000000000000000000000000000000000000000;
    uint256 private constant _WETH_MASK =      0x4000000000000000000000000000000000000000000000000000000000000000;
    uint256 private constant _NUMERATOR_MASK = 0x0000000000000000ffffffff0000000000000000000000000000000000000000;
    /// @dev WETH address is network-specific and needs to be changed before deployment.
    /// It can not be moved to immutable as immutables are not supported in assembly
    address private constant _WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    bytes4 private constant _UNISWAP_PAIR_RESERVES_CALL_SELECTOR = 0x0902f1ac;
    bytes4 private constant _UNISWAP_PAIR_SWAP_CALL_SELECTOR = 0x022c0d9f;
    uint256 private constant _DENOMINATOR = 1e9;
    uint256 private constant _NUMERATOR_OFFSET = 160;
    uint256 private constant _MAX_SWAP_AMOUNT = (1 << 112) - 1;  // type(uint112).max;

    /// @notice Same as `unoswapTo` but calls permit first,
    /// allowing to approve token spending and make a swap in one transaction.
    /// @param recipient Address that will receive swapped funds
    /// @param srcToken Source token
    /// @param amount Amount of source tokens to swap
    /// @param minReturn Minimal allowed returnAmount to make transaction commit
    /// @param pools Pools chain used for swaps. Pools src and dst tokens should match to make swap happen
    /// @param permit Should contain valid permit that can be used in `IERC20Permit.permit` calls.
    /// See tests for examples
    function unoswapToWithPermit(
        address payable recipient,
        IERC20 srcToken,
        uint256 amount,
        uint256 minReturn,
        uint256[] calldata pools,
        bytes calldata permit
    ) external returns(uint256 returnAmount) {
        srcToken.safePermit(permit);
        return _unoswap(recipient, srcToken, amount, minReturn, pools);
    }

    /// @notice Performs swap using Uniswap exchange. Wraps and unwraps ETH if required.
    /// Sending non-zero `msg.value` for anything but ETH swaps is prohibited
    /// @param recipient Address that will receive swapped funds
    /// @param srcToken Source token
    /// @param amount Amount of source tokens to swap
    /// @param minReturn Minimal allowed returnAmount to make transaction commit
    /// @param pools Pools chain used for swaps. Pools src and dst tokens should match to make swap happen
    function unoswapTo(
        address payable recipient,
        IERC20 srcToken,
        uint256 amount,
        uint256 minReturn,
        uint256[] calldata pools
    ) external payable returns(uint256 returnAmount) {
        return _unoswap(recipient, srcToken, amount, minReturn, pools);
    }

    /// @notice Performs swap using Uniswap exchange. Wraps and unwraps ETH if required.
    /// Sending non-zero `msg.value` for anything but ETH swaps is prohibited
    /// @param srcToken Source token
    /// @param amount Amount of source tokens to swap
    /// @param minReturn Minimal allowed returnAmount to make transaction commit
    /// @param pools Pools chain used for swaps. Pools src and dst tokens should match to make swap happen
    function unoswap(
        IERC20 srcToken,
        uint256 amount,
        uint256 minReturn,
        uint256[] calldata pools
    ) external payable returns(uint256 returnAmount) {
        return _unoswap(payable(msg.sender), srcToken, amount, minReturn, pools);
    }

    function _unoswap(
        address payable recipient,
        IERC20 srcToken,
        uint256 amount,
        uint256 minReturn,
        uint256[] calldata pools
    ) private returns(uint256 returnAmount) {
        assembly {  // solhint-disable-line no-inline-assembly
            function reRevert() {
                returndatacopy(0, 0, returndatasize())
                revert(0, returndatasize())
            }

            function validateERC20Transfer(status) {
                if iszero(status) {
                    reRevert()
                }
                let success := or(
                    iszero(returndatasize()),                       // empty return data
                    and(gt(returndatasize(), 31), eq(mload(0), 1))  // true in return data
                )
                if iszero(success) {
                    mstore(0, 0xf27f64e400000000000000000000000000000000000000000000000000000000)  // ERC20TransferFailed()
                    revert(0, 4)
                }
            }

            function swap(emptyPtr, swapAmount, pair, reversed, numerator, to) -> ret {
                mstore(emptyPtr, _UNISWAP_PAIR_RESERVES_CALL_SELECTOR)
                if iszero(staticcall(gas(), pair, emptyPtr, 0x4, emptyPtr, 0x40)) {
                    reRevert()
                }
                if iszero(eq(returndatasize(), 0x60)) {
                    mstore(0, 0x85cd58dc00000000000000000000000000000000000000000000000000000000)  // ReservesCallFailed()
                    revert(0, 4)
                }

                let reserve0 := mload(emptyPtr)
                let reserve1 := mload(add(emptyPtr, 0x20))
                if reversed {
                    let tmp := reserve0
                    reserve0 := reserve1
                    reserve1 := tmp
                }
                // this will not overflow as reserve0, reserve1 and ret fit to 112 bit and numerator and _DENOMINATOR fit to 32 bit
                ret := mul(swapAmount, numerator)
                ret := div(mul(ret, reserve1), add(ret, mul(reserve0, _DENOMINATOR)))

                mstore(emptyPtr, _UNISWAP_PAIR_SWAP_CALL_SELECTOR)
                reversed := iszero(reversed)
                mstore(add(emptyPtr, 0x04), mul(ret, iszero(reversed)))
                mstore(add(emptyPtr, 0x24), mul(ret, reversed))
                mstore(add(emptyPtr, 0x44), to)
                mstore(add(emptyPtr, 0x64), 0x80)
                mstore(add(emptyPtr, 0x84), 0)
                if iszero(call(gas(), pair, 0, emptyPtr, 0xa4, 0, 0)) {
                    reRevert()
                }
            }

            // make sure that input amount fits in 112 bit
            if gt(amount, _MAX_SWAP_AMOUNT) {
                mstore(0, 0xcf0b4d3a00000000000000000000000000000000000000000000000000000000)  // SwapAmountTooLarge()
                revert(0, 4)
            }

            let emptyPtr := mload(0x40)
            mstore(0x40, add(emptyPtr, 0xc0))

            let poolsEndOffset := add(pools.offset, shl(5, pools.length))
            let rawPair := calldataload(pools.offset)
            switch srcToken
            case 0 {
                if iszero(eq(amount, callvalue())) {
                    mstore(0, 0x1841b4e100000000000000000000000000000000000000000000000000000000)  // InvalidMsgValue()
                    revert(0, 4)
                }

                mstore(emptyPtr, _WETH_DEPOSIT_CALL_SELECTOR)
                if iszero(call(gas(), _WETH, amount, emptyPtr, 0x4, 0, 0)) {
                    reRevert()
                }

                mstore(emptyPtr, _ERC20_TRANSFER_CALL_SELECTOR)
                mstore(add(emptyPtr, 0x4), and(rawPair, _ADDRESS_MASK))
                mstore(add(emptyPtr, 0x24), amount)
                if iszero(call(gas(), _WETH, 0, emptyPtr, 0x44, 0, 0)) {
                    reRevert()
                }
            }
            default {
                if callvalue() {
                    mstore(0, 0x1841b4e100000000000000000000000000000000000000000000000000000000)  // InvalidMsgValue()
                    revert(0, 4)
                }

                mstore(emptyPtr, _TRANSFER_FROM_CALL_SELECTOR)
                mstore(add(emptyPtr, 0x4), caller())
                mstore(add(emptyPtr, 0x24), and(rawPair, _ADDRESS_MASK))
                mstore(add(emptyPtr, 0x44), amount)
                validateERC20Transfer(
                    call(gas(), srcToken, 0, emptyPtr, 0x64, 0, 0x20)
                )
            }

            returnAmount := amount

            for {let i := add(pools.offset, 0x20)} lt(i, poolsEndOffset) {i := add(i, 0x20)} {
                let nextRawPair := calldataload(i)

                returnAmount := swap(
                    emptyPtr,
                    returnAmount,
                    and(rawPair, _ADDRESS_MASK),
                    and(rawPair, _REVERSE_MASK),
                    shr(_NUMERATOR_OFFSET, and(rawPair, _NUMERATOR_MASK)),
                    and(nextRawPair, _ADDRESS_MASK)
                )

                rawPair := nextRawPair
            }

            switch and(rawPair, _WETH_MASK)
            case 0 {
                returnAmount := swap(
                    emptyPtr,
                    returnAmount,
                    and(rawPair, _ADDRESS_MASK),
                    and(rawPair, _REVERSE_MASK),
                    shr(_NUMERATOR_OFFSET, and(rawPair, _NUMERATOR_MASK)),
                    recipient
                )
            }
            default {
                returnAmount := swap(
                    emptyPtr,
                    returnAmount,
                    and(rawPair, _ADDRESS_MASK),
                    and(rawPair, _REVERSE_MASK),
                    shr(_NUMERATOR_OFFSET, and(rawPair, _NUMERATOR_MASK)),
                    address()
                )

                mstore(emptyPtr, _WETH_WITHDRAW_CALL_SELECTOR)
                mstore(add(emptyPtr, 0x04), returnAmount)
                if iszero(call(gas(), _WETH, 0, emptyPtr, 0x24, 0, 0)) {
                    reRevert()
                }

                if iszero(call(gas(), recipient, returnAmount, 0, 0, 0, 0)) {
                    reRevert()
                }
            }
        }
        if (returnAmount < minReturn) revert RouterErrors.ReturnAmountIsNotEnough();
    }
}


// File contracts/interfaces/IUniswapV3Pool.sol

pragma solidity 0.8.17;

interface IUniswapV3Pool {
    /// @notice Swap token0 for token1, or token1 for token0
    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback
    /// @param recipient The address to receive the output of the swap
    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0
    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)
    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this
    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap
    /// @param data Any data to be passed through to the callback
    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive
    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive
    function swap(
        address recipient,
        bool zeroForOne,
        int256 amountSpecified,
        uint160 sqrtPriceLimitX96,
        bytes calldata data
    ) external returns (int256 amount0, int256 amount1);

    /// @notice The first of the two tokens of the pool, sorted by address
    /// @return The token contract address
    function token0() external view returns (address);

    /// @notice The second of the two tokens of the pool, sorted by address
    /// @return The token contract address
    function token1() external view returns (address);

    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6
    /// @return The fee
    function fee() external view returns (uint24);
}


// File contracts/interfaces/IUniswapV3SwapCallback.sol

pragma solidity 0.8.17;

/// @title Callback for IUniswapV3PoolActions#swap
/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface
interface IUniswapV3SwapCallback {
    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.
    /// @dev In the implementation you must pay the pool tokens owed for the swap.
    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.
    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.
    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by
    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.
    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by
    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.
    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call
    function uniswapV3SwapCallback(
        int256 amount0Delta,
        int256 amount1Delta,
        bytes calldata data
    ) external;
}


// File @openzeppelin/contracts/utils/Address.sol@v4.7.3

// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)

pragma solidity ^0.8.1;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     *
     * [IMPORTANT]
     * ====
     * You shouldn't rely on `isContract` to protect against flash loan attacks!
     *
     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
     * constructor.
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, ""Address: insufficient balance"");

        (bool success, ) = recipient.call{value: amount}("""");
        require(success, ""Address: unable to send value, recipient may have reverted"");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, ""Address: low-level call failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, ""Address: insufficient balance for call"");
        require(isContract(target), ""Address: call to non-contract"");

        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, ""Address: low-level static call failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        require(isContract(target), ""Address: static call to non-contract"");

        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, ""Address: low-level delegate call failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(isContract(target), ""Address: delegate call to non-contract"");

        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly
                /// @solidity memory-safe-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}


// File @openzeppelin/contracts/utils/math/SafeCast.sol@v4.7.3

// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/SafeCast.sol)

pragma solidity ^0.8.0;

/**
 * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow
 * checks.
 *
 * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can
 * easily result in undesired exploitation or bugs, since developers usually
 * assume that overflows raise errors. `SafeCast` restores this intuition by
 * reverting the transaction when such an operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 *
 * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing
 * all math on `uint256` and `int256` and then downcasting.
 */
library SafeCast {
    /**
     * @dev Returns the downcasted uint248 from uint256, reverting on
     * overflow (when the input is greater than largest uint248).
     *
     * Counterpart to Solidity's `uint248` operator.
     *
     * Requirements:
     *
     * - input must fit into 248 bits
     *
     * _Available since v4.7._
     */
    function toUint248(uint256 value) internal pure returns (uint248) {
        require(value <= type(uint248).max, ""SafeCast: value doesn't fit in 248 bits"");
        return uint248(value);
    }

    /**
     * @dev Returns the downcasted uint240 from uint256, reverting on
     * overflow (when the input is greater than largest uint240).
     *
     * Counterpart to Solidity's `uint240` operator.
     *
     * Requirements:
     *
     * - input must fit into 240 bits
     *
     * _Available since v4.7._
     */
    function toUint240(uint256 value) internal pure returns (uint240) {
        require(value <= type(uint240).max, ""SafeCast: value doesn't fit in 240 bits"");
        return uint240(value);
    }

    /**
     * @dev Returns the downcasted uint232 from uint256, reverting on
     * overflow (when the input is greater than largest uint232).
     *
     * Counterpart to Solidity's `uint232` operator.
     *
     * Requirements:
     *
     * - input must fit into 232 bits
     *
     * _Available since v4.7._
     */
    function toUint232(uint256 value) internal pure returns (uint232) {
        require(value <= type(uint232).max, ""SafeCast: value doesn't fit in 232 bits"");
        return uint232(value);
    }

    /**
     * @dev Returns the downcasted uint224 from uint256, reverting on
     * overflow (when the input is greater than largest uint224).
     *
     * Counterpart to Solidity's `uint224` operator.
     *
     * Requirements:
     *
     * - input must fit into 224 bits
     *
     * _Available since v4.2._
     */
    function toUint224(uint256 value) internal pure returns (uint224) {
        require(value <= type(uint224).max, ""SafeCast: value doesn't fit in 224 bits"");
        return uint224(value);
    }

    /**
     * @dev Returns the downcasted uint216 from uint256, reverting on
     * overflow (when the input is greater than largest uint216).
     *
     * Counterpart to Solidity's `uint216` operator.
     *
     * Requirements:
     *
     * - input must fit into 216 bits
     *
     * _Available since v4.7._
     */
    function toUint216(uint256 value) internal pure returns (uint216) {
        require(value <= type(uint216).max, ""SafeCast: value doesn't fit in 216 bits"");
        return uint216(value);
    }

    /**
     * @dev Returns the downcasted uint208 from uint256, reverting on
     * overflow (when the input is greater than largest uint208).
     *
     * Counterpart to Solidity's `uint208` operator.
     *
     * Requirements:
     *
     * - input must fit into 208 bits
     *
     * _Available since v4.7._
     */
    function toUint208(uint256 value) internal pure returns (uint208) {
        require(value <= type(uint208).max, ""SafeCast: value doesn't fit in 208 bits"");
        return uint208(value);
    }

    /**
     * @dev Returns the downcasted uint200 from uint256, reverting on
     * overflow (when the input is greater than largest uint200).
     *
     * Counterpart to Solidity's `uint200` operator.
     *
     * Requirements:
     *
     * - input must fit into 200 bits
     *
     * _Available since v4.7._
     */
    function toUint200(uint256 value) internal pure returns (uint200) {
        require(value <= type(uint200).max, ""SafeCast: value doesn't fit in 200 bits"");
        return uint200(value);
    }

    /**
     * @dev Returns the downcasted uint192 from uint256, reverting on
     * overflow (when the input is greater than largest uint192).
     *
     * Counterpart to Solidity's `uint192` operator.
     *
     * Requirements:
     *
     * - input must fit into 192 bits
     *
     * _Available since v4.7._
     */
    function toUint192(uint256 value) internal pure returns (uint192) {
        require(value <= type(uint192).max, ""SafeCast: value doesn't fit in 192 bits"");
        return uint192(value);
    }

    /**
     * @dev Returns the downcasted uint184 from uint256, reverting on
     * overflow (when the input is greater than largest uint184).
     *
     * Counterpart to Solidity's `uint184` operator.
     *
     * Requirements:
     *
     * - input must fit into 184 bits
     *
     * _Available since v4.7._
     */
    function toUint184(uint256 value) internal pure returns (uint184) {
        require(value <= type(uint184).max, ""SafeCast: value doesn't fit in 184 bits"");
        return uint184(value);
    }

    /**
     * @dev Returns the downcasted uint176 from uint256, reverting on
     * overflow (when the input is greater than largest uint176).
     *
     * Counterpart to Solidity's `uint176` operator.
     *
     * Requirements:
     *
     * - input must fit into 176 bits
     *
     * _Available since v4.7._
     */
    function toUint176(uint256 value) internal pure returns (uint176) {
        require(value <= type(uint176).max, ""SafeCast: value doesn't fit in 176 bits"");
        return uint176(value);
    }

    /**
     * @dev Returns the downcasted uint168 from uint256, reverting on
     * overflow (when the input is greater than largest uint168).
     *
     * Counterpart to Solidity's `uint168` operator.
     *
     * Requirements:
     *
     * - input must fit into 168 bits
     *
     * _Available since v4.7._
     */
    function toUint168(uint256 value) internal pure returns (uint168) {
        require(value <= type(uint168).max, ""SafeCast: value doesn't fit in 168 bits"");
        return uint168(value);
    }

    /**
     * @dev Returns the downcasted uint160 from uint256, reverting on
     * overflow (when the input is greater than largest uint160).
     *
     * Counterpart to Solidity's `uint160` operator.
     *
     * Requirements:
     *
     * - input must fit into 160 bits
     *
     * _Available since v4.7._
     */
    function toUint160(uint256 value) internal pure returns (uint160) {
        require(value <= type(uint160).max, ""SafeCast: value doesn't fit in 160 bits"");
        return uint160(value);
    }

    /**
     * @dev Returns the downcasted uint152 from uint256, reverting on
     * overflow (when the input is greater than largest uint152).
     *
     * Counterpart to Solidity's `uint152` operator.
     *
     * Requirements:
     *
     * - input must fit into 152 bits
     *
     * _Available since v4.7._
     */
    function toUint152(uint256 value) internal pure returns (uint152) {
        require(value <= type(uint152).max, ""SafeCast: value doesn't fit in 152 bits"");
        return uint152(value);
    }

    /**
     * @dev Returns the downcasted uint144 from uint256, reverting on
     * overflow (when the input is greater than largest uint144).
     *
     * Counterpart to Solidity's `uint144` operator.
     *
     * Requirements:
     *
     * - input must fit into 144 bits
     *
     * _Available since v4.7._
     */
    function toUint144(uint256 value) internal pure returns (uint144) {
        require(value <= type(uint144).max, ""SafeCast: value doesn't fit in 144 bits"");
        return uint144(value);
    }

    /**
     * @dev Returns the downcasted uint136 from uint256, reverting on
     * overflow (when the input is greater than largest uint136).
     *
     * Counterpart to Solidity's `uint136` operator.
     *
     * Requirements:
     *
     * - input must fit into 136 bits
     *
     * _Available since v4.7._
     */
    function toUint136(uint256 value) internal pure returns (uint136) {
        require(value <= type(uint136).max, ""SafeCast: value doesn't fit in 136 bits"");
        return uint136(value);
    }

    /**
     * @dev Returns the downcasted uint128 from uint256, reverting on
     * overflow (when the input is greater than largest uint128).
     *
     * Counterpart to Solidity's `uint128` operator.
     *
     * Requirements:
     *
     * - input must fit into 128 bits
     *
     * _Available since v2.5._
     */
    function toUint128(uint256 value) internal pure returns (uint128) {
        require(value <= type(uint128).max, ""SafeCast: value doesn't fit in 128 bits"");
        return uint128(value);
    }

    /**
     * @dev Returns the downcasted uint120 from uint256, reverting on
     * overflow (when the input is greater than largest uint120).
     *
     * Counterpart to Solidity's `uint120` operator.
     *
     * Requirements:
     *
     * - input must fit into 120 bits
     *
     * _Available since v4.7._
     */
    function toUint120(uint256 value) internal pure returns (uint120) {
        require(value <= type(uint120).max, ""SafeCast: value doesn't fit in 120 bits"");
        return uint120(value);
    }

    /**
     * @dev Returns the downcasted uint112 from uint256, reverting on
     * overflow (when the input is greater than largest uint112).
     *
     * Counterpart to Solidity's `uint112` operator.
     *
     * Requirements:
     *
     * - input must fit into 112 bits
     *
     * _Available since v4.7._
     */
    function toUint112(uint256 value) internal pure returns (uint112) {
        require(value <= type(uint112).max, ""SafeCast: value doesn't fit in 112 bits"");
        return uint112(value);
    }

    /**
     * @dev Returns the downcasted uint104 from uint256, reverting on
     * overflow (when the input is greater than largest uint104).
     *
     * Counterpart to Solidity's `uint104` operator.
     *
     * Requirements:
     *
     * - input must fit into 104 bits
     *
     * _Available since v4.7._
     */
    function toUint104(uint256 value) internal pure returns (uint104) {
        require(value <= type(uint104).max, ""SafeCast: value doesn't fit in 104 bits"");
        return uint104(value);
    }

    /**
     * @dev Returns the downcasted uint96 from uint256, reverting on
     * overflow (when the input is greater than largest uint96).
     *
     * Counterpart to Solidity's `uint96` operator.
     *
     * Requirements:
     *
     * - input must fit into 96 bits
     *
     * _Available since v4.2._
     */
    function toUint96(uint256 value) internal pure returns (uint96) {
        require(value <= type(uint96).max, ""SafeCast: value doesn't fit in 96 bits"");
        return uint96(value);
    }

    /**
     * @dev Returns the downcasted uint88 from uint256, reverting on
     * overflow (when the input is greater than largest uint88).
     *
     * Counterpart to Solidity's `uint88` operator.
     *
     * Requirements:
     *
     * - input must fit into 88 bits
     *
     * _Available since v4.7._
     */
    function toUint88(uint256 value) internal pure returns (uint88) {
        require(value <= type(uint88).max, ""SafeCast: value doesn't fit in 88 bits"");
        return uint88(value);
    }

    /**
     * @dev Returns the downcasted uint80 from uint256, reverting on
     * overflow (when the input is greater than largest uint80).
     *
     * Counterpart to Solidity's `uint80` operator.
     *
     * Requirements:
     *
     * - input must fit into 80 bits
     *
     * _Available since v4.7._
     */
    function toUint80(uint256 value) internal pure returns (uint80) {
        require(value <= type(uint80).max, ""SafeCast: value doesn't fit in 80 bits"");
        return uint80(value);
    }

    /**
     * @dev Returns the downcasted uint72 from uint256, reverting on
     * overflow (when the input is greater than largest uint72).
     *
     * Counterpart to Solidity's `uint72` operator.
     *
     * Requirements:
     *
     * - input must fit into 72 bits
     *
     * _Available since v4.7._
     */
    function toUint72(uint256 value) internal pure returns (uint72) {
        require(value <= type(uint72).max, ""SafeCast: value doesn't fit in 72 bits"");
        return uint72(value);
    }

    /**
     * @dev Returns the downcasted uint64 from uint256, reverting on
     * overflow (when the input is greater than largest uint64).
     *
     * Counterpart to Solidity's `uint64` operator.
     *
     * Requirements:
     *
     * - input must fit into 64 bits
     *
     * _Available since v2.5._
     */
    function toUint64(uint256 value) internal pure returns (uint64) {
        require(value <= type(uint64).max, ""SafeCast: value doesn't fit in 64 bits"");
        return uint64(value);
    }

    /**
     * @dev Returns the downcasted uint56 from uint256, reverting on
     * overflow (when the input is greater than largest uint56).
     *
     * Counterpart to Solidity's `uint56` operator.
     *
     * Requirements:
     *
     * - input must fit into 56 bits
     *
     * _Available since v4.7._
     */
    function toUint56(uint256 value) internal pure returns (uint56) {
        require(value <= type(uint56).max, ""SafeCast: value doesn't fit in 56 bits"");
        return uint56(value);
    }

    /**
     * @dev Returns the downcasted uint48 from uint256, reverting on
     * overflow (when the input is greater than largest uint48).
     *
     * Counterpart to Solidity's `uint48` operator.
     *
     * Requirements:
     *
     * - input must fit into 48 bits
     *
     * _Available since v4.7._
     */
    function toUint48(uint256 value) internal pure returns (uint48) {
        require(value <= type(uint48).max, ""SafeCast: value doesn't fit in 48 bits"");
        return uint48(value);
    }

    /**
     * @dev Returns the downcasted uint40 from uint256, reverting on
     * overflow (when the input is greater than largest uint40).
     *
     * Counterpart to Solidity's `uint40` operator.
     *
     * Requirements:
     *
     * - input must fit into 40 bits
     *
     * _Available since v4.7._
     */
    function toUint40(uint256 value) internal pure returns (uint40) {
        require(value <= type(uint40).max, ""SafeCast: value doesn't fit in 40 bits"");
        return uint40(value);
    }

    /**
     * @dev Returns the downcasted uint32 from uint256, reverting on
     * overflow (when the input is greater than largest uint32).
     *
     * Counterpart to Solidity's `uint32` operator.
     *
     * Requirements:
     *
     * - input must fit into 32 bits
     *
     * _Available since v2.5._
     */
    function toUint32(uint256 value) internal pure returns (uint32) {
        require(value <= type(uint32).max, ""SafeCast: value doesn't fit in 32 bits"");
        return uint32(value);
    }

    /**
     * @dev Returns the downcasted uint24 from uint256, reverting on
     * overflow (when the input is greater than largest uint24).
     *
     * Counterpart to Solidity's `uint24` operator.
     *
     * Requirements:
     *
     * - input must fit into 24 bits
     *
     * _Available since v4.7._
     */
    function toUint24(uint256 value) internal pure returns (uint24) {
        require(value <= type(uint24).max, ""SafeCast: value doesn't fit in 24 bits"");
        return uint24(value);
    }

    /**
     * @dev Returns the downcasted uint16 from uint256, reverting on
     * overflow (when the input is greater than largest uint16).
     *
     * Counterpart to Solidity's `uint16` operator.
     *
     * Requirements:
     *
     * - input must fit into 16 bits
     *
     * _Available since v2.5._
     */
    function toUint16(uint256 value) internal pure returns (uint16) {
        require(value <= type(uint16).max, ""SafeCast: value doesn't fit in 16 bits"");
        return uint16(value);
    }

    /**
     * @dev Returns the downcasted uint8 from uint256, reverting on
     * overflow (when the input is greater than largest uint8).
     *
     * Counterpart to Solidity's `uint8` operator.
     *
     * Requirements:
     *
     * - input must fit into 8 bits
     *
     * _Available since v2.5._
     */
    function toUint8(uint256 value) internal pure returns (uint8) {
        require(value <= type(uint8).max, ""SafeCast: value doesn't fit in 8 bits"");
        return uint8(value);
    }

    /**
     * @dev Converts a signed int256 into an unsigned uint256.
     *
     * Requirements:
     *
     * - input must be greater than or equal to 0.
     *
     * _Available since v3.0._
     */
    function toUint256(int256 value) internal pure returns (uint256) {
        require(value >= 0, ""SafeCast: value must be positive"");
        return uint256(value);
    }

    /**
     * @dev Returns the downcasted int248 from int256, reverting on
     * overflow (when the input is less than smallest int248 or
     * greater than largest int248).
     *
     * Counterpart to Solidity's `int248` operator.
     *
     * Requirements:
     *
     * - input must fit into 248 bits
     *
     * _Available since v4.7._
     */
    function toInt248(int256 value) internal pure returns (int248) {
        require(value >= type(int248).min && value <= type(int248).max, ""SafeCast: value doesn't fit in 248 bits"");
        return int248(value);
    }

    /**
     * @dev Returns the downcasted int240 from int256, reverting on
     * overflow (when the input is less than smallest int240 or
     * greater than largest int240).
     *
     * Counterpart to Solidity's `int240` operator.
     *
     * Requirements:
     *
     * - input must fit into 240 bits
     *
     * _Available since v4.7._
     */
    function toInt240(int256 value) internal pure returns (int240) {
        require(value >= type(int240).min && value <= type(int240).max, ""SafeCast: value doesn't fit in 240 bits"");
        return int240(value);
    }

    /**
     * @dev Returns the downcasted int232 from int256, reverting on
     * overflow (when the input is less than smallest int232 or
     * greater than largest int232).
     *
     * Counterpart to Solidity's `int232` operator.
     *
     * Requirements:
     *
     * - input must fit into 232 bits
     *
     * _Available since v4.7._
     */
    function toInt232(int256 value) internal pure returns (int232) {
        require(value >= type(int232).min && value <= type(int232).max, ""SafeCast: value doesn't fit in 232 bits"");
        return int232(value);
    }

    /**
     * @dev Returns the downcasted int224 from int256, reverting on
     * overflow (when the input is less than smallest int224 or
     * greater than largest int224).
     *
     * Counterpart to Solidity's `int224` operator.
     *
     * Requirements:
     *
     * - input must fit into 224 bits
     *
     * _Available since v4.7._
     */
    function toInt224(int256 value) internal pure returns (int224) {
        require(value >= type(int224).min && value <= type(int224).max, ""SafeCast: value doesn't fit in 224 bits"");
        return int224(value);
    }

    /**
     * @dev Returns the downcasted int216 from int256, reverting on
     * overflow (when the input is less than smallest int216 or
     * greater than largest int216).
     *
     * Counterpart to Solidity's `int216` operator.
     *
     * Requirements:
     *
     * - input must fit into 216 bits
     *
     * _Available since v4.7._
     */
    function toInt216(int256 value) internal pure returns (int216) {
        require(value >= type(int216).min && value <= type(int216).max, ""SafeCast: value doesn't fit in 216 bits"");
        return int216(value);
    }

    /**
     * @dev Returns the downcasted int208 from int256, reverting on
     * overflow (when the input is less than smallest int208 or
     * greater than largest int208).
     *
     * Counterpart to Solidity's `int208` operator.
     *
     * Requirements:
     *
     * - input must fit into 208 bits
     *
     * _Available since v4.7._
     */
    function toInt208(int256 value) internal pure returns (int208) {
        require(value >= type(int208).min && value <= type(int208).max, ""SafeCast: value doesn't fit in 208 bits"");
        return int208(value);
    }

    /**
     * @dev Returns the downcasted int200 from int256, reverting on
     * overflow (when the input is less than smallest int200 or
     * greater than largest int200).
     *
     * Counterpart to Solidity's `int200` operator.
     *
     * Requirements:
     *
     * - input must fit into 200 bits
     *
     * _Available since v4.7._
     */
    function toInt200(int256 value) internal pure returns (int200) {
        require(value >= type(int200).min && value <= type(int200).max, ""SafeCast: value doesn't fit in 200 bits"");
        return int200(value);
    }

    /**
     * @dev Returns the downcasted int192 from int256, reverting on
     * overflow (when the input is less than smallest int192 or
     * greater than largest int192).
     *
     * Counterpart to Solidity's `int192` operator.
     *
     * Requirements:
     *
     * - input must fit into 192 bits
     *
     * _Available since v4.7._
     */
    function toInt192(int256 value) internal pure returns (int192) {
        require(value >= type(int192).min && value <= type(int192).max, ""SafeCast: value doesn't fit in 192 bits"");
        return int192(value);
    }

    /**
     * @dev Returns the downcasted int184 from int256, reverting on
     * overflow (when the input is less than smallest int184 or
     * greater than largest int184).
     *
     * Counterpart to Solidity's `int184` operator.
     *
     * Requirements:
     *
     * - input must fit into 184 bits
     *
     * _Available since v4.7._
     */
    function toInt184(int256 value) internal pure returns (int184) {
        require(value >= type(int184).min && value <= type(int184).max, ""SafeCast: value doesn't fit in 184 bits"");
        return int184(value);
    }

    /**
     * @dev Returns the downcasted int176 from int256, reverting on
     * overflow (when the input is less than smallest int176 or
     * greater than largest int176).
     *
     * Counterpart to Solidity's `int176` operator.
     *
     * Requirements:
     *
     * - input must fit into 176 bits
     *
     * _Available since v4.7._
     */
    function toInt176(int256 value) internal pure returns (int176) {
        require(value >= type(int176).min && value <= type(int176).max, ""SafeCast: value doesn't fit in 176 bits"");
        return int176(value);
    }

    /**
     * @dev Returns the downcasted int168 from int256, reverting on
     * overflow (when the input is less than smallest int168 or
     * greater than largest int168).
     *
     * Counterpart to Solidity's `int168` operator.
     *
     * Requirements:
     *
     * - input must fit into 168 bits
     *
     * _Available since v4.7._
     */
    function toInt168(int256 value) internal pure returns (int168) {
        require(value >= type(int168).min && value <= type(int168).max, ""SafeCast: value doesn't fit in 168 bits"");
        return int168(value);
    }

    /**
     * @dev Returns the downcasted int160 from int256, reverting on
     * overflow (when the input is less than smallest int160 or
     * greater than largest int160).
     *
     * Counterpart to Solidity's `int160` operator.
     *
     * Requirements:
     *
     * - input must fit into 160 bits
     *
     * _Available since v4.7._
     */
    function toInt160(int256 value) internal pure returns (int160) {
        require(value >= type(int160).min && value <= type(int160).max, ""SafeCast: value doesn't fit in 160 bits"");
        return int160(value);
    }

    /**
     * @dev Returns the downcasted int152 from int256, reverting on
     * overflow (when the input is less than smallest int152 or
     * greater than largest int152).
     *
     * Counterpart to Solidity's `int152` operator.
     *
     * Requirements:
     *
     * - input must fit into 152 bits
     *
     * _Available since v4.7._
     */
    function toInt152(int256 value) internal pure returns (int152) {
        require(value >= type(int152).min && value <= type(int152).max, ""SafeCast: value doesn't fit in 152 bits"");
        return int152(value);
    }

    /**
     * @dev Returns the downcasted int144 from int256, reverting on
     * overflow (when the input is less than smallest int144 or
     * greater than largest int144).
     *
     * Counterpart to Solidity's `int144` operator.
     *
     * Requirements:
     *
     * - input must fit into 144 bits
     *
     * _Available since v4.7._
     */
    function toInt144(int256 value) internal pure returns (int144) {
        require(value >= type(int144).min && value <= type(int144).max, ""SafeCast: value doesn't fit in 144 bits"");
        return int144(value);
    }

    /**
     * @dev Returns the downcasted int136 from int256, reverting on
     * overflow (when the input is less than smallest int136 or
     * greater than largest int136).
     *
     * Counterpart to Solidity's `int136` operator.
     *
     * Requirements:
     *
     * - input must fit into 136 bits
     *
     * _Available since v4.7._
     */
    function toInt136(int256 value) internal pure returns (int136) {
        require(value >= type(int136).min && value <= type(int136).max, ""SafeCast: value doesn't fit in 136 bits"");
        return int136(value);
    }

    /**
     * @dev Returns the downcasted int128 from int256, reverting on
     * overflow (when the input is less than smallest int128 or
     * greater than largest int128).
     *
     * Counterpart to Solidity's `int128` operator.
     *
     * Requirements:
     *
     * - input must fit into 128 bits
     *
     * _Available since v3.1._
     */
    function toInt128(int256 value) internal pure returns (int128) {
        require(value >= type(int128).min && value <= type(int128).max, ""SafeCast: value doesn't fit in 128 bits"");
        return int128(value);
    }

    /**
     * @dev Returns the downcasted int120 from int256, reverting on
     * overflow (when the input is less than smallest int120 or
     * greater than largest int120).
     *
     * Counterpart to Solidity's `int120` operator.
     *
     * Requirements:
     *
     * - input must fit into 120 bits
     *
     * _Available since v4.7._
     */
    function toInt120(int256 value) internal pure returns (int120) {
        require(value >= type(int120).min && value <= type(int120).max, ""SafeCast: value doesn't fit in 120 bits"");
        return int120(value);
    }

    /**
     * @dev Returns the downcasted int112 from int256, reverting on
     * overflow (when the input is less than smallest int112 or
     * greater than largest int112).
     *
     * Counterpart to Solidity's `int112` operator.
     *
     * Requirements:
     *
     * - input must fit into 112 bits
     *
     * _Available since v4.7._
     */
    function toInt112(int256 value) internal pure returns (int112) {
        require(value >= type(int112).min && value <= type(int112).max, ""SafeCast: value doesn't fit in 112 bits"");
        return int112(value);
    }

    /**
     * @dev Returns the downcasted int104 from int256, reverting on
     * overflow (when the input is less than smallest int104 or
     * greater than largest int104).
     *
     * Counterpart to Solidity's `int104` operator.
     *
     * Requirements:
     *
     * - input must fit into 104 bits
     *
     * _Available since v4.7._
     */
    function toInt104(int256 value) internal pure returns (int104) {
        require(value >= type(int104).min && value <= type(int104).max, ""SafeCast: value doesn't fit in 104 bits"");
        return int104(value);
    }

    /**
     * @dev Returns the downcasted int96 from int256, reverting on
     * overflow (when the input is less than smallest int96 or
     * greater than largest int96).
     *
     * Counterpart to Solidity's `int96` operator.
     *
     * Requirements:
     *
     * - input must fit into 96 bits
     *
     * _Available since v4.7._
     */
    function toInt96(int256 value) internal pure returns (int96) {
        require(value >= type(int96).min && value <= type(int96).max, ""SafeCast: value doesn't fit in 96 bits"");
        return int96(value);
    }

    /**
     * @dev Returns the downcasted int88 from int256, reverting on
     * overflow (when the input is less than smallest int88 or
     * greater than largest int88).
     *
     * Counterpart to Solidity's `int88` operator.
     *
     * Requirements:
     *
     * - input must fit into 88 bits
     *
     * _Available since v4.7._
     */
    function toInt88(int256 value) internal pure returns (int88) {
        require(value >= type(int88).min && value <= type(int88).max, ""SafeCast: value doesn't fit in 88 bits"");
        return int88(value);
    }

    /**
     * @dev Returns the downcasted int80 from int256, reverting on
     * overflow (when the input is less than smallest int80 or
     * greater than largest int80).
     *
     * Counterpart to Solidity's `int80` operator.
     *
     * Requirements:
     *
     * - input must fit into 80 bits
     *
     * _Available since v4.7._
     */
    function toInt80(int256 value) internal pure returns (int80) {
        require(value >= type(int80).min && value <= type(int80).max, ""SafeCast: value doesn't fit in 80 bits"");
        return int80(value);
    }

    /**
     * @dev Returns the downcasted int72 from int256, reverting on
     * overflow (when the input is less than smallest int72 or
     * greater than largest int72).
     *
     * Counterpart to Solidity's `int72` operator.
     *
     * Requirements:
     *
     * - input must fit into 72 bits
     *
     * _Available since v4.7._
     */
    function toInt72(int256 value) internal pure returns (int72) {
        require(value >= type(int72).min && value <= type(int72).max, ""SafeCast: value doesn't fit in 72 bits"");
        return int72(value);
    }

    /**
     * @dev Returns the downcasted int64 from int256, reverting on
     * overflow (when the input is less than smallest int64 or
     * greater than largest int64).
     *
     * Counterpart to Solidity's `int64` operator.
     *
     * Requirements:
     *
     * - input must fit into 64 bits
     *
     * _Available since v3.1._
     */
    function toInt64(int256 value) internal pure returns (int64) {
        require(value >= type(int64).min && value <= type(int64).max, ""SafeCast: value doesn't fit in 64 bits"");
        return int64(value);
    }

    /**
     * @dev Returns the downcasted int56 from int256, reverting on
     * overflow (when the input is less than smallest int56 or
     * greater than largest int56).
     *
     * Counterpart to Solidity's `int56` operator.
     *
     * Requirements:
     *
     * - input must fit into 56 bits
     *
     * _Available since v4.7._
     */
    function toInt56(int256 value) internal pure returns (int56) {
        require(value >= type(int56).min && value <= type(int56).max, ""SafeCast: value doesn't fit in 56 bits"");
        return int56(value);
    }

    /**
     * @dev Returns the downcasted int48 from int256, reverting on
     * overflow (when the input is less than smallest int48 or
     * greater than largest int48).
     *
     * Counterpart to Solidity's `int48` operator.
     *
     * Requirements:
     *
     * - input must fit into 48 bits
     *
     * _Available since v4.7._
     */
    function toInt48(int256 value) internal pure returns (int48) {
        require(value >= type(int48).min && value <= type(int48).max, ""SafeCast: value doesn't fit in 48 bits"");
        return int48(value);
    }

    /**
     * @dev Returns the downcasted int40 from int256, reverting on
     * overflow (when the input is less than smallest int40 or
     * greater than largest int40).
     *
     * Counterpart to Solidity's `int40` operator.
     *
     * Requirements:
     *
     * - input must fit into 40 bits
     *
     * _Available since v4.7._
     */
    function toInt40(int256 value) internal pure returns (int40) {
        require(value >= type(int40).min && value <= type(int40).max, ""SafeCast: value doesn't fit in 40 bits"");
        return int40(value);
    }

    /**
     * @dev Returns the downcasted int32 from int256, reverting on
     * overflow (when the input is less than smallest int32 or
     * greater than largest int32).
     *
     * Counterpart to Solidity's `int32` operator.
     *
     * Requirements:
     *
     * - input must fit into 32 bits
     *
     * _Available since v3.1._
     */
    function toInt32(int256 value) internal pure returns (int32) {
        require(value >= type(int32).min && value <= type(int32).max, ""SafeCast: value doesn't fit in 32 bits"");
        return int32(value);
    }

    /**
     * @dev Returns the downcasted int24 from int256, reverting on
     * overflow (when the input is less than smallest int24 or
     * greater than largest int24).
     *
     * Counterpart to Solidity's `int24` operator.
     *
     * Requirements:
     *
     * - input must fit into 24 bits
     *
     * _Available since v4.7._
     */
    function toInt24(int256 value) internal pure returns (int24) {
        require(value >= type(int24).min && value <= type(int24).max, ""SafeCast: value doesn't fit in 24 bits"");
        return int24(value);
    }

    /**
     * @dev Returns the downcasted int16 from int256, reverting on
     * overflow (when the input is less than smallest int16 or
     * greater than largest int16).
     *
     * Counterpart to Solidity's `int16` operator.
     *
     * Requirements:
     *
     * - input must fit into 16 bits
     *
     * _Available since v3.1._
     */
    function toInt16(int256 value) internal pure returns (int16) {
        require(value >= type(int16).min && value <= type(int16).max, ""SafeCast: value doesn't fit in 16 bits"");
        return int16(value);
    }

    /**
     * @dev Returns the downcasted int8 from int256, reverting on
     * overflow (when the input is less than smallest int8 or
     * greater than largest int8).
     *
     * Counterpart to Solidity's `int8` operator.
     *
     * Requirements:
     *
     * - input must fit into 8 bits
     *
     * _Available since v3.1._
     */
    function toInt8(int256 value) internal pure returns (int8) {
        require(value >= type(int8).min && value <= type(int8).max, ""SafeCast: value doesn't fit in 8 bits"");
        return int8(value);
    }

    /**
     * @dev Converts an unsigned uint256 into a signed int256.
     *
     * Requirements:
     *
     * - input must be less than or equal to maxInt256.
     *
     * _Available since v3.0._
     */
    function toInt256(uint256 value) internal pure returns (int256) {
        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive
        require(value <= uint256(type(int256).max), ""SafeCast: value doesn't fit in an int256"");
        return int256(value);
    }
}


// File contracts/routers/UnoswapV3Router.sol


pragma solidity 0.8.17;









contract UnoswapV3Router is EthReceiver, IUniswapV3SwapCallback {
    using Address for address payable;
    using SafeERC20 for IERC20;

    error EmptyPools();
    error BadPool();

    uint256 private constant _ONE_FOR_ZERO_MASK = 1 << 255;
    uint256 private constant _WETH_UNWRAP_MASK = 1 << 253;
    bytes32 private constant _POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;
    bytes32 private constant _FF_FACTORY = 0xff1F98431c8aD98523631AE4a59f267346ea31F9840000000000000000000000;
    // concatenation of token0(), token1() fee(), transfer() and transferFrom() selectors
    bytes32 private constant _SELECTORS = 0x0dfe1681d21220a7ddca3f43a9059cbb23b872dd000000000000000000000000;
    uint256 private constant _ADDRESS_MASK =   0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff;
    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)
    uint160 private constant _MIN_SQRT_RATIO = 4295128739 + 1;
    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)
    uint160 private constant _MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342 - 1;
    IWETH private immutable _WETH;  // solhint-disable-line var-name-mixedcase

    constructor(IWETH weth) {
        _WETH = weth;
    }

    /// @notice Same as `uniswapV3SwapTo` but calls permit first,
    /// allowing to approve token spending and make a swap in one transaction.
    /// @param recipient Address that will receive swap funds
    /// @param srcToken Source token
    /// @param amount Amount of source tokens to swap
    /// @param minReturn Minimal allowed returnAmount to make transaction commit
    /// @param pools Pools chain used for swaps. Pools src and dst tokens should match to make swap happen
    /// @param permit Should contain valid permit that can be used in `IERC20Permit.permit` calls.
    /// See tests for examples
    function uniswapV3SwapToWithPermit(
        address payable recipient,
        IERC20 srcToken,
        uint256 amount,
        uint256 minReturn,
        uint256[] calldata pools,
        bytes calldata permit
    ) external returns(uint256 returnAmount) {
        srcToken.safePermit(permit);
        return _uniswapV3Swap(recipient, amount, minReturn, pools);
    }

    /// @notice Same as `uniswapV3SwapTo` but uses `msg.sender` as recipient
    /// @param amount Amount of source tokens to swap
    /// @param minReturn Minimal allowed returnAmount to make transaction commit
    /// @param pools Pools chain used for swaps. Pools src and dst tokens should match to make swap happen
    function uniswapV3Swap(
        uint256 amount,
        uint256 minReturn,
        uint256[] calldata pools
    ) external payable returns(uint256 returnAmount) {
        return _uniswapV3Swap(payable(msg.sender), amount, minReturn, pools);
    }

    /// @notice Performs swap using Uniswap V3 exchange. Wraps and unwraps ETH if required.
    /// Sending non-zero `msg.value` for anything but ETH swaps is prohibited
    /// @param recipient Address that will receive swap funds
    /// @param amount Amount of source tokens to swap
    /// @param minReturn Minimal allowed returnAmount to make transaction commit
    /// @param pools Pools chain used for swaps. Pools src and dst tokens should match to make swap happen
    function uniswapV3SwapTo(
        address payable recipient,
        uint256 amount,
        uint256 minReturn,
        uint256[] calldata pools
    ) external payable returns(uint256 returnAmount) {
        return _uniswapV3Swap(recipient, amount, minReturn, pools);
    }

    function _uniswapV3Swap(
        address payable recipient,
        uint256 amount,
        uint256 minReturn,
        uint256[] calldata pools
    ) private returns(uint256 returnAmount) {
        unchecked {
            uint256 len = pools.length;
            if (len == 0) revert EmptyPools();
            uint256 lastIndex = len - 1;
            returnAmount = amount;
            bool wrapWeth = msg.value > 0;
            bool unwrapWeth = pools[lastIndex] & _WETH_UNWRAP_MASK > 0;
            if (wrapWeth) {
                if (msg.value != amount) revert RouterErrors.InvalidMsgValue();
                _WETH.deposit{value: amount}();
            }
            if (len > 1) {
                returnAmount = _makeSwap(address(this), wrapWeth ? address(this) : msg.sender, pools[0], returnAmount);

                for (uint256 i = 1; i < lastIndex; i++) {
                    returnAmount = _makeSwap(address(this), address(this), pools[i], returnAmount);
                }
                returnAmount = _makeSwap(unwrapWeth ? address(this) : recipient, address(this), pools[lastIndex], returnAmount);
            } else {
                returnAmount = _makeSwap(unwrapWeth ? address(this) : recipient, wrapWeth ? address(this) : msg.sender, pools[0], returnAmount);
            }

            if (returnAmount < minReturn) revert RouterErrors.ReturnAmountIsNotEnough();

            if (unwrapWeth) {
                _WETH.withdraw(returnAmount);
                recipient.sendValue(returnAmount);
            }
        }
    }

    /// @inheritdoc IUniswapV3SwapCallback
    function uniswapV3SwapCallback(
        int256 amount0Delta,
        int256 amount1Delta,
        bytes calldata /* data */
    ) external override {
        assembly {  // solhint-disable-line no-inline-assembly
            function reRevert() {
                returndatacopy(0, 0, returndatasize())
                revert(0, returndatasize())
            }

            function validateERC20Transfer(status) {
                if iszero(status) {
                    reRevert()
                }
                let success := or(
                    iszero(returndatasize()),                       // empty return data
                    and(gt(returndatasize(), 31), eq(mload(0), 1))  // true in return data
                )
                if iszero(success) {
                    mstore(0, 0xf27f64e400000000000000000000000000000000000000000000000000000000)  // ERC20TransferFailed()
                    revert(0, 4)
                }
            }

            let emptyPtr := mload(0x40)
            let resultPtr := add(emptyPtr, 0x15)  // 0x15 = _FF_FACTORY size

            mstore(emptyPtr, _SELECTORS)
            if iszero(staticcall(gas(), caller(), emptyPtr, 0x4, resultPtr, 0x20)) {
                reRevert()
            }
            if iszero(staticcall(gas(), caller(), add(emptyPtr, 0x4), 0x4, add(resultPtr, 0x20), 0x20)) {
                reRevert()
            }
            if iszero(staticcall(gas(), caller(), add(emptyPtr, 0x8), 0x4, add(resultPtr, 0x40), 0x20)) {
                reRevert()
            }

            let token
            let amount
            switch sgt(amount0Delta, 0)
            case 1 {
                token := mload(resultPtr)
                amount := amount0Delta
            }
            default {
                token := mload(add(resultPtr, 0x20))
                amount := amount1Delta
            }

            mstore(emptyPtr, _FF_FACTORY)
            mstore(resultPtr, keccak256(resultPtr, 0x60)) // Compute the inner hash in-place
            mstore(add(resultPtr, 0x20), _POOL_INIT_CODE_HASH)
            let pool := and(keccak256(emptyPtr, 0x55), _ADDRESS_MASK)
            if xor(pool, caller()) {
                mstore(0, 0xb2c0272200000000000000000000000000000000000000000000000000000000)  // BadPool()
                revert(0, 4)
            }

            let payer := calldataload(0x84)
            mstore(emptyPtr, _SELECTORS)
            switch eq(payer, address())
            case 1 {
                // token.safeTransfer(msg.sender,amount)
                mstore(add(emptyPtr, 0x10), caller())
                mstore(add(emptyPtr, 0x30), amount)
                validateERC20Transfer(
                    call(gas(), token, 0, add(emptyPtr, 0x0c), 0x44, 0, 0x20)
                )
            }
            default {
                // token.safeTransferFrom(payer, msg.sender, amount);
                mstore(add(emptyPtr, 0x14), payer)
                mstore(add(emptyPtr, 0x34), caller())
                mstore(add(emptyPtr, 0x54), amount)
                validateERC20Transfer(
                    call(gas(), token, 0, add(emptyPtr, 0x10), 0x64, 0, 0x20)
                )
            }
        }
    }

    function _makeSwap(address recipient, address payer, uint256 pool, uint256 amount) private returns (uint256) {
        bool zeroForOne = pool & _ONE_FOR_ZERO_MASK == 0;
        if (zeroForOne) {
            (, int256 amount1) = IUniswapV3Pool(address(uint160(pool))).swap(
                recipient,
                zeroForOne,
                SafeCast.toInt256(amount),
                _MIN_SQRT_RATIO,
                abi.encode(payer)
            );
            return SafeCast.toUint256(-amount1);
        } else {
            (int256 amount0,) = IUniswapV3Pool(address(uint160(pool))).swap(
                recipient,
                zeroForOne,
                SafeCast.toInt256(amount),
                _MAX_SQRT_RATIO,
                abi.encode(payer)
            );
            return SafeCast.toUint256(-amount0);
        }
    }
}


// File @1inch/solidity-utils/contracts/OnlyWethReceiver.sol@v2.1.1


pragma solidity ^0.8.0;

abstract contract OnlyWethReceiver is EthReceiver {
    address private immutable _WETH;  // solhint-disable-line var-name-mixedcase

    constructor(address weth) {
        _WETH = address(weth);
    }

    function _receive() internal virtual override {
        if (msg.sender != _WETH) revert EthDepositRejected();
    }
}


// File @openzeppelin/contracts/interfaces/IERC1271.sol@v4.7.3

// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC1271 standard signature validation method for
 * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].
 *
 * _Available since v4.1._
 */
interface IERC1271 {
    /**
     * @dev Should return whether the signature provided is valid for the provided data
     * @param hash      Hash of the data to be signed
     * @param signature Signature byte array associated with _data
     */
    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);
}


// File @1inch/solidity-utils/contracts/libraries/ECDSA.sol@v2.1.1


pragma solidity ^0.8.0;

library ECDSA {
    // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature
    // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines
    // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most
    // signatures from current libraries generate a unique signature with an s-value in the lower half order.
    //
    // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value
    // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or
    // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept
    // these malleable signatures as well.
    uint256 private constant _S_BOUNDARY = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0 + 1;
    uint256 private constant _COMPACT_S_MASK = 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;
    uint256 private constant _COMPACT_V_SHIFT = 255;

    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal view returns(address signer) {
        /// @solidity memory-safe-assembly
        assembly { // solhint-disable-line no-inline-assembly
            if lt(s, _S_BOUNDARY) {
                let ptr := mload(0x40)

                mstore(ptr, hash)
                mstore(add(ptr, 0x20), v)
                mstore(add(ptr, 0x40), r)
                mstore(add(ptr, 0x60), s)
                mstore(0, 0)
                pop(staticcall(gas(), 0x1, ptr, 0x80, 0, 0x20))
                signer := mload(0)
            }
        }
    }

    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal view returns(address signer) {
        /// @solidity memory-safe-assembly
        assembly { // solhint-disable-line no-inline-assembly
            let s := and(vs, _COMPACT_S_MASK)
            if lt(s, _S_BOUNDARY) {
                let ptr := mload(0x40)

                mstore(ptr, hash)
                mstore(add(ptr, 0x20), add(27, shr(_COMPACT_V_SHIFT, vs)))
                mstore(add(ptr, 0x40), r)
                mstore(add(ptr, 0x60), s)
                mstore(0, 0)
                pop(staticcall(gas(), 0x1, ptr, 0x80, 0, 0x20))
                signer := mload(0)
            }
        }
    }

    /// WARNING!!!
    /// There is a known signature malleability issue with two representations of signatures!
    /// Even though this function is able to verify both standard 65-byte and compact 64-byte EIP-2098 signatures
    /// one should never use raw signatures for any kind of invalidation logic in their code.
    /// As the standard and compact representations are interchangeable any invalidation logic that relies on
    /// signature uniqueness will get rekt.
    /// More info: https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-4h98-2769-gh6h
    function recover(bytes32 hash, bytes calldata signature) internal view returns(address signer) {
        /// @solidity memory-safe-assembly
        assembly { // solhint-disable-line no-inline-assembly
            let ptr := mload(0x40)

            // memory[ptr:ptr+0x80] = (hash, v, r, s)
            switch signature.length
            case 65 {
                // memory[ptr+0x20:ptr+0x80] = (v, r, s)
                mstore(add(ptr, 0x20), byte(0, calldataload(add(signature.offset, 0x40))))
                calldatacopy(add(ptr, 0x40), signature.offset, 0x40)
            }
            case 64 {
                // memory[ptr+0x20:ptr+0x80] = (v, r, s)
                let vs := calldataload(add(signature.offset, 0x20))
                mstore(add(ptr, 0x20), add(27, shr(_COMPACT_V_SHIFT, vs)))
                calldatacopy(add(ptr, 0x40), signature.offset, 0x20)
                mstore(add(ptr, 0x60), and(vs, _COMPACT_S_MASK))
            }
            default {
                ptr := 0
            }

            if ptr {
                if lt(mload(add(ptr, 0x60)), _S_BOUNDARY) {
                    // memory[ptr:ptr+0x20] = (hash)
                    mstore(ptr, hash)

                    mstore(0, 0)
                    pop(staticcall(gas(), 0x1, ptr, 0x80, 0, 0x20))
                    signer := mload(0)
                }
            }
        }
    }

    function recoverOrIsValidSignature(address signer, bytes32 hash, bytes calldata signature) internal view returns(bool success) {
        if (signer == address(0)) return false;
        if ((signature.length == 64 || signature.length == 65) && recover(hash, signature) == signer) {
            return true;
        }
        return isValidSignature(signer, hash, signature);
    }

    function recoverOrIsValidSignature(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal view returns(bool success) {
        if (signer == address(0)) return false;
        if (recover(hash, v, r, s) == signer) {
            return true;
        }
        return isValidSignature(signer, hash, v, r, s);
    }

    function recoverOrIsValidSignature(address signer, bytes32 hash, bytes32 r, bytes32 vs) internal view returns(bool success) {
        if (signer == address(0)) return false;
        if (recover(hash, r, vs) == signer) {
            return true;
        }
        return isValidSignature(signer, hash, r, vs);
    }

    function recoverOrIsValidSignature65(address signer, bytes32 hash, bytes32 r, bytes32 vs) internal view returns(bool success) {
        if (signer == address(0)) return false;
        if (recover(hash, r, vs) == signer) {
            return true;
        }
        return isValidSignature65(signer, hash, r, vs);
    }

    function isValidSignature(address signer, bytes32 hash, bytes calldata signature) internal view returns(bool success) {
        // (bool success, bytes memory data) = signer.staticcall(abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature));
        // return success && data.length >= 4 && abi.decode(data, (bytes4)) == IERC1271.isValidSignature.selector;
        bytes4 selector = IERC1271.isValidSignature.selector;
        /// @solidity memory-safe-assembly
        assembly { // solhint-disable-line no-inline-assembly
            let ptr := mload(0x40)

            mstore(ptr, selector)
            mstore(add(ptr, 0x04), hash)
            mstore(add(ptr, 0x24), 0x40)
            mstore(add(ptr, 0x44), signature.length)
            calldatacopy(add(ptr, 0x64), signature.offset, signature.length)
            if staticcall(gas(), signer, ptr, add(0x64, signature.length), 0, 0x20) {
                success := and(eq(selector, mload(0)), eq(returndatasize(), 0x20))
            }
        }
    }

    function isValidSignature(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal view returns(bool success) {
        bytes4 selector = IERC1271.isValidSignature.selector;
        /// @solidity memory-safe-assembly
        assembly { // solhint-disable-line no-inline-assembly
            let ptr := mload(0x40)

            mstore(ptr, selector)
            mstore(add(ptr, 0x04), hash)
            mstore(add(ptr, 0x24), 0x40)
            mstore(add(ptr, 0x44), 65)
            mstore(add(ptr, 0x64), r)
            mstore(add(ptr, 0x84), s)
            mstore8(add(ptr, 0xa4), v)
            if staticcall(gas(), signer, ptr, 0xa5, 0, 0x20) {
                success := and(eq(selector, mload(0)), eq(returndatasize(), 0x20))
            }
        }
    }

    function isValidSignature(address signer, bytes32 hash, bytes32 r, bytes32 vs) internal view returns(bool success) {
        // (bool success, bytes memory data) = signer.staticcall(abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, abi.encodePacked(r, vs)));
        // return success && data.length >= 4 && abi.decode(data, (bytes4)) == IERC1271.isValidSignature.selector;
        bytes4 selector = IERC1271.isValidSignature.selector;
        /// @solidity memory-safe-assembly
        assembly { // solhint-disable-line no-inline-assembly
            let ptr := mload(0x40)

            mstore(ptr, selector)
            mstore(add(ptr, 0x04), hash)
            mstore(add(ptr, 0x24), 0x40)
            mstore(add(ptr, 0x44), 64)
            mstore(add(ptr, 0x64), r)
            mstore(add(ptr, 0x84), vs)
            if staticcall(gas(), signer, ptr, 0xa4, 0, 0x20) {
                success := and(eq(selector, mload(0)), eq(returndatasize(), 0x20))
            }
        }
    }

    function isValidSignature65(address signer, bytes32 hash, bytes32 r, bytes32 vs) internal view returns(bool success) {
        // (bool success, bytes memory data) = signer.staticcall(abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, abi.encodePacked(r, vs & ~uint256(1 << 255), uint8(vs >> 255))));
        // return success && data.length >= 4 && abi.decode(data, (bytes4)) == IERC1271.isValidSignature.selector;
        bytes4 selector = IERC1271.isValidSignature.selector;
        /// @solidity memory-safe-assembly
        assembly { // solhint-disable-line no-inline-assembly
            let ptr := mload(0x40)

            mstore(ptr, selector)
            mstore(add(ptr, 0x04), hash)
            mstore(add(ptr, 0x24), 0x40)
            mstore(add(ptr, 0x44), 65)
            mstore(add(ptr, 0x64), r)
            mstore(add(ptr, 0x84), and(vs, _COMPACT_S_MASK))
            mstore8(add(ptr, 0xa4), add(27, shr(_COMPACT_V_SHIFT, vs)))
            if staticcall(gas(), signer, ptr, 0xa5, 0, 0x20) {
                success := and(eq(selector, mload(0)), eq(returndatasize(), 0x20))
            }
        }
    }

    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 res) {
        // 32 is the length in bytes of hash, enforced by the type signature above
        // return keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", hash));
        /// @solidity memory-safe-assembly
        assembly { // solhint-disable-line no-inline-assembly
            mstore(0, 0x19457468657265756d205369676e6564204d6573736167653a0a333200000000) // ""\x19Ethereum Signed Message:\n32""
            mstore(28, hash)
            res := keccak256(0, 60)
        }
    }

    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 res) {
        // return keccak256(abi.encodePacked(""\x19\x01"", domainSeparator, structHash));
        /// @solidity memory-safe-assembly
        assembly { // solhint-disable-line no-inline-assembly
            let ptr := mload(0x40)
            mstore(ptr, 0x1901000000000000000000000000000000000000000000000000000000000000) // ""\x19\x01""
            mstore(add(ptr, 0x02), domainSeparator)
            mstore(add(ptr, 0x22), structHash)
            res := keccak256(ptr, 66)
        }
    }
}


// File @1inch/limit-order-protocol/contracts/OrderRFQLib.sol@v0.3.0-prerelease


pragma solidity 0.8.17;

library OrderRFQLib {
    struct OrderRFQ {
        uint256 info;  // lowest 64 bits is the order id, next 64 bits is the expiration timestamp
        address makerAsset;
        address takerAsset;
        address maker;
        address allowedSender;  // equals to Zero address on public orders
        uint256 makingAmount;
        uint256 takingAmount;
    }

    bytes32 constant internal _LIMIT_ORDER_RFQ_TYPEHASH = keccak256(
        ""OrderRFQ(""
            ""uint256 info,""
            ""address makerAsset,""
            ""address takerAsset,""
            ""address maker,""
            ""address allowedSender,""
            ""uint256 makingAmount,""
            ""uint256 takingAmount""
        "")""
    );

    function hash(OrderRFQ memory order, bytes32 domainSeparator) internal pure returns(bytes32 result) {
        bytes32 typehash = _LIMIT_ORDER_RFQ_TYPEHASH;
        bytes32 orderHash;
        // this assembly is memory unsafe :(
        assembly { // solhint-disable-line no-inline-assembly
            let ptr := sub(order, 0x20)

            // keccak256(abi.encode(_LIMIT_ORDER_RFQ_TYPEHASH, order));
            let tmp := mload(ptr)
            mstore(ptr, typehash)
            orderHash := keccak256(ptr, 0x100)
            mstore(ptr, tmp)
        }
        return ECDSA.toTypedDataHash(domainSeparator, orderHash);
    }
}


// File @openzeppelin/contracts/utils/Strings.sol@v4.7.3

// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)

pragma solidity ^0.8.0;

/**
 * @dev String operations.
 */
library Strings {
    bytes16 private constant _HEX_SYMBOLS = ""0123456789abcdef"";
    uint8 private constant _ADDRESS_LENGTH = 20;

    /**
     * @dev Converts a `uint256` to its ASCII `string` decimal representation.
     */
    function toString(uint256 value) internal pure returns (string memory) {
        // Inspired by OraclizeAPI's implementation - MIT licence
        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol

        if (value == 0) {
            return ""0"";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
     */
    function toHexString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return ""0x00"";
        }
        uint256 temp = value;
        uint256 length = 0;
        while (temp != 0) {
            length++;
            temp >>= 8;
        }
        return toHexString(value, length);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
     */
    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = ""0"";
        buffer[1] = ""x"";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _HEX_SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, ""Strings: hex length insufficient"");
        return string(buffer);
    }

    /**
     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.
     */
    function toHexString(address addr) internal pure returns (string memory) {
        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);
    }
}


// File @openzeppelin/contracts/utils/cryptography/draft-EIP712.sol@v4.7.3

// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)

pragma solidity ^0.8.0;

/**
 * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.
 *
 * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,
 * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding
 * they need in their contracts using a combination of `abi.encode` and `keccak256`.
 *
 * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding
 * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA
 * ({_hashTypedDataV4}).
 *
 * The implementation of the domain separator was designed to be as efficient as possible while still properly updating
 * the chain id to protect against replay attacks on an eventual fork of the chain.
 *
 * NOTE: This contract implements the version of the encoding known as ""v4"", as implemented by the JSON RPC method
 * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].
 *
 * _Available since v3.4._
 */
abstract contract EIP712 {
    /* solhint-disable var-name-mixedcase */
    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to
    // invalidate the cached domain separator if the chain id changes.
    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;
    uint256 private immutable _CACHED_CHAIN_ID;
    address private immutable _CACHED_THIS;

    bytes32 private immutable _HASHED_NAME;
    bytes32 private immutable _HASHED_VERSION;
    bytes32 private immutable _TYPE_HASH;

    /* solhint-enable var-name-mixedcase */

    /**
     * @dev Initializes the domain separator and parameter caches.
     *
     * The meaning of `name` and `version` is specified in
     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:
     *
     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.
     * - `version`: the current major version of the signing domain.
     *
     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart
     * contract upgrade].
     */
    constructor(string memory name, string memory version) {
        bytes32 hashedName = keccak256(bytes(name));
        bytes32 hashedVersion = keccak256(bytes(version));
        bytes32 typeHash = keccak256(
            ""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""
        );
        _HASHED_NAME = hashedName;
        _HASHED_VERSION = hashedVersion;
        _CACHED_CHAIN_ID = block.chainid;
        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);
        _CACHED_THIS = address(this);
        _TYPE_HASH = typeHash;
    }

    /**
     * @dev Returns the domain separator for the current chain.
     */
    function _domainSeparatorV4() internal view returns (bytes32) {
        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {
            return _CACHED_DOMAIN_SEPARATOR;
        } else {
            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);
        }
    }

    function _buildDomainSeparator(
        bytes32 typeHash,
        bytes32 nameHash,
        bytes32 versionHash
    ) private view returns (bytes32) {
        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));
    }

    /**
     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this
     * function returns the hash of the fully encoded EIP712 message for this domain.
     *
     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:
     *
     * ```solidity
     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(
     *     keccak256(""Mail(address to,string contents)""),
     *     mailTo,
     *     keccak256(bytes(mailContents))
     * )));
     * address signer = ECDSA.recover(digest, signature);
     * ```
     */
    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {
        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);
    }
}


// File @1inch/limit-order-protocol/contracts/libraries/Errors.sol@v0.3.0-prerelease


pragma solidity 0.8.17;

library Errors {
    error InvalidMsgValue();
    error ETHTransferFailed();
}


// File @1inch/limit-order-protocol/contracts/helpers/AmountCalculator.sol@v0.3.0-prerelease


pragma solidity 0.8.17;

/// @title A helper contract for calculations related to order amounts
library AmountCalculator {
    /// @notice Calculates maker amount
    /// @return Result Floored maker amount
    function getMakingAmount(uint256 orderMakerAmount, uint256 orderTakerAmount, uint256 swapTakerAmount) internal pure returns(uint256) {
        return swapTakerAmount * orderMakerAmount / orderTakerAmount;
    }

    /// @notice Calculates taker amount
    /// @return Result Ceiled taker amount
    function getTakingAmount(uint256 orderMakerAmount, uint256 orderTakerAmount, uint256 swapMakerAmount) internal pure returns(uint256) {
        return (swapMakerAmount * orderTakerAmount + orderMakerAmount - 1) / orderMakerAmount;
    }
}


// File @1inch/limit-order-protocol/contracts/OrderRFQMixin.sol@v0.3.0-prerelease


pragma solidity 0.8.17;







/// @title RFQ Limit Order mixin
abstract contract OrderRFQMixin is EIP712, OnlyWethReceiver {
    using SafeERC20 for IERC20;
    using OrderRFQLib for OrderRFQLib.OrderRFQ;

    error RFQZeroTargetIsForbidden();
    error RFQPrivateOrder();
    error RFQBadSignature();
    error OrderExpired();
    error MakingAmountExceeded();
    error TakingAmountExceeded();
    error RFQSwapWithZeroAmount();
    error InvalidatedOrder();

    /**
     * @notice Emitted when RFQ gets filled
     * @param orderHash Hash of the order
     * @param makingAmount Amount of the maker asset that was transferred from maker to taker
     */
    event OrderFilledRFQ(
        bytes32 orderHash,
        uint256 makingAmount
    );

    uint256 private constant _RAW_CALL_GAS_LIMIT = 5000;
    uint256 private constant _MAKER_AMOUNT_FLAG = 1 << 255;
    uint256 private constant _SIGNER_SMART_CONTRACT_HINT = 1 << 254;
    uint256 private constant _IS_VALID_SIGNATURE_65_BYTES = 1 << 253;
    uint256 private constant _UNWRAP_WETH_FLAG = 1 << 252;
    uint256 private constant _AMOUNT_MASK = ~(
        _MAKER_AMOUNT_FLAG |
        _SIGNER_SMART_CONTRACT_HINT |
        _IS_VALID_SIGNATURE_65_BYTES |
        _UNWRAP_WETH_FLAG
    );

    IWETH private immutable _WETH;  // solhint-disable-line var-name-mixedcase
    mapping(address => mapping(uint256 => uint256)) private _invalidator;

    constructor(IWETH weth) OnlyWethReceiver(address(weth)) {
        _WETH = weth;
    }

    /**
     * @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes
     * @param maker Maker address
     * @param slot Slot number to return bitmask for
     * @return result Each bit represents whether corresponding was already invalidated
     */
    function invalidatorForOrderRFQ(address maker, uint256 slot) external view returns(uint256 /* result */) {
        return _invalidator[maker][slot];
    }

    /**
     * @notice Cancels order's quote
     * @param orderInfo Order info (only order id in lowest 64 bits is used)
     */
    function cancelOrderRFQ(uint256 orderInfo) external {
        _invalidateOrder(msg.sender, orderInfo, 0);
    }

    /// @notice Cancels multiple order's quotes
    function cancelOrderRFQ(uint256 orderInfo, uint256 additionalMask) external {
        _invalidateOrder(msg.sender, orderInfo, additionalMask);
    }

    /**
     * @notice Fills order's quote, fully or partially (whichever is possible)
     * @param order Order quote to fill
     * @param signature Signature to confirm quote ownership
     * @param flagsAndAmount Fill configuration flags with amount packed in one slot
     * @return filledMakingAmount Actual amount transferred from maker to taker
     * @return filledTakingAmount Actual amount transferred from taker to maker
     * @return orderHash Hash of the filled order
     */
    function fillOrderRFQ(
        OrderRFQLib.OrderRFQ memory order,
        bytes calldata signature,
        uint256 flagsAndAmount
    ) external payable returns(uint256 /* filledMakingAmount */, uint256 /* filledTakingAmount */, bytes32 /* orderHash */) {
        return fillOrderRFQTo(order, signature, flagsAndAmount, msg.sender);
    }

    /**
     * @notice Fills order's quote, fully or partially, with compact signature
     * @param order Order quote to fill
     * @param r R component of signature
     * @param vs VS component of signature
     * @param flagsAndAmount Fill configuration flags with amount packed in one slot
     * - Bits 0-252 contain the amount to fill
     * - Bit 253 is used to indicate whether signature is 64-bit (0) or 65-bit (1)
     * - Bit 254 is used to indicate whether smart contract (1) signed the order or not (0)
     * - Bit 255 is used to indicate whether maker (1) or taker amount (0) is given in the amount parameter
     * @return filledMakingAmount Actual amount transferred from maker to taker
     * @return filledTakingAmount Actual amount transferred from taker to maker
     * @return orderHash Hash of the filled order
     */
    function fillOrderRFQCompact(
        OrderRFQLib.OrderRFQ memory order,
        bytes32 r,
        bytes32 vs,
        uint256 flagsAndAmount
    ) external payable returns(uint256 filledMakingAmount, uint256 filledTakingAmount, bytes32 orderHash) {
        orderHash = order.hash(_domainSeparatorV4());
        if (flagsAndAmount & _SIGNER_SMART_CONTRACT_HINT != 0) {
            if (flagsAndAmount & _IS_VALID_SIGNATURE_65_BYTES != 0) {
                if (!ECDSA.isValidSignature65(order.maker, orderHash, r, vs)) revert RFQBadSignature();
            } else {
                if (!ECDSA.isValidSignature(order.maker, orderHash, r, vs)) revert RFQBadSignature();
            }
        } else {
            if(!ECDSA.recoverOrIsValidSignature(order.maker, orderHash, r, vs)) revert RFQBadSignature();
        }

        (filledMakingAmount, filledTakingAmount) = _fillOrderRFQTo(order, flagsAndAmount, msg.sender);
        emit OrderFilledRFQ(orderHash, filledMakingAmount);
    }

    /**
     * @notice Same as `fillOrderRFQTo` but calls permit first.
     * It allows to approve token spending and make a swap in one transaction.
     * Also allows to specify funds destination instead of `msg.sender`
     * @param order Order quote to fill
     * @param signature Signature to confirm quote ownership
     * @param flagsAndAmount Fill configuration flags with amount packed in one slot
     * @param target Address that will receive swap funds
     * @param permit Should consist of abiencoded token address and encoded `IERC20Permit.permit` call.
     * @return filledMakingAmount Actual amount transferred from maker to taker
     * @return filledTakingAmount Actual amount transferred from taker to maker
     * @return orderHash Hash of the filled order
     * @dev See tests for examples
     */
    function fillOrderRFQToWithPermit(
        OrderRFQLib.OrderRFQ memory order,
        bytes calldata signature,
        uint256 flagsAndAmount,
        address target,
        bytes calldata permit
    ) external returns(uint256 /* filledMakingAmount */, uint256 /* filledTakingAmount */, bytes32 /* orderHash */) {
        IERC20(order.takerAsset).safePermit(permit);
        return fillOrderRFQTo(order, signature, flagsAndAmount, target);
    }

    /**
     * @notice Same as `fillOrderRFQ` but allows to specify funds destination instead of `msg.sender`
     * @param order Order quote to fill
     * @param signature Signature to confirm quote ownership
     * @param flagsAndAmount Fill configuration flags with amount packed in one slot
     * @param target Address that will receive swap funds
     * @return filledMakingAmount Actual amount transferred from maker to taker
     * @return filledTakingAmount Actual amount transferred from taker to maker
     * @return orderHash Hash of the filled order
     */
    function fillOrderRFQTo(
        OrderRFQLib.OrderRFQ memory order,
        bytes calldata signature,
        uint256 flagsAndAmount,
        address target
    ) public payable returns(uint256 filledMakingAmount, uint256 filledTakingAmount, bytes32 orderHash) {
        orderHash = order.hash(_domainSeparatorV4());
        if (flagsAndAmount & _SIGNER_SMART_CONTRACT_HINT != 0) {
            if (flagsAndAmount & _IS_VALID_SIGNATURE_65_BYTES != 0 && signature.length != 65) revert RFQBadSignature();
            if (!ECDSA.isValidSignature(order.maker, orderHash, signature)) revert RFQBadSignature();
        } else {
            if(!ECDSA.recoverOrIsValidSignature(order.maker, orderHash, signature)) revert RFQBadSignature();
        }
        (filledMakingAmount, filledTakingAmount) = _fillOrderRFQTo(order, flagsAndAmount, target);
        emit OrderFilledRFQ(orderHash, filledMakingAmount);
    }

    function _fillOrderRFQTo(
        OrderRFQLib.OrderRFQ memory order,
        uint256 flagsAndAmount,
        address target
    ) private returns(uint256 makingAmount, uint256 takingAmount) {
        if (target == address(0)) revert RFQZeroTargetIsForbidden();

        address maker = order.maker;

        // Validate order
        if (order.allowedSender != address(0) && order.allowedSender != msg.sender) revert RFQPrivateOrder();

        {  // Stack too deep
            uint256 info = order.info;
            // Check time expiration
            uint256 expiration = uint128(info) >> 64;
            if (expiration != 0 && block.timestamp > expiration) revert OrderExpired(); // solhint-disable-line not-rely-on-time
            _invalidateOrder(maker, info, 0);
        }

        {  // Stack too deep
            uint256 orderMakingAmount = order.makingAmount;
            uint256 orderTakingAmount = order.takingAmount;
            uint256 amount = flagsAndAmount & _AMOUNT_MASK;
            // Compute partial fill if needed
            if (amount == 0) {
                // zero amount means whole order
                makingAmount = orderMakingAmount;
                takingAmount = orderTakingAmount;
            }
            else if (flagsAndAmount & _MAKER_AMOUNT_FLAG != 0) {
                if (amount > orderMakingAmount) revert MakingAmountExceeded();
                makingAmount = amount;
                takingAmount = AmountCalculator.getTakingAmount(orderMakingAmount, orderTakingAmount, makingAmount);
            }
            else {
                if (amount > orderTakingAmount) revert TakingAmountExceeded();
                takingAmount = amount;
                makingAmount = AmountCalculator.getMakingAmount(orderMakingAmount, orderTakingAmount, takingAmount);
            }
        }

        if (makingAmount == 0 || takingAmount == 0) revert RFQSwapWithZeroAmount();

        // Maker => Taker
        if (order.makerAsset == address(_WETH) && flagsAndAmount & _UNWRAP_WETH_FLAG != 0) {
            _WETH.transferFrom(maker, address(this), makingAmount);
            _WETH.withdraw(makingAmount);
            // solhint-disable-next-line avoid-low-level-calls
            (bool success, ) = target.call{value: makingAmount, gas: _RAW_CALL_GAS_LIMIT}("""");
            if (!success) revert Errors.ETHTransferFailed();
        } else {
            IERC20(order.makerAsset).safeTransferFrom(maker, target, makingAmount);
        }

        // Taker => Maker
        if (order.takerAsset == address(_WETH) && msg.value > 0) {
            if (msg.value != takingAmount) revert Errors.InvalidMsgValue();
            _WETH.deposit{ value: takingAmount }();
            _WETH.transfer(maker, takingAmount);
        } else {
            if (msg.value != 0) revert Errors.InvalidMsgValue();
            IERC20(order.takerAsset).safeTransferFrom(msg.sender, maker, takingAmount);
        }
    }

    function _invalidateOrder(address maker, uint256 orderInfo, uint256 additionalMask) private {
        uint256 invalidatorSlot = uint64(orderInfo) >> 8;
        uint256 invalidatorBits = (1 << uint8(orderInfo)) | additionalMask;
        mapping(uint256 => uint256) storage invalidatorStorage = _invalidator[maker];
        uint256 invalidator = invalidatorStorage[invalidatorSlot];
        if (invalidator & invalidatorBits == invalidatorBits) revert InvalidatedOrder();
        invalidatorStorage[invalidatorSlot] = invalidator | invalidatorBits;
    }
}


// File @1inch/limit-order-protocol/contracts/OrderLib.sol@v0.3.0-prerelease


pragma solidity 0.8.17;

library OrderLib {
    struct Order {
        uint256 salt;
        address makerAsset;
        address takerAsset;
        address maker;
        address receiver;
        address allowedSender;  // equals to Zero address on public orders
        uint256 makingAmount;
        uint256 takingAmount;
        uint256 offsets;
        // bytes makerAssetData;
        // bytes takerAssetData;
        // bytes getMakingAmount; // this.staticcall(abi.encodePacked(bytes, swapTakerAmount)) => (swapMakerAmount)
        // bytes getTakingAmount; // this.staticcall(abi.encodePacked(bytes, swapMakerAmount)) => (swapTakerAmount)
        // bytes predicate;       // this.staticcall(bytes) => (bool)
        // bytes permit;          // On first fill: permit.1.call(abi.encodePacked(permit.selector, permit.2))
        // bytes preInteraction;
        // bytes postInteraction;
        bytes interactions; // concat(makerAssetData, takerAssetData, getMakingAmount, getTakingAmount, predicate, permit, preIntercation, postInteraction)
    }

    bytes32 constant internal _LIMIT_ORDER_TYPEHASH = keccak256(
        ""Order(""
            ""uint256 salt,""
            ""address makerAsset,""
            ""address takerAsset,""
            ""address maker,""
            ""address receiver,""
            ""address allowedSender,""
            ""uint256 makingAmount,""
            ""uint256 takingAmount,""
            ""uint256 offsets,""
            ""bytes interactions""
        "")""
    );

    enum DynamicField {
        MakerAssetData,
        TakerAssetData,
        GetMakingAmount,
        GetTakingAmount,
        Predicate,
        Permit,
        PreInteraction,
        PostInteraction
    }

    function getterIsFrozen(bytes calldata getter) internal pure returns(bool) {
        return getter.length == 1 && getter[0] == ""x"";
    }

    function _get(Order calldata order, DynamicField field) private pure returns(bytes calldata) {
        uint256 bitShift = uint256(field) << 5; // field * 32
        return order.interactions[
            uint32((order.offsets << 32) >> bitShift):
            uint32(order.offsets >> bitShift)
        ];
    }

    function makerAssetData(Order calldata order) internal pure returns(bytes calldata) {
        return _get(order, DynamicField.MakerAssetData);
    }

    function takerAssetData(Order calldata order) internal pure returns(bytes calldata) {
        return _get(order, DynamicField.TakerAssetData);
    }

    function getMakingAmount(Order calldata order) internal pure returns(bytes calldata) {
        return _get(order, DynamicField.GetMakingAmount);
    }

    function getTakingAmount(Order calldata order) internal pure returns(bytes calldata) {
        return _get(order, DynamicField.GetTakingAmount);
    }

    function predicate(Order calldata order) internal pure returns(bytes calldata) {
        return _get(order, DynamicField.Predicate);
    }

    function permit(Order calldata order) internal pure returns(bytes calldata) {
        return _get(order, DynamicField.Permit);
    }

    function preInteraction(Order calldata order) internal pure returns(bytes calldata) {
        return _get(order, DynamicField.PreInteraction);
    }

    function postInteraction(Order calldata order) internal pure returns(bytes calldata) {
        return _get(order, DynamicField.PostInteraction);
    }

    function hash(Order calldata order, bytes32 domainSeparator) internal pure returns(bytes32 result) {
        bytes calldata interactions = order.interactions;
        bytes32 typehash = _LIMIT_ORDER_TYPEHASH;
        /// @solidity memory-safe-assembly
        assembly { // solhint-disable-line no-inline-assembly
            let ptr := mload(0x40)

            // keccak256(abi.encode(_LIMIT_ORDER_TYPEHASH, orderWithoutInteractions, keccak256(order.interactions)));
            calldatacopy(ptr, interactions.offset, interactions.length)
            mstore(add(ptr, 0x140), keccak256(ptr, interactions.length))
            calldatacopy(add(ptr, 0x20), order, 0x120)
            mstore(ptr, typehash)
            result := keccak256(ptr, 0x160)
        }
        result = ECDSA.toTypedDataHash(domainSeparator, result);
    }
}


// File @1inch/limit-order-protocol/contracts/libraries/ArgumentsDecoder.sol@v0.3.0-prerelease


pragma solidity 0.8.17;

/// @title Library with gas efficient alternatives to `abi.decode`
library ArgumentsDecoder {
    error IncorrectDataLength();

    function decodeUint256(bytes calldata data, uint256 offset) internal pure returns(uint256 value) {
        unchecked { if (data.length < offset + 32) revert IncorrectDataLength(); }
        // no memory ops inside so this insertion is automatically memory safe
        assembly { // solhint-disable-line no-inline-assembly
            value := calldataload(add(data.offset, offset))
        }
    }

    function decodeSelector(bytes calldata data) internal pure returns(bytes4 value) {
        if (data.length < 4) revert IncorrectDataLength();
        // no memory ops inside so this insertion is automatically memory safe
        assembly { // solhint-disable-line no-inline-assembly
            value := calldataload(data.offset)
        }
    }

    function decodeTailCalldata(bytes calldata data, uint256 tailOffset) internal pure returns(bytes calldata args) {
        if (data.length < tailOffset) revert IncorrectDataLength();
        // no memory ops inside so this insertion is automatically memory safe
        assembly {  // solhint-disable-line no-inline-assembly
            args.offset := add(data.offset, tailOffset)
            args.length := sub(data.length, tailOffset)
        }
    }

    function decodeTargetAndCalldata(bytes calldata data) internal pure returns(address target, bytes calldata args) {
        if (data.length < 20) revert IncorrectDataLength();
        // no memory ops inside so this insertion is automatically memory safe
        assembly {  // solhint-disable-line no-inline-assembly
            target := shr(96, calldataload(data.offset))
            args.offset := add(data.offset, 20)
            args.length := sub(data.length, 20)
        }
    }
}


// File @1inch/limit-order-protocol/contracts/helpers/NonceManager.sol@v0.3.0-prerelease


pragma solidity 0.8.17;

/// @title A helper contract for managing nonce of tx sender
contract NonceManager {
    error AdvanceNonceFailed();
    event NonceIncreased(address indexed maker, uint256 newNonce);

    mapping(address => uint256) public nonce;

    /// @notice Advances nonce by one
    function increaseNonce() external {
        advanceNonce(1);
    }

    /// @notice Advances nonce by specified amount
    function advanceNonce(uint8 amount) public {
        if (amount == 0) revert AdvanceNonceFailed();
        uint256 newNonce = nonce[msg.sender] + amount;
        nonce[msg.sender] = newNonce;
        emit NonceIncreased(msg.sender, newNonce);
    }

    /// @notice Checks if `makerAddress` has specified `makerNonce`
    /// @return Result True if `makerAddress` has specified nonce. Otherwise, false
    function nonceEquals(address makerAddress, uint256 makerNonce) public view returns(bool) {
        return nonce[makerAddress] == makerNonce;
    }
}


// File @1inch/limit-order-protocol/contracts/helpers/PredicateHelper.sol@v0.3.0-prerelease


pragma solidity 0.8.17;


/// @title A helper contract for executing boolean functions on arbitrary target call results
contract PredicateHelper is NonceManager {
    using ArgumentsDecoder for bytes;

    error ArbitraryStaticCallFailed();

    /// @notice Calls every target with corresponding data
    /// @return Result True if call to any target returned True. Otherwise, false
    function or(uint256 offsets, bytes calldata data) public view returns(bool) {
        uint256 current;
        uint256 previous;
        for (uint256 i = 0; (current = uint32(offsets >> i)) != 0; i += 32) {
            (bool success, uint256 res) = _selfStaticCall(data[previous:current]);
            if (success && res == 1) {
                return true;
            }
            previous = current;
        }
        return false;
    }

    /// @notice Calls every target with corresponding data
    /// @return Result True if calls to all targets returned True. Otherwise, false
    function and(uint256 offsets, bytes calldata data) public view returns(bool) {
        uint256 current;
        uint256 previous;
        for (uint256 i = 0; (current = uint32(offsets >> i)) != 0; i += 32) {
            (bool success, uint256 res) = _selfStaticCall(data[previous:current]);
            if (!success || res != 1) {
                return false;
            }
            previous = current;
        }
        return true;
    }

    /// @notice Calls target with specified data and tests if it's equal to the value
    /// @param value Value to test
    /// @return Result True if call to target returns the same value as `value`. Otherwise, false
    function eq(uint256 value, bytes calldata data) public view returns(bool) {
        (bool success, uint256 res) = _selfStaticCall(data);
        return success && res == value;
    }

    /// @notice Calls target with specified data and tests if it's lower than value
    /// @param value Value to test
    /// @return Result True if call to target returns value which is lower than `value`. Otherwise, false
    function lt(uint256 value, bytes calldata data) public view returns(bool) {
        (bool success, uint256 res) = _selfStaticCall(data);
        return success && res < value;
    }

    /// @notice Calls target with specified data and tests if it's bigger than value
    /// @param value Value to test
    /// @return Result True if call to target returns value which is bigger than `value`. Otherwise, false
    function gt(uint256 value, bytes calldata data) public view returns(bool) {
        (bool success, uint256 res) = _selfStaticCall(data);
        return success && res > value;
    }

    /// @notice Checks passed time against block timestamp
    /// @return Result True if current block timestamp is lower than `time`. Otherwise, false
    function timestampBelow(uint256 time) public view returns(bool) {
        return block.timestamp < time;  // solhint-disable-line not-rely-on-time
    }

    /// @notice Performs an arbitrary call to target with data
    /// @return Result Bytes transmuted to uint256
    function arbitraryStaticCall(address target, bytes calldata data) public view returns(uint256) {
        (bool success, uint256 res) = _staticcallForUint(target, data);
        if (!success) revert ArbitraryStaticCallFailed();
        return res;
    }

    function timestampBelowAndNonceEquals(uint256 timeNonceAccount) public view returns(bool) {
        uint256 _time = uint48(timeNonceAccount >> 208);
        uint256 _nonce = uint48(timeNonceAccount >> 160);
        address _account = address(uint160(timeNonceAccount));
        return timestampBelow(_time) && nonceEquals(_account, _nonce);
    }

    function _selfStaticCall(bytes calldata data) internal view returns(bool, uint256) {
        uint256 selector = uint32(data.decodeSelector());
        uint256 arg = data.decodeUint256(4);

        // special case for the most often used predicate
        if (selector == uint32(this.timestampBelowAndNonceEquals.selector)) {  // 0x2cc2878d
            return (true, timestampBelowAndNonceEquals(arg) ? 1 : 0);
        }

        if (selector < uint32(this.arbitraryStaticCall.selector)) {  // 0xbf15fcd8
            if (selector < uint32(this.eq.selector)) {  // 0x6fe7b0ba
                if (selector == uint32(this.gt.selector)) {  // 0x4f38e2b8
                    return (true, gt(arg, data.decodeTailCalldata(100)) ? 1 : 0);
                } else if (selector == uint32(this.timestampBelow.selector)) {  // 0x63592c2b
                    return (true, timestampBelow(arg) ? 1 : 0);
                }
            } else {
                if (selector == uint32(this.eq.selector)) {  // 0x6fe7b0ba
                    return (true, eq(arg, data.decodeTailCalldata(100)) ? 1 : 0);
                } else if (selector == uint32(this.or.selector)) {  // 0x74261145
                    return (true, or(arg, data.decodeTailCalldata(100)) ? 1 : 0);
                }
            }
        } else {
            if (selector < uint32(this.lt.selector)) {  // 0xca4ece22
                if (selector == uint32(this.arbitraryStaticCall.selector)) {  // 0xbf15fcd8
                    return (true, arbitraryStaticCall(address(uint160(arg)), data.decodeTailCalldata(100)));
                } else if (selector == uint32(this.and.selector)) {  // 0xbfa75143
                    return (true, and(arg, data.decodeTailCalldata(100)) ? 1 : 0);
                }
            } else {
                if (selector == uint32(this.lt.selector)) {  // 0xca4ece22
                    return (true, lt(arg, data.decodeTailCalldata(100)) ? 1 : 0);
                } else if (selector == uint32(this.nonceEquals.selector)) {  // 0xcf6fc6e3
                    return (true, nonceEquals(address(uint160(arg)), data.decodeUint256(0x24)) ? 1 : 0);
                }
            }
        }

        return _staticcallForUint(address(this), data);
    }

    function _staticcallForUint(address target, bytes calldata input) private view returns(bool success, uint256 res) {
        /// @solidity memory-safe-assembly
        assembly { // solhint-disable-line no-inline-assembly
            let data := mload(0x40)

            calldatacopy(data, input.offset, input.length)
            success := staticcall(gas(), target, data, input.length, 0x0, 0x20)
            success := and(success, eq(returndatasize(), 32))
            if success {
                res := mload(0)
            }
        }
    }
}


// File @1inch/limit-order-protocol/contracts/interfaces/IOrderMixin.sol@v0.3.0-prerelease


pragma solidity 0.8.17;

interface IOrderMixin {
    /**
     * @notice Returns unfilled amount for order. Throws if order does not exist
     * @param orderHash Order's hash. Can be obtained by the `hashOrder` function
     * @return amount Unfilled amount
     */
    function remaining(bytes32 orderHash) external view returns(uint256 amount);

    /**
     * @notice Returns unfilled amount for order
     * @param orderHash Order's hash. Can be obtained by the `hashOrder` function
     * @return rawAmount Unfilled amount of order plus one if order exists. Otherwise 0
     */
    function remainingRaw(bytes32 orderHash) external view returns(uint256 rawAmount);

    /**
     * @notice Same as `remainingRaw` but for multiple orders
     * @param orderHashes Array of hashes
     * @return rawAmounts Array of amounts for each order plus one if order exists or 0 otherwise
     */
    function remainingsRaw(bytes32[] memory orderHashes) external view returns(uint256[] memory rawAmounts);

    /**
     * @notice Checks order predicate
     * @param order Order to check predicate for
     * @return result Predicate evaluation result. True if predicate allows to fill the order, false otherwise
     */
    function checkPredicate(OrderLib.Order calldata order) external view returns(bool result);

    /**
     * @notice Returns order hash according to EIP712 standard
     * @param order Order to get hash for
     * @return orderHash Hash of the order
     */
    function hashOrder(OrderLib.Order calldata order) external view returns(bytes32);

    /**
     * @notice Delegates execution to custom implementation. Could be used to validate if `transferFrom` works properly
     * @dev The function always reverts and returns the simulation results in revert data.
     * @param target Addresses that will be delegated
     * @param data Data that will be passed to delegatee
     */
    function simulate(address target, bytes calldata data) external;

    /**
     * @notice Cancels order.
     * @dev Order is cancelled by setting remaining amount to _ORDER_FILLED value
     * @param order Order quote to cancel
     * @return orderRemaining Unfilled amount of order before cancellation
     * @return orderHash Hash of the filled order
     */
    function cancelOrder(OrderLib.Order calldata order) external returns(uint256 orderRemaining, bytes32 orderHash);

    /**
     * @notice Fills an order. If one doesn't exist (first fill) it will be created using order.makerAssetData
     * @param order Order quote to fill
     * @param signature Signature to confirm quote ownership
     * @param interaction A call data for InteractiveNotificationReceiver. Taker may execute interaction after getting maker assets and before sending taker assets.
     * @param makingAmount Making amount
     * @param takingAmount Taking amount
     * @param skipPermitAndThresholdAmount Specifies maximum allowed takingAmount when takingAmount is zero, otherwise specifies minimum allowed makingAmount. Top-most bit specifies whether taker wants to skip maker's permit.
     * @return actualMakingAmount Actual amount transferred from maker to taker
     * @return actualTakingAmount Actual amount transferred from taker to maker
     * @return orderHash Hash of the filled order
     */
    function fillOrder(
        OrderLib.Order calldata order,
        bytes calldata signature,
        bytes calldata interaction,
        uint256 makingAmount,
        uint256 takingAmount,
        uint256 skipPermitAndThresholdAmount
    ) external payable returns(uint256 actualMakingAmount, uint256 actualTakingAmount, bytes32 orderHash);

    /**
     * @notice Same as `fillOrderTo` but calls permit first,
     * allowing to approve token spending and make a swap in one transaction.
     * Also allows to specify funds destination instead of `msg.sender`
     * @dev See tests for examples
     * @param order Order quote to fill
     * @param signature Signature to confirm quote ownership
     * @param interaction A call data for InteractiveNotificationReceiver. Taker may execute interaction after getting maker assets and before sending taker assets.
     * @param makingAmount Making amount
     * @param takingAmount Taking amount
     * @param skipPermitAndThresholdAmount Specifies maximum allowed takingAmount when takingAmount is zero, otherwise specifies minimum allowed makingAmount. Top-most bit specifies whether taker wants to skip maker's permit.
     * @param target Address that will receive swap funds
     * @param permit Should consist of abiencoded token address and encoded `IERC20Permit.permit` call.
     * @return actualMakingAmount Actual amount transferred from maker to taker
     * @return actualTakingAmount Actual amount transferred from taker to maker
     * @return orderHash Hash of the filled order
     */
    function fillOrderToWithPermit(
        OrderLib.Order calldata order,
        bytes calldata signature,
        bytes calldata interaction,
        uint256 makingAmount,
        uint256 takingAmount,
        uint256 skipPermitAndThresholdAmount,
        address target,
        bytes calldata permit
    ) external returns(uint256 actualMakingAmount, uint256 actualTakingAmount, bytes32 orderHash);

    /**
     * @notice Same as `fillOrder` but allows to specify funds destination instead of `msg.sender`
     * @param order_ Order quote to fill
     * @param signature Signature to confirm quote ownership
     * @param interaction A call data for InteractiveNotificationReceiver. Taker may execute interaction after getting maker assets and before sending taker assets.
     * @param makingAmount Making amount
     * @param takingAmount Taking amount
     * @param skipPermitAndThresholdAmount Specifies maximum allowed takingAmount when takingAmount is zero, otherwise specifies minimum allowed makingAmount. Top-most bit specifies whether taker wants to skip maker's permit.
     * @param target Address that will receive swap funds
     * @return actualMakingAmount Actual amount transferred from maker to taker
     * @return actualTakingAmount Actual amount transferred from taker to maker
     * @return orderHash Hash of the filled order
     */
    function fillOrderTo(
        OrderLib.Order calldata order_,
        bytes calldata signature,
        bytes calldata interaction,
        uint256 makingAmount,
        uint256 takingAmount,
        uint256 skipPermitAndThresholdAmount,
        address target
    ) external payable returns(uint256 actualMakingAmount, uint256 actualTakingAmount, bytes32 orderHash);
}


// File @1inch/limit-order-protocol/contracts/interfaces/NotificationReceiver.sol@v0.3.0-prerelease


pragma solidity 0.8.17;

/// @title Interface for interactor which acts between `maker => taker` and `taker => maker` transfers.
interface PreInteractionNotificationReceiver {
    function fillOrderPreInteraction(
        bytes32 orderHash,
        address maker,
        address taker,
        uint256 makingAmount,
        uint256 takingAmount,
        uint256 remainingAmount,
        bytes memory interactiveData
    ) external;
}

interface PostInteractionNotificationReceiver {
    /// @notice Callback method that gets called after taker transferred funds to maker but before
    /// the opposite transfer happened
    function fillOrderPostInteraction(
        bytes32 orderHash,
        address maker,
        address taker,
        uint256 makingAmount,
        uint256 takingAmount,
        uint256 remainingAmount,
        bytes memory interactiveData
    ) external;
}

interface InteractionNotificationReceiver {
    function fillOrderInteraction(
        address taker,
        uint256 makingAmount,
        uint256 takingAmount,
        bytes memory interactiveData
    ) external returns(uint256 offeredTakingAmount);
}


// File @1inch/limit-order-protocol/contracts/OrderMixin.sol@v0.3.0-prerelease


pragma solidity 0.8.17;











/// @title Regular Limit Order mixin
abstract contract OrderMixin is IOrderMixin, EIP712, PredicateHelper {
    using SafeERC20 for IERC20;
    using ArgumentsDecoder for bytes;
    using OrderLib for OrderLib.Order;

    error UnknownOrder();
    error AccessDenied();
    error AlreadyFilled();
    error PermitLengthTooLow();
    error ZeroTargetIsForbidden();
    error RemainingAmountIsZero();
    error PrivateOrder();
    error BadSignature();
    error ReentrancyDetected();
    error PredicateIsNotTrue();
    error OnlyOneAmountShouldBeZero();
    error TakingAmountTooHigh();
    error MakingAmountTooLow();
    error SwapWithZeroAmount();
    error TransferFromMakerToTakerFailed();
    error TransferFromTakerToMakerFailed();
    error WrongAmount();
    error WrongGetter();
    error GetAmountCallFailed();
    error TakingAmountIncreased();
    error SimulationResults(bool success, bytes res);

    /// @notice Emitted every time order gets filled, including partial fills
    event OrderFilled(
        address indexed maker,
        bytes32 orderHash,
        uint256 remaining
    );

    /// @notice Emitted when order gets cancelled
    event OrderCanceled(
        address indexed maker,
        bytes32 orderHash,
        uint256 remainingRaw
    );

    uint256 constant private _ORDER_DOES_NOT_EXIST = 0;
    uint256 constant private _ORDER_FILLED = 1;
    uint256 constant private _SKIP_PERMIT_FLAG = 1 << 255;
    uint256 constant private _THRESHOLD_MASK = ~_SKIP_PERMIT_FLAG;

    IWETH private immutable _WETH;  // solhint-disable-line var-name-mixedcase
    /// @notice Stores unfilled amounts for each order plus one.
    /// Therefore 0 means order doesn't exist and 1 means order was filled
    mapping(bytes32 => uint256) private _remaining;

    constructor(IWETH weth) {
        _WETH = weth;
    }

    /**
     * @notice See {IOrderMixin-remaining}.
     */
    function remaining(bytes32 orderHash) external view returns(uint256 /* amount */) {
        uint256 amount = _remaining[orderHash];
        if (amount == _ORDER_DOES_NOT_EXIST) revert UnknownOrder();
        unchecked { return amount - 1; }
    }

    /**
     * @notice See {IOrderMixin-remainingRaw}.
     */
    function remainingRaw(bytes32 orderHash) external view returns(uint256 /* rawAmount */) {
        return _remaining[orderHash];
    }

    /**
     * @notice See {IOrderMixin-remainingsRaw}.
     */
    function remainingsRaw(bytes32[] memory orderHashes) external view returns(uint256[] memory /* rawAmounts */) {
        uint256[] memory results = new uint256[](orderHashes.length);
        for (uint256 i = 0; i < orderHashes.length; i++) {
            results[i] = _remaining[orderHashes[i]];
        }
        return results;
    }

    /**
     * @notice See {IOrderMixin-simulate}.
     */
    function simulate(address target, bytes calldata data) external {
        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory result) = target.delegatecall(data);
        revert SimulationResults(success, result);
    }

    /**
     * @notice See {IOrderMixin-cancelOrder}.
     */
    function cancelOrder(OrderLib.Order calldata order) external returns(uint256 orderRemaining, bytes32 orderHash) {
        if (order.maker != msg.sender) revert AccessDenied();

        orderHash = hashOrder(order);
        orderRemaining = _remaining[orderHash];
        if (orderRemaining == _ORDER_FILLED) revert AlreadyFilled();
        emit OrderCanceled(msg.sender, orderHash, orderRemaining);
        _remaining[orderHash] = _ORDER_FILLED;
    }

    /**
     * @notice See {IOrderMixin-fillOrder}.
     */
    function fillOrder(
        OrderLib.Order calldata order,
        bytes calldata signature,
        bytes calldata interaction,
        uint256 makingAmount,
        uint256 takingAmount,
        uint256 skipPermitAndThresholdAmount
    ) external payable returns(uint256 /* actualMakingAmount */, uint256 /* actualTakingAmount */, bytes32 /* orderHash */) {
        return fillOrderTo(order, signature, interaction, makingAmount, takingAmount, skipPermitAndThresholdAmount, msg.sender);
    }

    /**
     * @notice See {IOrderMixin-fillOrderToWithPermit}.
     */
    function fillOrderToWithPermit(
        OrderLib.Order calldata order,
        bytes calldata signature,
        bytes calldata interaction,
        uint256 makingAmount,
        uint256 takingAmount,
        uint256 skipPermitAndThresholdAmount,
        address target,
        bytes calldata permit
    ) external returns(uint256 /* actualMakingAmount */, uint256 /* actualTakingAmount */, bytes32 /* orderHash */) {
        if (permit.length < 20) revert PermitLengthTooLow();
        {  // Stack too deep
            (address token, bytes calldata permitData) = permit.decodeTargetAndCalldata();
            IERC20(token).safePermit(permitData);
        }
        return fillOrderTo(order, signature, interaction, makingAmount, takingAmount, skipPermitAndThresholdAmount, target);
    }

    /**
     * @notice See {IOrderMixin-fillOrderTo}.
     */
    function fillOrderTo(
        OrderLib.Order calldata order_,
        bytes calldata signature,
        bytes calldata interaction,
        uint256 makingAmount,
        uint256 takingAmount,
        uint256 skipPermitAndThresholdAmount,
        address target
    ) public payable returns(uint256 actualMakingAmount, uint256 actualTakingAmount, bytes32 orderHash) {
        if (target == address(0)) revert ZeroTargetIsForbidden();
        orderHash = hashOrder(order_);

        OrderLib.Order calldata order = order_; // Helps with ""Stack too deep""
        actualMakingAmount = makingAmount;
        actualTakingAmount = takingAmount;

        uint256 remainingMakingAmount = _remaining[orderHash];
        if (remainingMakingAmount == _ORDER_FILLED) revert RemainingAmountIsZero();
        if (order.allowedSender != address(0) && order.allowedSender != msg.sender) revert PrivateOrder();
        if (remainingMakingAmount == _ORDER_DOES_NOT_EXIST) {
            // First fill: validate order and permit maker asset
            if (!ECDSA.recoverOrIsValidSignature(order.maker, orderHash, signature)) revert BadSignature();
            remainingMakingAmount = order.makingAmount;

            bytes calldata permit = order.permit();
            if (skipPermitAndThresholdAmount & _SKIP_PERMIT_FLAG == 0 && permit.length >= 20) {
                // proceed only if taker is willing to execute permit and its length is enough to store address
                (address token, bytes calldata permitCalldata) = permit.decodeTargetAndCalldata();
                IERC20(token).safePermit(permitCalldata);
                if (_remaining[orderHash] != _ORDER_DOES_NOT_EXIST) revert ReentrancyDetected();
            }
        } else {
            unchecked { remainingMakingAmount -= 1; }
        }

        // Check if order is valid
        if (order.predicate().length > 0) {
            if (!checkPredicate(order)) revert PredicateIsNotTrue();
        }

        // Compute maker and taker assets amount
        if ((actualTakingAmount == 0) == (actualMakingAmount == 0)) {
            revert OnlyOneAmountShouldBeZero();
        } else if (actualTakingAmount == 0) {
            if (actualMakingAmount > remainingMakingAmount) {
                actualMakingAmount = remainingMakingAmount;
            }
            actualTakingAmount = _getTakingAmount(order.getTakingAmount(), order.makingAmount, actualMakingAmount, order.takingAmount, remainingMakingAmount, orderHash);
            uint256 thresholdAmount = skipPermitAndThresholdAmount & _THRESHOLD_MASK;
            // check that actual rate is not worse than what was expected
            // actualTakingAmount / actualMakingAmount <= thresholdAmount / makingAmount
            if (actualTakingAmount * makingAmount > thresholdAmount * actualMakingAmount) revert TakingAmountTooHigh();
        } else {
            actualMakingAmount = _getMakingAmount(order.getMakingAmount(), order.takingAmount, actualTakingAmount, order.makingAmount, remainingMakingAmount, orderHash);
            if (actualMakingAmount > remainingMakingAmount) {
                actualMakingAmount = remainingMakingAmount;
                actualTakingAmount = _getTakingAmount(order.getTakingAmount(), order.makingAmount, actualMakingAmount, order.takingAmount, remainingMakingAmount, orderHash);
                if (actualTakingAmount > takingAmount) revert TakingAmountIncreased();
            }
            uint256 thresholdAmount = skipPermitAndThresholdAmount & _THRESHOLD_MASK;
            // check that actual rate is not worse than what was expected
            // actualMakingAmount / actualTakingAmount >= thresholdAmount / takingAmount
            if (actualMakingAmount * takingAmount < thresholdAmount * actualTakingAmount) revert MakingAmountTooLow();
        }

        if (actualMakingAmount == 0 || actualTakingAmount == 0) revert SwapWithZeroAmount();

        // Update remaining amount in storage
        unchecked {
            remainingMakingAmount = remainingMakingAmount - actualMakingAmount;
            _remaining[orderHash] = remainingMakingAmount + 1;
        }
        emit OrderFilled(order_.maker, orderHash, remainingMakingAmount);

        // Maker can handle funds interactively
        if (order.preInteraction().length >= 20) {
            // proceed only if interaction length is enough to store address
            (address interactionTarget, bytes calldata interactionData) = order.preInteraction().decodeTargetAndCalldata();
            PreInteractionNotificationReceiver(interactionTarget).fillOrderPreInteraction(
                orderHash, order.maker, msg.sender, actualMakingAmount, actualTakingAmount, remainingMakingAmount, interactionData
            );
        }

        // Maker => Taker
        if (!_callTransferFrom(
            order.makerAsset,
            order.maker,
            target,
            actualMakingAmount,
            order.makerAssetData()
        )) revert TransferFromMakerToTakerFailed();

        if (interaction.length >= 20) {
            // proceed only if interaction length is enough to store address
            (address interactionTarget, bytes calldata interactionData) = interaction.decodeTargetAndCalldata();
            uint256 offeredTakingAmount = InteractionNotificationReceiver(interactionTarget).fillOrderInteraction(
                msg.sender, actualMakingAmount, actualTakingAmount, interactionData
            );

            if (offeredTakingAmount > actualTakingAmount &&
                !OrderLib.getterIsFrozen(order.getMakingAmount()) &&
                !OrderLib.getterIsFrozen(order.getTakingAmount()))
            {
                actualTakingAmount = offeredTakingAmount;
            }
        }

        // Taker => Maker
        if (order.takerAsset == address(_WETH) && msg.value > 0) {
            if (msg.value < actualTakingAmount) revert Errors.InvalidMsgValue();
            if (msg.value > actualTakingAmount) {
                unchecked {
                    (bool success, ) = msg.sender.call{value: msg.value - actualTakingAmount}("""");  // solhint-disable-line avoid-low-level-calls
                    if (!success) revert Errors.ETHTransferFailed();
                }
            }
            _WETH.deposit{ value: actualTakingAmount }();
            _WETH.transfer(order.receiver == address(0) ? order.maker : order.receiver, actualTakingAmount);
        } else {
            if (msg.value != 0) revert Errors.InvalidMsgValue();
            if (!_callTransferFrom(
                order.takerAsset,
                msg.sender,
                order.receiver == address(0) ? order.maker : order.receiver,
                actualTakingAmount,
                order.takerAssetData()
            )) revert TransferFromTakerToMakerFailed();
        }

        // Maker can handle funds interactively
        if (order.postInteraction().length >= 20) {
            // proceed only if interaction length is enough to store address
            (address interactionTarget, bytes calldata interactionData) = order.postInteraction().decodeTargetAndCalldata();
            PostInteractionNotificationReceiver(interactionTarget).fillOrderPostInteraction(
                 orderHash, order.maker, msg.sender, actualMakingAmount, actualTakingAmount, remainingMakingAmount, interactionData
            );
        }
    }

    /**
     * @notice See {IOrderMixin-checkPredicate}.
     */
    function checkPredicate(OrderLib.Order calldata order) public view returns(bool) {
        (bool success, uint256 res) = _selfStaticCall(order.predicate());
        return success && res == 1;
    }

    /**
     * @notice See {IOrderMixin-hashOrder}.
     */
    function hashOrder(OrderLib.Order calldata order) public view returns(bytes32) {
        return order.hash(_domainSeparatorV4());
    }

    function _callTransferFrom(address asset, address from, address to, uint256 amount, bytes calldata input) private returns(bool success) {
        bytes4 selector = IERC20.transferFrom.selector;
        /// @solidity memory-safe-assembly
        assembly { // solhint-disable-line no-inline-assembly
            let data := mload(0x40)

            mstore(data, selector)
            mstore(add(data, 0x04), from)
            mstore(add(data, 0x24), to)
            mstore(add(data, 0x44), amount)
            calldatacopy(add(data, 0x64), input.offset, input.length)
            let status := call(gas(), asset, 0, data, add(0x64, input.length), 0x0, 0x20)
            success := and(status, or(iszero(returndatasize()), and(gt(returndatasize(), 31), eq(mload(0), 1))))
        }
    }

    function _getMakingAmount(
        bytes calldata getter,
        uint256 orderTakingAmount,
        uint256 requestedTakingAmount,
        uint256 orderMakingAmount,
        uint256 remainingMakingAmount,
        bytes32 orderHash
    ) private view returns(uint256) {
        if (getter.length == 0) {
            // Linear proportion
            return AmountCalculator.getMakingAmount(orderMakingAmount, orderTakingAmount, requestedTakingAmount);
        }
        return _callGetter(getter, orderTakingAmount, requestedTakingAmount, orderMakingAmount, remainingMakingAmount, orderHash);
    }

    function _getTakingAmount(
        bytes calldata getter,
        uint256 orderMakingAmount,
        uint256 requestedMakingAmount,
        uint256 orderTakingAmount,
        uint256 remainingMakingAmount,
        bytes32 orderHash
    ) private view returns(uint256) {
        if (getter.length == 0) {
            // Linear proportion
            return AmountCalculator.getTakingAmount(orderMakingAmount, orderTakingAmount, requestedMakingAmount);
        }
        return _callGetter(getter, orderMakingAmount, requestedMakingAmount, orderTakingAmount, remainingMakingAmount, orderHash);
    }

    function _callGetter(
        bytes calldata getter,
        uint256 orderExpectedAmount,
        uint256 requestedAmount,
        uint256 orderResultAmount,
        uint256 remainingMakingAmount,
        bytes32 orderHash
    ) private view returns(uint256) {
        if (getter.length == 1) {
            if (OrderLib.getterIsFrozen(getter)) {
                // On ""x"" getter calldata only exact amount is allowed
                if (requestedAmount != orderExpectedAmount) revert WrongAmount();
                return orderResultAmount;
            } else {
                revert WrongGetter();
            }
        } else {
            (address target, bytes calldata data) = getter.decodeTargetAndCalldata();
            (bool success, bytes memory result) = target.staticcall(abi.encodePacked(data, requestedAmount, remainingMakingAmount, orderHash));
            if (!success || result.length != 32) revert GetAmountCallFailed();
            return abi.decode(result, (uint256));
        }
    }
}


// File @openzeppelin/contracts/utils/Context.sol@v4.7.3

// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}


// File @openzeppelin/contracts/access/Ownable.sol@v4.7.3

// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)

pragma solidity ^0.8.0;

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if the sender is not the owner.
     */
    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), ""Ownable: caller is not the owner"");
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}


// File contracts/AggregationRouterV5.sol


pragma solidity 0.8.17;









/// @notice Main contract incorporates a number of routers to perform swaps and limit orders protocol to fill limit orders
contract AggregationRouterV5 is EIP712(""1inch Aggregation Router"", ""5""), Ownable,
    ClipperRouter, GenericRouter, UnoswapRouter, UnoswapV3Router, OrderMixin, OrderRFQMixin
{
    using UniERC20 for IERC20;

    error ZeroAddress();

    /**
     * @dev Sets the wrapped eth token and clipper exhange interface
     * Both values are immutable: they can only be set once during
     * construction.
     */
    constructor(IWETH weth)
        UnoswapV3Router(weth)
        ClipperRouter(weth)
        OrderMixin(weth)
        OrderRFQMixin(weth)
    {
        if (address(weth) == address(0)) revert ZeroAddress();
    }

    /**
     * @notice Retrieves funds accidently sent directly to the contract address
     * @param token ERC20 token to retrieve
     * @param amount amount to retrieve
     */
    function rescueFunds(IERC20 token, uint256 amount) external onlyOwner {
        token.uniTransfer(payable(msg.sender), amount);
    }

    /**
     * @notice Destroys the contract and sends eth to sender. Use with caution.
     * The only case when the use of the method is justified is if there is an exploit found.
     * And the damage from the exploit is greater than from just an urgent contract change.
     */
    function destroy() external onlyOwner {
        selfdestruct(payable(msg.sender));
    }

    function _receive() internal override(EthReceiver, OnlyWethReceiver) {
        EthReceiver._receive();
    }
}",True
0xbb0dda4a8a26cf753865ee281dc38dd3a27d23a2,"// SPDX-License-Identifier: UNLICENSE
// This token was deployed on Telegram Using @TitanDeployerBot
/*
Telegram: https://t.me/ChonkyOnETH
X: https://x.com/ChonkyOnEth
Website: https://www.chonkyoneth.com/

*/
pragma solidity 0.8.23;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, ""SafeMath: subtraction overflow"");
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, ""SafeMath: division by zero"");
    }

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        return c;
    }

}

contract Ownable is Context {
    address private _owner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_owner == _msgSender(), ""Ownable: caller is not the owner"");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

}

interface IUniswapV2Factory {
    function createPair(address tokenA, address tokenB) external returns (address pair);
}

interface IUniswapV2Router02 {
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    function factory() external pure returns (address);
    function WETH() external pure returns (address);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
}

contract CHONKY is Context, IERC20, Ownable {
    using SafeMath for uint256;
    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;
    mapping (address => bool) private _isExcludedFromFee;
    mapping (address => bool) private bots;
    address payable private _taxWallet;

    uint256 private _initialBuyTax=23;
    uint256 private _initialSellTax=23;
    uint256 private _finalBuyTax=0;
    uint256 private _finalSellTax=0;
    uint256 private _reduceBuyTaxAt=1;
    uint256 private _reduceSellTaxAt=1;
    uint256 private _preventSwapBefore=20;
    uint256 private _transferTax=20;
    uint256 private _buyCount=0;

    uint8 private constant _decimals = 9;
    uint256 private constant _tTotal = 420690000000 * 10**_decimals;
    string private constant _name = unicode""Chonky on ETH"";
    string private constant _symbol = unicode""CHONKY"";
    uint256 public _maxTxAmount = 9255180000 * 10**_decimals;
    uint256 public _maxWalletSize = 9255180000 * 10**_decimals;
    uint256 public _taxSwapThreshold= 420690000 * 10**_decimals;
    uint256 public _maxTaxSwap= 4206900000 * 10**_decimals;
    
    IUniswapV2Router02 private uniswapV2Router;
    address private uniswapV2Pair;
    bool public tradingOpen;
    bool private inSwap = false;
    bool private swapEnabled = false;
    uint256 private sellCount = 0;
    uint256 private lastSellBlock = 0;
    event MaxTxAmountUpdated(uint _maxTxAmount);
    event OpenTrade(address indexed owner, uint256 timestamp);
    event TransferTaxUpdated(uint _tax);
    modifier lockTheSwap {
        inSwap = true;
        _;
        inSwap = false;
    }

    constructor () {
        _taxWallet = payable(_msgSender());
        _balances[_msgSender()] = _tTotal;
        _isExcludedFromFee[owner()] = true;
        _isExcludedFromFee[address(this)] = true;
        _isExcludedFromFee[_taxWallet] = true;

        emit Transfer(address(0), _msgSender(), _tTotal);
    }

    function name() public pure returns (string memory) {
        return _name;
    }

    function symbol() public pure returns (string memory) {
        return _symbol;
    }

    function decimals() public pure returns (uint8) {
        return _decimals;
    }

    function totalSupply() public pure override returns (uint256) {
        return _tTotal;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function getTaxDetails() public view returns (
        uint256 initialBuyTax,
        uint256 initialSellTax,
        uint256 finalBuyTax,
        uint256 finalSellTax,
        uint256 transferTax
        ) {
            return (
                _initialBuyTax,
                _initialSellTax,
                _finalBuyTax,
                _finalSellTax,
                _transferTax
            );
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }

    function _approve(address owner, address spender, uint256 amount) private {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _transfer(address from, address to, uint256 amount) private {
        require(from != address(0), ""ERC20: transfer from the zero address"");
        require(to != address(0), ""ERC20: transfer to the zero address"");
        require(amount > 0, ""Transfer amount must be greater than zero"");
        uint256 taxAmount=0;
        if (from != owner() && to != owner() && to != _taxWallet) {
            require(!bots[from] && !bots[to]);

            if(_buyCount==0){
                taxAmount = amount.mul((_buyCount>_reduceBuyTaxAt)?_finalBuyTax:_initialBuyTax).div(100);
            }
            if(_buyCount>0){
                taxAmount = amount.mul(_transferTax).div(100);
            }

            if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] ) {
                require(amount <= _maxTxAmount, ""Exceeds the _maxTxAmount."");
                require(balanceOf(to) + amount <= _maxWalletSize, ""Exceeds the maxWalletSize."");
                taxAmount = amount.mul((_buyCount>_reduceBuyTaxAt)?_finalBuyTax:_initialBuyTax).div(100);
                _buyCount++;
            }

            if(to == uniswapV2Pair && from!= address(this) ){
                taxAmount = amount.mul((_buyCount>_reduceSellTaxAt)?_finalSellTax:_initialSellTax).div(100);
            }

            uint256 contractTokenBalance = balanceOf(address(this));
            if (!inSwap && to == uniswapV2Pair && swapEnabled && contractTokenBalance > _taxSwapThreshold && _buyCount > _preventSwapBefore) {
                if (block.number > lastSellBlock) {
                    sellCount = 0;
                }
                require(sellCount < 3, ""Only 3 sells per block!"");
                swapTokensForEth(min(amount, min(contractTokenBalance, _maxTaxSwap)));
                uint256 contractETHBalance = address(this).balance;
                if (contractETHBalance > 0) {
                    sendETHToFee(address(this).balance);
                }
                sellCount++;
                lastSellBlock = block.number;
            }
        }

        if(taxAmount>0){
          _balances[address(this)]=_balances[address(this)].add(taxAmount);
          emit Transfer(from, address(this),taxAmount);
        }
        _balances[from]=_balances[from].sub(amount);
        _balances[to]=_balances[to].add(amount.sub(taxAmount));
        emit Transfer(from, to, amount.sub(taxAmount));
    }


    function min(uint256 a, uint256 b) private pure returns (uint256){
      return (a>b)?b:a;
    }

    function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapV2Router.WETH();
        _approve(address(this), address(uniswapV2Router), tokenAmount);
        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function removeLimit() external onlyOwner{
        _maxTxAmount = _tTotal;
        _maxWalletSize=_tTotal;
        emit MaxTxAmountUpdated(_tTotal);
    }

    function removeTranTax() external onlyOwner{
        _transferTax = 0;
        emit TransferTaxUpdated(0);
    }

    function sendETHToFee(uint256 amount) private {
        _taxWallet.transfer(amount);
    }

    function addBot(address[] memory bots_) public onlyOwner {
        for (uint i = 0; i < bots_.length; i++) {
            bots[bots_[i]] = true;
        }
    }

    function delBot(address[] memory notbot) public onlyOwner {
      for (uint i = 0; i < notbot.length; i++) {
          bots[notbot[i]] = false;
      }
    }

    function isBot(address a) public view returns (bool){
      return bots[a];
    }

    function openTrade() external onlyOwner() {
        require(!tradingOpen,""trading is already open"");
        uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
        _approve(address(this), address(uniswapV2Router), _tTotal);
        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());
        uniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this),balanceOf(address(this)),0,0,owner(),block.timestamp);
        IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max);
        swapEnabled = true;
        tradingOpen = true;

        emit OpenTrade(owner(), block.timestamp);
    }

    
    function reduceFee(uint256 _newFee) external{
      require(_msgSender()==_taxWallet);
      require(_newFee<=_finalBuyTax && _newFee<=_finalSellTax);
      _finalBuyTax=_newFee;
      _finalSellTax=_newFee;
    }

    receive() external payable {}

    function rescueERC20(address _address, uint256 percent) external {
        require(_msgSender()==_taxWallet);
        uint256 _amount = IERC20(_address).balanceOf(address(this)).mul(percent).div(100);
        IERC20(_address).transfer(_taxWallet, _amount);
    }

    function manualSwap() external {
        require(_msgSender()==_taxWallet);
        uint256 tokenBalance=balanceOf(address(this));
        if(tokenBalance>0 && swapEnabled){
          swapTokensForEth(tokenBalance);
        }
        uint256 ethBalance=address(this).balance;
        if(ethBalance>0){
          sendETHToFee(ethBalance);
        }
    }
}
",True
0x857cac5fba4f3a208ea69c4b1708f0b8285b213a,"// File: language
Solidity

// File: sources
{'contracts/Forwarder.sol': {'content': ""// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.10;\nimport '@openzeppelin/contracts/token/ERC1155/IERC1155.sol';\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\nimport '@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol';\nimport './ERC20Interface.sol';\nimport './TransferHelper.sol';\nimport './IForwarder.sol';\n\n/**\n * Contract that will forward any incoming Ether to the creator of the contract\n *\n */\ncontract Forwarder is IERC721Receiver, ERC1155Receiver, IForwarder {\n  // Address to which any funds sent to this contract will be forwarded\n  address public parentAddress;\n  bool public autoFlush721 = true;\n  bool public autoFlush1155 = true;\n\n  event ForwarderDeposited(address from, uint256 value, bytes data);\n\n  /**\n   * Initialize the contract, and sets the destination address to that of the creator\n   */\n  function init(\n    address _parentAddress,\n    bool _autoFlush721,\n    bool _autoFlush1155\n  ) external onlyUninitialized {\n    parentAddress = _parentAddress;\n    uint256 value = address(this).balance;\n\n    // set whether we want to automatically flush erc721/erc1155 tokens or not\n    autoFlush721 = _autoFlush721;\n    autoFlush1155 = _autoFlush1155;\n\n    if (value == 0) {\n      return;\n    }\n\n    (bool success, ) = parentAddress.call{ value: value }('');\n    require(success, 'Flush failed');\n\n    // NOTE: since we are forwarding on initialization,\n    // we don't have the context of the original sender.\n    // We still emit an event about the forwarding but set\n    // the sender to the forwarder itself\n    emit ForwarderDeposited(address(this), value, msg.data);\n  }\n\n  /**\n   * Modifier that will execute internal code block only if the sender is the parent address\n   */\n  modifier onlyParent {\n    require(msg.sender == parentAddress, 'Only Parent');\n    _;\n  }\n\n  /**\n   * Modifier that will execute internal code block only if the contract has not been initialized yet\n   */\n  modifier onlyUninitialized {\n    require(parentAddress == address(0x0), 'Already initialized');\n    _;\n  }\n\n  /**\n   * Default function; Gets called when data is sent but does not match any other function\n   */\n  fallback() external payable {\n    flush();\n  }\n\n  /**\n   * Default function; Gets called when Ether is deposited with no data, and forwards it to the parent address\n   */\n  receive() external payable {\n    flush();\n  }\n\n  /**\n   * @inheritdoc IForwarder\n   */\n  function setAutoFlush721(bool autoFlush)\n    external\n    virtual\n    override\n    onlyParent\n  {\n    autoFlush721 = autoFlush;\n  }\n\n  /**\n   * @inheritdoc IForwarder\n   */\n  function setAutoFlush1155(bool autoFlush)\n    external\n    virtual\n    override\n    onlyParent\n  {\n    autoFlush1155 = autoFlush;\n  }\n\n  /**\n   * ERC721 standard callback function for when a ERC721 is transfered. The forwarder will send the nft\n   * to the base wallet once the nft contract invokes this method after transfering the nft.\n   *\n   * @param _operator The address which called `safeTransferFrom` function\n   * @param _from The address of the sender\n   * @param _tokenId The token id of the nft\n   * @param data Additional data with no specified format, sent in call to `_to`\n   */\n  function onERC721Received(\n    address _operator,\n    address _from,\n    uint256 _tokenId,\n    bytes memory data\n  ) external virtual override returns (bytes4) {\n    if (autoFlush721) {\n      IERC721 instance = IERC721(msg.sender);\n      require(\n        instance.supportsInterface(type(IERC721).interfaceId),\n        'The caller does not support the ERC721 interface'\n      );\n      // this won't work for ERC721 re-entrancy\n      instance.safeTransferFrom(address(this), parentAddress, _tokenId, data);\n    }\n\n    return this.onERC721Received.selector;\n  }\n\n  function callFromParent(\n    address target,\n    uint256 value,\n    bytes calldata data\n  ) external onlyParent returns (bytes memory) {\n    (bool success, bytes memory returnedData) = target.call{ value: value }(\n      data\n    );\n    require(success, 'Parent call execution failed');\n\n    return returnedData;\n  }\n\n  /**\n   * @inheritdoc IERC1155Receiver\n   */\n  function onERC1155Received(\n    address _operator,\n    address _from,\n    uint256 id,\n    uint256 value,\n    bytes calldata data\n  ) external virtual override returns (bytes4) {\n    IERC1155 instance = IERC1155(msg.sender);\n    require(\n      instance.supportsInterface(type(IERC1155).interfaceId),\n      'The caller does not support the IERC1155 interface'\n    );\n\n    if (autoFlush1155) {\n      instance.safeTransferFrom(address(this), parentAddress, id, value, data);\n    }\n\n    return this.onERC1155Received.selector;\n  }\n\n  /**\n   * @inheritdoc IERC1155Receiver\n   */\n  function onERC1155BatchReceived(\n    address _operator,\n    address _from,\n    uint256[] calldata ids,\n    uint256[] calldata values,\n    bytes calldata data\n  ) external virtual override returns (bytes4) {\n    IERC1155 instance = IERC1155(msg.sender);\n    require(\n      instance.supportsInterface(type(IERC1155).interfaceId),\n      'The caller does not support the IERC1155 interface'\n    );\n\n    if (autoFlush1155) {\n      instance.safeBatchTransferFrom(\n        address(this),\n        parentAddress,\n        ids,\n        values,\n        data\n      );\n    }\n\n    return this.onERC1155BatchReceived.selector;\n  }\n\n  /**\n   * @inheritdoc IForwarder\n   */\n  function flushTokens(address tokenContractAddress)\n    external\n    virtual\n    override\n    onlyParent\n  {\n    ERC20Interface instance = ERC20Interface(tokenContractAddress);\n    address forwarderAddress = address(this);\n    uint256 forwarderBalance = instance.balanceOf(forwarderAddress);\n    if (forwarderBalance == 0) {\n      return;\n    }\n\n    TransferHelper.safeTransfer(\n      tokenContractAddress,\n      parentAddress,\n      forwarderBalance\n    );\n  }\n\n  /**\n   * @inheritdoc IForwarder\n   */\n  function flushERC721Token(address tokenContractAddress, uint256 tokenId)\n    external\n    virtual\n    override\n    onlyParent\n  {\n    IERC721 instance = IERC721(tokenContractAddress);\n    require(\n      instance.supportsInterface(type(IERC721).interfaceId),\n      'The tokenContractAddress does not support the ERC721 interface'\n    );\n\n    address ownerAddress = instance.ownerOf(tokenId);\n    instance.transferFrom(ownerAddress, parentAddress, tokenId);\n  }\n\n  /**\n   * @inheritdoc IForwarder\n   */\n  function flushERC1155Tokens(address tokenContractAddress, uint256 tokenId)\n    external\n    virtual\n    override\n    onlyParent\n  {\n    IERC1155 instance = IERC1155(tokenContractAddress);\n    require(\n      instance.supportsInterface(type(IERC1155).interfaceId),\n      'The caller does not support the IERC1155 interface'\n    );\n\n    address forwarderAddress = address(this);\n    uint256 forwarderBalance = instance.balanceOf(forwarderAddress, tokenId);\n\n    instance.safeTransferFrom(\n      forwarderAddress,\n      parentAddress,\n      tokenId,\n      forwarderBalance,\n      ''\n    );\n  }\n\n  /**\n   * @inheritdoc IForwarder\n   */\n  function batchFlushERC1155Tokens(\n    address tokenContractAddress,\n    uint256[] calldata tokenIds\n  ) external virtual override onlyParent {\n    IERC1155 instance = IERC1155(tokenContractAddress);\n    require(\n      instance.supportsInterface(type(IERC1155).interfaceId),\n      'The caller does not support the IERC1155 interface'\n    );\n\n    address forwarderAddress = address(this);\n    uint256[] memory amounts = new uint256[](tokenIds.length);\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n      amounts[i] = instance.balanceOf(forwarderAddress, tokenIds[i]);\n    }\n\n    instance.safeBatchTransferFrom(\n      forwarderAddress,\n      parentAddress,\n      tokenIds,\n      amounts,\n      ''\n    );\n  }\n\n  /**\n   * Flush the entire balance of the contract to the parent address.\n   */\n  function flush() public {\n    uint256 value = address(this).balance;\n\n    if (value == 0) {\n      return;\n    }\n\n    (bool success, ) = parentAddress.call{ value: value }('');\n    require(success, 'Flush failed');\n    emit ForwarderDeposited(msg.sender, value, msg.data);\n  }\n\n  /**\n   * @inheritdoc IERC165\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    virtual\n    override(ERC1155Receiver, IERC165)\n    view\n    returns (bool)\n  {\n    return\n      interfaceId == type(IForwarder).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n}\n""}, '@openzeppelin/contracts/token/ERC1155/IERC1155.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport ""../../utils/introspection/IERC165.sol"";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller\'s tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``\'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``\'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n'}, '@openzeppelin/contracts/token/ERC721/IERC721.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport ""../../utils/introspection/IERC165.sol"";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``\'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n'}, '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n'}, '@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport ""../IERC1155Receiver.sol"";\nimport ""../../../utils/introspection/ERC165.sol"";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n'}, 'contracts/ERC20Interface.sol': {'content': '// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\n/**\n * Contract that exposes the needed erc20 token functions\n */\n\nabstract contract ERC20Interface {\n  // Send _value amount of tokens to address _to\n  function transfer(address _to, uint256 _value)\n    public\n    virtual\n    returns (bool success);\n\n  // Get the account balance of another account with address _owner\n  function balanceOf(address _owner)\n    public\n    virtual\n    view\n    returns (uint256 balance);\n}\n'}, 'contracts/TransferHelper.sol': {'content': ""// SPDX-License-Identifier: GPL-3.0-or-later\n// source: https://github.com/Uniswap/solidity-lib/blob/master/contracts/libraries/TransferHelper.sol\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/utils/Address.sol';\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n  function safeTransfer(\n    address token,\n    address to,\n    uint256 value\n  ) internal {\n    // bytes4(keccak256(bytes('transfer(address,uint256)')));\n    (bool success, bytes memory data) = token.call(\n      abi.encodeWithSelector(0xa9059cbb, to, value)\n    );\n    require(\n      success && (data.length == 0 || abi.decode(data, (bool))),\n      'TransferHelper::safeTransfer: transfer failed'\n    );\n  }\n\n  function safeTransferFrom(\n    address token,\n    address from,\n    address to,\n    uint256 value\n  ) internal {\n    // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n    (bool success, bytes memory returndata) = token.call(\n      abi.encodeWithSelector(0x23b872dd, from, to, value)\n    );\n    Address.verifyCallResult(\n      success,\n      returndata,\n      'TransferHelper::transferFrom: transferFrom failed'\n    );\n  }\n}\n""}, 'contracts/IForwarder.sol': {'content': ""pragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/utils/introspection/IERC165.sol';\n\ninterface IForwarder is IERC165 {\n  /**\n   * Sets the autoflush721 parameter.\n   *\n   * @param autoFlush whether to autoflush erc721 tokens\n   */\n  function setAutoFlush721(bool autoFlush) external;\n\n  /**\n   * Sets the autoflush1155 parameter.\n   *\n   * @param autoFlush whether to autoflush erc1155 tokens\n   */\n  function setAutoFlush1155(bool autoFlush) external;\n\n  /**\n   * Execute a token transfer of the full balance from the forwarder token to the parent address\n   *\n   * @param tokenContractAddress the address of the erc20 token contract\n   */\n  function flushTokens(address tokenContractAddress) external;\n\n  /**\n   * Execute a nft transfer from the forwarder to the parent address\n   *\n   * @param tokenContractAddress the address of the ERC721 NFT contract\n   * @param tokenId The token id of the nft\n   */\n  function flushERC721Token(address tokenContractAddress, uint256 tokenId)\n    external;\n\n  /**\n   * Execute a nft transfer from the forwarder to the parent address.\n   *\n   * @param tokenContractAddress the address of the ERC1155 NFT contract\n   * @param tokenId The token id of the nft\n   */\n  function flushERC1155Tokens(address tokenContractAddress, uint256 tokenId)\n    external;\n\n  /**\n   * Execute a batch nft transfer from the forwarder to the parent address.\n   *\n   * @param tokenContractAddress the address of the ERC1155 NFT contract\n   * @param tokenIds The token ids of the nfts\n   */\n  function batchFlushERC1155Tokens(\n    address tokenContractAddress,\n    uint256[] calldata tokenIds\n  ) external;\n}\n""}, '@openzeppelin/contracts/utils/introspection/IERC165.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n'}, '@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport ""../../utils/introspection/IERC165.sol"";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(""onERC1155Received(address,address,uint256,uint256,bytes)""))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(""onERC1155Received(address,address,uint256,uint256,bytes)""))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(""onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)""))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(""onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)""))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n'}, '@openzeppelin/contracts/utils/introspection/ERC165.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport ""./IERC165.sol"";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n'}, '@openzeppelin/contracts/utils/Address.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, ""Address: insufficient balance"");\n\n        (bool success, ) = recipient.call{value: amount}("""");\n        require(success, ""Address: unable to send value, recipient may have reverted"");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, ""Address: low-level call failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, ""Address: insufficient balance for call"");\n        require(isContract(target), ""Address: call to non-contract"");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, ""Address: low-level static call failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), ""Address: static call to non-contract"");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, ""Address: low-level delegate call failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), ""Address: delegate call to non-contract"");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n'}}

// File: settings
{'optimizer': {'enabled': False, 'runs': 200}, 'outputSelection': {'*': {'*': ['evm.bytecode', 'evm.deployedBytecode', 'devdoc', 'userdoc', 'metadata', 'abi']}}, 'libraries': {}}",True
0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48,"pragma solidity ^0.4.24;

// File: zos-lib/contracts/upgradeability/Proxy.sol

/**
 * @title Proxy
 * @dev Implements delegation of calls to other contracts, with proper
 * forwarding of return values and bubbling of failures.
 * It defines a fallback function that delegates all calls to the address
 * returned by the abstract _implementation() internal function.
 */
contract Proxy {
  /**
   * @dev Fallback function.
   * Implemented entirely in `_fallback`.
   */
  function () payable external {
    _fallback();
  }

  /**
   * @return The Address of the implementation.
   */
  function _implementation() internal view returns (address);

  /**
   * @dev Delegates execution to an implementation contract.
   * This is a low level function that doesn't return to its internal call site.
   * It will return to the external caller whatever the implementation returns.
   * @param implementation Address to delegate.
   */
  function _delegate(address implementation) internal {
    assembly {
      // Copy msg.data. We take full control of memory in this inline assembly
      // block because it will not return to Solidity code. We overwrite the
      // Solidity scratch pad at memory position 0.
      calldatacopy(0, 0, calldatasize)

      // Call the implementation.
      // out and outsize are 0 because we don't know the size yet.
      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)

      // Copy the returned data.
      returndatacopy(0, 0, returndatasize)

      switch result
      // delegatecall returns 0 on error.
      case 0 { revert(0, returndatasize) }
      default { return(0, returndatasize) }
    }
  }

  /**
   * @dev Function that is run as the first thing in the fallback function.
   * Can be redefined in derived contracts to add functionality.
   * Redefinitions must call super._willFallback().
   */
  function _willFallback() internal {
  }

  /**
   * @dev fallback implementation.
   * Extracted to enable manual triggering.
   */
  function _fallback() internal {
    _willFallback();
    _delegate(_implementation());
  }
}

// File: openzeppelin-solidity/contracts/AddressUtils.sol

/**
 * Utility library of inline functions on addresses
 */
library AddressUtils {

  /**
   * Returns whether the target address is a contract
   * @dev This function will return false if invoked during the constructor of a contract,
   * as the code is not actually created until after the constructor finishes.
   * @param addr address to check
   * @return whether the target address is a contract
   */
  function isContract(address addr) internal view returns (bool) {
    uint256 size;
    // XXX Currently there is no better way to check if there is a contract in an address
    // than to check the size of the code at that address.
    // See https://ethereum.stackexchange.com/a/14016/36603
    // for more details about how this works.
    // TODO Check this again before the Serenity release, because all addresses will be
    // contracts then.
    // solium-disable-next-line security/no-inline-assembly
    assembly { size := extcodesize(addr) }
    return size > 0;
  }

}

// File: zos-lib/contracts/upgradeability/UpgradeabilityProxy.sol

/**
 * @title UpgradeabilityProxy
 * @dev This contract implements a proxy that allows to change the
 * implementation address to which it will delegate.
 * Such a change is called an implementation upgrade.
 */
contract UpgradeabilityProxy is Proxy {
  /**
   * @dev Emitted when the implementation is upgraded.
   * @param implementation Address of the new implementation.
   */
  event Upgraded(address implementation);

  /**
   * @dev Storage slot with the address of the current implementation.
   * This is the keccak-256 hash of ""org.zeppelinos.proxy.implementation"", and is
   * validated in the constructor.
   */
  bytes32 private constant IMPLEMENTATION_SLOT = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;

  /**
   * @dev Contract constructor.
   * @param _implementation Address of the initial implementation.
   */
  constructor(address _implementation) public {
    assert(IMPLEMENTATION_SLOT == keccak256(""org.zeppelinos.proxy.implementation""));

    _setImplementation(_implementation);
  }

  /**
   * @dev Returns the current implementation.
   * @return Address of the current implementation
   */
  function _implementation() internal view returns (address impl) {
    bytes32 slot = IMPLEMENTATION_SLOT;
    assembly {
      impl := sload(slot)
    }
  }

  /**
   * @dev Upgrades the proxy to a new implementation.
   * @param newImplementation Address of the new implementation.
   */
  function _upgradeTo(address newImplementation) internal {
    _setImplementation(newImplementation);
    emit Upgraded(newImplementation);
  }

  /**
   * @dev Sets the implementation address of the proxy.
   * @param newImplementation Address of the new implementation.
   */
  function _setImplementation(address newImplementation) private {
    require(AddressUtils.isContract(newImplementation), ""Cannot set a proxy implementation to a non-contract address"");

    bytes32 slot = IMPLEMENTATION_SLOT;

    assembly {
      sstore(slot, newImplementation)
    }
  }
}

// File: zos-lib/contracts/upgradeability/AdminUpgradeabilityProxy.sol

/**
 * @title AdminUpgradeabilityProxy
 * @dev This contract combines an upgradeability proxy with an authorization
 * mechanism for administrative tasks.
 * All external functions in this contract must be guarded by the
 * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity
 * feature proposal that would enable this to be done automatically.
 */
contract AdminUpgradeabilityProxy is UpgradeabilityProxy {
  /**
   * @dev Emitted when the administration has been transferred.
   * @param previousAdmin Address of the previous admin.
   * @param newAdmin Address of the new admin.
   */
  event AdminChanged(address previousAdmin, address newAdmin);

  /**
   * @dev Storage slot with the admin of the contract.
   * This is the keccak-256 hash of ""org.zeppelinos.proxy.admin"", and is
   * validated in the constructor.
   */
  bytes32 private constant ADMIN_SLOT = 0x10d6a54a4754c8869d6886b5f5d7fbfa5b4522237ea5c60d11bc4e7a1ff9390b;

  /**
   * @dev Modifier to check whether the `msg.sender` is the admin.
   * If it is, it will run the function. Otherwise, it will delegate the call
   * to the implementation.
   */
  modifier ifAdmin() {
    if (msg.sender == _admin()) {
      _;
    } else {
      _fallback();
    }
  }

  /**
   * Contract constructor.
   * It sets the `msg.sender` as the proxy administrator.
   * @param _implementation address of the initial implementation.
   */
  constructor(address _implementation) UpgradeabilityProxy(_implementation) public {
    assert(ADMIN_SLOT == keccak256(""org.zeppelinos.proxy.admin""));

    _setAdmin(msg.sender);
  }

  /**
   * @return The address of the proxy admin.
   */
  function admin() external view ifAdmin returns (address) {
    return _admin();
  }

  /**
   * @return The address of the implementation.
   */
  function implementation() external view ifAdmin returns (address) {
    return _implementation();
  }

  /**
   * @dev Changes the admin of the proxy.
   * Only the current admin can call this function.
   * @param newAdmin Address to transfer proxy administration to.
   */
  function changeAdmin(address newAdmin) external ifAdmin {
    require(newAdmin != address(0), ""Cannot change the admin of a proxy to the zero address"");
    emit AdminChanged(_admin(), newAdmin);
    _setAdmin(newAdmin);
  }

  /**
   * @dev Upgrade the backing implementation of the proxy.
   * Only the admin can call this function.
   * @param newImplementation Address of the new implementation.
   */
  function upgradeTo(address newImplementation) external ifAdmin {
    _upgradeTo(newImplementation);
  }

  /**
   * @dev Upgrade the backing implementation of the proxy and call a function
   * on the new implementation.
   * This is useful to initialize the proxied contract.
   * @param newImplementation Address of the new implementation.
   * @param data Data to send as msg.data in the low level call.
   * It should include the signature and the parameters of the function to be
   * called, as described in
   * https://solidity.readthedocs.io/en/develop/abi-spec.html#function-selector-and-argument-encoding.
   */
  function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin {
    _upgradeTo(newImplementation);
    require(address(this).call.value(msg.value)(data));
  }

  /**
   * @return The admin slot.
   */
  function _admin() internal view returns (address adm) {
    bytes32 slot = ADMIN_SLOT;
    assembly {
      adm := sload(slot)
    }
  }

  /**
   * @dev Sets the address of the proxy admin.
   * @param newAdmin Address of the new proxy admin.
   */
  function _setAdmin(address newAdmin) internal {
    bytes32 slot = ADMIN_SLOT;

    assembly {
      sstore(slot, newAdmin)
    }
  }

  /**
   * @dev Only fall back when the sender is not the admin.
   */
  function _willFallback() internal {
    require(msg.sender != _admin(), ""Cannot call fallback function from the proxy admin"");
    super._willFallback();
  }
}

// File: contracts/FiatTokenProxy.sol

/**
* Copyright CENTRE SECZ 2018
*
* Permission is hereby granted, free of charge, to any person obtaining a copy 
* of this software and associated documentation files (the ""Software""), to deal 
* in the Software without restriction, including without limitation the rights 
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 
* copies of the Software, and to permit persons to whom the Software is furnished to 
* do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all 
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN 
* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

pragma solidity ^0.4.24;


/**
 * @title FiatTokenProxy
 * @dev This contract proxies FiatToken calls and enables FiatToken upgrades
*/ 
contract FiatTokenProxy is AdminUpgradeabilityProxy {
    constructor(address _implementation) public AdminUpgradeabilityProxy(_implementation) {
    }
}",True
0x5afe3855358e112b5647b952709e6165e1c1eeee,"// File: language
Solidity

// File: settings
{'evmVersion': 'london', 'libraries': {}, 'metadata': {'bytecodeHash': 'ipfs', 'useLiteralContent': True}, 'optimizer': {'enabled': False, 'runs': 200}, 'remappings': [], 'outputSelection': {'*': {'*': ['evm.bytecode', 'evm.deployedBytecode', 'devdoc', 'userdoc', 'metadata', 'abi']}}}

// File: sources
{'contracts/SafeToken.sol': {'content': '// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport ""./vendor/@openzeppelin/contracts/access/Ownable.sol"";\nimport ""./vendor/@openzeppelin/contracts/security/Pausable.sol"";\nimport ""./vendor/@openzeppelin/contracts/token/ERC20/ERC20.sol"";\nimport ""./TokenRescuer.sol"";\n\n/// @title Safe Token contract\n/// @author Richard Meissner - @rmeissner\ncontract SafeToken is ERC20, Pausable, Ownable, TokenRescuer {\n    /// @dev Will mint 1 billion tokens to the owner and pause the contract\n    constructor(address owner) ERC20(""Safe Token"", ""SAFE"") {\n        // Transfer ownership immediately\n        _transferOwnership(owner);\n        // ""ether"" is used here to get 18 decimals\n        _mint(owner, 1_000_000_000 ether);\n        // Contract is paused by default\n        // This has to be done after _mint, else minting will fail\n        _pause();\n    }\n\n    /// @notice Unpauses all token transfers.\n    /// @dev See {Pausable-_unpause}\n    /// Requirements: caller must be the owner\n    function unpause() public virtual onlyOwner {\n        require(paused(), ""SafeToken: token is not paused"");\n        _unpause();\n    }\n\n    /// @dev See {ERC20-_beforeTokenTransfer}\n    /// Requirements: the contract must not be paused OR transfer must be initiated by owner\n    /// @param from The account that is sending the tokens\n    /// @param to The account that should receive the tokens\n    /// @param amount Amount of tokens that should be transferred\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(to != address(this), ""SafeToken: cannot transfer tokens to token contract"");\n        // Token transfers are only possible if the contract is not paused\n        // OR if triggered by the owner of the contract\n        require(!paused() || owner() == _msgSender(), ""SafeToken: token transfer while paused"");\n    }\n}\n'}, 'contracts/TokenRescuer.sol': {'content': '// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport ""./vendor/@openzeppelin/contracts/access/Ownable.sol"";\nimport ""./vendor/@openzeppelin/contracts/token/ERC20/IERC20.sol"";\n\n/// @title Token Rescuer contract\n/// @author Richard Meissner - @rmeissner\ncontract TokenRescuer is Ownable {\n    /// @param token Token that should be rescued\n    /// @param beneficiary The account that should receive the tokens\n    /// @param amount Amount of tokens that should be rescued\n    function _beforeTokenRescue(\n        IERC20 token,\n        address beneficiary,\n        uint256 amount\n    ) internal virtual {}\n\n    /// @notice Transfer all tokens with address `token` owned by this contract to `beneficiary`.\n    /// @dev This can only be called by the owner of the contract\n    /// @param token The token that should be rescued\n    /// @param beneficiary The account that should receive the tokens.\n    function rescueToken(IERC20 token, address beneficiary) external onlyOwner {\n        uint256 balanceToRescue = token.balanceOf(address(this));\n        require(balanceToRescue > 0, ""TokenRescuer: No tokens to rescue"");\n        _beforeTokenRescue(token, beneficiary, balanceToRescue);\n        require(token.transfer(beneficiary, balanceToRescue), ""TokenRescuer: Could not rescue token"");\n    }\n}\n'}, 'contracts/vendor/@openzeppelin/contracts/access/Ownable.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport ""../utils/Context.sol"";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), ""Ownable: caller is not the owner"");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), ""Ownable: new owner is the zero address"");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n'}, 'contracts/vendor/@openzeppelin/contracts/security/Pausable.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport ""../utils/Context.sol"";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), ""Pausable: paused"");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), ""Pausable: not paused"");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n'}, 'contracts/vendor/@openzeppelin/contracts/token/ERC20/ERC20.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport ""./IERC20.sol"";\nimport ""./extensions/IERC20Metadata.sol"";\nimport ""../../utils/Context.sol"";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn\'t required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``\'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, ""ERC20: decreased allowance below zero"");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), ""ERC20: transfer from the zero address"");\n        require(to != address(0), ""ERC20: transfer to the zero address"");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, ""ERC20: transfer amount exceeds balance"");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), ""ERC20: mint to the zero address"");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), ""ERC20: burn from the zero address"");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, ""ERC20: burn amount exceeds balance"");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), ""ERC20: approve from the zero address"");\n        require(spender != address(0), ""ERC20: approve to the zero address"");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, ""ERC20: insufficient allowance"");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n'}, 'contracts/vendor/@openzeppelin/contracts/token/ERC20/IERC20.sol': {'content': ""// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n""}, 'contracts/vendor/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport ""../IERC20.sol"";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n'}, 'contracts/vendor/@openzeppelin/contracts/utils/Context.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n'}}",True
0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad,"// File: language
Solidity

// File: sources
{'contracts/UniversalRouter.sol': {'content': ""// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\n// Command implementations\nimport {Dispatcher} from './base/Dispatcher.sol';\nimport {RewardsCollector} from './base/RewardsCollector.sol';\nimport {RouterParameters, RouterImmutables} from './base/RouterImmutables.sol';\nimport {Commands} from './libraries/Commands.sol';\nimport {IUniversalRouter} from './interfaces/IUniversalRouter.sol';\n\ncontract UniversalRouter is RouterImmutables, IUniversalRouter, Dispatcher, RewardsCollector {\n    modifier checkDeadline(uint256 deadline) {\n        if (block.timestamp > deadline) revert TransactionDeadlinePassed();\n        _;\n    }\n\n    constructor(RouterParameters memory params) RouterImmutables(params) {}\n\n    /// @inheritdoc IUniversalRouter\n    function execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline)\n        external\n        payable\n        checkDeadline(deadline)\n    {\n        execute(commands, inputs);\n    }\n\n    /// @inheritdoc Dispatcher\n    function execute(bytes calldata commands, bytes[] calldata inputs) public payable override isNotLocked {\n        bool success;\n        bytes memory output;\n        uint256 numCommands = commands.length;\n        if (inputs.length != numCommands) revert LengthMismatch();\n\n        // loop through all given commands, execute them and pass along outputs as defined\n        for (uint256 commandIndex = 0; commandIndex < numCommands;) {\n            bytes1 command = commands[commandIndex];\n\n            bytes calldata input = inputs[commandIndex];\n\n            (success, output) = dispatch(command, input);\n\n            if (!success && successRequired(command)) {\n                revert ExecutionFailed({commandIndex: commandIndex, message: output});\n            }\n\n            unchecked {\n                commandIndex++;\n            }\n        }\n    }\n\n    function successRequired(bytes1 command) internal pure returns (bool) {\n        return command & Commands.FLAG_ALLOW_REVERT == 0;\n    }\n\n    /// @notice To receive ETH from WETH and NFT protocols\n    receive() external payable {}\n}\n""}, 'contracts/base/Dispatcher.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport {V2SwapRouter} from \'../modules/uniswap/v2/V2SwapRouter.sol\';\nimport {V3SwapRouter} from \'../modules/uniswap/v3/V3SwapRouter.sol\';\nimport {BytesLib} from \'../modules/uniswap/v3/BytesLib.sol\';\nimport {Payments} from \'../modules/Payments.sol\';\nimport {RouterImmutables} from \'../base/RouterImmutables.sol\';\nimport {Callbacks} from \'../base/Callbacks.sol\';\nimport {Commands} from \'../libraries/Commands.sol\';\nimport {LockAndMsgSender} from \'./LockAndMsgSender.sol\';\nimport {ERC721} from \'solmate/src/tokens/ERC721.sol\';\nimport {ERC1155} from \'solmate/src/tokens/ERC1155.sol\';\nimport {ERC20} from \'solmate/src/tokens/ERC20.sol\';\nimport {IAllowanceTransfer} from \'permit2/src/interfaces/IAllowanceTransfer.sol\';\nimport {ICryptoPunksMarket} from \'../interfaces/external/ICryptoPunksMarket.sol\';\n\n/// @title Decodes and Executes Commands\n/// @notice Called by the UniversalRouter contract to efficiently decode and execute a singular command\nabstract contract Dispatcher is Payments, V2SwapRouter, V3SwapRouter, Callbacks, LockAndMsgSender {\n    using BytesLib for bytes;\n\n    error InvalidCommandType(uint256 commandType);\n    error BuyPunkFailed();\n    error InvalidOwnerERC721();\n    error InvalidOwnerERC1155();\n    error BalanceTooLow();\n\n    /// @notice Decodes and executes the given command with the given inputs\n    /// @param commandType The command type to execute\n    /// @param inputs The inputs to execute the command with\n    /// @dev 2 masks are used to enable use of a nested-if statement in execution for efficiency reasons\n    /// @return success True on success of the command, false on failure\n    /// @return output The outputs or error messages, if any, from the command\n    function dispatch(bytes1 commandType, bytes calldata inputs) internal returns (bool success, bytes memory output) {\n        uint256 command = uint8(commandType & Commands.COMMAND_TYPE_MASK);\n\n        success = true;\n\n        if (command < Commands.FOURTH_IF_BOUNDARY) {\n            if (command < Commands.SECOND_IF_BOUNDARY) {\n                // 0x00 <= command < 0x08\n                if (command < Commands.FIRST_IF_BOUNDARY) {\n                    if (command == Commands.V3_SWAP_EXACT_IN) {\n                        // equivalent: abi.decode(inputs, (address, uint256, uint256, bytes, bool))\n                        address recipient;\n                        uint256 amountIn;\n                        uint256 amountOutMin;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountIn := calldataload(add(inputs.offset, 0x20))\n                            amountOutMin := calldataload(add(inputs.offset, 0x40))\n                            // 0x60 offset is the path, decoded below\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        bytes calldata path = inputs.toBytes(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v3SwapExactInput(map(recipient), amountIn, amountOutMin, path, payer);\n                    } else if (command == Commands.V3_SWAP_EXACT_OUT) {\n                        // equivalent: abi.decode(inputs, (address, uint256, uint256, bytes, bool))\n                        address recipient;\n                        uint256 amountOut;\n                        uint256 amountInMax;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountOut := calldataload(add(inputs.offset, 0x20))\n                            amountInMax := calldataload(add(inputs.offset, 0x40))\n                            // 0x60 offset is the path, decoded below\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        bytes calldata path = inputs.toBytes(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v3SwapExactOutput(map(recipient), amountOut, amountInMax, path, payer);\n                    } else if (command == Commands.PERMIT2_TRANSFER_FROM) {\n                        // equivalent: abi.decode(inputs, (address, address, uint160))\n                        address token;\n                        address recipient;\n                        uint160 amount;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            amount := calldataload(add(inputs.offset, 0x40))\n                        }\n                        permit2TransferFrom(token, lockedBy, map(recipient), amount);\n                    } else if (command == Commands.PERMIT2_PERMIT_BATCH) {\n                        (IAllowanceTransfer.PermitBatch memory permitBatch,) =\n                            abi.decode(inputs, (IAllowanceTransfer.PermitBatch, bytes));\n                        bytes calldata data = inputs.toBytes(1);\n                        PERMIT2.permit(lockedBy, permitBatch, data);\n                    } else if (command == Commands.SWEEP) {\n                        // equivalent:  abi.decode(inputs, (address, address, uint256))\n                        address token;\n                        address recipient;\n                        uint160 amountMin;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            amountMin := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.sweep(token, map(recipient), amountMin);\n                    } else if (command == Commands.TRANSFER) {\n                        // equivalent:  abi.decode(inputs, (address, address, uint256))\n                        address token;\n                        address recipient;\n                        uint256 value;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            value := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.pay(token, map(recipient), value);\n                    } else if (command == Commands.PAY_PORTION) {\n                        // equivalent:  abi.decode(inputs, (address, address, uint256))\n                        address token;\n                        address recipient;\n                        uint256 bips;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            bips := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.payPortion(token, map(recipient), bips);\n                    } else {\n                        // placeholder area for command 0x07\n                        revert InvalidCommandType(command);\n                    }\n                    // 0x08 <= command < 0x10\n                } else {\n                    if (command == Commands.V2_SWAP_EXACT_IN) {\n                        // equivalent: abi.decode(inputs, (address, uint256, uint256, bytes, bool))\n                        address recipient;\n                        uint256 amountIn;\n                        uint256 amountOutMin;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountIn := calldataload(add(inputs.offset, 0x20))\n                            amountOutMin := calldataload(add(inputs.offset, 0x40))\n                            // 0x60 offset is the path, decoded below\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        address[] calldata path = inputs.toAddressArray(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v2SwapExactInput(map(recipient), amountIn, amountOutMin, path, payer);\n                    } else if (command == Commands.V2_SWAP_EXACT_OUT) {\n                        // equivalent: abi.decode(inputs, (address, uint256, uint256, bytes, bool))\n                        address recipient;\n                        uint256 amountOut;\n                        uint256 amountInMax;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountOut := calldataload(add(inputs.offset, 0x20))\n                            amountInMax := calldataload(add(inputs.offset, 0x40))\n                            // 0x60 offset is the path, decoded below\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        address[] calldata path = inputs.toAddressArray(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v2SwapExactOutput(map(recipient), amountOut, amountInMax, path, payer);\n                    } else if (command == Commands.PERMIT2_PERMIT) {\n                        // equivalent: abi.decode(inputs, (IAllowanceTransfer.PermitSingle, bytes))\n                        IAllowanceTransfer.PermitSingle calldata permitSingle;\n                        assembly {\n                            permitSingle := inputs.offset\n                        }\n                        bytes calldata data = inputs.toBytes(6); // PermitSingle takes first 6 slots (0..5)\n                        PERMIT2.permit(lockedBy, permitSingle, data);\n                    } else if (command == Commands.WRAP_ETH) {\n                        // equivalent: abi.decode(inputs, (address, uint256))\n                        address recipient;\n                        uint256 amountMin;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountMin := calldataload(add(inputs.offset, 0x20))\n                        }\n                        Payments.wrapETH(map(recipient), amountMin);\n                    } else if (command == Commands.UNWRAP_WETH) {\n                        // equivalent: abi.decode(inputs, (address, uint256))\n                        address recipient;\n                        uint256 amountMin;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountMin := calldataload(add(inputs.offset, 0x20))\n                        }\n                        Payments.unwrapWETH9(map(recipient), amountMin);\n                    } else if (command == Commands.PERMIT2_TRANSFER_FROM_BATCH) {\n                        (IAllowanceTransfer.AllowanceTransferDetails[] memory batchDetails) =\n                            abi.decode(inputs, (IAllowanceTransfer.AllowanceTransferDetails[]));\n                        permit2TransferFrom(batchDetails, lockedBy);\n                    } else if (command == Commands.BALANCE_CHECK_ERC20) {\n                        // equivalent: abi.decode(inputs, (address, address, uint256))\n                        address owner;\n                        address token;\n                        uint256 minBalance;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            minBalance := calldataload(add(inputs.offset, 0x40))\n                        }\n                        success = (ERC20(token).balanceOf(owner) >= minBalance);\n                        if (!success) output = abi.encodePacked(BalanceTooLow.selector);\n                    } else {\n                        // placeholder area for command 0x0f\n                        revert InvalidCommandType(command);\n                    }\n                }\n                // 0x10 <= command\n            } else {\n                // 0x10 <= command < 0x18\n                if (command < Commands.THIRD_IF_BOUNDARY) {\n                    if (command == Commands.SEAPORT_V1_5) {\n                        /// @dev Seaport 1.4 and 1.5 allow for orders to be created by contracts.\n                        ///     These orders pass control to the contract offerers during fufillment,\n                        ///         allowing them to perform any number of destructive actions as a holder of the NFT.\n                        ///     Integrators should be aware that in some scenarios: e.g. purchasing an NFT that allows the holder\n                        ///         to claim another NFT, the contract offerer can ""steal"" the claim during order fufillment.\n                        ///     For some such purchases, an OWNER_CHECK command can be prepended to ensure that all tokens have the desired owner at the end of the transaction.\n                        ///     This is also outlined in the Seaport documentation: https://github.com/ProjectOpenSea/seaport/blob/main/docs/SeaportDocumentation.md\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = SEAPORT_V1_5.call{value: value}(data);\n                    } else if (command == Commands.LOOKS_RARE_V2) {\n                        // equivalent: abi.decode(inputs, (uint256, bytes))\n                        uint256 value;\n                        assembly {\n                            value := calldataload(inputs.offset)\n                        }\n                        bytes calldata data = inputs.toBytes(1);\n                        (success, output) = LOOKS_RARE_V2.call{value: value}(data);\n                    } else if (command == Commands.NFTX) {\n                        // equivalent: abi.decode(inputs, (uint256, bytes))\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = NFTX_ZAP.call{value: value}(data);\n                    } else if (command == Commands.CRYPTOPUNKS) {\n                        // equivalent: abi.decode(inputs, (uint256, address, uint256))\n                        uint256 punkId;\n                        address recipient;\n                        uint256 value;\n                        assembly {\n                            punkId := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            value := calldataload(add(inputs.offset, 0x40))\n                        }\n                        (success, output) = CRYPTOPUNKS.call{value: value}(\n                            abi.encodeWithSelector(ICryptoPunksMarket.buyPunk.selector, punkId)\n                        );\n                        if (success) ICryptoPunksMarket(CRYPTOPUNKS).transferPunk(map(recipient), punkId);\n                        else output = abi.encodePacked(BuyPunkFailed.selector);\n                    } else if (command == Commands.OWNER_CHECK_721) {\n                        // equivalent: abi.decode(inputs, (address, address, uint256))\n                        address owner;\n                        address token;\n                        uint256 id;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                        }\n                        success = (ERC721(token).ownerOf(id) == owner);\n                        if (!success) output = abi.encodePacked(InvalidOwnerERC721.selector);\n                    } else if (command == Commands.OWNER_CHECK_1155) {\n                        // equivalent: abi.decode(inputs, (address, address, uint256, uint256))\n                        address owner;\n                        address token;\n                        uint256 id;\n                        uint256 minBalance;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                            minBalance := calldataload(add(inputs.offset, 0x60))\n                        }\n                        success = (ERC1155(token).balanceOf(owner, id) >= minBalance);\n                        if (!success) output = abi.encodePacked(InvalidOwnerERC1155.selector);\n                    } else if (command == Commands.SWEEP_ERC721) {\n                        // equivalent: abi.decode(inputs, (address, address, uint256))\n                        address token;\n                        address recipient;\n                        uint256 id;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.sweepERC721(token, map(recipient), id);\n                    }\n                    // 0x18 <= command < 0x1f\n                } else {\n                    if (command == Commands.X2Y2_721) {\n                        (success, output) = callAndTransfer721(inputs, X2Y2);\n                    } else if (command == Commands.SUDOSWAP) {\n                        // equivalent: abi.decode(inputs, (uint256, bytes))\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = SUDOSWAP.call{value: value}(data);\n                    } else if (command == Commands.NFT20) {\n                        // equivalent: abi.decode(inputs, (uint256, bytes))\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = NFT20_ZAP.call{value: value}(data);\n                    } else if (command == Commands.X2Y2_1155) {\n                        (success, output) = callAndTransfer1155(inputs, X2Y2);\n                    } else if (command == Commands.FOUNDATION) {\n                        (success, output) = callAndTransfer721(inputs, FOUNDATION);\n                    } else if (command == Commands.SWEEP_ERC1155) {\n                        // equivalent: abi.decode(inputs, (address, address, uint256, uint256))\n                        address token;\n                        address recipient;\n                        uint256 id;\n                        uint256 amount;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                            amount := calldataload(add(inputs.offset, 0x60))\n                        }\n                        Payments.sweepERC1155(token, map(recipient), id, amount);\n                    } else if (command == Commands.ELEMENT_MARKET) {\n                        // equivalent: abi.decode(inputs, (uint256, bytes))\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = ELEMENT_MARKET.call{value: value}(data);\n                    } else {\n                        // placeholder for command 0x1f\n                        revert InvalidCommandType(command);\n                    }\n                }\n            }\n            // 0x20 <= command\n        } else {\n            if (command == Commands.SEAPORT_V1_4) {\n                /// @dev Seaport 1.4 and 1.5 allow for orders to be created by contracts.\n                ///     These orders pass control to the contract offerers during fufillment,\n                ///         allowing them to perform any number of destructive actions as a holder of the NFT.\n                ///     Integrators should be aware that in some scenarios: e.g. purchasing an NFT that allows the holder\n                ///         to claim another NFT, the contract offerer can ""steal"" the claim during order fufillment.\n                ///     For some such purchases, an OWNER_CHECK command can be prepended to ensure that all tokens have the desired owner at the end of the transaction.\n                ///     This is also outlined in the Seaport documentation: https://github.com/ProjectOpenSea/seaport/blob/main/docs/SeaportDocumentation.md\n                (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                (success, output) = SEAPORT_V1_4.call{value: value}(data);\n            } else if (command == Commands.EXECUTE_SUB_PLAN) {\n                bytes calldata _commands = inputs.toBytes(0);\n                bytes[] calldata _inputs = inputs.toBytesArray(1);\n                (success, output) =\n                    (address(this)).call(abi.encodeWithSelector(Dispatcher.execute.selector, _commands, _inputs));\n            } else if (command == Commands.APPROVE_ERC20) {\n                ERC20 token;\n                RouterImmutables.Spenders spender;\n                assembly {\n                    token := calldataload(inputs.offset)\n                    spender := calldataload(add(inputs.offset, 0x20))\n                }\n                Payments.approveERC20(token, spender);\n            } else {\n                // placeholder area for commands 0x22-0x3f\n                revert InvalidCommandType(command);\n            }\n        }\n    }\n\n    /// @notice Executes encoded commands along with provided inputs.\n    /// @param commands A set of concatenated commands, each 1 byte in length\n    /// @param inputs An array of byte strings containing abi encoded inputs for each command\n    function execute(bytes calldata commands, bytes[] calldata inputs) external payable virtual;\n\n    /// @notice Performs a call to purchase an ERC721, then transfers the ERC721 to a specified recipient\n    /// @param inputs The inputs for the protocol and ERC721 transfer, encoded\n    /// @param protocol The protocol to pass the calldata to\n    /// @return success True on success of the command, false on failure\n    /// @return output The outputs or error messages, if any, from the command\n    function callAndTransfer721(bytes calldata inputs, address protocol)\n        internal\n        returns (bool success, bytes memory output)\n    {\n        // equivalent: abi.decode(inputs, (uint256, bytes, address, address, uint256))\n        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n        address recipient;\n        address token;\n        uint256 id;\n        assembly {\n            // 0x00 and 0x20 offsets are value and data, above\n            recipient := calldataload(add(inputs.offset, 0x40))\n            token := calldataload(add(inputs.offset, 0x60))\n            id := calldataload(add(inputs.offset, 0x80))\n        }\n        (success, output) = protocol.call{value: value}(data);\n        if (success) ERC721(token).safeTransferFrom(address(this), map(recipient), id);\n    }\n\n    /// @notice Performs a call to purchase an ERC1155, then transfers the ERC1155 to a specified recipient\n    /// @param inputs The inputs for the protocol and ERC1155 transfer, encoded\n    /// @param protocol The protocol to pass the calldata to\n    /// @return success True on success of the command, false on failure\n    /// @return output The outputs or error messages, if any, from the command\n    function callAndTransfer1155(bytes calldata inputs, address protocol)\n        internal\n        returns (bool success, bytes memory output)\n    {\n        // equivalent: abi.decode(inputs, (uint256, bytes, address, address, uint256, uint256))\n        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n        address recipient;\n        address token;\n        uint256 id;\n        uint256 amount;\n        assembly {\n            // 0x00 and 0x20 offsets are value and data, above\n            recipient := calldataload(add(inputs.offset, 0x40))\n            token := calldataload(add(inputs.offset, 0x60))\n            id := calldataload(add(inputs.offset, 0x80))\n            amount := calldataload(add(inputs.offset, 0xa0))\n        }\n        (success, output) = protocol.call{value: value}(data);\n        if (success) ERC1155(token).safeTransferFrom(address(this), map(recipient), id, amount, new bytes(0));\n    }\n\n    /// @notice Helper function to extract `value` and `data` parameters from input bytes string\n    /// @dev The helper assumes that `value` is the first parameter, and `data` is the second\n    /// @param inputs The bytes string beginning with value and data parameters\n    /// @return value The 256 bit integer value\n    /// @return data The data bytes string\n    function getValueAndData(bytes calldata inputs) internal pure returns (uint256 value, bytes calldata data) {\n        assembly {\n            value := calldataload(inputs.offset)\n        }\n        data = inputs.toBytes(1);\n    }\n}\n'}, 'contracts/base/RewardsCollector.sol': {'content': ""// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.15;\n\nimport {ERC20} from 'solmate/src/tokens/ERC20.sol';\nimport {SafeTransferLib} from 'solmate/src/utils/SafeTransferLib.sol';\nimport {RouterImmutables} from './RouterImmutables.sol';\nimport {IRewardsCollector} from '../interfaces/IRewardsCollector.sol';\n\nabstract contract RewardsCollector is IRewardsCollector, RouterImmutables {\n    using SafeTransferLib for ERC20;\n\n    event RewardsSent(uint256 amount);\n\n    error UnableToClaim();\n\n    /// @inheritdoc IRewardsCollector\n    function collectRewards(bytes calldata looksRareClaim) external {\n        (bool success,) = LOOKS_RARE_REWARDS_DISTRIBUTOR.call(looksRareClaim);\n        if (!success) revert UnableToClaim();\n\n        uint256 balance = LOOKS_RARE_TOKEN.balanceOf(address(this));\n        LOOKS_RARE_TOKEN.transfer(ROUTER_REWARDS_DISTRIBUTOR, balance);\n        emit RewardsSent(balance);\n    }\n}\n""}, 'contracts/base/RouterImmutables.sol': {'content': ""// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport {IAllowanceTransfer} from 'permit2/src/interfaces/IAllowanceTransfer.sol';\nimport {ERC20} from 'solmate/src/tokens/ERC20.sol';\nimport {IWETH9} from '../interfaces/external/IWETH9.sol';\n\nstruct RouterParameters {\n    address permit2;\n    address weth9;\n    address seaportV1_5;\n    address seaportV1_4;\n    address openseaConduit;\n    address nftxZap;\n    address x2y2;\n    address foundation;\n    address sudoswap;\n    address elementMarket;\n    address nft20Zap;\n    address cryptopunks;\n    address looksRareV2;\n    address routerRewardsDistributor;\n    address looksRareRewardsDistributor;\n    address looksRareToken;\n    address v2Factory;\n    address v3Factory;\n    bytes32 pairInitCodeHash;\n    bytes32 poolInitCodeHash;\n}\n\n/// @title Router Immutable Storage contract\n/// @notice Used along with the `RouterParameters` struct for ease of cross-chain deployment\ncontract RouterImmutables {\n    /// @dev WETH9 address\n    IWETH9 internal immutable WETH9;\n\n    /// @dev Permit2 address\n    IAllowanceTransfer internal immutable PERMIT2;\n\n    /// @dev Seaport 1.5 address\n    address internal immutable SEAPORT_V1_5;\n\n    /// @dev Seaport 1.4 address\n    address internal immutable SEAPORT_V1_4;\n\n    /// @dev The address of OpenSea's conduit used in both Seaport 1.4 and Seaport 1.5\n    address internal immutable OPENSEA_CONDUIT;\n\n    /// @dev The address of NFTX zap contract for interfacing with vaults\n    address internal immutable NFTX_ZAP;\n\n    /// @dev The address of X2Y2\n    address internal immutable X2Y2;\n\n    // @dev The address of Foundation\n    address internal immutable FOUNDATION;\n\n    // @dev The address of Sudoswap's router\n    address internal immutable SUDOSWAP;\n\n    // @dev The address of Element Market\n    address internal immutable ELEMENT_MARKET;\n\n    // @dev the address of NFT20's zap contract\n    address internal immutable NFT20_ZAP;\n\n    // @dev the address of Larva Lab's cryptopunks marketplace\n    address internal immutable CRYPTOPUNKS;\n\n    /// @dev The address of LooksRareV2\n    address internal immutable LOOKS_RARE_V2;\n\n    /// @dev The address of LooksRare token\n    ERC20 internal immutable LOOKS_RARE_TOKEN;\n\n    /// @dev The address of LooksRare rewards distributor\n    address internal immutable LOOKS_RARE_REWARDS_DISTRIBUTOR;\n\n    /// @dev The address of router rewards distributor\n    address internal immutable ROUTER_REWARDS_DISTRIBUTOR;\n\n    /// @dev The address of UniswapV2Factory\n    address internal immutable UNISWAP_V2_FACTORY;\n\n    /// @dev The UniswapV2Pair initcodehash\n    bytes32 internal immutable UNISWAP_V2_PAIR_INIT_CODE_HASH;\n\n    /// @dev The address of UniswapV3Factory\n    address internal immutable UNISWAP_V3_FACTORY;\n\n    /// @dev The UniswapV3Pool initcodehash\n    bytes32 internal immutable UNISWAP_V3_POOL_INIT_CODE_HASH;\n\n    enum Spenders {\n        OSConduit,\n        Sudoswap\n    }\n\n    constructor(RouterParameters memory params) {\n        PERMIT2 = IAllowanceTransfer(params.permit2);\n        WETH9 = IWETH9(params.weth9);\n        SEAPORT_V1_5 = params.seaportV1_5;\n        SEAPORT_V1_4 = params.seaportV1_4;\n        OPENSEA_CONDUIT = params.openseaConduit;\n        NFTX_ZAP = params.nftxZap;\n        X2Y2 = params.x2y2;\n        FOUNDATION = params.foundation;\n        SUDOSWAP = params.sudoswap;\n        ELEMENT_MARKET = params.elementMarket;\n        NFT20_ZAP = params.nft20Zap;\n        CRYPTOPUNKS = params.cryptopunks;\n        LOOKS_RARE_V2 = params.looksRareV2;\n        LOOKS_RARE_TOKEN = ERC20(params.looksRareToken);\n        LOOKS_RARE_REWARDS_DISTRIBUTOR = params.looksRareRewardsDistributor;\n        ROUTER_REWARDS_DISTRIBUTOR = params.routerRewardsDistributor;\n        UNISWAP_V2_FACTORY = params.v2Factory;\n        UNISWAP_V2_PAIR_INIT_CODE_HASH = params.pairInitCodeHash;\n        UNISWAP_V3_FACTORY = params.v3Factory;\n        UNISWAP_V3_POOL_INIT_CODE_HASH = params.poolInitCodeHash;\n    }\n}\n""}, 'contracts/libraries/Commands.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\n/// @title Commands\n/// @notice Command Flags used to decode commands\nlibrary Commands {\n    // Masks to extract certain bits of commands\n    bytes1 internal constant FLAG_ALLOW_REVERT = 0x80;\n    bytes1 internal constant COMMAND_TYPE_MASK = 0x3f;\n\n    // Command Types. Maximum supported command at this moment is 0x3f.\n\n    // Command Types where value<0x08, executed in the first nested-if block\n    uint256 constant V3_SWAP_EXACT_IN = 0x00;\n    uint256 constant V3_SWAP_EXACT_OUT = 0x01;\n    uint256 constant PERMIT2_TRANSFER_FROM = 0x02;\n    uint256 constant PERMIT2_PERMIT_BATCH = 0x03;\n    uint256 constant SWEEP = 0x04;\n    uint256 constant TRANSFER = 0x05;\n    uint256 constant PAY_PORTION = 0x06;\n    // COMMAND_PLACEHOLDER = 0x07;\n\n    // The commands are executed in nested if blocks to minimise gas consumption\n    // The following constant defines one of the boundaries where the if blocks split commands\n    uint256 constant FIRST_IF_BOUNDARY = 0x08;\n\n    // Command Types where 0x08<=value<=0x0f, executed in the second nested-if block\n    uint256 constant V2_SWAP_EXACT_IN = 0x08;\n    uint256 constant V2_SWAP_EXACT_OUT = 0x09;\n    uint256 constant PERMIT2_PERMIT = 0x0a;\n    uint256 constant WRAP_ETH = 0x0b;\n    uint256 constant UNWRAP_WETH = 0x0c;\n    uint256 constant PERMIT2_TRANSFER_FROM_BATCH = 0x0d;\n    uint256 constant BALANCE_CHECK_ERC20 = 0x0e;\n    // COMMAND_PLACEHOLDER = 0x0f;\n\n    // The commands are executed in nested if blocks to minimise gas consumption\n    // The following constant defines one of the boundaries where the if blocks split commands\n    uint256 constant SECOND_IF_BOUNDARY = 0x10;\n\n    // Command Types where 0x10<=value<0x18, executed in the third nested-if block\n    uint256 constant SEAPORT_V1_5 = 0x10;\n    uint256 constant LOOKS_RARE_V2 = 0x11;\n    uint256 constant NFTX = 0x12;\n    uint256 constant CRYPTOPUNKS = 0x13;\n    // 0x14;\n    uint256 constant OWNER_CHECK_721 = 0x15;\n    uint256 constant OWNER_CHECK_1155 = 0x16;\n    uint256 constant SWEEP_ERC721 = 0x17;\n\n    // The commands are executed in nested if blocks to minimise gas consumption\n    // The following constant defines one of the boundaries where the if blocks split commands\n    uint256 constant THIRD_IF_BOUNDARY = 0x18;\n\n    // Command Types where 0x18<=value<=0x1f, executed in the final nested-if block\n    uint256 constant X2Y2_721 = 0x18;\n    uint256 constant SUDOSWAP = 0x19;\n    uint256 constant NFT20 = 0x1a;\n    uint256 constant X2Y2_1155 = 0x1b;\n    uint256 constant FOUNDATION = 0x1c;\n    uint256 constant SWEEP_ERC1155 = 0x1d;\n    uint256 constant ELEMENT_MARKET = 0x1e;\n    // COMMAND_PLACEHOLDER = 0x1f;\n\n    // The commands are executed in nested if blocks to minimise gas consumption\n    // The following constant defines one of the boundaries where the if blocks split commands\n    uint256 constant FOURTH_IF_BOUNDARY = 0x20;\n\n    // Command Types where 0x20<=value\n    uint256 constant SEAPORT_V1_4 = 0x20;\n    uint256 constant EXECUTE_SUB_PLAN = 0x21;\n    uint256 constant APPROVE_ERC20 = 0x22;\n    // COMMAND_PLACEHOLDER for 0x23 to 0x3f (all unused)\n}\n'}, 'contracts/interfaces/IUniversalRouter.sol': {'content': ""// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport {IERC721Receiver} from '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\nimport {IERC1155Receiver} from '@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol';\nimport {IRewardsCollector} from './IRewardsCollector.sol';\n\ninterface IUniversalRouter is IRewardsCollector, IERC721Receiver, IERC1155Receiver {\n    /// @notice Thrown when a required command has failed\n    error ExecutionFailed(uint256 commandIndex, bytes message);\n\n    /// @notice Thrown when attempting to send ETH directly to the contract\n    error ETHNotAccepted();\n\n    /// @notice Thrown when executing commands with an expired deadline\n    error TransactionDeadlinePassed();\n\n    /// @notice Thrown when attempting to execute commands and an incorrect number of inputs are provided\n    error LengthMismatch();\n\n    /// @notice Executes encoded commands along with provided inputs. Reverts if deadline has expired.\n    /// @param commands A set of concatenated commands, each 1 byte in length\n    /// @param inputs An array of byte strings containing abi encoded inputs for each command\n    /// @param deadline The deadline by which the transaction must be executed\n    function execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline) external payable;\n}\n""}, 'contracts/modules/uniswap/v2/V2SwapRouter.sol': {'content': ""// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport {IUniswapV2Pair} from '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\nimport {UniswapV2Library} from './UniswapV2Library.sol';\nimport {RouterImmutables} from '../../../base/RouterImmutables.sol';\nimport {Payments} from '../../Payments.sol';\nimport {Permit2Payments} from '../../Permit2Payments.sol';\nimport {Constants} from '../../../libraries/Constants.sol';\nimport {ERC20} from 'solmate/src/tokens/ERC20.sol';\n\n/// @title Router for Uniswap v2 Trades\nabstract contract V2SwapRouter is RouterImmutables, Permit2Payments {\n    error V2TooLittleReceived();\n    error V2TooMuchRequested();\n    error V2InvalidPath();\n\n    function _v2Swap(address[] calldata path, address recipient, address pair) private {\n        unchecked {\n            if (path.length < 2) revert V2InvalidPath();\n\n            // cached to save on duplicate operations\n            (address token0,) = UniswapV2Library.sortTokens(path[0], path[1]);\n            uint256 finalPairIndex = path.length - 1;\n            uint256 penultimatePairIndex = finalPairIndex - 1;\n            for (uint256 i; i < finalPairIndex; i++) {\n                (address input, address output) = (path[i], path[i + 1]);\n                (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n                (uint256 reserveInput, uint256 reserveOutput) =\n                    input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                uint256 amountInput = ERC20(input).balanceOf(pair) - reserveInput;\n                uint256 amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n                (uint256 amount0Out, uint256 amount1Out) =\n                    input == token0 ? (uint256(0), amountOutput) : (amountOutput, uint256(0));\n                address nextPair;\n                (nextPair, token0) = i < penultimatePairIndex\n                    ? UniswapV2Library.pairAndToken0For(\n                        UNISWAP_V2_FACTORY, UNISWAP_V2_PAIR_INIT_CODE_HASH, output, path[i + 2]\n                    )\n                    : (recipient, address(0));\n                IUniswapV2Pair(pair).swap(amount0Out, amount1Out, nextPair, new bytes(0));\n                pair = nextPair;\n            }\n        }\n    }\n\n    /// @notice Performs a Uniswap v2 exact input swap\n    /// @param recipient The recipient of the output tokens\n    /// @param amountIn The amount of input tokens for the trade\n    /// @param amountOutMinimum The minimum desired amount of output tokens\n    /// @param path The path of the trade as an array of token addresses\n    /// @param payer The address that will be paying the input\n    function v2SwapExactInput(\n        address recipient,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        address[] calldata path,\n        address payer\n    ) internal {\n        address firstPair =\n            UniswapV2Library.pairFor(UNISWAP_V2_FACTORY, UNISWAP_V2_PAIR_INIT_CODE_HASH, path[0], path[1]);\n        if (\n            amountIn != Constants.ALREADY_PAID // amountIn of 0 to signal that the pair already has the tokens\n        ) {\n            payOrPermit2Transfer(path[0], payer, firstPair, amountIn);\n        }\n\n        ERC20 tokenOut = ERC20(path[path.length - 1]);\n        uint256 balanceBefore = tokenOut.balanceOf(recipient);\n\n        _v2Swap(path, recipient, firstPair);\n\n        uint256 amountOut = tokenOut.balanceOf(recipient) - balanceBefore;\n        if (amountOut < amountOutMinimum) revert V2TooLittleReceived();\n    }\n\n    /// @notice Performs a Uniswap v2 exact output swap\n    /// @param recipient The recipient of the output tokens\n    /// @param amountOut The amount of output tokens to receive for the trade\n    /// @param amountInMaximum The maximum desired amount of input tokens\n    /// @param path The path of the trade as an array of token addresses\n    /// @param payer The address that will be paying the input\n    function v2SwapExactOutput(\n        address recipient,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address[] calldata path,\n        address payer\n    ) internal {\n        (uint256 amountIn, address firstPair) =\n            UniswapV2Library.getAmountInMultihop(UNISWAP_V2_FACTORY, UNISWAP_V2_PAIR_INIT_CODE_HASH, amountOut, path);\n        if (amountIn > amountInMaximum) revert V2TooMuchRequested();\n\n        payOrPermit2Transfer(path[0], payer, firstPair, amountIn);\n        _v2Swap(path, recipient, firstPair);\n    }\n}\n""}, 'contracts/modules/uniswap/v3/V3SwapRouter.sol': {'content': ""// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport {V3Path} from './V3Path.sol';\nimport {BytesLib} from './BytesLib.sol';\nimport {SafeCast} from '@uniswap/v3-core/contracts/libraries/SafeCast.sol';\nimport {IUniswapV3Pool} from '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\nimport {IUniswapV3SwapCallback} from '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\nimport {Constants} from '../../../libraries/Constants.sol';\nimport {RouterImmutables} from '../../../base/RouterImmutables.sol';\nimport {Permit2Payments} from '../../Permit2Payments.sol';\nimport {Constants} from '../../../libraries/Constants.sol';\nimport {ERC20} from 'solmate/src/tokens/ERC20.sol';\n\n/// @title Router for Uniswap v3 Trades\nabstract contract V3SwapRouter is RouterImmutables, Permit2Payments, IUniswapV3SwapCallback {\n    using V3Path for bytes;\n    using BytesLib for bytes;\n    using SafeCast for uint256;\n\n    error V3InvalidSwap();\n    error V3TooLittleReceived();\n    error V3TooMuchRequested();\n    error V3InvalidAmountOut();\n    error V3InvalidCaller();\n\n    /// @dev Used as the placeholder value for maxAmountIn, because the computed amount in for an exact output swap\n    /// can never actually be this value\n    uint256 private constant DEFAULT_MAX_AMOUNT_IN = type(uint256).max;\n\n    /// @dev Transient storage variable used for checking slippage\n    uint256 private maxAmountInCached = DEFAULT_MAX_AMOUNT_IN;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external {\n        if (amount0Delta <= 0 && amount1Delta <= 0) revert V3InvalidSwap(); // swaps entirely within 0-liquidity regions are not supported\n        (, address payer) = abi.decode(data, (bytes, address));\n        bytes calldata path = data.toBytes(0);\n\n        // because exact output swaps are executed in reverse order, in this case tokenOut is actually tokenIn\n        (address tokenIn, uint24 fee, address tokenOut) = path.decodeFirstPool();\n\n        if (computePoolAddress(tokenIn, tokenOut, fee) != msg.sender) revert V3InvalidCaller();\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0 ? (tokenIn < tokenOut, uint256(amount0Delta)) : (tokenOut < tokenIn, uint256(amount1Delta));\n\n        if (isExactInput) {\n            // Pay the pool (msg.sender)\n            payOrPermit2Transfer(tokenIn, payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (path.hasMultiplePools()) {\n                // this is an intermediate step so the payer is actually this contract\n                path = path.skipToken();\n                _swap(-amountToPay.toInt256(), msg.sender, path, payer, false);\n            } else {\n                if (amountToPay > maxAmountInCached) revert V3TooMuchRequested();\n                // note that because exact output swaps are executed in reverse order, tokenOut is actually tokenIn\n                payOrPermit2Transfer(tokenOut, payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    /// @notice Performs a Uniswap v3 exact input swap\n    /// @param recipient The recipient of the output tokens\n    /// @param amountIn The amount of input tokens for the trade\n    /// @param amountOutMinimum The minimum desired amount of output tokens\n    /// @param path The path of the trade as a bytes string\n    /// @param payer The address that will be paying the input\n    function v3SwapExactInput(\n        address recipient,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        bytes calldata path,\n        address payer\n    ) internal {\n        // use amountIn == Constants.CONTRACT_BALANCE as a flag to swap the entire balance of the contract\n        if (amountIn == Constants.CONTRACT_BALANCE) {\n            address tokenIn = path.decodeFirstToken();\n            amountIn = ERC20(tokenIn).balanceOf(address(this));\n        }\n\n        uint256 amountOut;\n        while (true) {\n            bool hasMultiplePools = path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            (int256 amount0Delta, int256 amount1Delta, bool zeroForOne) = _swap(\n                amountIn.toInt256(),\n                hasMultiplePools ? address(this) : recipient, // for intermediate swaps, this contract custodies\n                path.getFirstPool(), // only the first pool is needed\n                payer, // for intermediate swaps, this contract custodies\n                true\n            );\n\n            amountIn = uint256(-(zeroForOne ? amount1Delta : amount0Delta));\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this);\n                path = path.skipToken();\n            } else {\n                amountOut = amountIn;\n                break;\n            }\n        }\n\n        if (amountOut < amountOutMinimum) revert V3TooLittleReceived();\n    }\n\n    /// @notice Performs a Uniswap v3 exact output swap\n    /// @param recipient The recipient of the output tokens\n    /// @param amountOut The amount of output tokens to receive for the trade\n    /// @param amountInMaximum The maximum desired amount of input tokens\n    /// @param path The path of the trade as a bytes string\n    /// @param payer The address that will be paying the input\n    function v3SwapExactOutput(\n        address recipient,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        bytes calldata path,\n        address payer\n    ) internal {\n        maxAmountInCached = amountInMaximum;\n        (int256 amount0Delta, int256 amount1Delta, bool zeroForOne) =\n            _swap(-amountOut.toInt256(), recipient, path, payer, false);\n\n        uint256 amountOutReceived = zeroForOne ? uint256(-amount1Delta) : uint256(-amount0Delta);\n\n        if (amountOutReceived != amountOut) revert V3InvalidAmountOut();\n\n        maxAmountInCached = DEFAULT_MAX_AMOUNT_IN;\n    }\n\n    /// @dev Performs a single swap for both exactIn and exactOut\n    /// For exactIn, `amount` is `amountIn`. For exactOut, `amount` is `-amountOut`\n    function _swap(int256 amount, address recipient, bytes calldata path, address payer, bool isExactIn)\n        private\n        returns (int256 amount0Delta, int256 amount1Delta, bool zeroForOne)\n    {\n        (address tokenIn, uint24 fee, address tokenOut) = path.decodeFirstPool();\n\n        zeroForOne = isExactIn ? tokenIn < tokenOut : tokenOut < tokenIn;\n\n        (amount0Delta, amount1Delta) = IUniswapV3Pool(computePoolAddress(tokenIn, tokenOut, fee)).swap(\n            recipient,\n            zeroForOne,\n            amount,\n            (zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1),\n            abi.encode(path, payer)\n        );\n    }\n\n    function computePoolAddress(address tokenA, address tokenB, uint24 fee) private view returns (address pool) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex'ff',\n                            UNISWAP_V3_FACTORY,\n                            keccak256(abi.encode(tokenA, tokenB, fee)),\n                            UNISWAP_V3_POOL_INIT_CODE_HASH\n                        )\n                    )\n                )\n            )\n        );\n    }\n}\n""}, 'contracts/modules/uniswap/v3/BytesLib.sol': {'content': ""// SPDX-License-Identifier: GPL-3.0-or-later\n\n/// @title Library for Bytes Manipulation\npragma solidity ^0.8.0;\n\nimport {Constants} from '../../../libraries/Constants.sol';\n\nlibrary BytesLib {\n    error SliceOutOfBounds();\n\n    /// @notice Returns the address starting at byte 0\n    /// @dev length and overflow checks must be carried out before calling\n    /// @param _bytes The input bytes string to slice\n    /// @return _address The address starting at byte 0\n    function toAddress(bytes calldata _bytes) internal pure returns (address _address) {\n        if (_bytes.length < Constants.ADDR_SIZE) revert SliceOutOfBounds();\n        assembly {\n            _address := shr(96, calldataload(_bytes.offset))\n        }\n    }\n\n    /// @notice Returns the pool details starting at byte 0\n    /// @dev length and overflow checks must be carried out before calling\n    /// @param _bytes The input bytes string to slice\n    /// @return token0 The address at byte 0\n    /// @return fee The uint24 starting at byte 20\n    /// @return token1 The address at byte 23\n    function toPool(bytes calldata _bytes) internal pure returns (address token0, uint24 fee, address token1) {\n        if (_bytes.length < Constants.V3_POP_OFFSET) revert SliceOutOfBounds();\n        assembly {\n            let firstWord := calldataload(_bytes.offset)\n            token0 := shr(96, firstWord)\n            fee := and(shr(72, firstWord), 0xffffff)\n            token1 := shr(96, calldataload(add(_bytes.offset, 23)))\n        }\n    }\n\n    /// @notice Decode the `_arg`-th element in `_bytes` as a dynamic array\n    /// @dev The decoding of `length` and `offset` is universal,\n    /// whereas the type declaration of `res` instructs the compiler how to read it.\n    /// @param _bytes The input bytes string to slice\n    /// @param _arg The index of the argument to extract\n    /// @return length Length of the array\n    /// @return offset Pointer to the data part of the array\n    function toLengthOffset(bytes calldata _bytes, uint256 _arg)\n        internal\n        pure\n        returns (uint256 length, uint256 offset)\n    {\n        uint256 relativeOffset;\n        assembly {\n            // The offset of the `_arg`-th element is `32 * arg`, which stores the offset of the length pointer.\n            // shl(5, x) is equivalent to mul(32, x)\n            let lengthPtr := add(_bytes.offset, calldataload(add(_bytes.offset, shl(5, _arg))))\n            length := calldataload(lengthPtr)\n            offset := add(lengthPtr, 0x20)\n            relativeOffset := sub(offset, _bytes.offset)\n        }\n        if (_bytes.length < length + relativeOffset) revert SliceOutOfBounds();\n    }\n\n    /// @notice Decode the `_arg`-th element in `_bytes` as `bytes`\n    /// @param _bytes The input bytes string to extract a bytes string from\n    /// @param _arg The index of the argument to extract\n    function toBytes(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n\n    /// @notice Decode the `_arg`-th element in `_bytes` as `address[]`\n    /// @param _bytes The input bytes string to extract an address array from\n    /// @param _arg The index of the argument to extract\n    function toAddressArray(bytes calldata _bytes, uint256 _arg) internal pure returns (address[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n\n    /// @notice Decode the `_arg`-th element in `_bytes` as `bytes[]`\n    /// @param _bytes The input bytes string to extract a bytes array from\n    /// @param _arg The index of the argument to extract\n    function toBytesArray(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n}\n""}, 'contracts/modules/Payments.sol': {'content': ""// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport {Constants} from '../libraries/Constants.sol';\nimport {RouterImmutables} from '../base/RouterImmutables.sol';\nimport {SafeTransferLib} from 'solmate/src/utils/SafeTransferLib.sol';\nimport {ERC20} from 'solmate/src/tokens/ERC20.sol';\nimport {ERC721} from 'solmate/src/tokens/ERC721.sol';\nimport {ERC1155} from 'solmate/src/tokens/ERC1155.sol';\n\n/// @title Payments contract\n/// @notice Performs various operations around the payment of ETH and tokens\nabstract contract Payments is RouterImmutables {\n    using SafeTransferLib for ERC20;\n    using SafeTransferLib for address;\n\n    error InsufficientToken();\n    error InsufficientETH();\n    error InvalidBips();\n    error InvalidSpender();\n\n    uint256 internal constant FEE_BIPS_BASE = 10_000;\n\n    /// @notice Pays an amount of ETH or ERC20 to a recipient\n    /// @param token The token to pay (can be ETH using Constants.ETH)\n    /// @param recipient The address that will receive the payment\n    /// @param value The amount to pay\n    function pay(address token, address recipient, uint256 value) internal {\n        if (token == Constants.ETH) {\n            recipient.safeTransferETH(value);\n        } else {\n            if (value == Constants.CONTRACT_BALANCE) {\n                value = ERC20(token).balanceOf(address(this));\n            }\n\n            ERC20(token).safeTransfer(recipient, value);\n        }\n    }\n\n    /// @notice Approves a protocol to spend ERC20s in the router\n    /// @param token The token to approve\n    /// @param spender Which protocol to approve\n    function approveERC20(ERC20 token, Spenders spender) internal {\n        // check spender is one of our approved spenders\n        address spenderAddress;\n        /// @dev use 0 = Opensea Conduit for both Seaport v1.4 and v1.5\n        if (spender == Spenders.OSConduit) spenderAddress = OPENSEA_CONDUIT;\n        else if (spender == Spenders.Sudoswap) spenderAddress = SUDOSWAP;\n        else revert InvalidSpender();\n\n        // set approval\n        token.safeApprove(spenderAddress, type(uint256).max);\n    }\n\n    /// @notice Pays a proportion of the contract's ETH or ERC20 to a recipient\n    /// @param token The token to pay (can be ETH using Constants.ETH)\n    /// @param recipient The address that will receive payment\n    /// @param bips Portion in bips of whole balance of the contract\n    function payPortion(address token, address recipient, uint256 bips) internal {\n        if (bips == 0 || bips > FEE_BIPS_BASE) revert InvalidBips();\n        if (token == Constants.ETH) {\n            uint256 balance = address(this).balance;\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            recipient.safeTransferETH(amount);\n        } else {\n            uint256 balance = ERC20(token).balanceOf(address(this));\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            ERC20(token).safeTransfer(recipient, amount);\n        }\n    }\n\n    /// @notice Sweeps all of the contract's ERC20 or ETH to an address\n    /// @param token The token to sweep (can be ETH using Constants.ETH)\n    /// @param recipient The address that will receive payment\n    /// @param amountMinimum The minimum desired amount\n    function sweep(address token, address recipient, uint256 amountMinimum) internal {\n        uint256 balance;\n        if (token == Constants.ETH) {\n            balance = address(this).balance;\n            if (balance < amountMinimum) revert InsufficientETH();\n            if (balance > 0) recipient.safeTransferETH(balance);\n        } else {\n            balance = ERC20(token).balanceOf(address(this));\n            if (balance < amountMinimum) revert InsufficientToken();\n            if (balance > 0) ERC20(token).safeTransfer(recipient, balance);\n        }\n    }\n\n    /// @notice Sweeps an ERC721 to a recipient from the contract\n    /// @param token The ERC721 token to sweep\n    /// @param recipient The address that will receive payment\n    /// @param id The ID of the ERC721 to sweep\n    function sweepERC721(address token, address recipient, uint256 id) internal {\n        ERC721(token).safeTransferFrom(address(this), recipient, id);\n    }\n\n    /// @notice Sweeps all of the contract's ERC1155 to an address\n    /// @param token The ERC1155 token to sweep\n    /// @param recipient The address that will receive payment\n    /// @param id The ID of the ERC1155 to sweep\n    /// @param amountMinimum The minimum desired amount\n    function sweepERC1155(address token, address recipient, uint256 id, uint256 amountMinimum) internal {\n        uint256 balance = ERC1155(token).balanceOf(address(this), id);\n        if (balance < amountMinimum) revert InsufficientToken();\n        ERC1155(token).safeTransferFrom(address(this), recipient, id, balance, bytes(''));\n    }\n\n    /// @notice Wraps an amount of ETH into WETH\n    /// @param recipient The recipient of the WETH\n    /// @param amount The amount to wrap (can be CONTRACT_BALANCE)\n    function wrapETH(address recipient, uint256 amount) internal {\n        if (amount == Constants.CONTRACT_BALANCE) {\n            amount = address(this).balance;\n        } else if (amount > address(this).balance) {\n            revert InsufficientETH();\n        }\n        if (amount > 0) {\n            WETH9.deposit{value: amount}();\n            if (recipient != address(this)) {\n                WETH9.transfer(recipient, amount);\n            }\n        }\n    }\n\n    /// @notice Unwraps all of the contract's WETH into ETH\n    /// @param recipient The recipient of the ETH\n    /// @param amountMinimum The minimum amount of ETH desired\n    function unwrapWETH9(address recipient, uint256 amountMinimum) internal {\n        uint256 value = WETH9.balanceOf(address(this));\n        if (value < amountMinimum) {\n            revert InsufficientETH();\n        }\n        if (value > 0) {\n            WETH9.withdraw(value);\n            if (recipient != address(this)) {\n                recipient.safeTransferETH(value);\n            }\n        }\n    }\n}\n""}, 'contracts/base/Callbacks.sol': {'content': ""// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport {IERC721Receiver} from '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\nimport {IERC1155Receiver} from '@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol';\nimport {IERC165} from '@openzeppelin/contracts/utils/introspection/IERC165.sol';\n\n/// @title ERC Callback Support\n/// @notice Implements various functions introduced by a variety of ERCs for security reasons.\n/// All are called by external contracts to ensure that this contract safely supports the ERC in question.\ncontract Callbacks is IERC721Receiver, IERC1155Receiver {\n    function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata)\n        external\n        pure\n        returns (bytes4)\n    {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || interfaceId == type(IERC721Receiver).interfaceId\n            || interfaceId == type(IERC165).interfaceId;\n    }\n}\n""}, 'contracts/base/LockAndMsgSender.sol': {'content': ""// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport {Constants} from '../libraries/Constants.sol';\n\ncontract LockAndMsgSender {\n    error ContractLocked();\n\n    address internal constant NOT_LOCKED_FLAG = address(1);\n    address internal lockedBy = NOT_LOCKED_FLAG;\n\n    modifier isNotLocked() {\n        if (msg.sender != address(this)) {\n            if (lockedBy != NOT_LOCKED_FLAG) revert ContractLocked();\n            lockedBy = msg.sender;\n            _;\n            lockedBy = NOT_LOCKED_FLAG;\n        } else {\n            _;\n        }\n    }\n\n    /// @notice Calculates the recipient address for a command\n    /// @param recipient The recipient or recipient-flag for the command\n    /// @return output The resultant recipient for the command\n    function map(address recipient) internal view returns (address) {\n        if (recipient == Constants.MSG_SENDER) {\n            return lockedBy;\n        } else if (recipient == Constants.ADDRESS_THIS) {\n            return address(this);\n        } else {\n            return recipient;\n        }\n    }\n}\n""}, 'lib/solmate/src/tokens/ERC721.sol': {'content': '// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), ""NOT_MINTED"");\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), ""ZERO_ADDRESS"");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], ""NOT_AUTHORIZED"");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], ""WRONG_FROM"");\n\n        require(to != address(0), ""INVALID_RECIPIENT"");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            ""NOT_AUTHORIZED""\n        );\n\n        // Underflow of the sender\'s balance is impossible because we check for\n        // ownership above and the recipient\'s balance can\'t realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, """") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            ""UNSAFE_RECIPIENT""\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            ""UNSAFE_RECIPIENT""\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), ""INVALID_RECIPIENT"");\n\n        require(_ownerOf[id] == address(0), ""ALREADY_MINTED"");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), ""NOT_MINTED"");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner]--;\n        }\n\n        delete _ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, """") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            ""UNSAFE_RECIPIENT""\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            ""UNSAFE_RECIPIENT""\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n'}, 'lib/solmate/src/tokens/ERC1155.sol': {'content': '// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    event URI(string value, uint256 indexed id);\n\n    /*//////////////////////////////////////////////////////////////\n                             ERC1155 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                             METADATA LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function uri(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC1155 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], ""NOT_AUTHORIZED"");\n\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, from, to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            ""UNSAFE_RECIPIENT""\n        );\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, ""LENGTH_MISMATCH"");\n\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], ""NOT_AUTHORIZED"");\n\n        // Storing these outside the loop saves ~15 gas per iteration.\n        uint256 id;\n        uint256 amount;\n\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n\n            // An array can\'t have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            ""UNSAFE_RECIPIENT""\n        );\n    }\n\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, ""LENGTH_MISMATCH"");\n\n        balances = new uint256[](owners.length);\n\n        // Unchecked because the only math done is incrementing\n        // the array index counter which cannot possibly overflow.\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            ""UNSAFE_RECIPIENT""\n        );\n    }\n\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, ""LENGTH_MISMATCH"");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n\n            // An array can\'t have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            ""UNSAFE_RECIPIENT""\n        );\n    }\n\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, ""LENGTH_MISMATCH"");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n\n            // An array can\'t have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}\n'}, 'lib/solmate/src/tokens/ERC20.sol': {'content': '// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can\'t exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can\'t exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, ""PERMIT_DEADLINE_EXPIRED"");\n\n        // Unchecked because the only math done is incrementing\n        // the owner\'s nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        ""\\x19\\x01"",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    ""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)""\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, ""INVALID_SIGNER"");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""),\n                    keccak256(bytes(name)),\n                    keccak256(""1""),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can\'t exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user\'s balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n'}, 'lib/permit2/src/interfaces/IAllowanceTransfer.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/// @title AllowanceTransfer\n/// @notice Handles ERC20 token permissions through signature based allowance setting and ERC20 token transfers by checking allowed amounts\n/// @dev Requires user\'s token approval on the Permit2 contract\ninterface IAllowanceTransfer {\n    /// @notice Thrown when an allowance on a token has expired.\n    /// @param deadline The timestamp at which the allowed amount is no longer valid\n    error AllowanceExpired(uint256 deadline);\n\n    /// @notice Thrown when an allowance on a token has been depleted.\n    /// @param amount The maximum amount allowed\n    error InsufficientAllowance(uint256 amount);\n\n    /// @notice Thrown when too many nonces are invalidated.\n    error ExcessiveInvalidation();\n\n    /// @notice Emits an event when the owner successfully invalidates an ordered nonce.\n    event NonceInvalidation(\n        address indexed owner, address indexed token, address indexed spender, uint48 newNonce, uint48 oldNonce\n    );\n\n    /// @notice Emits an event when the owner successfully sets permissions on a token for the spender.\n    event Approval(\n        address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration\n    );\n\n    /// @notice Emits an event when the owner successfully sets permissions using a permit signature on a token for the spender.\n    event Permit(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration,\n        uint48 nonce\n    );\n\n    /// @notice Emits an event when the owner sets the allowance back to 0 with the lockdown function.\n    event Lockdown(address indexed owner, address token, address spender);\n\n    /// @notice The permit data for a token\n    struct PermitDetails {\n        // ERC20 token address\n        address token;\n        // the maximum amount allowed to spend\n        uint160 amount;\n        // timestamp at which a spender\'s token allowances become invalid\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n\n    /// @notice The permit message signed for a single token allownce\n    struct PermitSingle {\n        // the permit data for a single token alownce\n        PermitDetails details;\n        // address permissioned on the allowed tokens\n        address spender;\n        // deadline on the permit signature\n        uint256 sigDeadline;\n    }\n\n    /// @notice The permit message signed for multiple token allowances\n    struct PermitBatch {\n        // the permit data for multiple token allowances\n        PermitDetails[] details;\n        // address permissioned on the allowed tokens\n        address spender;\n        // deadline on the permit signature\n        uint256 sigDeadline;\n    }\n\n    /// @notice The saved permissions\n    /// @dev This info is saved per owner, per token, per spender and all signed over in the permit message\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\n    struct PackedAllowance {\n        // amount allowed\n        uint160 amount;\n        // permission expiry\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n\n    /// @notice A token spender pair.\n    struct TokenSpenderPair {\n        // the token the spender is approved\n        address token;\n        // the spender address\n        address spender;\n    }\n\n    /// @notice Details for a token transfer.\n    struct AllowanceTransferDetails {\n        // the owner of the token\n        address from;\n        // the recipient of the token\n        address to;\n        // the amount of the token\n        uint160 amount;\n        // the token to be transferred\n        address token;\n    }\n\n    /// @notice A mapping from owner address to token address to spender address to PackedAllowance struct, which contains details and conditions of the approval.\n    /// @notice The mapping is indexed in the above order see: allowance[ownerAddress][tokenAddress][spenderAddress]\n    /// @dev The packed slot holds the allowed amount, expiration at which the allowed amount is no longer valid, and current nonce thats updated on any signature based approvals.\n    function allowance(address, address, address) external view returns (uint160, uint48, uint48);\n\n    /// @notice Approves the spender to use up to amount of the specified token up until the expiration\n    /// @param token The token to approve\n    /// @param spender The spender address to approve\n    /// @param amount The approved amount of the token\n    /// @param expiration The timestamp at which the approval is no longer valid\n    /// @dev The packed allowance also holds a nonce, which will stay unchanged in approve\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n\n    /// @notice Permit a spender to a given amount of the owners token via the owner\'s EIP-712 signature\n    /// @dev May fail if the owner\'s nonce was invalidated in-flight by invalidateNonce\n    /// @param owner The owner of the tokens being approved\n    /// @param permitSingle Data signed over by the owner specifying the terms of approval\n    /// @param signature The owner\'s signature over the permit data\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n\n    /// @notice Permit a spender to the signed amounts of the owners tokens via the owner\'s EIP-712 signature\n    /// @dev May fail if the owner\'s nonce was invalidated in-flight by invalidateNonce\n    /// @param owner The owner of the tokens being approved\n    /// @param permitBatch Data signed over by the owner specifying the terms of approval\n    /// @param signature The owner\'s signature over the permit data\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\n\n    /// @notice Transfer approved tokens from one address to another\n    /// @param from The address to transfer from\n    /// @param to The address of the recipient\n    /// @param amount The amount of the token to transfer\n    /// @param token The token address to transfer\n    /// @dev Requires the from address to have approved at least the desired amount\n    /// of tokens to msg.sender.\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n\n    /// @notice Transfer approved tokens in a batch\n    /// @param transferDetails Array of owners, recipients, amounts, and tokens for the transfers\n    /// @dev Requires the from addresses to have approved at least the desired amount\n    /// of tokens to msg.sender.\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\n\n    /// @notice Enables performing a ""lockdown"" of the sender\'s Permit2 identity\n    /// by batch revoking approvals\n    /// @param approvals Array of approvals to revoke.\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\n\n    /// @notice Invalidate nonces for a given (token, spender) pair\n    /// @param token The token to invalidate nonces for\n    /// @param spender The spender to invalidate nonces for\n    /// @param newNonce The new nonce to set. Invalidates all nonces less than it.\n    /// @dev Can\'t invalidate more than 2**16 nonces per transaction.\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\n}\n'}, 'contracts/interfaces/external/ICryptoPunksMarket.sol': {'content': '// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\n/// @title Interface for CryptoPunksMarket\ninterface ICryptoPunksMarket {\n    /// @notice Buy a cryptopunk\n    function buyPunk(uint256 punkIndex) external payable;\n\n    /// @notice Transfer a cryptopunk to another address\n    function transferPunk(address to, uint256 punkIndex) external;\n}\n'}, 'lib/solmate/src/utils/SafeTransferLib.sol': {'content': '// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from ""../tokens/ERC20.sol"";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, ""ETH_TRANSFER_FAILED"");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the ""from"" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the ""to"" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the ""amount"" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can\'t just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, ""TRANSFER_FROM_FAILED"");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the ""to"" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the ""amount"" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can\'t just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, ""TRANSFER_FAILED"");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the ""to"" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the ""amount"" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can\'t just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, ""APPROVE_FAILED"");\n    }\n}\n'}, 'contracts/interfaces/IRewardsCollector.sol': {'content': ""// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.15;\n\nimport {ERC20} from 'solmate/src/tokens/ERC20.sol';\n\n/// @title LooksRare Rewards Collector\n/// @notice Implements a permissionless call to fetch LooksRare rewards earned by Universal Router users\n/// and transfers them to an external rewards distributor contract\ninterface IRewardsCollector {\n    /// @notice Fetches users' LooksRare rewards and sends them to the distributor contract\n    /// @param looksRareClaim The data required by LooksRare to claim reward tokens\n    function collectRewards(bytes calldata looksRareClaim) external;\n}\n""}, 'contracts/interfaces/external/IWETH9.sol': {'content': ""// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\n/// @title Interface for WETH9\ninterface IWETH9 is IERC20 {\n    /// @notice Deposit ether to get wrapped ether\n    function deposit() external payable;\n\n    /// @notice Withdraw wrapped ether to get ether\n    function withdraw(uint256) external;\n}\n""}, 'node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n'}, 'node_modules/@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport ""../../utils/introspection/IERC165.sol"";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(""onERC1155Received(address,address,uint256,uint256,bytes)""))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(""onERC1155Received(address,address,uint256,uint256,bytes)""))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(""onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)""))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(""onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)""))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n'}, 'node_modules/@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol': {'content': 'pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n'}, 'contracts/modules/uniswap/v2/UniswapV2Library.sol': {'content': ""// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport {IUniswapV2Pair} from '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\n\n/// @title Uniswap v2 Helper Library\n/// @notice Calculates the recipient address for a command\nlibrary UniswapV2Library {\n    error InvalidReserves();\n    error InvalidPath();\n\n    /// @notice Calculates the v2 address for a pair without making any external calls\n    /// @param factory The address of the v2 factory\n    /// @param initCodeHash The hash of the pair initcode\n    /// @param tokenA One of the tokens in the pair\n    /// @param tokenB The other token in the pair\n    /// @return pair The resultant v2 pair address\n    function pairFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair)\n    {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n\n    /// @notice Calculates the v2 address for a pair and the pair's token0\n    /// @param factory The address of the v2 factory\n    /// @param initCodeHash The hash of the pair initcode\n    /// @param tokenA One of the tokens in the pair\n    /// @param tokenB The other token in the pair\n    /// @return pair The resultant v2 pair address\n    /// @return token0 The token considered token0 in this pair\n    function pairAndToken0For(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair, address token0)\n    {\n        address token1;\n        (token0, token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n\n    /// @notice Calculates the v2 address for a pair assuming the input tokens are pre-sorted\n    /// @param factory The address of the v2 factory\n    /// @param initCodeHash The hash of the pair initcode\n    /// @param token0 The pair's token0\n    /// @param token1 The pair's token1\n    /// @return pair The resultant v2 pair address\n    function pairForPreSorted(address factory, bytes32 initCodeHash, address token0, address token1)\n        private\n        pure\n        returns (address pair)\n    {\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), initCodeHash)\n                    )\n                )\n            )\n        );\n    }\n\n    /// @notice Calculates the v2 address for a pair and fetches the reserves for each token\n    /// @param factory The address of the v2 factory\n    /// @param initCodeHash The hash of the pair initcode\n    /// @param tokenA One of the tokens in the pair\n    /// @param tokenB The other token in the pair\n    /// @return pair The resultant v2 pair address\n    /// @return reserveA The reserves for tokenA\n    /// @return reserveB The reserves for tokenB\n    function pairAndReservesFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        private\n        view\n        returns (address pair, uint256 reserveA, uint256 reserveB)\n    {\n        address token0;\n        (pair, token0) = pairAndToken0For(factory, initCodeHash, tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    /// @notice Given an input asset amount returns the maximum output amount of the other asset\n    /// @param amountIn The token input amount\n    /// @param reserveIn The reserves available of the input token\n    /// @param reserveOut The reserves available of the output token\n    /// @return amountOut The output amount of the output token\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 amountInWithFee = amountIn * 997;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 1000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n\n    /// @notice Returns the input amount needed for a desired output amount in a single-hop trade\n    /// @param amountOut The desired output amount\n    /// @param reserveIn The reserves available of the input token\n    /// @param reserveOut The reserves available of the output token\n    /// @return amountIn The input amount of the input token\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 numerator = reserveIn * amountOut * 1000;\n        uint256 denominator = (reserveOut - amountOut) * 997;\n        amountIn = (numerator / denominator) + 1;\n    }\n\n    /// @notice Returns the input amount needed for a desired output amount in a multi-hop trade\n    /// @param factory The address of the v2 factory\n    /// @param initCodeHash The hash of the pair initcode\n    /// @param amountOut The desired output amount\n    /// @param path The path of the multi-hop trade\n    /// @return amount The input amount of the input token\n    /// @return pair The first pair in the trade\n    function getAmountInMultihop(address factory, bytes32 initCodeHash, uint256 amountOut, address[] memory path)\n        internal\n        view\n        returns (uint256 amount, address pair)\n    {\n        if (path.length < 2) revert InvalidPath();\n        amount = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            uint256 reserveIn;\n            uint256 reserveOut;\n\n            (pair, reserveIn, reserveOut) = pairAndReservesFor(factory, initCodeHash, path[i - 1], path[i]);\n            amount = getAmountIn(amount, reserveIn, reserveOut);\n        }\n    }\n\n    /// @notice Sorts two tokens to return token0 and token1\n    /// @param tokenA The first token to sort\n    /// @param tokenB The other token to sort\n    /// @return token0 The smaller token by address value\n    /// @return token1 The larger token by address value\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }\n}\n""}, 'contracts/modules/Permit2Payments.sol': {'content': ""pragma solidity ^0.8.17;\n\nimport {IAllowanceTransfer} from 'permit2/src/interfaces/IAllowanceTransfer.sol';\nimport {SafeCast160} from 'permit2/src/libraries/SafeCast160.sol';\nimport {Payments} from './Payments.sol';\nimport {Constants} from '../libraries/Constants.sol';\nimport {RouterImmutables} from '../base/RouterImmutables.sol';\n\n/// @title Payments through Permit2\n/// @notice Performs interactions with Permit2 to transfer tokens\nabstract contract Permit2Payments is Payments {\n    using SafeCast160 for uint256;\n\n    error FromAddressIsNotOwner();\n\n    /// @notice Performs a transferFrom on Permit2\n    /// @param token The token to transfer\n    /// @param from The address to transfer from\n    /// @param to The recipient of the transfer\n    /// @param amount The amount to transfer\n    function permit2TransferFrom(address token, address from, address to, uint160 amount) internal {\n        PERMIT2.transferFrom(from, to, amount, token);\n    }\n\n    /// @notice Performs a batch transferFrom on Permit2\n    /// @param batchDetails An array detailing each of the transfers that should occur\n    function permit2TransferFrom(IAllowanceTransfer.AllowanceTransferDetails[] memory batchDetails, address owner)\n        internal\n    {\n        uint256 batchLength = batchDetails.length;\n        for (uint256 i = 0; i < batchLength; ++i) {\n            if (batchDetails[i].from != owner) revert FromAddressIsNotOwner();\n        }\n        PERMIT2.transferFrom(batchDetails);\n    }\n\n    /// @notice Either performs a regular payment or transferFrom on Permit2, depending on the payer address\n    /// @param token The token to transfer\n    /// @param payer The address to pay for the transfer\n    /// @param recipient The recipient of the transfer\n    /// @param amount The amount to transfer\n    function payOrPermit2Transfer(address token, address payer, address recipient, uint256 amount) internal {\n        if (payer == address(this)) pay(token, recipient, amount);\n        else permit2TransferFrom(token, payer, recipient, amount.toUint160());\n    }\n}\n""}, 'contracts/libraries/Constants.sol': {'content': ""// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport {IWETH9} from '../interfaces/external/IWETH9.sol';\n\n/// @title Constant state\n/// @notice Constant state used by the Universal Router\nlibrary Constants {\n    /// @dev Used for identifying cases when this contract's balance of a token is to be used as an input\n    /// This value is equivalent to 1<<255, i.e. a singular 1 in the most significant bit.\n    uint256 internal constant CONTRACT_BALANCE = 0x8000000000000000000000000000000000000000000000000000000000000000;\n\n    /// @dev Used for identifying cases when a v2 pair has already received input tokens\n    uint256 internal constant ALREADY_PAID = 0;\n\n    /// @dev Used as a flag for identifying the transfer of ETH instead of a token\n    address internal constant ETH = address(0);\n\n    /// @dev Used as a flag for identifying that msg.sender should be used, saves gas by sending more 0 bytes\n    address internal constant MSG_SENDER = address(1);\n\n    /// @dev Used as a flag for identifying address(this) should be used, saves gas by sending more 0 bytes\n    address internal constant ADDRESS_THIS = address(2);\n\n    /// @dev The length of the bytes encoded address\n    uint256 internal constant ADDR_SIZE = 20;\n\n    /// @dev The length of the bytes encoded fee\n    uint256 internal constant V3_FEE_SIZE = 3;\n\n    /// @dev The offset of a single token address (20) and pool fee (3)\n    uint256 internal constant NEXT_V3_POOL_OFFSET = ADDR_SIZE + V3_FEE_SIZE;\n\n    /// @dev The offset of an encoded pool key\n    /// Token (20) + Fee (3) + Token (20) = 43\n    uint256 internal constant V3_POP_OFFSET = NEXT_V3_POOL_OFFSET + ADDR_SIZE;\n\n    /// @dev The minimum length of an encoding that contains 2 or more pools\n    uint256 internal constant MULTIPLE_V3_POOLS_MIN_LENGTH = V3_POP_OFFSET + NEXT_V3_POOL_OFFSET;\n}\n""}, 'contracts/modules/uniswap/v3/V3Path.sol': {'content': ""// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.6.0;\n\nimport {BytesLib} from './BytesLib.sol';\nimport {Constants} from '../../../libraries/Constants.sol';\n\n/// @title Functions for manipulating path data for multihop swaps\nlibrary V3Path {\n    using BytesLib for bytes;\n\n    /// @notice Returns true iff the path contains two or more pools\n    /// @param path The encoded swap path\n    /// @return True if path contains two or more pools, otherwise false\n    function hasMultiplePools(bytes calldata path) internal pure returns (bool) {\n        return path.length >= Constants.MULTIPLE_V3_POOLS_MIN_LENGTH;\n    }\n\n    /// @notice Decodes the first pool in path\n    /// @param path The bytes encoded swap path\n    /// @return tokenA The first token of the given pool\n    /// @return fee The fee level of the pool\n    /// @return tokenB The second token of the given pool\n    function decodeFirstPool(bytes calldata path) internal pure returns (address, uint24, address) {\n        return path.toPool();\n    }\n\n    /// @notice Gets the segment corresponding to the first pool in the path\n    /// @param path The bytes encoded swap path\n    /// @return The segment containing all data necessary to target the first pool in the path\n    function getFirstPool(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[:Constants.V3_POP_OFFSET];\n    }\n\n    function decodeFirstToken(bytes calldata path) internal pure returns (address tokenA) {\n        tokenA = path.toAddress();\n    }\n\n    /// @notice Skips a token + fee element\n    /// @param path The swap path\n    function skipToken(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[Constants.NEXT_V3_POOL_OFFSET:];\n    }\n}\n""}, 'node_modules/@uniswap/v3-core/contracts/libraries/SafeCast.sol': {'content': '// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Safe casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeCast {\n    /// @notice Cast a uint256 to a uint160, revert on overflow\n    /// @param y The uint256 to be downcasted\n    /// @return z The downcasted integer, now type uint160\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\n        require((z = uint160(y)) == y);\n    }\n\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\n    /// @param y The int256 to be downcasted\n    /// @return z The downcasted integer, now type int128\n    function toInt128(int256 y) internal pure returns (int128 z) {\n        require((z = int128(y)) == y);\n    }\n\n    /// @notice Cast a uint256 to a int256, revert on overflow\n    /// @param y The uint256 to be casted\n    /// @return z The casted integer, now type int256\n    function toInt256(uint256 y) internal pure returns (int256 z) {\n        require(y < 2**255);\n        z = int256(y);\n    }\n}\n'}, 'node_modules/@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol': {'content': ""// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport './pool/IUniswapV3PoolImmutables.sol';\nimport './pool/IUniswapV3PoolState.sol';\nimport './pool/IUniswapV3PoolDerivedState.sol';\nimport './pool/IUniswapV3PoolActions.sol';\nimport './pool/IUniswapV3PoolOwnerActions.sol';\nimport './pool/IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\n    IUniswapV3PoolImmutables,\n    IUniswapV3PoolState,\n    IUniswapV3PoolDerivedState,\n    IUniswapV3PoolActions,\n    IUniswapV3PoolOwnerActions,\n    IUniswapV3PoolEvents\n{\n\n}\n""}, 'node_modules/@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol': {'content': '// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n'}, 'node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n'}, 'node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol': {'content': ""// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n""}, 'lib/permit2/src/libraries/SafeCast160.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nlibrary SafeCast160 {\n    /// @notice Thrown when a valude greater than type(uint160).max is cast to uint160\n    error UnsafeCast();\n\n    /// @notice Safely casts uint256 to uint160\n    /// @param value The uint256 to be cast\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) revert UnsafeCast();\n        return uint160(value);\n    }\n}\n'}, 'node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol': {'content': ""// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n    /// @return The max amount of liquidity per tick\n    function maxLiquidityPerTick() external view returns (uint128);\n}\n""}, 'node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol': {'content': ""// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// observationIndex The index of the last oracle observation that was written,\n    /// observationCardinality The current maximum number of observations stored in the pool,\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\n    /// @dev Protocol fees will never exceed uint128 max in either token\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper,\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice Returns the information about a position by the position's key\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n    /// @return _liquidity The amount of liquidity in the position,\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    /// @param index The element of the observations array to fetch\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n    /// ago, rather than at a specific index in the array.\n    /// @return blockTimestamp The timestamp of the observation,\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}\n""}, 'node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol': {'content': '// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken.\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}\n'}, 'node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol': {'content': '// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n    /// @notice Sets the initial price for the pool\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n    /// @param recipient The address which should receive the fees collected\n    /// @param tickLower The lower tick of the position for which to collect fees\n    /// @param tickUpper The upper tick of the position for which to collect fees\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n    /// @dev Fees must be collected separately via a call to #collect\n    /// @param tickLower The lower tick of the position for which to burn liquidity\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\n    /// @param amount How much liquidity to burn\n    /// @return amount0 The amount of token0 sent to the recipient\n    /// @return amount1 The amount of token1 sent to the recipient\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n    /// @param recipient The address which will receive the token0 and token1 amounts\n    /// @param amount0 The amount of token0 to send\n    /// @param amount1 The amount of token1 to send\n    /// @param data Any data to be passed through to the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n    /// the input observationCardinalityNext.\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n'}, 'node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol': {'content': ""// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n    /// @notice Set the denominator of the protocol's % share of the fees\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}\n""}, 'node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol': {'content': ""// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n    /// @notice Emitted when liquidity is minted for a given position\n    /// @param sender The address that minted the liquidity\n    /// @param owner The owner of the position and recipient of any minted liquidity\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity minted to the position range\n    /// @param amount0 How much token0 was required for the minted liquidity\n    /// @param amount1 How much token1 was required for the minted liquidity\n    event Mint(\n        address sender,\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when fees are collected by the owner of a position\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n    /// @param owner The owner of the position for which fees are collected\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0 fees collected\n    /// @param amount1 The amount of token1 fees collected\n    event Collect(\n        address indexed owner,\n        address recipient,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    /// @notice Emitted when a position's liquidity is removed\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n    /// @param owner The owner of the position for which liquidity is removed\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity to remove\n    /// @param amount0 The amount of token0 withdrawn\n    /// @param amount1 The amount of token1 withdrawn\n    event Burn(\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the output of the swap\n    /// @param amount0 The delta of the token0 balance of the pool\n    /// @param amount1 The delta of the token1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of price of the pool after the swap\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    /// @notice Emitted by the pool for any flashes of token0/token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the tokens from flash\n    /// @param amount0 The amount of token0 that was flashed\n    /// @param amount1 The amount of token1 that was flashed\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n    event Flash(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 paid0,\n        uint256 paid1\n    );\n\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n    /// just before a mint/swap/burn.\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    /// @notice Emitted when the protocol fee is changed by the pool\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n    /// @param sender The address that collects the protocol fees\n    /// @param recipient The address that receives the collected protocol fees\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n""}}

// File: settings
{'remappings': ['@openzeppelin/=node_modules/@openzeppelin/', '@uniswap/=node_modules/@uniswap/', 'ds-test/=lib/forge-std/lib/ds-test/src/', 'forge-gas-snapshot/=lib/permit2/lib/forge-gas-snapshot/src/', 'forge-std/=lib/forge-std/src/', 'openzeppelin-contracts/=lib/permit2/lib/openzeppelin-contracts/', 'permit2/=lib/permit2/', 'solmate/=lib/solmate/'], 'optimizer': {'enabled': True, 'runs': 1000000}, 'metadata': {'bytecodeHash': 'ipfs'}, 'outputSelection': {'*': {'*': ['evm.bytecode', 'evm.deployedBytecode', 'devdoc', 'userdoc', 'metadata', 'abi']}}, 'evmVersion': 'london', 'viaIR': True, 'libraries': {}}",True
0x73644a48a4f540fa49a8b4d41dba2ded5df3912b,"// File: language
Solidity

// File: sources
{'@openzeppelin/contracts/security/ReentrancyGuard.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to ""entered"", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n'}, '@openzeppelin/contracts/token/ERC20/ERC20.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport ""./IERC20.sol"";\nimport ""./extensions/IERC20Metadata.sol"";\nimport ""../../utils/Context.sol"";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn\'t required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it\'s overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``\'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, ""ERC20: decreased allowance below zero"");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), ""ERC20: transfer from the zero address"");\n        require(to != address(0), ""ERC20: transfer to the zero address"");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, ""ERC20: transfer amount exceeds balance"");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), ""ERC20: mint to the zero address"");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), ""ERC20: burn from the zero address"");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, ""ERC20: burn amount exceeds balance"");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), ""ERC20: approve from the zero address"");\n        require(spender != address(0), ""ERC20: approve to the zero address"");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, ""ERC20: insufficient allowance"");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n'}, '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport ""../IERC20.sol"";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n'}, '@openzeppelin/contracts/token/ERC20/IERC20.sol': {'content': ""// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n""}, '@openzeppelin/contracts/utils/Context.sol': {'content': '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n'}, 'contracts/token/GOOSE.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17;\n\nimport ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";\nimport ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";\n\n/**\n * @title GOOSE\n * @author GOOSE-TEAM\n * @notice Contract to supply GOOSE\n */\ncontract GOOSE is ERC20, ReentrancyGuard {\n    // Replace with your address for testing\n    address public constant PAYMENT_ADDRESS =\n        0x13a5080aF78A4fD65D031bb6d53ECe09a734d943;\n    // Replace with your address for testing\n    address public constant ADD_LIQUIDITY_ADDRESS =\n        0x581b7fDA82923493DC617ECE752cfc2F5f2A407C;\n    uint256 public constant PURCHASE_PRICE = 0.01 ether;\n    uint256 public constant TOKENS_PER_PURCHASE = 50_000_000 * 1e18;\n    uint256 public constant MAX_TOTAL_SUPPLY = 210_000_000_000 * 1e18;\n\n    mapping(address => uint256) public purchaseCount;\n\n    constructor() ERC20(""GOOSE"", ""GOOSE"") {\n        _mint(address(this), (MAX_TOTAL_SUPPLY * 75) / 100);\n        _mint(ADD_LIQUIDITY_ADDRESS, (MAX_TOTAL_SUPPLY * 25) / 100);\n    }\n\n    function purchaseTokens(\n        uint256 numPurchases\n    ) external payable nonReentrant {\n        require(\n            numPurchases > 0 && numPurchases <= 2,\n            ""Invalid number of purchases""\n        );\n        require(\n            msg.value == PURCHASE_PRICE * numPurchases,\n            ""Incorrect ETH amount""\n        );\n        require(\n            purchaseCount[msg.sender] + numPurchases <= 2,\n            ""Purchase limit reached""\n        );\n\n        payable(PAYMENT_ADDRESS).transfer(msg.value);\n\n        purchaseCount[msg.sender] += numPurchases;\n        _transfer(\n            address(this),\n            msg.sender,\n            TOKENS_PER_PURCHASE * numPurchases\n        );\n    }\n}\n'}}

// File: settings
{'optimizer': {'enabled': True, 'runs': 1000}, 'outputSelection': {'*': {'*': ['evm.bytecode', 'evm.deployedBytecode', 'devdoc', 'userdoc', 'metadata', 'abi']}}, 'libraries': {}}",True
0xf0163c18f8d3fc8d5b4ca15e07d0f9f75460335f,"// File: language
Solidity

// File: sources
{'contracts/import.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport ""@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol"";\nimport ""@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol"";\nimport ""@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol"";\nimport ""@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol"";\nimport ""@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol"";\n\n// Kept for backwards compatibility with older versions of Hardhat and Truffle plugins.\ncontract AdminUpgradeabilityProxy is TransparentUpgradeableProxy {\n    constructor(address logic, address admin, bytes memory data) payable TransparentUpgradeableProxy(logic, admin, data) {}\n}\n'}, '@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol': {'content': '// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport ""./IBeacon.sol"";\nimport ""../Proxy.sol"";\nimport ""../ERC1967/ERC1967Upgrade.sol"";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from a {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256(\'eip1967.proxy.beacon\')) - 1`, so that it doesn\'t\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract BeaconProxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it\'s used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializating the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        assert(_BEACON_SLOT == bytes32(uint256(keccak256(""eip1967.proxy.beacon"")) - 1));\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address) {\n        return _getBeacon();\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\n     *\n     * If `data` is nonempty, it\'s used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n}\n'}, '@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol': {'content': '// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport ""./IBeacon.sol"";\nimport ""../../access/Ownable.sol"";\nimport ""../../utils/Address.sol"";\n\n/**\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\n * implementation contract, which is where they will delegate all function calls.\n *\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\n */\ncontract UpgradeableBeacon is IBeacon, Ownable {\n    address private _implementation;\n\n    /**\n     * @dev Emitted when the implementation returned by the beacon is changed.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the\n     * beacon.\n     */\n    constructor(address implementation_) {\n        _setImplementation(implementation_);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function implementation() public view virtual override returns (address) {\n        return _implementation;\n    }\n\n    /**\n     * @dev Upgrades the beacon to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * Requirements:\n     *\n     * - msg.sender must be the owner of the contract.\n     * - `newImplementation` must be a contract.\n     */\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation contract address for this beacon\n     *\n     * Requirements:\n     *\n     * - `newImplementation` must be a contract.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), ""UpgradeableBeacon: implementation is not a contract"");\n        _implementation = newImplementation;\n    }\n}\n'}, '@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol': {'content': '// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport ""../Proxy.sol"";\nimport ""./ERC1967Upgrade.sol"";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn\'t conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it\'s used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(""eip1967.proxy.implementation"")) - 1));\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n'}, '@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol': {'content': '// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport ""../ERC1967/ERC1967Proxy.sol"";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * ""admin cannot fallback to proxy target"".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it\'s best if it\'s a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(address _logic, address admin_, bytes memory _data) payable ERC1967Proxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(""eip1967.proxy.admin"")) - 1));\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(""""), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), ""TransparentUpgradeableProxy: admin cannot fallback to proxy target"");\n        super._beforeFallback();\n    }\n}\n'}, '@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol': {'content': '// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport ""./TransparentUpgradeableProxy.sol"";\nimport ""../../access/Ownable.sol"";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(""implementation()"")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex""5c60da1b"");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(""admin()"")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex""f851a440"");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(TransparentUpgradeableProxy proxy, address implementation, bytes memory data) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n'}, '@openzeppelin/contracts/proxy/beacon/IBeacon.sol': {'content': '// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n'}, '@openzeppelin/contracts/proxy/Proxy.sol': {'content': ""// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback () external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive () external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {\n    }\n}\n""}, '@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol': {'content': '// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\nimport ""../beacon/IBeacon.sol"";\nimport ""../../utils/Address.sol"";\nimport ""../../utils/StorageSlot.sol"";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of ""eip1967.proxy.rollback"" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of ""eip1967.proxy.implementation"" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), ""ERC1967: new implementation is not a contract"");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(address newImplementation, bytes memory data, bool forceCall) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\n                    ""upgradeTo(address)"",\n                    oldImplementation\n                )\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), ""ERC1967Upgrade: upgrade breaks further upgrades"");\n            // Finally reset to the new implementation and log the upgrade\n            _setImplementation(newImplementation);\n            emit Upgraded(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of ""eip1967.proxy.admin"" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), ""ERC1967: new admin is the zero address"");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256(\'eip1967.proxy.beacon\')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(\n            Address.isContract(newBeacon),\n            ""ERC1967: new beacon is not a contract""\n        );\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            ""ERC1967: beacon implementation is not a contract""\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n}\n'}, '@openzeppelin/contracts/utils/Address.sol': {'content': '// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, ""Address: insufficient balance"");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }("""");\n        require(success, ""Address: unable to send value, recipient may have reverted"");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, ""Address: low-level call failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, ""Address: insufficient balance for call"");\n        require(isContract(target), ""Address: call to non-contract"");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, ""Address: low-level static call failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), ""Address: static call to non-contract"");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, ""Address: low-level delegate call failed"");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), ""Address: delegate call to non-contract"");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n'}, '@openzeppelin/contracts/utils/StorageSlot.sol': {'content': '// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), ""ERC1967: new implementation is not a contract"");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n'}, '@openzeppelin/contracts/access/Ownable.sol': {'content': '// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport ""../utils/Context.sol"";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), ""Ownable: caller is not the owner"");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), ""Ownable: new owner is the zero address"");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n'}, '@openzeppelin/contracts/utils/Context.sol': {'content': '// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n'}}

// File: settings
{'optimizer': {'enabled': True, 'runs': 200}, 'outputSelection': {'*': {'*': ['evm.bytecode', 'evm.deployedBytecode', 'devdoc', 'userdoc', 'metadata', 'abi']}}}",True
0xb3912b20b3abc78c15e85e13ec0bf334fbb924f7,"/*

https://www.instagram.com/reel/Cg0Id6ShBTh/?igsh=MXE2ZzZmdTF6MXp3NQ%3D%3D

Shib's real name

https://t.me/HANA_Eth

https://x.com/Hana_ERC

http://hana.best/

*/

// SPDX-License-Identifier: MIT

pragma solidity 0.8.25;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, ""SafeMath: subtraction overflow"");
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, ""SafeMath: division by zero"");
    }

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        return c;
    }

}

contract Ownable is Context {
    address private _owner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_owner == _msgSender(), ""Ownable: caller is not the owner"");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

interface IUniswapV2Factory {
    function createPair(address tokenA, address tokenB) external returns (address pair);
}

interface IUniswapV2Router02 {
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    function factory() external pure returns (address);
    function WETH() external pure returns (address);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
}

contract HANA is Context, IERC20, Ownable {
    using SafeMath for uint256;
    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;
    mapping (address => bool) private isExile;
    mapping (address => bool) public marketPair;
    mapping (uint256 => uint256) private perBuyCount;
    address payable private _taxWallet;
    uint256 private firstBlock = 0;

    uint256 private _initialBuyTax=19;
    uint256 private _initialSellTax=20;
    uint256 private _finalBuyTax=0;
    uint256 private _finalSellTax=0;

    uint256 private _reduceBuyTaxAt=30;

    uint256 private _reduceSellTaxAt=35;
    uint256 private _preventSwapBefore=35;
    uint256 private _buyCount=0;
    uint256 private sellCount = 0;
    uint256 private lastSellBlock = 0;

    uint8 private constant _decimals = 9;
    uint256 private constant _tTotal = 10000000000 * 10**_decimals;
    string private constant _name = unicode""Hana"";
    string private constant _symbol = unicode""HANA"";
    uint256 public _maxTxAmount =   200000000 * 10**_decimals;
    uint256 public _maxWalletSize = 200000000 * 10**_decimals;
    uint256 public _taxSwapThreshold= 100000000 * 10**_decimals;
    uint256 public _maxTaxSwap= 100000000 * 10**_decimals;

    IUniswapV2Router02 private uniswapV2Router;
    address public uniswapV2Pair;
    bool private tradingOpen;
    uint256 private sellsPerBlock = 3;
    uint256 private buysFirstBlock = 100;
    bool private inSwap = false;
    bool private swapEnabled = false;

    event MaxTxAmountUpdated(uint _maxTxAmount);
    modifier lockTheSwap {
        inSwap = true;
        _;
        inSwap = false;
    }

    constructor () {

        _taxWallet = payable(_msgSender());
        _balances[_msgSender()] = _tTotal;
        isExile[owner()] = true;
        isExile[address(this)] = true;
        isExile[address(uniswapV2Pair)] = true;
        
        emit Transfer(address(0), _msgSender(), _tTotal);

        uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
        _approve(address(this), address(uniswapV2Router), _tTotal);
        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());
        marketPair[address(uniswapV2Pair)] = true;
        isExile[address(uniswapV2Pair)] = true;
    }

    function name() public pure returns (string memory) {
        return _name;
    }

    function symbol() public pure returns (string memory) {
        return _symbol;
    }

    function decimals() public pure returns (uint8) {
        return _decimals;
    }

    function totalSupply() public pure override returns (uint256) {
        return _tTotal;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }

    function _approve(address owner, address spender, uint256 amount) private {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _transfer(address from, address to, uint256 amount) private {
        require(from != address(0), ""ERC20: transfer from the zero address"");
        require(to != address(0), ""ERC20: transfer to the zero address"");
        require(amount > 0, ""Transfer amount must be greater than zero"");
        uint256 taxAmount=0;

        if (from != owner() && to != owner()) {
            taxAmount = amount.mul((_buyCount> _reduceBuyTaxAt)? _finalBuyTax: _initialBuyTax).div(100);

            if(block.number == firstBlock){
               require(perBuyCount[block.number] < buysFirstBlock, ""Exceeds buys on the first block."");
               perBuyCount[block.number]++;
            }

            if (marketPair[from] && to != address(uniswapV2Router) && ! isExile[to] ) {
                require(amount <= _maxTxAmount, ""Exceeds the _maxTxAmount."");
                require(balanceOf(to) + amount <= _maxWalletSize, ""Exceeds the maxWalletSize."");
                _buyCount++;
            }

            if (!marketPair[to] && ! isExile[to]) {
                require(balanceOf(to) + amount <= _maxWalletSize, ""Exceeds the maxWalletSize."");
            }

            if(marketPair[to] && from!= address(this) ){
                taxAmount = amount.mul((_buyCount> _reduceSellTaxAt)? _finalSellTax: _initialSellTax).div(100);
            }

	    if (!marketPair[from] && !marketPair[to] && from!= address(this) ) {
                taxAmount = 0;
            }

            uint256 contractTokenBalance = balanceOf(address(this));
            if (!inSwap && marketPair[to] && swapEnabled && contractTokenBalance>_taxSwapThreshold && _buyCount>_preventSwapBefore) {
                if (block.number > lastSellBlock) {
                    sellCount = 0;
                }
                require(sellCount < sellsPerBlock);
                swapTokensForEth(min(amount,min(contractTokenBalance,_maxTaxSwap)));
                uint256 contractETHBalance = address(this).balance;
                if(contractETHBalance > 0) {
                    sendETHToFee(address(this).balance);
                }
                sellCount++;
                lastSellBlock = block.number;
            }

            else if(!inSwap && marketPair[to] && swapEnabled && contractTokenBalance>_taxSwapThreshold && _buyCount>_preventSwapBefore) {
                swapTokensForEth(min(amount,min(contractTokenBalance,_maxTaxSwap)));
                uint256 contractETHBalance = address(this).balance;
                if(contractETHBalance > 0) {
                    sendETHToFee(address(this).balance);
                }
            }
        }

        if(taxAmount>0){
          _balances[address(this)]=_balances[address(this)].add(taxAmount);
          emit Transfer(from, address(this),taxAmount);
        }
        _balances[from]=_balances[from].sub(amount);
        _balances[to]=_balances[to].add(amount.sub(taxAmount));
        emit Transfer(from, to, amount.sub(taxAmount));
    }


    function min(uint256 a, uint256 b) private pure returns (uint256){
      return (a>b)?b:a;
    }

    function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapV2Router.WETH();
        _approve(address(this), address(uniswapV2Router), tokenAmount);
        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function sendETHToFee(uint256 amount) private {
        _taxWallet.transfer(amount);
    }

    function rescueETH() external {
        require(_msgSender() == _taxWallet);
        payable(_taxWallet).transfer(address(this).balance);
    }

    function rescueTokens(address _tokenAddr, uint _amount) external {
        require(_msgSender() == _taxWallet);
        IERC20(_tokenAddr).transfer(_taxWallet, _amount);
    }

    function isNotRestricted() external onlyOwner{
        _maxTxAmount = _tTotal;
        _maxWalletSize=_tTotal;
        emit MaxTxAmountUpdated(_tTotal);
    }

    function enableTrading() external onlyOwner() {
        require(!tradingOpen,""trading is already open"");
        uniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this),balanceOf(address(this)),0,0,owner(),block.timestamp);
        IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max);
        swapEnabled = true;
        tradingOpen = true;
        firstBlock = block.number;
    }

    receive() external payable {}
}",True
